<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="User’s Guide">
  <title>ROOTUsersGuide</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="ROOTUsersGuide_files/MathJax.html" type="text/javascript"></script>
  <style>
  body {
    font-family: Helvetica, arial, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    padding-top: 10px;
    padding-bottom: 10px;
    background-color: white;
    padding: 30px; }
  
  body > *:first-child {
    margin-top: 0 !important; }
  body > *:last-child {
    margin-bottom: 0 !important; }
  
  a {
    text-decoration: none;
    color: #4183C4; }
  a.absent {
    color: #cc0000; }
  a.anchor {
    display: block;
    padding-left: 30px;
    margin-left: -30px;
    cursor: pointer;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0; }
  
  h1, h2, h3, h4, h5, h6 {
    margin: 20px 0 10px;
    padding: 0;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
    cursor: text;
    position: relative; }
  
  h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
    text-decoration: none; }
  
  h1 tt, h1 code {
    font-size: inherit; }
  
  h2 tt, h2 code {
    font-size: inherit; }
  
  h3 tt, h3 code {
    font-size: inherit; }
  
  h4 tt, h4 code {
    font-size: inherit; }
  
  h5 tt, h5 code {
    font-size: inherit; }
  
  h6 tt, h6 code {
    font-size: inherit; }
  
  h1 {
    font-size: 28px;
    color: black; }
  
  h2 {
    font-size: 24px;
    border-bottom: 1px solid #cccccc;
    color: black; }
  
  h3 {
    font-size: 18px; }
  
  h4 {
    font-size: 16px; }
  
  h5 {
    font-size: 14px; }
  
  h6 {
    color: #777777;
    font-size: 14px; }
  
  p, blockquote, ul, ol, dl, li, table, pre {
    margin: 15px 0; }
  
  hr {
    background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
    border: 0 none;
    color: #cccccc;
    height: 4px;
    padding: 0;
  }
  
  body > h2:first-child {
    margin-top: 0;
    padding-top: 0; }
  body > h1:first-child {
    margin-top: 0;
    padding-top: 0; }
    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0; }
  body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
    margin-top: 0;
    padding-top: 0; }
  
  a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
    margin-top: 0;
    padding-top: 0; }
  
  h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
    margin-top: 0; }
  
  li p.first {
    display: inline-block; }
  li {
    margin: 0; }
  ul, ol {
    padding-left: 30px; }
  
  ul :first-child, ol :first-child {
    margin-top: 0; }
  
  dl {
    padding: 0; }
    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px; }
      dl dt:first-child {
        padding: 0; }
      dl dt > :first-child {
        margin-top: 0; }
      dl dt > :last-child {
        margin-bottom: 0; }
    dl dd {
      margin: 0 0 15px;
      padding: 0 15px; }
      dl dd > :first-child {
        margin-top: 0; }
      dl dd > :last-child {
        margin-bottom: 0; }
  
  blockquote {
    border-left: 4px solid #dddddd;
    padding: 0 15px;
    color: #777777; }
    blockquote > :first-child {
      margin-top: 0; }
    blockquote > :last-child {
      margin-bottom: 0; }
  
  table {
    padding: 0;border-collapse: collapse; }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0; }
      table tr:nth-child(2n) {
        background-color: #f8f8f8; }
      table tr th {
        font-weight: bold;
        border: 1px solid #cccccc;
        margin: 0;
        padding: 6px 13px; }
      table tr td {
        border: 1px solid #cccccc;
        margin: 0;
        padding: 6px 13px; }
      table tr th :first-child, table tr td :first-child {
        margin-top: 0; }
      table tr th :last-child, table tr td :last-child {
        margin-bottom: 0; }
  
  img {
    max-width: 100%; }
  
  span.frame {
    display: block;
    overflow: hidden; }
    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto; }
    span.frame span img {
      display: block;
      float: left; }
    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0; }
  span.align-center {
    display: block;
    overflow: hidden;
    clear: both; }
    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center; }
    span.align-center span img {
      margin: 0 auto;
      text-align: center; }
  span.align-right {
    display: block;
    overflow: hidden;
    clear: both; }
    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right; }
    span.align-right span img {
      margin: 0;
      text-align: right; }
  span.float-left {
    display: block;
    margin-right: 13px;
    overflow: hidden;
    float: left; }
    span.float-left span {
      margin: 13px 0 0; }
  span.float-right {
    display: block;
    margin-left: 13px;
    overflow: hidden;
    float: right; }
    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right; }
  
  code, tt {
    margin: 0 2px;
    padding: 0 5px;
    white-space: nowrap;
    border: 1px solid #eaeaea;
    background-color: #f8f8f8;
    border-radius: 3px; }
  
  pre code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent; }
  
  .highlight pre {
    background-color: #f8f8f8;
    border: 1px solid #cccccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px; }
  
  pre {
    background-color: #f8f8f8;
    border: 1px solid #cccccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px; }
    pre code, pre tt {
      background-color: transparent;
      border: none; }
  
  sup {
      font-size: 0.83em;
      vertical-align: super;
      line-height: 0;
  }
  * {
  	-webkit-print-color-adjust: exact;
  }
  @media screen and (min-width: 914px) {
      body {
          width: 854px;
          margin:0 auto;
      }
  }
  @media print {
  	table, pre {
  		page-break-inside: avoid;
  	}
  	pre {
  		word-wrap: break-word;
  	}
  }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title"><img src="ROOTUsersGuide_files/rootlogo.png"></h1>
<p class="author">User’s Guide</p>
<p class="date">May 2018</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#getting-started"><span class="toc-section-number">2</span> Getting Started</a></li>
<li><a href="#histograms"><span class="toc-section-number">3</span> Histograms</a></li>
<li><a href="#graphs"><span class="toc-section-number">4</span> Graphs</a></li>
<li><a href="#fitting-histograms"><span class="toc-section-number">5</span> Fitting Histograms</a></li>
<li><a href="#a-little-c"><span class="toc-section-number">6</span> A Little C++</a></li>
<li><a href="#the-c-interpreter-cling"><span class="toc-section-number">7</span> The C++ Interpreter Cling</a></li>
<li><a href="#object-ownership"><span class="toc-section-number">8</span> Object Ownership</a></li>
<li><a href="#graphics-and-the-graphical-user-interface"><span class="toc-section-number">9</span> Graphics and the Graphical User Interface</a></li>
<li><a href="#folders-and-tasks"><span class="toc-section-number">10</span> Folders and Tasks</a></li>
<li><a href="#inputoutput"><span class="toc-section-number">11</span> Input/Output</a></li>
<li><a href="#trees"><span class="toc-section-number">12</span> Trees</a></li>
<li><a href="#math-libraries-in-root"><span class="toc-section-number">13</span> Math Libraries in ROOT</a></li>
<li><a href="#linear-algebra-in-root"><span class="toc-section-number">14</span> Linear Algebra in ROOT</a></li>
<li><a href="#adding-a-class"><span class="toc-section-number">15</span> Adding a Class</a></li>
<li><a href="#collection-classes"><span class="toc-section-number">16</span> Collection Classes</a></li>
<li><a href="#physics-vectors"><span class="toc-section-number">17</span> Physics Vectors</a></li>
<li><a href="#the-geometry-package"><span class="toc-section-number">18</span> The Geometry Package</a></li>
<li><a href="#python-interface"><span class="toc-section-number">19</span> Python Interface</a></li>
<li><a href="#the-tutorials-and-tests"><span class="toc-section-number">20</span> The Tutorials and Tests</a></li>
<li><a href="#example-analysis"><span class="toc-section-number">21</span> Example Analysis</a></li>
<li><a href="#networking"><span class="toc-section-number">22</span> Networking</a></li>
<li><a href="#threads"><span class="toc-section-number">23</span> Threads</a></li>
<li><a href="#proof-parallel-processing"><span class="toc-section-number">24</span> PROOF: Parallel Processing</a></li>
<li><a href="#writing-a-graphical-user-interface"><span class="toc-section-number">25</span> Writing a Graphical User Interface</a></li>
<li><a href="#the-signalslot-communication-mechanism"><span class="toc-section-number">26</span> The Signal/Slot Communication Mechanism</a></li>
<li><a href="#automatic-html-documentation"><span class="toc-section-number">27</span> Automatic HTML Documentation</a></li>
<li><a href="#appendix-a-install-and-build-root"><span class="toc-section-number">28</span> Appendix A: Install and Build ROOT</a></li>
</ul>
</nav>
<blockquote>
<hr>
<p><span style="color:red"><strong>WARNING:</strong></span> This documentation is <strong>not maintained anymore</strong>.
 Some part might be obsolete or wrong, some part might be missing but 
still some valuable information can be found there. Instead please refer
 to the <a href="https://root.cern/doc/master/index.html">ROOT Reference Guide</a> and the <a href="https://root.cern/manual/">ROOT Manual</a>. If you think some information should be imported in the <a href="https://root.cern/doc/master/index.html">ROOT Reference Guide</a> or in the <a href="https://root.cern/manual/">ROOT Manual</a>, please post your request to the <a href="https://root-forum.cern.ch/">ROOT Forum</a> or via a <a href="https://github.com/root-project/web/issues/new">Github Issue</a>.</p>
<hr>
</blockquote>
<h1 id="preface" class="unnumbered">Preface</h1>
<p>In late 1994, we decided to learn and investigate Object Oriented 
programming and C++ to better judge the suitability of these relatively 
new techniques for scientific programming. We knew that there is no 
better way to learn a new programming environment than to use it to 
write a program that can solve a real problem. After a few weeks, we had
 our first histogramming package in C++. A few weeks later we had a 
rewrite of the same package using the, at that time, very new template 
features of C++. Again, a few weeks later we had another rewrite of the 
package without templates since we could only compile the version with 
templates on one single platform using a specific compiler. Finally, 
after about four months we had a histogramming package that was faster 
and more efficient than the well-known FORTRAN based HBOOK histogramming
 package. This gave us enough confidence in the new technologies to 
decide to continue the development. Thus was born ROOT. Since its first 
public release at the end of 1995, ROOT has enjoyed an ever-increasing 
popularity. Currently it is being used in all major High Energy and 
Nuclear Physics laboratories around the world to monitor, to store and 
to analyse data. In the other sciences as well as the medical and 
financial industries, many people are using ROOT. We estimate the 
current user base to be around several thousand people. In 1997, Eric 
Raymond analysed in his paper “The Cathedral and the Bazaar” the 
development method that makes Linux such a success. The essence of that 
method is: “release early, release often and listen to your customers”. 
This is precisely how ROOT is being developed. Over the last five years,
 many of our “customers” became co-developers. Here we would like to 
thank our main co-developers and contributors:</p>
<p><strong>Masaharu Goto</strong> wrote the C++ interpreter CINT that 
was an essential part of ROOT before ROOT 6. Despite being 8 time zones 
ahead of us, we have the feeling he has been sitting in the room next 
door since 1995.</p>
<p><strong>Andrei</strong> and <strong>Mihaela Gheata</strong> (Alice 
collaboration) are co-authors of the ROOT geometry classes and Virtual 
Monte-Carlo. They have been working with the ROOT team since 2000.</p>
<p><strong>Olivier Couet</strong>, who after a successful development 
and maintenance of PAW, has joined the ROOT team in 2000 and has been 
working on the graphics sub-system.</p>
<p><strong>Ilka Antcheva</strong> has been working on the Graphical User
 Interface classes. She is also responsible for this latest edition of 
the Users Guide with a better style, improved index and several new 
chapters (since 2002).</p>
<p><strong>Bertrand Bellenot</strong> has been developing and 
maintaining the Win32GDK version of ROOT. Bertrand has also many other 
contributions like the nice RootShower example (since 2001).</p>
<p><strong>Valeriy Onoutchin</strong> has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).</p>
<p><strong>Gerri Ganis</strong> has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).</p>
<p><strong>Maarten Ballintijn</strong> (MIT) is one of the main developers of the PROOF sub-system (since 1995).</p>
<p><strong>Valeri Fine</strong> (now at BNL) ported ROOT to Windows and 
contributed largely to the 3-D graphics. He is currently working on the 
Qt layer of ROOT (since 1995).</p>
<p><strong>Victor Perevoztchikov</strong> (BNL) worked on key elements of the I/O system, in particular the improved support for STL collections (1997-2001).</p>
<p><strong>Nenad Buncic</strong> developed the HTML documentation generation system and integrated the X3D viewer inside ROOT (1995-1997).</p>
<p><strong>Suzanne Panacek</strong> was the author of the first version 
of this User’s Guide and very active in preparing tutorials and giving 
lectures about ROOT (1999-2002).</p>
<p><strong>Axel Naumann</strong> has been developing further the HTML 
Reference Guide and helps in porting ROOT under Windows (cygwin/gcc 
implementation) (since 2000).</p>
<p><strong>Anna Kreshuk</strong> has developed the Linear Fitter and Robust Fitter classes as well as many functions in TMath, TF1, TGraph (since 2005).</p>
<p><strong>Richard Maunder</strong> has contributed to the GL viewer classes (since 2004).</p>
<p><strong>Timur Pocheptsov</strong> has contributed to the GL viewer classes and GL in pad classes (since 2004).</p>
<p><strong>Sergei Linev</strong> has developed the XML driver and the TSQLFile classes (since 2003).</p>
<p><strong>Stefan Roiser</strong> has been contributing to the reflex and cintex packages (since 2005).</p>
<p><strong>Lorenzo Moneta</strong> has been contributing the MathCore, MathMore, Smatrix &amp; Minuit2 packages (since 2005).</p>
<p><strong>Wim Lavrijsen</strong> is the author of the PyRoot package (since 2004).</p>
<p>Further we would like to thank all the people mentioned in the <code>$ROOTSYS/README/CREDITS</code> file for their contributions, and finally, everybody who gave comments, reported bugs and provided fixes.</p>
<p>Happy ROOTing!</p>
<p>Rene Brun &amp; Fons Rademakers</p>
<p>Geneva, July 2007</p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>In the mid 1990’s, René Brun and Fons Rademakers had many years of 
experience developing interactive tools and simulation packages. They 
had lead successful projects such as PAW, PIAF, and GEANT, and they knew
 PAW the twenty-year-old FORTRAN libraries had reached their limits. 
Although still very popular, these tools could not scale up to the 
challenges offered by the Large Hadron Collider, where the data is a few
 orders of magnitude larger than anything seen before.</p>
<p>At the same time, computer science had made leaps of progress 
especially in the area of Object Oriented Design, and René and Fons were
 ready to take advantage of it.</p>
<p>ROOT was developed in the context of the NA49 experiment at CERN. 
NA49 has generated an impressive amount of data, around 10 Terabytes per
 run. This rate provided the ideal environment to develop and test the 
next generation data analysis.</p>
<p>ROOT was, and still is, developed in the “Bazaar style”, a term from 
the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a 
liberal, informal development style that heavily relies on the diverse 
and deep talent of the user community. The result is that physicists 
developed ROOT for themselves; this made it specific, appropriate, 
useful, and over time refined and very powerful. The development of ROOT
 is a continuous conversation between users and developers with the line
 between the two blurring at times and the users becoming co-developers.</p>
<p>When it comes to storing and mining large amount of data, physics 
plows the way with its Terabytes, but other fields and industry follow 
close behind as they acquiring more and more data over time. They are 
ready to use the true and tested technologies physics has invented. In 
this way, other fields and industries have found ROOT useful and they 
have started to use it also.</p>
<p>In the bazaar view, software is released early and frequently to 
expose it to thousands of eager co-developers to pound on, report bugs, 
and contribute possible fixes. More users find more bugs, because they 
stress the program in different ways. By now, after ten years, the age 
of ROOT is quite mature. Most likely, you will find the features you are
 looking for, and if you have found a hole, you are encouraged to 
participate in the dialog and post your suggestion or even 
implementation on the ROOT forum.</p>
<h2 id="the-root-forum"><span class="header-section-number">1.1</span> The ROOT forum</h2>
<p>If you have a question, it is likely that it has been asked, 
answered, and stored in the ROOT Forum. Please use the search engine to 
see if your question has already been answered before posting a topic in
 the Forum.</p>
<p>You can access the ROOT forum at: <a href="https://root-forum.cern.ch/" class="uri">https://root-forum.cern.ch</a>.</p>
<h2 id="contact-information"><span class="header-section-number">1.2</span> Contact Information</h2>
<p>Several authors wrote this book and you may see a “change of voice” 
from one chapter to the next. We felt we could accept this in order to 
have the expert explain what they know best. If you would like to 
contribute a chapter or add to a section, please contact <a href="mailto:rootdoc@cern.ch" class="email">rootdoc@cern.ch</a>.
 We count on you to send us suggestions on additional topics or on the 
topics that need more documentation. Please send your comments, 
corrections, questions, and suggestions to the <code>rootdoc</code> list: <a href="mailto:rootdoc@cern.ch" class="email">rootdoc@cern.ch</a></p>
<p>We attempt to give the user insight into the many capabilities of 
ROOT. The book begins with the elementary functionality and progresses 
in complexity reaching the specialized topics at the end. The 
experienced user looking for special topics may find these chapters 
useful: see “Networking”, “Writing a Graphical User Interface”, 
“Threads”, and “PROOF: Parallel Processing”.</p>
<h2 id="conventions-used-in-this-book"><span class="header-section-number">1.3</span> Conventions Used in This Book</h2>
<p>We tried to follow a style convention for the sake of clarity. The styles in used are described below.</p>
<p>To show source code in scripts or source files:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">{</a>
<a class="sourceLine" id="cb1-2" title="2">   cout &lt;&lt; <span class="st">" Hello"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-3" title="3">   <span class="dt">float</span> x = <span class="fl">3.</span>;</a>
<a class="sourceLine" id="cb1-4" title="4">   <span class="dt">float</span> y = <span class="fl">5.</span>;</a>
<a class="sourceLine" id="cb1-5" title="5">   <span class="dt">int</span>   i = <span class="dv">101</span>;</a>
<a class="sourceLine" id="cb1-6" title="6">   cout &lt;&lt;<span class="st">" x = "</span>&lt;&lt;x&lt;&lt;<span class="st">" y = "</span>&lt;&lt;y&lt;&lt;<span class="st">" i = "</span>&lt;&lt;i&lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-7" title="7">}</a></code></pre></div>
<p>To show the ROOT command line, we show the ROOT prompt without 
numbers. In the interactive system, the ROOT prompt has a line number (<code>root[12]</code>); for the sake of simplicity, the line numbers are left off.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">root[] TLine l</a>
<a class="sourceLine" id="cb2-2" title="2">root[] l.Print()</a>
<a class="sourceLine" id="cb2-3" title="3">TLine  X1=<span class="fl">0.000000</span> Y1=<span class="fl">0.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a></code></pre></div>
<p>Italic bold monotype font indicates a global variable, for example <strong><em><code>gDirectory</code></em></strong>.</p>
<p>When a variable term is used, it is shown between angled brackets. In
 the example below the variable term &lt;library&gt; can be replaced 
with any library in the <code>$ROOTSYS</code> directory: <code>$ROOTSYS/&lt;library&gt;/inc.</code></p>
<h2 id="the-framework"><span class="header-section-number">1.4</span> The Framework</h2>
<p>ROOT is an object-oriented framework aimed at solving the data 
analysis challenges of high-energy physics. There are two key words in 
this definition, object oriented and framework. First, we explain what 
we mean by a framework and then why it is an object-oriented framework.</p>
<h3 id="what-is-a-framework"><span class="header-section-number">1.4.1</span> What Is a Framework?</h3>
<p>Programming inside a framework is a little like living in a city. 
Plumbing, electricity, telephone, and transportation are services 
provided by the city. In your house, you have interfaces to the services
 such as light switches, electrical outlets, and telephones. The 
details, for example, the routing algorithm of the phone switching 
system, are transparent to you as the user. You do not care; you are 
only interested in using the phone to communicate with your 
collaborators to solve your domain specific problems.</p>
<p>Programming outside of a framework may be compared to living in the 
country. In order to have transportation and water, you will have to 
build a road and dig a well. To have services like telephone and 
electricity you will need to route the wires to your home. In addition, 
you cannot build some things yourself. For example, you cannot build a 
commercial airport on your patch of land. From a global perspective, it 
would make no sense for everyone to build their own airport. You see you
 will be very busy building the infrastructure (or framework) before you
 can use the phone to communicate with your collaborators and have a 
drink of water at the same time. In software engineering, it is much the
 same way. In a framework, the basic utilities and services, such as I/O
 and graphics, are provided. In addition, ROOT being a HEP analysis 
framework, it provides a large selection of HEP specific utilities such 
as histograms and fitting. The drawback of a framework is that you are 
constrained to it, as you are constraint to use the routing algorithm 
provided by your telephone service. You also have to learn the framework
 interfaces, which in this analogy is the same as learning how to use a 
telephone.</p>
<p>If you are interested in doing physics, a good HEP framework will 
save you much work. Next is a list of the more commonly used components 
of ROOT: Command Line Interpreter, Histograms and Fitting, Writing a 
Graphical User Interface, 2D Graphics, Input/Output , Collection 
Classes, Script Processor.</p>
<p>There are also less commonly used components, as: 3D Graphics, 
Parallel Processing (PROOF), Run Time Type Identification (RTTI), Socket
 and Network Communication, Threads.</p>
<h4 id="advantages-of-frameworks"><span class="header-section-number">1.4.1.1</span> Advantages of Frameworks</h4>
<p>The benefits of frameworks can be summarized as follows:</p>
<ul>
<li><p>Less code to write - the programmer should be able to use and 
reuse the majority of the existing code. Basic functionality, such as 
fitting and histogramming are implemented and ready to use and 
customize.</p></li>
<li><p>More reliable and robust code - the code inherited from a 
framework has already been tested and integrated with the rest of the 
framework.</p></li>
<li><p>More consistent and modular code - the code reuse provides 
consistency and common capabilities between programs, no matter who 
writes them. Frameworks make it easier to break programs into smaller 
pieces.</p></li>
<li><p>More focus on areas of expertise - users can concentrate on their
 particular problem domain. They do not have to be experts at writing 
user interfaces, graphics, or networking to use the frameworks that 
provide those services.</p></li>
</ul>
<h3 id="why-object-oriented"><span class="header-section-number">1.4.2</span> Why Object-Oriented?</h3>
<p>Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:</p>
<ul>
<li><p>Encapsulation enforces data abstraction and increases opportunity for reuse.</p></li>
<li><p>Sub classing and inheritance make it possible to extend and modify objects.</p></li>
<li><p>Class hierarchies and containment containment hierarchies provide
 a flexible mechanism for modeling real-world objects and the 
relationships among them.</p></li>
<li><p>Complexity is reduced because there is little growth of the 
global state, the state is contained within each object, rather than 
scattered through the program in the form of global variables.</p></li>
<li><p>Objects may come and go, but the basic structure of the program 
remains relatively static, increases opportunity for reuse of design.</p></li>
</ul>
<h2 id="installing-root"><span class="header-section-number">1.5</span> Installing ROOT</h2>
<p></p>
<p>To install ROOT you will need to go to the ROOT website at: <a href="http://root.cern.ch/root/Availability.html" class="uri">http://root.cern.ch/root/Availability.html</a>.
 You have a choice to download the binaries or the source. The source is
 quicker to transfer since it is only ~22 MB, but you will need to 
compile and link it. The binaries compiled with no debug information 
range from ~35 MB to ~45 MB depending on the target platform.</p>
<p>The installation and building of ROOT is described in Appendix A: 
Install and Build ROOT. You can download the binaries, or the source. 
The GNU g++ compiler on most UNIX platforms can compile ROOT.</p>
<p>Before downloading a binary version make sure your machine contains 
the right run-time environment. In most cases it is not possible to run a
 version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is
 installed. In such cases you’ll have to install ROOT from source.</p>
<p>ROOT is currently running on the following platforms: supported platforms</p>
<ul>
<li><p><code>GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,  Portland/PGCC,KAI/KCC)</code></p></li>
<li><p><code>Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC)</code></p></li>
<li><p><code>FreeBSD and OpenBSD (GCC)</code></p></li>
<li><p><code>GNU/Hurd (GCC)</code></p></li>
<li><p><code>HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)</code></p></li>
<li><p><code>IBM AIX 4.1 (xlC compiler, GCC)</code></p></li>
<li><p><code>Sun Solaris for SPARC (SUN C++ compiler, GCC)</code></p></li>
<li><p><code>Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)</code></p></li>
<li><p><code>Compaq Alpha (GCC, KAI/KCC, DEC/CXX)</code></p></li>
<li><p><code>SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler)</code></p></li>
<li><p><code>Windows &gt;= 95 (Microsoft Visual C++ compiler, Cygwin/GCC)</code></p></li>
<li><p><code>MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)</code></p></li>
<li><p><code>PowerPC with GNU/Linux and GCC, Debian v2</code></p></li>
<li><p><code>PowerPC64 with GNU/Linux and GCC</code></p></li>
<li><p><code>ARM with GNU/Linux and GCC</code></p></li>
<li><p><code>LynxOS</code></p></li>
</ul>
<h2 id="the-organization-of-the-root-framework"><span class="header-section-number">1.6</span> The Organization of the ROOT Framework</h2>
<p>Now after we know in abstract terms what the ROOT framework is, let 
us look at the physical directories and files that come with the ROOT 
installation. You may work on a platform where your system administrator
 has already installed ROOT. You will need to follow the specific 
development environment for your setup and you may not have write access
 to the directories. In any case, you will need an environment variable 
called <code>ROOTSYS</code>, which holds the path of the top ROOT directory.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">&gt; echo <span class="er">$</span>ROOTSYS</a>
<a class="sourceLine" id="cb3-2" title="2">/opt/root</a></code></pre></div>
<p>In the <code>ROOTSYS</code> directory are examples, executables, 
tutorials, header tutorials files, and, if you opted to download it, the
 source is here. The directories of special interest to us are <code>bin</code>, <code>tutorials</code>, <code>lib</code>, <code>test</code>, and<code>include</code>. The next figure shows the contents of these directories.</p>
<figure>
<img src="ROOTUsersGuide_files/02000004.jpg" alt="ROOT framework directories"><figcaption>ROOT framework directories</figcaption>
</figure>
<h3 id="rootsysbin"><span class="header-section-number">1.6.1</span> $ROOTSYS/bin</h3>
<p>The <code>bin</code> directory contains several executables.</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>root</code></td>
<td>shows the ROOT splash screen and calls <code>root.exe</code></td>
</tr>
<tr class="even">
<td><code>root.exe</code></td>
<td>the executable that <code>root</code> calls, if you use a debugger such as <code>gdb</code>, you will need to run <code>root.exe</code> directly</td>
</tr>
<tr class="odd">
<td><code>rootcling</code></td>
<td>is the utility ROOT uses to create a class dictionary for Cling</td>
</tr>
<tr class="even">
<td><code>rmkdepend</code></td>
<td>a modified version of <code>makedepend</code> that is used by the ROOT build system</td>
</tr>
<tr class="odd">
<td><code>root-config</code></td>
<td>a script returning the needed compile flags and libraries for projects that compile and link with ROOT</td>
</tr>
<tr class="even">
<td><code>proofd</code></td>
<td>a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF)</td>
</tr>
<tr class="odd">
<td><code>proofserv</code></td>
<td>the actual PROOF process, which is started by <code>proofd</code> after a user, has successfully been authenticated</td>
</tr>
<tr class="even">
<td><code>rootd</code></td>
<td>is the daemon for remote ROOT file access (see the <strong><code>TNetFile</code></strong>)</td>
</tr>
</tbody>
</table>
<h3 id="rootsyslib"><span class="header-section-number">1.6.2</span> $ROOTSYS/lib</h3>
<p>There are several ways to use ROOT, one way is to run the executable by typing <code>root</code> at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.</p>
<p>Here is a short description of the most relevant libraries, the ones 
marked with a * are only installed when the options specified them.</p>
<ul>
<li><p><code>libAsImage</code> is the image manipulation library</p></li>
<li><p><code>libCling</code> is the C++ interpreter (Cling)</p></li>
<li><p><code>libCore</code> is the Base classes</p></li>
<li><p><code>libEG</code> is the abstract event generator interface classes</p></li>
<li><p>*<code>libEGPythia</code> is the Pythia5 event generator interface</p></li>
<li><p>*<code>libEGPythia6</code> is the Pythia6 event generator interface</p></li>
<li><p><code>libFitPanel</code> contains the GUI used for fitting</p></li>
<li><p><code>libGed</code> contains the GUI used for editing the properties of histograms, graphs, etc.</p></li>
<li><p><code>libGeom</code> is the geometry package (with builder and painter)</p></li>
<li><p><code>libGpad</code> is the pad and canvas classes which depend on low level graphics</p></li>
<li><p><code>libGraf</code> is the 2D graphics primitives (can be used independent of libGpad)</p></li>
<li><p><code>libGraf3d</code> is the 3D graphics primitives</p></li>
<li><p><code>libGui</code> is the GUI classes (depend on low level graphics)</p></li>
<li><p><code>libGuiBld</code> is the GUI designer</p></li>
<li><p><code>libGuiHtml</code> contains the embedded HTML browser</p></li>
<li><p><code>libGX11</code> is the low level graphics interface to the X11 system</p></li>
<li><p>*<code>libGX11TTF</code> is an add-on library to libGX11 providing TrueType fonts</p></li>
<li><p><code>libHbook</code> is for interface ROOT - HBOOK</p></li>
<li><p><code>libHist</code> is the histogram classes (with accompanying painter library)</p></li>
<li><p><code>libHtml</code> is the HTML documentation generation system</p></li>
<li><p><code>libMatrix</code> is the matrix and vector manipulation</p></li>
<li><p><code>libMathCore</code> contains the core mathematics and physics vector classes</p></li>
<li><p><code>libMathMore</code> contains additional functions, interfacing the GSL math library</p></li>
<li><p><code>libMinuit</code> is the MINUIT fitter</p></li>
<li><p><code>libNet</code> contains functionality related to network transfer</p></li>
<li><p><code>libNew</code> is the special global new/delete, provides extra memory checking and interface for shared memory (optional)</p></li>
<li><p><code>libPhysics</code> contains the legacy physics classes (TLorentzVector, etc.)</p></li>
<li><p><code>libPostscript</code> is the PostScript interface</p></li>
<li><p><code>libProof</code> is the parallel ROOT Facility classes</p></li>
<li><p><code>libPython</code> provides the interface to Python</p></li>
<li><p>*<code>libRFIO</code> is the interface to CERN RFIO remote I/O system.</p></li>
<li><p>*<code>libRGL</code> is the interface to OpenGL.</p></li>
<li><p><code>libReflex</code> is the runtime type database library used by Cling</p></li>
<li><p><code>libRint</code> is the interactive interface to ROOT (provides command prompt)</p></li>
<li><p><code>libRIO</code> provides the functionality to write and read objects to and from ROOT files</p></li>
<li><p><code>libRooFit</code> is the RooFit fitting framework</p></li>
<li><p><code>libRuby</code> is the interface to Ruby</p></li>
<li><p><code>libSpectrum</code> provides functionality for spectral analysis</p></li>
<li><p>*<code>libThread</code> is the interface to TThread classes</p></li>
<li><p><code>libTMVA</code> contains the multivariate analysis toolkit</p></li>
<li><p><code>libTree</code> is the TTree object container system</p></li>
<li><p><code>libTreePlayer</code> is the TTree drawing classes</p></li>
<li><p><code>libTreeViewer</code> is the graphical TTree query interface</p></li>
</ul>
<h4 id="library-dependencies"><span class="header-section-number">1.6.2.1</span> Library Dependencies</h4>
<figure>
<img src="ROOTUsersGuide_files/03000005.png" alt="ROOT libraries dependencies"><figcaption>ROOT libraries dependencies</figcaption>
</figure>
<p>The libraries are designed and organized to minimize dependencies, 
such that you can load just enough code for the task at hand rather than
 having to load all libraries or one monolithic chunk. The core library (<code>libCore.so</code>)
 contains the essentials; it is a part of all ROOT applications. In the 
Figure 1-2 you see that libCore.so is made up of base classes, container
 classes, meta information classes, operating system specific classes, 
and the ZIP algorithm used for compression of the ROOT files.</p>
<p>The Cling library (<code>libCling.so</code>) is also needed in all ROOT applications, and even by <code>libCore</code>. A program referencing only <strong><code>TObject</code></strong> only needs <code>libCore</code>; <code>libCling</code> will be opened automatically. To add the ability to read and write ROOT objects one also has to load <code>libRIO</code>. As one would expect, none of that depends on graphics or the GUI.</p>
<p>Library dependencies have different consequences; depending on 
whether you try to build a binary, or you just try to access a class 
that is defined in a library.</p>
<h4 id="linktime-library-dependencies"><span class="header-section-number">1.6.2.2</span> Linktime Library Dependencies</h4>
<p>When building your own executable you will have to link against the 
libraries that contain the classes you use. The ROOT reference guide 
states the library a class is reference guide defined in. Almost all 
relevant classes can be found in libraries returned by <code>root-config -glibs</code>; the graphics libraries are retuned by <code>root-config --libs</code>. These commands are commonly used in <code>Makefiles</code>. Using <code>root-config</code>
 instead of enumerating the libraries by hand allows you to link them in
 a platform independent way. Also, if ROOT library names change you will
 not need to change your Makefile.</p>
<p>A batch program that does not have a graphic display, which creates, 
fills, and saves histograms and trees, only needs to link the core 
libraries (<code>libCore</code>, <code>libRIO</code>), <code>libHist</code> and <code>libTree</code>. If ROOT needs access to other libraries, it loads them dynamically. For example, if the <strong><code>TreeViewer</code></strong> is used, <code>libTreePlayer</code> and all libraries <code>libTreePlayer</code>
 depends on are loaded also. The dependent libraries are shown in the 
ROOT reference guide’s library dependency graph. The difference between 
reference guide <code>libHist</code> and <code>libHistPainter</code> is 
that the former needs to be explicitly linked and the latter will be 
loaded automatically at runtime when ROOT needs it, by means of the 
Plugin Manager. plugin manager</p>
<p>In the Figure 1-2, the libraries represented by green boxes outside 
of the core are loaded via the plugin manager plugin manager or 
equivalent techniques, while the white ones are not. Of course, if one 
wants to access a plugin library directly, it has to be explicitly 
linked. An example of a plugin library is <code>libMinuit</code>. To create and fill histograms you need to link <code>libHist.so</code>. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.</p>
<h4 id="plugins-runtime-library-dependencies-for-linking"><span class="header-section-number">1.6.2.3</span> Plugins: Runtime Library Dependencies for Linking</h4>
<p>plugin manager The Plugin Manager <strong><code>TPluginManager</code></strong>
 allows postponing library dependencies to runtime: a plugin library 
will only be loaded when it is needed. Non-plugins will need to be 
linked, and are thus loaded at start-up. Plugins are defined by a base 
class (e.g. <strong><code>TFile</code></strong>) that will be implemented in a plugin, a tag used to identify the plugin (e.g.&nbsp;<code>^rfio:</code> as part of the protocol string), the plugin class of which an object will be created (e.g.&nbsp;<strong><code>TRFIOFile</code></strong>), the library to be loaded (in short <code>libRFIO.so</code> to RFIO), and the constructor to be called (e.g. “<code>TRFIOFile()</code>”). This can be specified in the <code>.rootrc</code> which already contains many plugin definitions, or by calls to <code>gROOT-&gt;GetPluginManager()-&gt;AddHandler()</code>.</p>
<h4 id="library-autoloading"><span class="header-section-number">1.6.2.4</span> Library AutoLoading</h4>
<p>When using a class in Cling, e.g.&nbsp;in an interpreted source file,
 ROOT will automatically load the library that defines this class. On 
start-up, ROOT parses all files ending on <code>.rootmap</code> rootmap that are in one of the <code>$LD_LIBRARY_PATH</code> (or <code>$DYLD_LIBRARY_PATH</code> for <code>MacOS</code>, or <code>$PATH</code> for <code>Windows</code>).
 They contain class names and the library names that the class depends 
on. After reading them, ROOT knows which classes are available, and 
which libraries to load for them.</p>
<p>When <code>TSystem::Load("ALib")</code> is called, ROOT uses this information to determine which libraries <code>libALib.so</code>
 depends on. It will load these libraries first. Otherwise, loading the 
requested library could cause a system (dynamic loader) error due to 
unresolved symbols.</p>
<h3 id="rootsystutorials"><span class="header-section-number">1.6.3</span> $ROOTSYS/tutorials</h3>
<p>tutorials The tutorials directory contains many example example 
scripts. They assume some basic knowledge of ROOT, and for the new user 
we recommend reading the chapters: “Histograms” and “Input/Output” 
before trying the examples. The more experienced user can jump to 
chapter “The Tutorials and Tests” to find more explicit and specific 
information about how to build and run the examples.</p>
<p>The <code>$ROOTSYS/tutorials/</code> directory include the following sub-directories:</p>
<p><code>fft</code>: Fast Fourier Transform with the fftw package <code>fit</code>: Several examples illustrating minimization/fitting <code>foam</code>: Random generator in multidimensional space <code>geom</code>: Examples of use of the geometry package (<strong><code>TGeo</code></strong> classes) <code>gl</code>: Visualisation with OpenGL <code>graphics</code>: Basic graphics <code>graphs</code>: Use of <strong><code>TGraph</code></strong>, <strong><code>TGraphErrors</code></strong>, etc. <code>gui</code>: Scripts to create Graphical User Interface <code>hist</code>: Histogramming <code>image</code>: Image Processing <code>io</code>: Input/Output <code>math</code>: Maths and Statistics functions <code>matrix</code>: Matrices (<strong><code>TMatrix</code></strong>) examples <code>mlp</code>: Neural networks with <strong><code>TMultiLayerPerceptron</code></strong> <code>net</code>: Network classes (client/server examples) <code>physics</code>: LorentzVectors, phase space <code>pyroot</code>: Python tutorials <code>pythia</code>: Example with <code>pythia8</code> <code>quadp</code>: Quadratic Programming <code>smatrix</code>: Matrices with a templated package <code>spectrum</code>: Peak finder, background, deconvolutions <code>splot</code>: Example of the <strong><code>TSplot</code></strong> class (signal/background estimator) <code>sql</code>: Interfaces to SQL (mysql, oracle, etc) <code>thread</code>: Using Threads <code>tmva</code>: Examples of the MultiVariate Analysis classes <code>tree</code>: Creating Trees, Playing with Trees <code>unuran</code>: Interface with the unuram random generator library <code>xml</code>: Writing/Reading xml files</p>
<p>You can execute the scripts in <code>$ROOTSYS/tutorials</code> (or 
sub-directories) by setting your current directory in the script 
directory or from any user directory with write access. Several 
tutorials create new files. If you have write access to the tutorials 
directory, the new files will be created in the tutorials directory, 
otherwise they will be created in the user directory.</p>
<h3 id="rootsystest"><span class="header-section-number">1.6.4</span> $ROOTSYS/test</h3>
<p>The test directory contains a set of examples example that represent 
all areas of the framework. When a new release is cut, the examples in 
this directory are compiled and run to test the new release’s backward 
compatibility. The list of source files is described in chapter “The 
Tutorials and Tests”.</p>
<p>The <code>$ROOTSYS/test</code> directory is a gold mine of 
ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We 
recommend the new users to read the chapter “Getting Started”. The 
chapter “The Tutorials and Tests” has instructions on how to build all 
the programs and it goes over the examples <code>Event</code> and <code>stress</code>.</p>
<h3 id="rootsysinclude"><span class="header-section-number">1.6.5</span> $ROOTSYS/include</h3>
<p>The <code>include</code> directory contains all header files. It is especially important because the header files contain the class definitions.</p>
<h3 id="rootsyslibrary"><span class="header-section-number">1.6.6</span> $ROOTSYS/&lt;library&gt;</h3>
<p>The directories we explored above are available when downloading the 
binaries. When downloading the source you also get a directory for each 
library with the corresponding header and source files, located in the <code>inc</code> and <code>src</code> subdirectories. To see what classes are in a library, you can check the <code>&lt;library&gt;/inc</code> directory for the list of class definitions. For example, the physics library <code>libPhysics.so</code> contains these class definitions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">&gt; ls -m <span class="er">$</span>ROOTSYS/math/physics/inc/</a>
<a class="sourceLine" id="cb4-2" title="2">LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,</a>
<a class="sourceLine" id="cb4-3" title="3">TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,</a>
<a class="sourceLine" id="cb4-4" title="4">TRotation.h, TVector2.h, TVector3.h</a></code></pre></div>
<h2 id="how-to-find-more-information"><span class="header-section-number">1.7</span> How to Find More Information</h2>
<p>website The ROOT web site has up to date documentation. The ROOT 
source code automatically generates this documentation, so each class is
 explicitly documented on its own web page, which is always up to date 
with the latest official release of ROOT.</p>
<p>The ROOT Reference Guide web pages can be found at class index reference guide <a href="http://root.cern.ch/root/html/ClassIndex.html" class="uri">http://root.cern.ch/root/html/ClassIndex.html</a>.
 Each page contains a class description, and an explanation of each 
method. It shows the class inheritance tree and lets you jump to the 
parent class page by clicking on the class name. If you want more 
details, you can even see the source. There is a help page available in 
the little box on the upper right hand side of each class documentation 
page. You can see on the next page what a typical class documentation 
web page looks like. The ROOT web site also contains in addition to this
 Reference Guide, “How To’s”, a list of publications and example 
applications.</p>
<h3 id="class-reference-guide"><span class="header-section-number">1.7.1</span> Class Reference Guide</h3>
<p>The top of any class reference page lets you jump to different parts 
of the documentation. The first line links to the class index and the 
index for the current module (a group of classes, often a library). The 
second line links to the ROOT homepage and the class overviews. The 
third line links the source information - a HTML version of the source 
and header file as well as the CVS (the source management system used 
for the ROOT development) information of the files. The last line links 
the different parts of the current pages.</p>
<p><img src="ROOTUsersGuide_files/03000006.png"></p>
<figure>
<img src="ROOTUsersGuide_files/03000007.png" alt="Example of function documentation, with automatically generated LaTeX-like graphics"><figcaption>Example of function documentation, with automatically generated LaTeX-like graphics</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/03000008.png" alt="Inheritance tree, showing what the current class derives from, and which classes inherit from it"><figcaption>Inheritance tree, showing what the current class derives from, and which classes inherit from it</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/03000009.png" alt="HTML version of the source file linking all types and most functions"><figcaption>HTML version of the source file linking all types and most functions</figcaption>
</figure>
<h1 id="getting-started"><span class="header-section-number">2</span> Getting Started</h1>
<p>We begin by showing you how to use ROOT interactively. There are two 
examples to click through and learn how to use the GUI. We continue by 
using the command line, and explaining the coding conventions, global 
variables and the environment setup. If you have not installed ROOT, you
 can do so by following the instructions in the appendix, or on the ROOT
 web site: <a href="http://root.cern.ch/root/Availability.html" class="uri">http://root.cern.ch/root/Availability.html</a></p>
<h2 id="setting-the-environment-variables"><span class="header-section-number">2.1</span> Setting the Environment Variables</h2>
<p>Before you can run ROOT you need to set the environment variable <code>ROOTSYS</code> and change your path to include <code>root/bin</code> and library path variables to include <code>root/lib</code>. Please note: the syntax is for <code>bash</code>, if you are running <code>tcsh</code> you will have to use <code>setenv</code> instead of <code>export</code>.</p>
<ol type="1">
<li>Define the variable $ROOTSYS to the directory where you unpacked the ROOT:</li>
</ol>
<pre><code>$ export ROOTSYS=$HOME/root</code></pre>
<ol start="2" type="1">
<li>Add ROOTSYS/bin to your PATH:</li>
</ol>
<pre><code>$ export PATH=$PATH:$ROOTSYS/bin</code></pre>
<ol start="3" type="1">
<li>Setting the Library Path</li>
</ol>
<p>On HP-UX, before executing the interactive module, you must set the library path:</p>
<pre><code>$ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib</code></pre>
<p>On AIX, before executing the interactive module, you must set the library path:</p>
<pre><code>$ [ -z "$LIBPATH" ] &amp;&amp; export LIBPATH=/lib:/usr/lib
$ export LIBPATH=$LIBPATH:$ROOTSYS/lib</code></pre>
<p>On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:</p>
<pre><code>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib</code></pre>
<p>On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:</p>
<pre><code>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib</code></pre>
<p>If you use the <code>afs</code> version you should set (<em>vers</em> = version number, <em>arch</em> = architecture):</p>
<pre><code>$ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root</code></pre>
<p>If ROOT was installed in <code>$HOME/myroot</code> directory on a local machine, one can do:</p>
<pre><code>cd $HOME/myroot
. bin/thisroot.sh       // or source bin/thisroot.sh</code></pre>
<p>The new <code>$ROOTSYS/bin/thisroot.[c]sh</code> scripts will set correctly the <code>ROOTSYS</code>, <code>LD_LIBRARY_PATH</code> or other paths depending on the platform and the <code>MANPATH</code>. To run the program just type: <code>root</code>.</p>
<h2 id="start-and-quit-a-root-session"><span class="header-section-number">2.2</span> Start and Quit a ROOT Session</h2>
<pre><code>$ root
   -------------------------------------------------------------------------
  | Welcome to ROOT 6.10/01                             http://root.cern.ch |
  |                                            (c) 1995-2017, The ROOT Team |
  | Built for macosx64                                                      |
  | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |
  | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'              |
   -------------------------------------------------------------------------

root [0]</code></pre>
<p>To start ROOT you can type <code>root</code> at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (<code>root[0]</code>).</p>
<p>It is possible to launch ROOT with some command line options, as shown below:</p>
<pre><code>%  root -?
Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]
                                                [file1.C ... fileN.C]
Options:
  -b : run in batch mode without graphics
  -n : do not execute logon and logoff macros as specified in .rootrc
  -q : exit after processing command line macro files
  -l : do not show splash screen
  -x : exit on exception
 dir : if dir is a valid directory cd to it before executing

  -?       : print usage
  -h       : print usage
  --help   : print usage
  -config  : print ./configure options</code></pre>
<ul>
<li><p>-b ROOT session runs in batch mode, without graphics display. 
This mode is useful in case one does not want to set the DISPLAY or 
cannot do it for some reason.</p></li>
<li><p>-n usually, launching a ROOT session will execute a logon script 
and quitting will execute a logoff script. This option prevents the 
execution of these two scripts.</p></li>
<li><p>it is also possible to execute a script without entering a ROOT 
session. One simply adds the name of the script(s) after the ROOT 
command. Be warned: after finishing the execution of the script, ROOT 
will normally enter a new session.</p></li>
<li><p>-q process command line script files and exit.</p></li>
</ul>
<p>For example if you would like to run a script <code>myMacro.C</code> in the background, redirect the output into a file <code>myMacro.log</code>, and exit after the script execution, use the following syntax:</p>
<pre><code>root -b -q myMacro.C &gt; myMacro.log</code></pre>
<p>If you need to pass a parameter to the script use:</p>
<pre><code>root -b -q 'myMacro.C(3)' &gt; myMacro.log</code></pre>
<p>Be mindful of the quotes, i.e.&nbsp;if you need to pass a string as a parameter, the syntax is:</p>
<pre><code>root -b -q 'myMacro.C("text")' &gt; myMacro.log</code></pre>
<p>You can build a shared library with ACLiC and then use this shared 
library on the command line for a quicker execution (i.e.&nbsp;the 
compiled speed rather than the interpreted speed). See also “Cling the 
C++ Interpreter”.</p>
<pre><code>root -b -q myMacro.so &gt; myMacro.log</code></pre>
<p>ROOT has a powerful C/C++ interpreter giving you access to all 
available ROOT classes, global variables, and functions via the command 
line. By typing C++ statements at the prompt, you can create objects, 
call functions, execute scripts, etc. For example:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1">root[] <span class="dv">1</span>+sqrt(<span class="dv">9</span>)</a>
<a class="sourceLine" id="cb19-2" title="2">(<span class="at">const</span> <span class="dt">double</span>)<span class="fl">4.00000000000000000e+00</span></a>
<a class="sourceLine" id="cb19-3" title="3">root[] <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++) cout &lt;&lt; <span class="st">"Hello"</span> &lt;&lt; i &lt;&lt; endl</a>
<a class="sourceLine" id="cb19-4" title="4">Hello <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-5" title="5">Hello <span class="dv">1</span></a>
<a class="sourceLine" id="cb19-6" title="6">Hello <span class="dv">2</span></a>
<a class="sourceLine" id="cb19-7" title="7">Hello <span class="dv">3</span></a>
<a class="sourceLine" id="cb19-8" title="8">root[] .q</a></code></pre></div>
<p>To exit the ROOT session, type <code>.q</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1">root[] .q</a></code></pre></div>
<h2 id="using-the-gui"><span class="header-section-number">2.3</span> Using the GUI</h2>
<p>The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class <strong><code>TCanvas</code></strong>).
 Every object in the canvas is a graphical object in the sense that you 
can grab it, resize it, and change some characteristics using the mouse.
 The canvas area can be divided in several sub areas, so-called pads 
(the class <strong><code>TPad</code></strong>). A pad is a canvas sub 
area that can contain other pads or graphical objects. At any one time, 
just one pad is the so-called active pad. Any object at the moment of 
drawing will be drawn in the active pad. The obvious question is: what 
is the relation between a canvas and a pad? In fact, a canvas is a pad 
that spans through an entire window. This is nothing else than the 
notion of inheritance. The <strong><code>TPad</code></strong> class is the parent of the <strong><code>TCanvas</code></strong> class. In ROOT, most objects derive from a base class <strong><code>TObject</code></strong>. This class has a virtual method <code>Draw()</code>
 such as all objects are supposed to be able to be “drawn”. If several 
canvases are defined, there is only one active at a time. One draws an 
object in the active canvas by using the statement:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1">object.Draw()</a></code></pre></div>
<p>This instructs the object “<code>object</code>” to draw itself. If no canvas is opened, a default one (named “<code>c1</code>”)
 is created. In the next example, the first statement defines a function
 and the second one draws it. A default canvas is created since there 
was no opened one. You should see the picture as shown in the next 
figure.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1">root[] TF1 f1(<span class="st">"func1"</span>,<span class="st">"sin(x)/x"</span>,<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb22-2" title="2">root[] f1.Draw()</a>
<a class="sourceLine" id="cb22-3" title="3">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/0300000A.png" alt="A canvas with drawing"><figcaption>A canvas with drawing</figcaption>
</figure>
<p>The following components comprise the canvas window:</p>
<ul>
<li><p>Menu bar - contains main menus for global operations with files, print, clear canvas, inspect, etc.</p></li>
<li><p>Tool bar - has buttons for global and drawing operations; such as arrow, ellipse, latex, pad, etc.</p></li>
<li><p>Canvas - an area to draw objects.</p></li>
<li><p>Status bar - displays descriptive messages about the selected object.</p></li>
<li><p>Editor frame - responds dynamically and presents the user interface according to the selected object in the canvas.</p></li>
</ul>
<h3 id="main-menus-and-toolbar"><span class="header-section-number">2.3.1</span> Main Menus and Toolbar</h3>
<p>At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.</p>
<h4 id="file-menu"><span class="header-section-number">2.3.1.1</span> File Menu</h4>
<ul>
<li><p><em>New Canvas</em>: creates a new canvas window in the current ROOT session.</p></li>
<li><p><em>Open…</em>: popup a dialog to open a file.</p></li>
<li><p><em>Close Canvas</em>: close the canvas window.</p></li>
<li><p><em>Save</em>: save the drawing of the current canvas in a format
 selectable from the submenu. The current canvas name is used as a file 
name for various formats such as PostScript, GIF, JPEG, C macro file, 
root file.</p></li>
<li><p><em>Save As…</em>: popup a dialog for saving the current canvas drawing in a new filename.</p></li>
<li><p><em>Print</em>: popup a dialog to print the current canvas drawing</p></li>
<li><p><em>Quit ROOT</em>: exit the ROOT session</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300000B.png"></p>
<h4 id="edit-menu"><span class="header-section-number">2.3.1.2</span> Edit Menu</h4>
<p>There is only one active menu entry in the Edit menu. The others menu
 entries will be implemented and will become active in the near future.</p>
<ul>
<li><em>Clear:</em> delete all objects in the canvas or in the selected pad according to the selected entry in the submenu.</li>
</ul>
<h4 id="view-menu"><span class="header-section-number">2.3.1.3</span> View Menu</h4>
<ul>
<li><p><em>Editor</em>: toggles the view of the editor. If it is 
selected activates and shows up the editor on the left side of the 
canvas window. According to the selected object, the editor loads the 
corresponding user interface for easy change of the object’s attributes.</p></li>
<li><p><em>Toolbar</em>: toggles the view of the toolbar. If it is 
selected activates and shows up the toolbar. It contains buttons for 
easy and fast access to most frequently used commands and for graphics 
primitive drawing. Tool tips are provided for helping users.</p></li>
<li><p><em>Status Bar</em>: toggles the view of the status bar. If it is
 selected, the status bar below the canvas window shows up. There the 
identification of the objects is displayed when moving the mouse (such 
as the object’s name, the object’s type, its coordinates, etc.).</p></li>
<li><p><em>Colors</em>: creates a new canvas showing the color palette.</p></li>
<li><p><em>Markers</em>: creates a new canvas showing the various marker styles.</p></li>
<li><p><em>Iconify</em>: create the canvas window icon, does not close the canvas</p></li>
<li><p><em>View With…</em>: If the last selected pad contains a 3-d 
structure, a new canvas is created with a 3-D picture according to the 
selection made from the cascaded menu: X3D or OpenGL. The 3-D image can 
be interactively rotated, zoomed in wire-frame, solid, hidden line or 
stereo mode.</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300000C.png"></p>
<h4 id="options-menu"><span class="header-section-number">2.3.1.4</span> Options Menu</h4>
<ul>
<li><p><em>Auto Resize Canvas</em>: turns auto-resize of the canvas <em>on/off</em>:</p>
<ul>
<li><em>on</em> - the canvas fits to the window when changing the window size;</li>
<li><em>off</em> - the canvas stays fixed when changing the window size.</li>
</ul></li>
<li><p><em>Resize Canvas</em>: resizes and fits the canvas to the window size.</p></li>
<li><p><em>Move Opaque</em>: if selected, graphics objects are moved in 
opaque mode; otherwise, only the outline of objects is drawn when moving
 them. The option opaque produces the best effect but it requires a 
reasonably fast workstation or response time.</p></li>
<li><p><em>Resize Opaque</em>: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.</p></li>
<li><p><em>Interrupt</em>: interrupts the current drawing process.</p></li>
<li><p><em>Refresh</em>: redraws the canvas contents.</p></li>
<li><p><em>Pad Auto Exec</em>: executes the list of <strong><code>TExecs</code></strong> in the current pad.</p></li>
<li><p><em>Statistics</em>: toggles the display of the histogram statistics box.</p></li>
<li><p><em>Histogram Title</em>: toggles the display of the histogram title.</p></li>
<li><p><em>Fit Parameters</em>: toggles the display of the histogram or graph fit parameters.</p></li>
<li><p><em>Can Edit Histogram</em>: enables/disables the possibility to edit histogram bin contents.</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300000D.png"></p>
<h4 id="inspect-menu"><span class="header-section-number">2.3.1.5</span> Inspect Menu</h4>
<ul>
<li><p><em>ROOT</em>: inspects the top-level <strong><em><code>gROOT</code></em></strong> object (in a new canvas).</p></li>
<li><p><em>Start Browser</em>: starts a new object browser (in a separate window).</p></li>
<li><p><em>GUI Builder</em>: starts the GUI builder application (in a separate window).</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300000E.png"></p>
<h4 id="help-menu"><span class="header-section-number">2.3.1.6</span> Help Menu</h4>
<ul>
<li><p><em>Canvas:</em> help on canvas as a whiteboard area for drawing.</p></li>
<li><p><em>Menus</em>: help on canvas menus.</p></li>
<li><p><em>Graphics Editor</em>: help on primitives’ drawing and objects’ editor.</p></li>
<li><p><em>Browser</em>: help on the ROOT objects’ and files’ browser.</p></li>
<li><p><em>Objects</em>: help on DrawClass, Inspect and Dump context menu items.</p></li>
<li><p><em>PostScript</em>: help on how to print a canvas to a PostScript file format.</p></li>
<li><p><em>About ROOT</em>: pops up the ROOT Logo with the version number.</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300000F.png"></p>
<h4 id="classes-menu"><span class="header-section-number">2.3.1.7</span> Classes Menu</h4>
<ul>
<li><em>Classes</em>: starts the ClassTree viewer that draws inheritance tree for a list of classes.</li>
</ul>
<h4 id="toolbar"><span class="header-section-number">2.3.1.8</span> Toolbar</h4>
<p>The following menu shortcuts and utilities are available from the toolbar:</p>
<p><img src="ROOTUsersGuide_files/03000010.png"> Create a new canvas window.</p>
<p><img src="ROOTUsersGuide_files/03000011.png"> Popup the Open File dialog.</p>
<p><img src="ROOTUsersGuide_files/03000012.png"> Popup the Save As… dialog.</p>
<p><img src="ROOTUsersGuide_files/03000013.png"> Popup the Print dialog.</p>
<p><img src="ROOTUsersGuide_files/03000014.png"> Interrupts the current drawing process.</p>
<p><img src="ROOTUsersGuide_files/03000015.png"> Redraw the canvas.</p>
<p><img src="ROOTUsersGuide_files/03000016.png"> Inspect the <strong><em><code>gROOT</code></em></strong> object.</p>
<p><img src="ROOTUsersGuide_files/03000017.png"> Create a new objects’ browser.</p>
<p>You can create the following graphical objects using the toolbar 
buttons for primitive drawing. Tool tips are provided for helping your 
choice.</p>
<p><img src="ROOTUsersGuide_files/03000018.png"> <strong>An Arc or circle</strong>:
 Click on the center of the arc, and then move the mouse. A rubber band 
circle is shown. Click again with the left button to freeze the arc.</p>
<p><img src="ROOTUsersGuide_files/03000019.png"> <strong>A Line</strong>:
 Click with the left button at the point where you want to start the 
line, then move the mouse and click again with the left button to freeze
 the line.</p>
<p><img src="ROOTUsersGuide_files/0300001A.png"> <strong>An Arrow:</strong>Click
 with the left button at the point where you want to start the arrow, 
then move the mouse and click again with the left button to freeze the 
arrow.</p>
<p><img src="ROOTUsersGuide_files/0300001B.png"> <strong>A Diamond</strong>:
 Click with the left button and freeze again with the left button. The 
editor draws a rubber band box to suggest the outline of the diamond.</p>
<p><img src="ROOTUsersGuide_files/0300001C.png"> <strong>An Ellipse</strong>:
 Proceed like for an arc. You can grow/shrink the ellipse by pointing to
 the sensitive points. They are highlighted. You can move the ellipse by
 clicking on the ellipse, but not on the sensitive points. If, with the 
ellipse context menu, you have selected a fill area color, you can move a
 filled-ellipse by pointing inside the ellipse and dragging it to its 
new position.</p>
<p><img src="ROOTUsersGuide_files/0300001D.png"> <strong>A Pad</strong>:
 Click with the left button and freeze again with the left button. The 
editor draws a rubber band box to suggest the outline of the pad.</p>
<p><img src="ROOTUsersGuide_files/0300001E.png"> <strong>A PaveLabel</strong>: Proceed like for a pad. Type the text of label and finish with a carriage return. The text will appear in the box.</p>
<p><img src="ROOTUsersGuide_files/0300001F.png"> <strong>A Pave Text</strong>: Proceed like for a pad. You can then click on the <strong><code>TPaveText</code></strong> object with the right mouse button and select the option <code>InsertText</code>.</p>
<p><img src="ROOTUsersGuide_files/03000020.png"> <strong>Paves Text</strong>: Proceed like for a <strong><code>TPaveText</code></strong>.</p>
<p><img src="ROOTUsersGuide_files/03000021.png"> <strong>A Poly Line</strong>:
 Click with the left button for the first point, move the moose, click 
again with the left button for a new point. Close the poly-line with a 
double click. To edit one vertex point, pick it with the left button and
 drag to the new point position.</p>
<p><img src="ROOTUsersGuide_files/03000022.png"> <strong>A Curly Line</strong>:
 Proceed as for the arrow or line. Once done, click with the third 
button to change the characteristics of the curly line, like transform 
it to wave, change the wavelength, etc.</p>
<p><img src="ROOTUsersGuide_files/03000023.png"> <strong>A Curly Arc</strong>:
 Proceed like for an ellipse. The first click is located at the position
 of the center, the second click at the position of the arc beginning. 
Once done, one obtains a curly ellipse, for which one can click with the
 third button to change the characteristics, like transform it to wavy, 
change the wavelength, set the minimum and maximum angle to make an arc 
that is not closed, etc.</p>
<p><img src="ROOTUsersGuide_files/03000024.png"> <strong>A Text/Latex string</strong>: Click with the left button where you want to draw the text and then type in the text terminated by carriage return. All <strong><code>TLatex</code></strong>
 expressions are valid. To move the text or formula, point on it keeping
 the left mouse button pressed and drag the text to its new position. 
You can grow/shrink the text if you position the mouse to the first 
top-third part of the string, then move the mouse up or down to grow or 
shrink the text respectively. If you position the mouse near the 
bottom-end of the text, you can rotate it.</p>
<p><img src="ROOTUsersGuide_files/03000025.png"> <strong>A Marker</strong>: Click with the left button where to place the marker. The marker can be modified by using the method <code>SetMarkerStyle()</code> of <strong><code>TSystem</code></strong>.</p>
<p><img src="ROOTUsersGuide_files/03000026.png"> <strong>A Graphical Cut</strong>:
 Click with the left button on each point of a polygon delimiting the 
selected area. Close the cut by double clicking on the last point. A <strong><code>TCutG</code></strong> object is created. It can be used as a selection for a <strong><code>TTree</code></strong><code>::Draw</code>. You can get a pointer to this object with:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1">TCutG cut = (TCutG*)gPad-&gt;GetPrimitive(<span class="st">"CUTG"</span>)</a></code></pre></div>
<p>Once you are happy with your picture, you can select the <code>Save as canvas.C</code>
 item in the canvas File menu. This will automatically generate a script
 with the C++ statements corresponding to the picture. This facility 
also works if you have other objects not drawn with the graphics editor 
(histograms for example).</p>
<h3 id="the-editor-frame"><span class="header-section-number">2.3.2</span> The Editor Frame</h3>
<p>The ROOT graphics editor loads the corresponding object editor <code>objEditor</code> according to the selected object <code>obj</code>
 in the canvas respecting the class inheritance. An object in the canvas
 is selected after the left mouse click on it. For example, if the 
selected object is <strong><code>TAxis</code></strong>, the <strong><code>TAxisEditor</code></strong> will shows up in the editor frame giving the possibility for changing different axis attributes. The graphics editor can be:</p>
<p>Embedded - connected only with the canvas in the application window 
that appears on the left of the canvas window after been activated via 
View menu / Editor. It appears on the left side if the canvas window 
allowing users to edit the attributes of the selected object via 
provided user interface. The name of the selected object is displayed on
 the top of the editor frame in red color. If the user interface needs 
more space then the height of the canvas window, a vertical scroll bar 
appears for easer navigation.</p>
<p><img src="ROOTUsersGuide_files/03000027.png"></p>
<p>Global - has own application window and can be connected to any 
created canvas in a ROOT session. It can be activated via the context 
menu entries for setting line, fill, text and marker attributes for 
backward compatibility, but there will be a unique entry in the near 
future.</p>
<p><img src="ROOTUsersGuide_files/03000028.png"></p>
<p>The user interface for the following classes is available since ROOT v.4.04: <strong><code>TAttLine</code></strong>, <strong><code>TAttFill</code></strong>, <strong><code>TAttMarker</code></strong>, <strong><code>TAttText</code></strong>, <strong><code>TArrow</code></strong>, <strong><code>TAxis</code></strong>, <strong><code>TCurlyArc</code></strong>, <strong><code>TCurlyLine</code></strong>, <strong><code>TFrame</code></strong>, <strong><code>TH1</code></strong>, <strong><code>TH2</code></strong>, <strong><code>TGraph</code></strong>, <strong><code>TPad</code></strong>, <strong><code>TCanvas</code></strong>, <strong><code>TPaveStats</code></strong>. For more details, see “The Graphics Editor”, “The User Interface for Histograms”, “The User Interface for Graphs”.</p>
<h3 id="classes-methods-and-constructors"><span class="header-section-number">2.3.3</span> Classes, Methods and Constructors</h3>
<p>Object oriented programming introduces objects, which have data members and methods. The next line creates an object named <code>f1</code> of the class <strong><code>TF1</code></strong>
 that is a one-dimensional function. The type of an object is called a 
class. The object itself is called an instance of a class. When a method
 builds an object, it is called a constructor.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1">TF1 f1(<span class="st">"func1"</span>,<span class="st">"sin(x)/x"</span>,<span class="dv">0</span>,<span class="dv">10</span>)</a></code></pre></div>
<p>In our constructor the function sin(x)/x is defined for use, and 0 and 10 are the limits. The first parameter, <code>func1</code> is the name of the object <code>f1</code>.
 Most objects in ROOT have a name. ROOT maintains a list of objects that
 can be searched to find any object by its given name (in our example <code>func1</code>).</p>
<p>The syntax to call an object’s method, or if one prefers, to make an object to do something is:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1">object.method_name(parameters)</a></code></pre></div>
<p>The dot can be replaced by “<code>-&gt;</code>” if <code>object</code> is a pointer. In compiled code, the dot MUST be replaced by a “<code>-&gt;</code>” if object is a pointer.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1">object_ptr-&gt;method_name(parameters)</a></code></pre></div>
<p>So now, we understand the two lines of code that allowed us to draw our function. <code>f1.Draw()</code> stands for “call the method <code>Draw()</code> associated with the object <code>f1</code> of the class <strong><code>TF1</code></strong>”. Other methods can be applied to the object <code>f1</code> of the class <strong><code>TF1</code></strong>. For example, the evaluating and calculating the derivative and the integral are what one would expect from a function.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1">root[] f1.Eval(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb27-2" title="2">(<span class="dt">Double_t</span>)<span class="fl">4.70400026866224020e-02</span></a>
<a class="sourceLine" id="cb27-3" title="3">root[] f1.Derivative(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb27-4" title="4">(<span class="dt">Double_t</span>)(-<span class="fl">3.45675056671992330e-01</span>)</a>
<a class="sourceLine" id="cb27-5" title="5">root[] f1.Integral(<span class="dv">0</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb27-6" title="6">(<span class="dt">Double_t</span>)<span class="fl">1.84865252799946810e+00</span></a>
<a class="sourceLine" id="cb27-7" title="7">root[] f1.Draw()</a></code></pre></div>
<p>By default the method <code>TF1::Paint()</code>, that draws the function, computes 100 equidistant points to draw it. The number of points can be set to a higher value with:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1">root[] f1.SetNpx(<span class="dv">2000</span>);</a></code></pre></div>
<p>Note that while the ROOT framework is an object-oriented framework, this does not prevent the user from calling plain functions.</p>
<h3 id="user-interaction"><span class="header-section-number">2.3.4</span> User Interaction</h3>
<p>Now we will look at some interactive capabilities. Try to draw the function <code>sin(x)/x</code>
 again. Every object in a window (which is called a canvas) is, in fact,
 a graphical object in the sense that you can grab it, resize it, and 
change its characteristics with a mouse click. For example, bring the 
cursor over the x-axis. The cursor changes to a hand with a pointing 
finger when it is over the axis. Now, left click and drag the mouse 
along the axis to the right. You have a very simple zoom.</p>
<p>When you move the mouse over any object, you can get access to 
selected methods by pressing the right mouse button and obtaining a 
context menu. If you try this on the function <strong><code>TF1</code></strong>, you will get a menu showing available methods. The other objects on this canvas are the title, a <strong><code>TPaveText</code></strong> object<code>;</code> the x and y-axis, <strong><code>TAxis</code></strong> objects, the frame, a <strong><code>TFrame</code></strong> object, and the canvas a <strong><code>TCanvas</code></strong> object. Try clicking on these and observe the context menu with their methods.</p>
<figure>
<img src="ROOTUsersGuide_files/0300002A.png" alt="A context menu"><figcaption>A context menu</figcaption>
</figure>
<p>For example try selecting the <code>SetRange()</code> method and putting <code>-10</code>, <code>10</code> in the dialog box fields. This is equivalent to executing <code>f1.SetRange(-10,10)</code> from the command line, followed by <code>f1.Draw()</code>. Here are some other options you can try.</p>
<p>Once the picture suits your wishes, you may want to see the code you 
should put in a script to obtain the same result. To do that, choose 
Save / <code>canvas.C</code> entry of the File menu. This will generate a
 script showing the options set in the current canvas. Notice that you 
can also save the picture into various file formats such as PostScript, 
GIF, etc. Another interesting possibility is to save your canvas into 
the native ROOT format (<code>.root</code>file). This will enable you to
 open it again and to change whatever you like. All objects associated 
to the canvas (histograms, graphs) are saved at the same time.</p>
<h3 id="building-a-multi-pad-canvas"><span class="header-section-number">2.3.5</span> Building a Multi-pad Canvas</h3>
<p>Let us now try to build a canvas with several pads.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1">root[] TCanvas *MyC = <span class="kw">new</span> TCanvas(<span class="st">"MyC"</span>,<span class="st">"Test canvas"</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb29-2" title="2">root[] MyC-&gt;Divide(<span class="dv">2</span>,<span class="dv">2</span>)</a></code></pre></div>
<p>Once again, we call the constructor of a class, this time the class <strong><code>TCanvas</code></strong>. The difference between this and the previous constructor call (<strong><code>TF1</code></strong>) is that here we are creating a pointer to an object. Next, we call the method <code>Divide()</code> of the <strong><code>TCanvas</code></strong> class (that is <code>TCanvas::Divide())</code>,
 which divides the canvas into four zones and sets up a pad in each of 
them. We set the first pad as the active one and than draw the function<code>f1</code>there.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1">root[] MyC-&gt;cd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-2" title="2">root[] f1-&gt;Draw()</a></code></pre></div>
<p>All objects will be drawn in that pad because it is the active one. The ways for changing the active pad are:</p>
<ul>
<li><p>Click the middle mouse button on a pad will set this pad as the active one.</p></li>
<li><p>Use the method <code>TCanvas::cd()</code> with the pad number, as was done in the example above:</p></li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1">root[] MyC-&gt;cd(<span class="dv">3</span>)</a></code></pre></div>
<p>Pads are numbered from left to right and from top to bottom. Each new pad created by <code>TCanvas::Divide()</code> has a name, which is the name of the canvas followed by _1, _2, etc. To apply the method <code>cd()</code> to the third pad, you would write:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1">root[] MyC_3-&gt;cd()</a></code></pre></div>
<ul>
<li>Third pad will be selected since you called <code>TPad::cd()</code> for the object <code>MyC_3</code>. ROOT will find the pad that was named<code>MyC_3</code>when you typed it on the command line (see ROOT/Cling Extensions to C++).</li>
</ul>
<h3 id="saving-the-canvas"><span class="header-section-number">2.3.6</span> Saving the Canvas</h3>
<figure>
<img src="ROOTUsersGuide_files/0300002B.png" alt="The SaveAs… dialog"><figcaption>The SaveAs… dialog</figcaption>
</figure>
<p>Using the File menu / Save cascade menu users can save the canvas as 
one of the files from the list. Please note that saving the canvas this 
way will overwrite the file with the same name without a warning.</p>
<p>All supported file types can be saved via File menu / SaveAs… This 
dialog gives a choice to show or suppress the confirmation message for 
overwriting an existing file.</p>
<p>If the Overwrite check box is not selected, a message dialog appears 
asking the user to overwrite the file (Yes/No). The user choice is saved
 for the next time the Save As… dialog shows up.</p>
<h3 id="printing-the-canvas"><span class="header-section-number">2.3.7</span> Printing the Canvas</h3>
<p>The Print command in the canvas File menu pops-up a print dialog 
where the user can specify a preferred print command and the printer 
name.</p>
<p><img src="ROOTUsersGuide_files/0300002D.png"></p>
<p>Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:</p>
<pre><code># Printer settings.
WinNT.*.Print.Command:    AcroRd32.exe
Unix.*.Print.Command:     xprint -P%p %f
Print.Printer:            32-rb205-hp
Print.Directory:          .</code></pre>
<p>If the <code>%p</code> and <code>%f</code> are specified as a part of
 the print command, they will be replaced by the specified printer name 
and the file name. All other parameters will be kept as they are 
written. A print button is available in the canvas toolbar (activated 
via View menu/Toolbar).</p>
<h2 id="the-root-command-line"><span class="header-section-number">2.4</span> The ROOT Command Line</h2>
<p>We have briefly touched on how to use the command line. There are different types of commands.</p>
<ol type="1">
<li>Cling commands start with “<code>.</code>”</li>
</ol>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" title="1">root[] .?  <span class="co">//this command will list all the Cling commands</span></a>
<a class="sourceLine" id="cb34-2" title="2">root[] .L &lt;filename&gt;  <span class="co">//load [filename]</span></a>
<a class="sourceLine" id="cb34-3" title="3">root[] .x &lt;filename&gt;  <span class="co">//load and execute [filename]</span></a></code></pre></div>
<ol start="2" type="1">
<li>SHELL commands start with “<code>.!</code>” for example:</li>
</ol>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" title="1">root[] .! ls</a></code></pre></div>
<ol start="3" type="1">
<li>C++ commands follow C++ syntax (almost)</li>
</ol>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1">root[] TBrowser *b = <span class="kw">new</span> TBrowser()</a></code></pre></div>
<h3 id="multi-line-commands"><span class="header-section-number">2.4.1</span> Multi-line Commands</h3>
<p>You can use the command line to execute multi-line commands. To begin
 a multi-line command you must type a single left curly bracket <code>{</code>, and to end it you must type a single right curly bracket <code>}</code>. For example:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" title="1">root[] {</a>
<a class="sourceLine" id="cb37-2" title="2">end with <span class="ch">'}'</span>&gt; <span class="dt">Int_t</span> j = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb37-3" title="3">end with <span class="ch">'}'</span>&gt; <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++)</a>
<a class="sourceLine" id="cb37-4" title="4">end with <span class="ch">'}'</span>&gt; {</a>
<a class="sourceLine" id="cb37-5" title="5">end with <span class="ch">'}'</span>&gt; j= j + i;</a>
<a class="sourceLine" id="cb37-6" title="6">end with <span class="ch">'}'</span>&gt; cout &lt;&lt; <span class="st">"i = "</span> &lt;&lt; i &lt;&lt; <span class="st">", j = "</span> &lt;&lt; j &lt;&lt; endl;</a>
<a class="sourceLine" id="cb37-7" title="7">end with <span class="ch">'}'</span>&gt; }</a>
<a class="sourceLine" id="cb37-8" title="8">end with <span class="ch">'}'</span>&gt; }</a>
<a class="sourceLine" id="cb37-9" title="9">i = <span class="dv">0</span>, j = <span class="dv">0</span></a>
<a class="sourceLine" id="cb37-10" title="10">i = <span class="dv">1</span>, j = <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-11" title="11">i = <span class="dv">2</span>, j = <span class="dv">3</span></a></code></pre></div>
<p>It is more convenient to edit a script than the command line, and if 
your multi line commands are getting unmanageable, you may want to start
 with a script instead.</p>
<h3 id="cling-extensions"><span class="header-section-number">2.4.2</span> Cling Extensions</h3>
<p>We should say that some things are not standard C++. The Cling 
interpreter has several extensions. See “ROOT/Cling Extensions to C++”.</p>
<h3 id="helpful-hints-for-command-line-typing"><span class="header-section-number">2.4.3</span> Helpful Hints for Command Line Typing</h3>
<p>The interpreter knows all the classes, functions, variables, and user
 defined types. This enables ROOT to help users to complete the command 
line. For example, if we do not know anything about the <strong><code>TLine</code></strong> class, the Tab feature helps us to get a list of all classes starting with <strong><code>TL</code></strong>(where <code>&lt;TAB&gt;</code> means type the Tab key).</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" title="1">root[] l = <span class="kw">new</span> TLi&lt;TAB&gt;</a>
<a class="sourceLine" id="cb38-2" title="2">TList</a>
<a class="sourceLine" id="cb38-3" title="3">TListIter</a>
<a class="sourceLine" id="cb38-4" title="4">TLink</a>
<a class="sourceLine" id="cb38-5" title="5">TLine</a>
<a class="sourceLine" id="cb38-6" title="6">TLimitDataSource</a>
<a class="sourceLine" id="cb38-7" title="7">TLimit</a></code></pre></div>
<p>To list the different constructors and parameters for <strong><code>TLine</code></strong> use the <code>&lt;TAB&gt;</code> key as follows:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb39-1" title="1">root[] l = <span class="kw">new</span> TLine(&lt;TAB&gt;</a>
<a class="sourceLine" id="cb39-2" title="2">TLine TLine()</a>
<a class="sourceLine" id="cb39-3" title="3">TLine TLine(<span class="dt">Double_t</span> x1,<span class="dt">Double_t</span> y1,<span class="dt">Double_t</span> x2,<span class="dt">Double_t</span> y2)</a>
<a class="sourceLine" id="cb39-4" title="4">TLine TLine(<span class="at">const</span> TLine&amp; line)</a></code></pre></div>
<h3 id="regular-expression"><span class="header-section-number">2.4.4</span> Regular Expression</h3>
<p>The meta-characters below can be used in a regular expression:</p>
<ul>
<li><p>‘<code>^</code>’ start-of-line anchor</p></li>
<li><p>‘<code>$</code>’ end-of-line anchor</p></li>
<li><p>‘<code>.</code>’ matches any character</p></li>
<li><p>‘<code>[</code>’ start a character class</p></li>
<li><p>’<code>]</code>’end a character class</p></li>
<li><p>’<code>^</code>’negates character class if first character</p></li>
<li><p>‘<code>*</code>’<code>Kleene</code> closure (matches 0 or more)</p></li>
<li><p>’<code>+</code>’Positive closure (1 or more)</p></li>
<li><p>‘<code>?</code>’ Optional closure (0 or 1)</p></li>
</ul>
<p>When using wildcards the regular expression is assumed to be preceded by a ‘<code>^</code>’ (BOL) and terminated by ‘<code>$</code>’ (EOL). All ‘<code>*</code>’ (closures) are assumed to be preceded by a ‘<code>.</code>’, i.e.&nbsp;any character, except slash _<code>/_</code>. Its special treatment allows the easy matching of pathnames. For example, <code>_*.root_</code> will match <code>_aap.root_</code>, but not <code>_pipo/aap.root_</code>.</p>
<p>The escape characters are:</p>
<ul>
<li><p><code>\</code> backslash</p></li>
<li><p><code>b</code> backspace</p></li>
<li><p><code>f</code> form feed</p></li>
<li><p><code>n</code> new line</p></li>
<li><p><code>r</code> carriage return</p></li>
<li><p><code>s</code> space</p></li>
<li><p><code>t</code> tab</p></li>
<li><p><code>e</code> ASCII ESC character (‘033’)</p></li>
<li><p><code>DDD</code> number formed of 1-3 octal digits</p></li>
<li><p><code>xDD</code> number formed of 1-2 hex digits</p></li>
<li><p><code>^C</code> C = any letter. Control code</p></li>
</ul>
<p>The class <strong><code>TRegexp</code></strong> can be used to create a regular expression from an input string. If <code>wildcard</code> is true then the input string contains a wildcard expression.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb40-1" title="1">TRegexp(<span class="at">const</span> <span class="dt">char</span> *re, <span class="dt">Bool_t</span> wildcard)</a></code></pre></div>
<p>Regular expression and wildcards can be easily used in methods like:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">Ssiz_t</span> Index(<span class="at">const</span> TString&amp; string,<span class="dt">Ssiz_t</span>* len,<span class="dt">Ssiz_t</span> i) <span class="at">const</span></a></code></pre></div>
<p>The method finds the first occurrence of the regular expression in the <code>string</code> and returns its position.</p>
<h2 id="conventions"><span class="header-section-number">2.5</span> Conventions</h2>
<p>In this paragraph, we will explain some of the conventions used in ROOT source and examples.</p>
<h3 id="coding-conventions"><span class="header-section-number">2.5.1</span> Coding Conventions</h3>
<p>From the first days of ROOT development, it was decided to use a set 
of coding conventions. This allows a consistency throughout the source 
code. Learning these will help you identify what type of information you
 are dealing with and enable you to understand the code better and 
quicker. Of course, you can use whatever convention you want but if you 
are going to submit some code for inclusion into the ROOT sources, you 
will need to use these.</p>
<p>These are the coding conventions:</p>
<ul>
<li><p>Classes begin with <strong><code>T</code></strong>: <strong><code>TLine</code></strong>, <strong><code>TTree</code></strong></p></li>
<li><p>Non-class types end with <strong><code>_t</code></strong>: <code>Int_t</code></p></li>
<li><p>Data members begin with <strong><code>f</code></strong>: <code>fTree</code></p></li>
<li><p>Member functions begin with a capital: <code>Loop()</code></p></li>
<li><p>Constants begin with <strong><code>k</code></strong>: <code>kInitialSize</code>, <code>kRed</code></p></li>
<li><p>Global variables begin with <strong><code>g</code></strong>: <strong><em><code>gEnv</code></em></strong></p></li>
<li><p>Static data members begin with <strong><code>fg</code></strong>: <code>fgTokenClient</code></p></li>
<li><p>Enumeration types begin with <strong><code>E</code></strong>: <code>EColorLevel</code></p></li>
<li><p>Locals and parameters begin with a lower case: <code>nbytes</code></p></li>
<li><p>Getters and setters begin with <strong><code>Get</code></strong> and <strong><code>Set</code></strong>: <code>SetLast</code>(), <code>GetFirst</code>()</p></li>
</ul>
<h3 id="machine-independent-types"><span class="header-section-number">2.5.2</span> Machine Independent Types</h3>
<p>Different machines may have different lengths for the same type. The most famous example is the <code>int</code>
 type. It may be 16 bits on some old machines and 32 bits on some newer 
ones. To ensure the size of your variables, use these pre defined types 
in ROOT:</p>
<ul>
<li><p><strong><code>Char_t</code></strong> Signed Character 1 byte</p></li>
<li><p><strong><code>UChar_t</code></strong> Unsigned Character 1 byte</p></li>
<li><p><strong><code>Short_t</code></strong> Signed Short integer 2 bytes</p></li>
<li><p><strong><code>UShort_t</code></strong> Unsigned Short integer 2 bytes</p></li>
<li><p><strong><code>Int_t</code></strong> Signed integer 4 bytes</p></li>
<li><p><strong><code>UInt_t</code></strong>Unsigned integer 4 bytes</p></li>
<li><p><strong><code>Long64_t</code></strong> Portable signed long integer 8 bytes</p></li>
<li><p><strong><code>ULong64_t</code></strong> Portable unsigned long integer 8 bytes</p></li>
<li><p><strong><code>Float_t</code></strong> Float 4 bytes</p></li>
<li><p><strong><code>Double_t</code></strong> Float 8 bytes</p></li>
<li><p><strong><code>Double32_t</code></strong> Double 8 bytes in memory, written as a Float 4 bytes</p></li>
<li><p><strong><code>Bool_t</code></strong> Boolean (0=false, 1=true)</p></li>
</ul>
<p>If you do not want to save a variable on disk, you can use <code>int</code> or <code>Int_t</code>, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.</p>
<h3 id="tobject"><span class="header-section-number">2.5.3</span> TObject</h3>
<p>In ROOT, almost all classes inherit from a common base class called <strong><code>TObject</code></strong>. This kind of architecture is also used in the Java language. The <strong><code>TObject</code></strong>
 class provides default behavior and protocol for all objects in the 
ROOT system. The main advantage of this approach is that it enforces the
 common behavior of the derived classes and consequently it ensures the 
consistency of the whole system. See “The Role of TObject”.</p>
<p><strong><code>TObject</code></strong> provides protocol, i.e.&nbsp;(abstract) member functions, for:</p>
<ul>
<li><p>Object I/O (<code>Read()</code>, <code>Write())</code></p></li>
<li><p>Error handling (<code>Warning()</code>, <code>Error()</code>, <code>SysError()</code>, <code>Fatal())</code></p></li>
<li><p>Sorting (<code>IsSortable()</code>, <code>Compare()</code>, <code>IsEqual()</code>, <code>Hash())</code></p></li>
<li><p>Inspection (<code>Dump()</code>, <code>Inspect()</code>)</p></li>
<li><p>Printing (<code>Print())</code></p></li>
<li><p>Drawing (<code>Draw()</code>, <code>Paint()</code>, <code>ExecuteEvent())</code></p></li>
<li><p>Bit handling (<code>SetBit()</code>, <code>TestBit()</code>)</p></li>
<li><p>Memory allocation (operator<code>new and delete</code>, <code>IsOnHeap())</code></p></li>
<li><p>Access to meta information (<code>IsA()</code>, <code>InheritsFrom())</code></p></li>
<li><p>Object browsing (<code>Browse()</code>, <code>IsFolder())</code></p></li>
</ul>
<h2 id="global-variables"><span class="header-section-number">2.6</span> Global Variables</h2>
<p>ROOT has a set of global variables that apply to the session. For example, <strong><em><code>gDirectory</code></em></strong> always holds the current directory, and <strong><em><code>gStyle</code></em></strong> holds the current style.</p>
<p>All global variables begin with “<em>g</em>” followed by a capital letter.</p>
<h3 id="groot"><span class="header-section-number">2.6.1</span> gROOT</h3>
<p>The single instance of <strong><code>TROOT</code></strong> is accessible via the global <strong><em><code>gROOT</code></em></strong> and holds information relative to the current session. By using the <strong><em><code>gROOT</code></em></strong> pointer, you get the access to every object created in a ROOT program. The <strong><code>TROOT</code></strong> object has several lists pointing to the main ROOT objects. During a ROOT session, the <strong><em><code>gROOT</code></em></strong> keeps a series of collections to manage objects. They can be accessed via <strong><em><code>gROOT</code></em></strong><code>::GetListOf...</code> methods.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb42-1" title="1">gROOT-&gt;GetListOfClasses()</a>
<a class="sourceLine" id="cb42-2" title="2">gROOT-&gt;GetListOfColors()</a>
<a class="sourceLine" id="cb42-3" title="3">gROOT-&gt;GetListOfTypes()</a>
<a class="sourceLine" id="cb42-4" title="4">gROOT-&gt;GetListOfGlobals()</a>
<a class="sourceLine" id="cb42-5" title="5">gROOT-&gt;GetListOfGlobalFunctions()</a>
<a class="sourceLine" id="cb42-6" title="6">gROOT-&gt;GetListOfFiles()</a>
<a class="sourceLine" id="cb42-7" title="7">gROOT-&gt;GetListOfMappedFiles()</a>
<a class="sourceLine" id="cb42-8" title="8">gROOT-&gt;GetListOfSockets()</a>
<a class="sourceLine" id="cb42-9" title="9">gROOT-&gt;GetListOfCanvases()</a>
<a class="sourceLine" id="cb42-10" title="10">gROOT-&gt;GetListOfStyles()</a>
<a class="sourceLine" id="cb42-11" title="11">gROOT-&gt;GetListOfFunctions()</a>
<a class="sourceLine" id="cb42-12" title="12">gROOT-&gt;GetListOfSpecials()</a>
<a class="sourceLine" id="cb42-13" title="13">gROOT-&gt;GetListOfGeometries()</a>
<a class="sourceLine" id="cb42-14" title="14">gROOT-&gt;GetListOfBrowsers()</a>
<a class="sourceLine" id="cb42-15" title="15">gROOT-&gt;GetListOfMessageHandlers()</a></code></pre></div>
<p>These methods return a <strong><code>TSeqCollection</code></strong>, 
meaning a collection of objects, and they can be used to do list 
operations such as finding an object, or traversing the list and calling
 a method for each of the members. See the <strong><code>TCollection</code></strong> class description for the full set of methods supported for a collection. For example, to find a canvas called <code>c1</code>you can do<code>:</code></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb43-1" title="1">root[] gROOT-&gt;GetListOfCanvases()-&gt;FindObject(<span class="st">"c1"</span>)</a></code></pre></div>
<p>This returns a pointer to a <strong><code>TObject</code></strong>, and before you can use it as a canvas you need to cast it to a <strong><code>TCanvas*</code>.</strong></p>
<h3 id="gfile"><span class="header-section-number">2.6.2</span> gFile</h3>
<p><strong><em><code>gFile</code></em></strong> is the pointer to the current opened file in the ROOT session.</p>
<h3 id="gdirectory"><span class="header-section-number">2.6.3</span> gDirectory</h3>
<p><strong><em><code>gDirectory</code></em></strong> is a pointer to the current directory. The concept and role of a directory is explained in the chapter “Input/Output”.</p>
<h3 id="gpad"><span class="header-section-number">2.6.4</span> gPad</h3>
<p>A graphic object is always drawn on the active pad. It is convenient 
to access the active pad, no matter what it is. For that, we have <strong><em><code>gPad</code></em></strong>
 that is always pointing to the active pad. For example, if you want to 
change the fill color of the active pad to blue, but you do not know its
 name, you can use <strong><em><code>gPad</code></em></strong>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" title="1">root[] gPad-&gt;SetFillColor(<span class="dv">38</span>)</a></code></pre></div>
<p>To get the list of colors, if you have an open canvas, click in the “View” menu, selecting the “Colors” entry.</p>
<h3 id="grandom"><span class="header-section-number">2.6.5</span> gRandom</h3>
<p><strong><em><code>gRandom</code></em></strong> is a pointer to the current random number generator. By default, it points to a <strong><code>TRandom3</code></strong>
 object, based on the “Mersenne-Twister” generator. This generator is 
very fast and has very good random proprieties (a very long period of 10<sup>600</sup>). Setting the seed to 0 implies that the seed will be uniquely generated using the <strong><code>TUUID</code></strong>. Any other value will be used as a constant. The following basic random distributions are provided: <code>Rndm()</code> or <code>Uniform(min,max)</code>, <code>Gaus(mean,sigma)</code>, <code>Exp(tau)</code>, <code>BreitWigner(mean,sigma)</code>, <code>Landau(mean,sigma)</code>, <code>Poisson(mean)</code>, <code>Binomial(ntot,prob)</code>. You can customize your ROOT session by replacing the random number generator. You can delete <strong><em><code>gRandom</code></em></strong> and recreate it with your own. For example:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb45-1" title="1">root[] <span class="kw">delete</span> gRandom;</a>
<a class="sourceLine" id="cb45-2" title="2">root[] gRandom = <span class="kw">new</span> TRandom2(<span class="dv">0</span>); <span class="co">//seed=0</span></a></code></pre></div>
<p><strong><code>TRandom2</code></strong> is another generator, which is also very fast and uses only three words for its state.</p>
<h3 id="genv"><span class="header-section-number">2.6.6</span> gEnv</h3>
<p><strong><code>gEnv</code></strong> is the global variable (of type <strong><code>TEnv</code></strong>) with all the environment settings for the current session. This variable is set by reading the contents of a <code>.rootrc</code> file (or <code>$ROOTSYS/etc/system.rootrc</code>) at the beginning of the root session. See Environment Setup below for more information.</p>
<h2 id="environment-setup"><span class="header-section-number">2.7</span> Environment Setup</h2>
<p>The behavior of a ROOT session can be tailored with the options in the .<code>rootrc</code> file. At start-up, ROOT looks for a .<code>rootrc</code> file in the following order:</p>
<ul>
<li><p><code>./.rootrc</code> <em><code>//local directory</code></em></p></li>
<li><p><code>$HOME/.rootrc</code> <em><code>//user directory</code></em></p></li>
<li><p><code>$ROOTSYS/etc/system.rootrc</code> <em><code>//global ROOT directory</code></em></p></li>
</ul>
<p>If more than one <code>.rootrc</code> files are found in the search 
paths above, the options are merged, with precedence local, user, 
global. While in a session, to see current settings, you can do:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb46-1" title="1">root[] gEnv-&gt;Print()</a></code></pre></div>
<p>The <code>rootrc</code> file typically looks like:</p>
<pre><code># Path used by dynamic loader to find shared libraries
Unix.*.Root.DynamicPath:  .:~/rootlibs:$(ROOTSYS)/lib
Unix.*.Root.MacroPath:    .:~/rootmacros:$(ROOTSYS)/macros

# Path where to look for TrueType fonts
Unix.*.Root.UseTTFonts:     true
Unix.*.Root.TTFontPath:
...
# Activate memory statistics
Rint.Load:               rootalias.C
Rint.Logon:              rootlogon.C
Rint.Logoff:             rootlogoff.C
...
Rint.Canvas.MoveOpaque:  false
Rint.Canvas.HighLightColor: 5</code></pre>
<p>The various options are explained in <code>$ROOTSYS/etc/system.rootrc</code>. The <code>.rootrc</code> file contents are combined. For example, if the flag to use true type fonts is set to true in the <code>system.rootrc</code> file, you have to set explicitly it false in your local <code>.rootrc</code> file if you do not want to use true type fonts. Removing the <code>UseTTFonts</code>statement in the local <code>.rootrc</code> file will not disable true fonts. The value of the environment variable <code>ROOTDEBUG</code> overrides the value in the <code>.rootrc</code> file at startup. Its value is used to set <strong><em><code>gDebug</code></em></strong> and helps for quick turn on debug mode in <strong><code>TROOT</code></strong> startup.</p>
<p>ROOT looks for scripts in the path specified in the <code>.rootrc</code> file in the <code>Root.Macro.Path</code> variable. You can expand this path to hold your own directories.</p>
<h3 id="logon-and-logoff-scripts"><span class="header-section-number">2.7.1</span> Logon and Logoff Scripts</h3>
<p>The <code>rootlogon.C</code> and <code>rootlogoff.C</code> files are scripts loaded and executed at start-up and shutdown. The <code>rootalias.C</code> file is loaded but not executed. It typically contains small utility functions. For example, the <code>rootalias.C</code> script that comes with the ROOT distributions (located in <code>$ROOTSYS/tutorials)</code> defines the function <code>edit(char *file)</code>.
 This allows the user to call the editor from the command line. This 
particular function will start the VI editor if the environment variable
 <code>EDITOR</code> is not set.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb48-1" title="1">root[<span class="dv">0</span>] edit(<span class="st">"c1.C"</span>)</a></code></pre></div>
<p>For more details, see <code>$ROOTSYS/tutorials/rootalias.C</code>.</p>
<h3 id="history-file"><span class="header-section-number">2.7.2</span> History File</h3>
<p>You can use the up and down arrow at the command line, to access the 
previous and next command. The commands are recorded in the history file
 <code>$HOME/.root_hist</code>. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the <code>system.rootrc</code> file, by setting the <code>Rint.History</code>option. You can also turn off the command logging in the <code>system.rootrc</code> file with the option: <code>Rint.History: -</code></p>
<p>The number of history lines to be kept can be set also in <code>.rootrc</code> by:</p>
<pre><code>Rint.HistSize:         500
Rint.HistSave:         400</code></pre>
<p>The first value defines the maximum of lines kept; once it is reached all, the last <code>HistSave</code> lines will be removed. One can set <code>HistSize</code> to 0 to disable history line management. There is also implemented an environment variable called <code>ROOT_HIST</code>. By setting <code>ROOT_HIST=300:200</code> the above values can be overriden - the first value corresponds to <code>HistSize</code>, the (optional) second one to <code>HistSave</code>. You can set <code>ROOT_HIST=0</code> to disable the history.</p>
<h3 id="tracking-memory-leaks"><span class="header-section-number">2.7.3</span> Tracking Memory Leaks</h3>
<p>You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see <strong><code>TObjectTable</code></strong>). To use this facility, edit the file <code>$ROOTSYS/etc/system.rootrc</code> or <code>.rootrc</code> if you have this file and add the two following lines:</p>
<pre><code>Root.ObjectStat:         1</code></pre>
<p>In your code or on the command line you can type the line:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb51-1" title="1">gObjectTable-&gt;Print();</a></code></pre></div>
<p>This line will print the list of all active classes and the number of
 instances for each class. By comparing consecutive print outs, you can 
see objects that you forgot to delete. Note that this method cannot show
 leaks coming from the allocation of non-objects or classes unknown to 
ROOT.</p>
<h2 id="converting-from-paw-to-root"><span class="header-section-number">2.8</span> Converting from PAW to ROOT</h2>
<p>The web page at: <a href="http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE" class="uri">http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE</a> gives the “translation” table of some commonly used PAW commands into ROOT. If you move the mouse cursor over the picture at: <a href="http://root.cern.ch/root/HowtoConvertFromPAW.html#SET" class="uri">http://root.cern.ch/root/HowtoConvertFromPAW.html#SET</a>, you will get the corresponding ROOT commands as tooltips.</p>
<h3 id="converting-hbookpaw-files"><span class="header-section-number">2.8.1</span> Converting HBOOK/PAW Files</h3>
<p>ROOT has a utility called <code>h2root</code> that you can use to 
convert your HBOOK/PAW histograms or ntuple files into ROOT files. To 
use this program, you type the shell script command:</p>
<pre><code>h2root  &lt;hbookfile&gt;  &lt;rootfile&gt;</code></pre>
<p>If you do not specify the second parameter, a file name is automatically generated for you. If <code>hbookfile</code> is of the form <code>file.hbook</code>, then the ROOT file will be called <code>file.root</code>. This utility converts HBOOK histograms into ROOT histograms of the class <strong><code>TH1F</code></strong>. HBOOK profile histograms are converted into ROOT profile histograms (see class <strong><code>TProfile</code></strong>).
 HBOOK row-wise and column-wise ntuples are automatically converted to 
ROOT Trees. See “Trees”. Some HBOOK column-wise ntuples may not be fully
 converted if the columns are an array of fixed dimension (e.g.&nbsp;<code>var[6]</code>) or if they are a multi-dimensional array.</p>
<p>HBOOK integer identifiers are converted into ROOT named objects by prefixing the integer identifier with the letter “<code>h</code>” if the identifier is a positive integer and by <code>"h_"</code>
 if it is a negative integer identifier. In case of row-wise or 
column-wise ntuples, each column is converted to a branch of a tree. 
Note that <code>h2root</code> is able to convert HBOOK files containing 
several levels of sub-directories. Once you have converted your file, 
you can look at it and draw histograms or process ntuples using the ROOT
 command line. An example of session is shown below:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb53-1" title="1"><span class="co">// this connects the file hbookconverted.root</span></a>
<a class="sourceLine" id="cb53-2" title="2">root[] TFile f(<span class="st">"hbookconverted.root"</span>);</a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="co">// display histogram named h10 (was HBBOK id 10)</span></a>
<a class="sourceLine" id="cb53-5" title="5">root[] h10.Draw();</a>
<a class="sourceLine" id="cb53-6" title="6"></a>
<a class="sourceLine" id="cb53-7" title="7"><span class="co">// display column "var" from ntuple h30</span></a>
<a class="sourceLine" id="cb53-8" title="8">root[] h30.Draw(<span class="st">"var"</span>);</a></code></pre></div>
<p>You can also use the ROOT browser (see <strong><code>TBrowser</code></strong>) to inspect this file.</p>
<p>The chapter on trees explains how to read a tree. ROOT includes a function <strong><code>TTree</code></strong><code>::MakeClass</code> to generate automatically the code for a skeleton analysis function. See “Example Analysis”.</p>
<p>In case one of the ntuple columns has a variable length (e.g. <code>px(ntrack)</code>), <code>h.Draw("px")</code> will histogram the <code>px</code>
 column for all tracks in the same histogram. Use the script quoted 
above to generate the skeleton function and create/fill the relevant 
histogram yourself.</p>
<h1 id="histograms"><span class="header-section-number">3</span> Histograms</h1>
<p>This chapter covers the functionality of the histogram classes. We 
begin with an overview of the histogram classes, after which we provide 
instructions and examples on the histogram features.</p>
<p>We have put this chapter ahead of the graphics chapter so that you 
can begin working with histograms as soon as possible. Some of the 
examples have graphics commands that may look unfamiliar to you. These 
are covered in the chapter “Input/Output”.</p>
<h2 id="the-histogram-classes"><span class="header-section-number">3.1</span> The Histogram Classes</h2>
<p></p>
<p>ROOT supports histograms up to three dimensions. Separate concrete 
classes are provided for one-dimensional, two-dimensional and 
three-dimensional classes. The histogram classes are split into further 
categories, depending on the set of possible bin values:</p>
<ul>
<li><p><strong><code>TH1C, TH2C and TH3C</code></strong> contain one char (one byte) per bin (maximum bin content = 255)</p></li>
<li><p><strong><code>TH1S, TH2S and TH3S</code></strong> contain one short (two bytes) per bin (maximum bin content = 65 535).</p></li>
<li><p><strong><code>TH1I, TH2I and TH3I</code></strong> contain one integer (four bytes) per bin (maximum bin content = 2 147 483 647).</p></li>
<li><p><strong><code>TH1L, TH2L and TH3L</code></strong> contain one long64 (eight bytes) per bin (maximum bin content = 9 223 372 036 854 775 807).</p></li>
<li><p><strong><code>TH1F, TH2F and TH3F</code></strong> contain one float (four bytes) per bin (maximum precision = 7 digits).</p></li>
<li><p><strong><code>TH1D, TH2D and TH3D</code></strong> contain one double (eight bytes) per bin (maximum precision = 14 digits).</p></li>
</ul>
<p>ROOT also supports profile histograms, which constitute an elegant 
replacement of two-dimensional histograms in many cases. The 
inter-relation of two measured quantities X and Y can always be 
visualized with a two-dimensional histogram or scatter-plot. Profile 
histograms, on the other hand, are used to display the mean value of Y 
and its RMS for each bin in X. If Y is an unknown but single-valued 
approximate function of X, it will have greater precision in a profile 
histogram than in a scatter plot.</p>
<ul>
<li><p><strong><code>TProfile</code></strong> : one dimensional profiles</p></li>
<li><p><strong><code>TProfile2D</code></strong> : two dimensional profiles</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/0600002E.png" alt="The class hierarchy of histogram classes"><figcaption>The class hierarchy of histogram classes</figcaption>
</figure>
<p>All ROOT histogram classes are derived from the base class <strong><code>TH1</code></strong>
 (see figure above). This means that two-dimensional and 
three-dimensional histograms are seen as a type of a one-dimensional 
histogram, in the same way in which multidimensional C arrays are just 
an abstraction of a one-dimensional contiguous block of memory.</p>
<h2 id="creating-histograms"><span class="header-section-number">3.2</span> Creating Histograms</h2>
<p>There are several ways in which you can create a histogram object in 
ROOT. The straightforward method is to use one of the several 
constructors provided for each concrete class in the histogram 
hierarchy. For more details on the constructor parameters, see the 
subsection <a href="#Fixed.or.Variable.Bin.Width">“Constant or Variable Bin Width”</a> below. Histograms may also be created by:</p>
<ul>
<li><p>Calling the Clone() method of an existing histogram</p></li>
<li><p>Making a projection from a 2-D or 3-D histogram</p></li>
<li><p>Reading a histogram from a file (see Input/Output chapter)</p></li>
</ul>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb54-1" title="1">   <span class="co">// using various constructors</span></a>
<a class="sourceLine" id="cb54-2" title="2">   TH1* h1 = <span class="kw">new</span> TH1I(<span class="st">"h1"</span>, <span class="st">"h1 title"</span>, <span class="dv">100</span>, <span class="fl">0.0</span>, <span class="fl">4.0</span>);</a>
<a class="sourceLine" id="cb54-3" title="3">   TH2* h2 = <span class="kw">new</span> TH2F(<span class="st">"h2"</span>, <span class="st">"h2 title"</span>, <span class="dv">40</span>, <span class="fl">0.0</span>, <span class="fl">2.0</span>, <span class="dv">30</span>, -<span class="fl">1.5</span>, <span class="fl">3.5</span>);</a>
<a class="sourceLine" id="cb54-4" title="4">   TH3* h3 = <span class="kw">new</span> TH3D(<span class="st">"h3"</span>, <span class="st">"h3 title"</span>, <span class="dv">80</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="dv">100</span>, -<span class="fl">2.0</span>, <span class="fl">2.0</span>,</a>
<a class="sourceLine" id="cb54-5" title="5">                       <span class="dv">50</span>, <span class="fl">0.0</span>, <span class="fl">3.0</span>);</a>
<a class="sourceLine" id="cb54-6" title="6"></a>
<a class="sourceLine" id="cb54-7" title="7">   <span class="co">// cloning a histogram</span></a>
<a class="sourceLine" id="cb54-8" title="8">   TH1* hc = (TH1*)h1-&gt;Clone();</a>
<a class="sourceLine" id="cb54-9" title="9"></a>
<a class="sourceLine" id="cb54-10" title="10">   <span class="co">// projecting histograms</span></a>
<a class="sourceLine" id="cb54-11" title="11">   <span class="co">// the projections always contain double values !</span></a>
<a class="sourceLine" id="cb54-12" title="12">   TH1* hx = h2-&gt;ProjectionX(); <span class="co">// ! TH1D, not TH1F</span></a>
<a class="sourceLine" id="cb54-13" title="13">   TH1* hy = h2-&gt;ProjectionY(); <span class="co">// ! TH1D, not TH1F</span></a></code></pre></div>
<h3 id="constant-or-variable-bin-width"><span class="header-section-number">3.2.1</span> Constant or Variable Bin Width</h3>
<p>The histogram classes provide a variety of ways to construct a 
histogram, but the most common way is to provide the name and title of 
histogram and for each dimension: the number of bins, the minimum x 
(lower edge of the first bin) and the maximum x (upper edge of the last 
bin).</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" title="1">   TH2* h = <span class="kw">new</span> TH2D(</a>
<a class="sourceLine" id="cb55-2" title="2">      <span class="co">/* name */</span> <span class="st">"h2"</span>,</a>
<a class="sourceLine" id="cb55-3" title="3">      <span class="co">/* title */</span> <span class="st">"Hist with constant bin width"</span>,</a>
<a class="sourceLine" id="cb55-4" title="4">      <span class="co">/* X-dimension */</span> <span class="dv">100</span>, <span class="fl">0.0</span>, <span class="fl">4.0</span>,</a>
<a class="sourceLine" id="cb55-5" title="5">      <span class="co">/* Y-dimension */</span> <span class="dv">200</span>, -<span class="fl">3.0</span>, <span class="fl">1.5</span>);</a></code></pre></div>
<p>When employing this constructor, you will create a histogram with 
constant (fixed) bin width on each axis. For the example above, the 
interval <code>[0.0, 4.0]</code> is divided into 100 bins of the same width <code>w</code> <code>X = 4.0 - 0.0 100 = 0.04</code> for the X axis (dimension). Likewise, for the Y axis (dimension), we have bins of equal width <code>w</code> <code>Y = 1.5 - (-3.0) 200 = 0.0225</code>.</p>
<p>If you want to create histograms with variable bin widths, ROOT 
provides another constructor suited for this purpose. Instead of passing
 the data interval and the number of bins, you have to pass an array 
(single or double precision) of bin edges. When the histogram has <code>n</code> bins, then there are <code>n+1</code> distinct edges, so the array you pass must be of size <code>n+1</code>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb56-1" title="1">   <span class="at">const</span> <span class="dt">Int_t</span> NBINS = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb56-2" title="2">   <span class="dt">Double_t</span> edges[NBINS + <span class="dv">1</span>] = {<span class="fl">0.0</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="fl">0.8</span>, <span class="fl">1.0</span>};</a>
<a class="sourceLine" id="cb56-3" title="3">   <span class="co">// Bin 1 corresponds to range [0.0, 0.2]</span></a>
<a class="sourceLine" id="cb56-4" title="4">   <span class="co">// Bin 2 corresponds to range [0.2, 0.3] etc...</span></a>
<a class="sourceLine" id="cb56-5" title="5"></a>
<a class="sourceLine" id="cb56-6" title="6">   TH1* h = <span class="kw">new</span> TH1D(</a>
<a class="sourceLine" id="cb56-7" title="7">      <span class="co">/* name */</span> <span class="st">"h1"</span>,</a>
<a class="sourceLine" id="cb56-8" title="8">      <span class="co">/* title */</span> <span class="st">"Hist with variable bin width"</span>,</a>
<a class="sourceLine" id="cb56-9" title="9">      <span class="co">/* number of bins */</span> NBINS,</a>
<a class="sourceLine" id="cb56-10" title="10">      <span class="co">/* edge array */</span> edges</a>
<a class="sourceLine" id="cb56-11" title="11">    );</a></code></pre></div>
<p>Each histogram object contains three <strong><code>TAxis</code></strong> objects: <code>fXaxis</code> , <code>fYaxis,</code> and <code>fZaxis</code>,
 but for one-dimensional histograms only the X-axis is relevant, while 
for two-dimensional histograms the X-axis and Y-axis are relevant. See 
the class <strong><code>TAxis</code></strong> for a description of all the access methods. The bin edges are always stored internally in double precision.</p>
<p>You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb57-1" title="1">   <span class="at">const</span> <span class="dt">Int_t</span> XBINS = <span class="dv">5</span>; <span class="at">const</span> <span class="dt">Int_t</span> YBINS = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb57-2" title="2">   <span class="dt">Double_t</span> xEdges[XBINS + <span class="dv">1</span>] = {<span class="fl">0.0</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="fl">0.8</span>, <span class="fl">1.0</span>};</a>
<a class="sourceLine" id="cb57-3" title="3">   <span class="dt">Double_t</span> yEdges[YBINS + <span class="dv">1</span>] = {-<span class="fl">1.0</span>, -<span class="fl">0.4</span>, -<span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.7</span>, <span class="fl">1.0</span>};</a>
<a class="sourceLine" id="cb57-4" title="4"></a>
<a class="sourceLine" id="cb57-5" title="5">   TH2* h = <span class="kw">new</span> TH2D(<span class="st">"h2"</span>, <span class="st">"h2"</span>, XBINS, xEdges, YBINS, yEdges);</a>
<a class="sourceLine" id="cb57-6" title="6">   TAxis* xAxis = h-&gt;GetXaxis(); TAxis* yAxis = h-&gt;GetYaxis();</a>
<a class="sourceLine" id="cb57-7" title="7"></a>
<a class="sourceLine" id="cb57-8" title="8">   cout &lt;&lt; <span class="st">"Third bin on Y-dimension: "</span> &lt;&lt; endl; <span class="co">// corresponds to</span></a>
<a class="sourceLine" id="cb57-9" title="9">                                                 <span class="co">// [-0.2, 0.5]</span></a>
<a class="sourceLine" id="cb57-10" title="10">   cout &lt;&lt; <span class="st">"</span><span class="sc">\t</span><span class="st">Lower edge: "</span> &lt;&lt; yAxis-&gt;GetBinLowEdge(<span class="dv">3</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb57-11" title="11">   cout &lt;&lt; <span class="st">"</span><span class="sc">\t</span><span class="st">Center: "</span> &lt;&lt; yAxis-&gt;GetBinCenter(<span class="dv">3</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb57-12" title="12">   cout &lt;&lt; <span class="st">"</span><span class="sc">\t</span><span class="st">Upper edge: "</span> &lt;&lt; yAxis-&gt;GetBinUpEdge(<span class="dv">3</span>) &lt;&lt; endl;</a></code></pre></div>
<h2 id="bin-numbering"><span class="header-section-number">3.3</span> Bin Numbering</h2>
<p>All histogram types support fixed or variable bin sizes. 2-D 
histograms may have fixed size bins along X and variable size bins along
 Y or vice-versa. The functions to fill, manipulate, draw, or access 
histograms are identical in both cases.</p>
<h3 id="convention"><span class="header-section-number">3.3.1</span> Convention</h3>
<p>For all histogram types: <code>nbins</code> , <code>xlow</code> , <code>xup</code></p>
<p>Bin# 0 contains the underflow.</p>
<p>Bin# 1&nbsp;contains the first bin with low-edge ( <code>xlow</code> INCLUDED).</p>
<p>The second to last bin (bin# <code>nbins</code>) contains the upper-edge (<code>xup</code> EXCLUDED).</p>
<p>The Last bin (bin# <code>nbins+1)</code> contains the overflow.</p>
<p>In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram <code>h</code> with <code>binx</code>, <code>biny</code>, <code>binz</code>, the function returns a global/linear bin number.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb58-1" title="1">   <span class="dt">Int_t</span> bin = h-&gt;GetBin(binx, biny, binz);</a></code></pre></div>
<p>This global bin is useful to access the bin information independently of the dimension.</p>
<h3 id="re-binning"><span class="header-section-number">3.3.2</span> Re-binning</h3>
<p></p>
<p>At any time, a histogram can be re-binned via the <strong><code>TH1</code></strong><code>::Rebin()</code>
 method. It returns a new histogram with the re-binned contents. If bin 
errors were stored, they are recomputed during the re-binning.</p>
<h2 id="filling-histograms"><span class="header-section-number">3.4</span> Filling Histograms</h2>
<p>A histogram is typically filled with statements like:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb59-1" title="1">   h1-&gt;Fill(x);</a>
<a class="sourceLine" id="cb59-2" title="2">   h1-&gt;Fill(x,w); <span class="co">// with weight</span></a>
<a class="sourceLine" id="cb59-3" title="3">   h2-&gt;Fill(x,y);</a>
<a class="sourceLine" id="cb59-4" title="4">   h2-&gt;Fill(x,y,w);</a>
<a class="sourceLine" id="cb59-5" title="5">   h3-&gt;Fill(x,y,z);</a>
<a class="sourceLine" id="cb59-6" title="6">   h3-&gt;Fill(x,y,z,w);</a></code></pre></div>
<p>The <code>Fill</code> method computes the bin number corresponding to the given x, y or z argument and increments this bin by the given weight. The <code>Fill()</code> method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If <strong><code>TH1</code></strong><code>::Sumw2()</code> has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling <strong><code>TH1</code></strong><code>::AddBinContent()</code>, replace the existing content via <strong><code>TH1</code></strong><code>::SetBinContent()</code> , and access the bin content of a given bin via <strong><code>TH1</code></strong><code>::GetBinContent()</code> .</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb60-1" title="1">   <span class="dt">Double_t</span> binContent = h-&gt;GetBinContent(bin);</a></code></pre></div>
<h3 id="automatic-re-binning-option"><span class="header-section-number">3.4.1</span> Automatic Re-binning Option</h3>
<p>By default, the number of bins is computed using the range of the 
axis. You can change this to re-bin automatically by setting the 
automatic re-binning option:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb61-1" title="1">   h-&gt;SetBit(TH1::kCanRebin);</a></code></pre></div>
<p></p>
<p>Once this is set, the <code>Fill()</code> method will automatically extend the axis range to accommodate the new value specified in the <code>Fill()</code> argument. The used method is to double the bin size until the new value fits in the range, merging bins two by two. The <strong><code>TTree</code></strong><code>::Draw()</code> method extensively uses this automatic binning option when drawing histograms of variables in <strong><code>TTree</code></strong>
 with an unknown range. The automatic binning option is supported for 
1-D, 2-D and 3-D histograms. During filling, some statistics parameters 
are incremented to compute the mean value and root mean square with the 
maximum precision. In case of histograms of type <strong><code>TH1C</code></strong>, <strong><code>TH1S</code></strong>, <strong><code>TH2C</code></strong>, <strong><code>TH2S</code></strong>, <strong><code>TH3C</code></strong>, <strong><code>TH3S</code></strong>
 a check is made that the bin contents do not exceed the maximum 
positive capacity (127 or 65 535). Histograms of all types may have 
positive or/and negative bin contents.</p>
<h2 id="random-numbers-and-histograms"><span class="header-section-number">3.5</span> Random Numbers and Histograms</h2>
<p><strong><code>TH1</code></strong><code>::FillRandom()</code> can be used to randomly fill a histogram using the contents of an existing <strong><code>TF1</code></strong> function or another <strong><code>TH1</code></strong>
 histogram (for all dimensions). For example, the following two 
statements create and fill a histogram 10 000 times with a default 
Gaussian distribution of <code>mean</code> <code>0</code> and <code>sigma</code> <code>1</code> :</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb62-1" title="1">root[] TH1F h1(<span class="st">"h1"</span>,<span class="st">"Histo from a Gaussian"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb62-2" title="2">root[] h1.FillRandom(<span class="st">"gaus"</span>,<span class="dv">10000</span>);</a></code></pre></div>
<p><strong><code>TH1</code></strong><code>::GetRandom()</code> can be 
used to get a random number distributed according the contents of a 
histogram. To fill a histogram following the distribution in an existing
 histogram you can use the second signature of <strong><code>TH1</code></strong><code>::FillRandom()</code>. Next code snipped assumes that <code>h</code> is an existing histogram (<strong><code>TH1</code></strong> ).</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb63-1" title="1">root[] TH1F h2(<span class="st">"h2"</span>,<span class="st">"Histo from existing histo"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb63-2" title="2">root[] h2.FillRandom(&amp;h1, <span class="dv">1000</span>);</a></code></pre></div>
<p>The distribution contained in the histogram <code>h1</code> ( <strong><code>TH1</code></strong>
 ) is integrated over the channel contents. It is normalized to one. The
 second parameter (1000) indicates how many random numbers are 
generated.</p>
<p>Getting 1 random number implies:</p>
<ul>
<li><p>Generating a random number between 0 and 1 (say <code>r1</code> )</p></li>
<li><p>Find the bin in the normalized integral for <code>r1</code></p></li>
<li><p>Fill histogram channel</p></li>
</ul>
<p>You can see below an example of the <strong><code>TH1</code></strong><code>::GetRandom()</code> method which can be used to get a random number distributed according the contents of a histogram.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb64-1" title="1"><span class="dt">void</span> getrandomh() {</a>
<a class="sourceLine" id="cb64-2" title="2">   TH1F *source = <span class="kw">new</span> TH1F(<span class="st">"source"</span>,<span class="st">"source hist"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb64-3" title="3">   source-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb64-4" title="4">   TH1F *<span class="kw">final</span> = <span class="kw">new</span> TH1F(<span class="st">"final"</span>,<span class="st">"final hist"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb64-5" title="5"></a>
<a class="sourceLine" id="cb64-6" title="6">             <span class="co">// continued...</span></a>
<a class="sourceLine" id="cb64-7" title="7"></a>
<a class="sourceLine" id="cb64-8" title="8">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;<span class="dv">10000</span>;i++) {</a>
<a class="sourceLine" id="cb64-9" title="9">      <span class="kw">final</span>-&gt;Fill(source-&gt;GetRandom());</a>
<a class="sourceLine" id="cb64-10" title="10">   }</a>
<a class="sourceLine" id="cb64-11" title="11">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"c1"</span>,<span class="dv">800</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb64-12" title="12">   c1-&gt;Divide(<span class="dv">1</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb64-13" title="13">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb64-14" title="14">   source-&gt;Draw();</a>
<a class="sourceLine" id="cb64-15" title="15">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb64-16" title="16">   <span class="kw">final</span>-&gt;Draw();</a>
<a class="sourceLine" id="cb64-17" title="17">   c1-&gt;cd();</a>
<a class="sourceLine" id="cb64-18" title="18">}</a></code></pre></div>
<h2 id="adding-dividing-and-multiplying"><span class="header-section-number">3.6</span> Adding, Dividing, and Multiplying</h2>
<p>Many types of operations are supported on histograms or between histograms:</p>
<ul>
<li><p>Addition of a histogram to the current histogram</p></li>
<li><p>Additions of two histograms with coefficients and storage into the current histogram</p></li>
<li><p>Multiplications and divisions are supported in the same way as additions.</p></li>
<li><p>The <code>Add</code> , <code>Divide</code> and <code>Multiply</code> methods also exist to add, divide or multiply a histogram by a function.</p></li>
</ul>
<p>Histograms objects (not pointers) <strong><code>TH1F</code></strong> <code>h1</code> can be multiplied by a constant using:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb65-1" title="1">   h1.Scale(<span class="at">const</span>)</a></code></pre></div>
<p>A new histogram can be created without changing the original one by doing:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb66-1" title="1">   TH1F h3 = <span class="dv">8</span>*h1;</a></code></pre></div>
<p>To multiply two histogram objects and put the result in a 3rd one do:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb67-1" title="1">   TH1F h3 = h1*h2;</a></code></pre></div>
<p>The same operations can be done with histogram pointers <strong><code>TH1F</code></strong> <code>*h1</code>, <strong><code>*h2</code></strong> following way:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb68-1" title="1">   h1-&gt;Scale(<span class="at">const</span>) TH1F h3 = <span class="dv">8</span>*(*h1); TH1F h3 = (*h1)*(*h2);</a></code></pre></div>
<p>Of course, the <strong><code>TH1</code></strong> methods <code>Add</code> , <code>Multiply</code> and <code>Divide</code> can be used instead of these operators.</p>
<p>If a histogram has associated error bars ( <strong><code>TH1</code></strong><code>::Sumw2()</code>
 has been called), the resulting error bars are also computed assuming 
independent histograms. In case of divisions, binomial errors are also 
supported.</p>
<h2 id="projections"><span class="header-section-number">3.7</span> Projections</h2>
<p>One can make:</p>
<ul>
<li><p>a 1-D projection of a 2-D histogram or profile. See <strong><code>TH2</code></strong><code>::ProfileX</code>, <strong><code>TH2</code></strong><code>::ProfileY,</code><strong><code>TProfile</code></strong><code>::ProjectionX</code>, <strong><code>TProfile2D</code></strong><code>::ProjectionXY</code>, <strong><code>TH2</code></strong><code>::ProjectionX</code>, <strong><code>TH2</code></strong><code>::ProjectionY</code> .</p></li>
<li><p>a 1-D, 2-D or profile out of a 3-D histogram see <strong><code>TH3</code></strong><code>::ProjectionZ</code>, <strong><code>TH3</code></strong><code>::Project3D</code>.</p></li>
</ul>
<p>These projections can be fit via: <strong><code>TH2</code></strong><code>::FitSlicesX</code>, <strong><code>TH2</code></strong><code>::FitSlicesY</code>, <strong><code>TH3</code></strong><code>::FitSlicesZ</code>.</p>
<h2 id="drawing-histograms"><span class="header-section-number">3.8</span> Drawing Histograms</h2>
<p>When you call the <code>Draw</code> method of a histogram ( <strong><code>TH1</code></strong><code>::Draw</code> ) for the first time, it creates a <strong><code>THistPainter</code></strong> object and saves a pointer to painter as a data member of the histogram. The <strong><code>THistPainter</code></strong>
 class specializes in the drawing of histograms. It allows logarithmic 
axes (x, y, z) when the CONT drawing option is using. The <strong><code>THistPainter</code></strong>
 class is separated from the histogram so that one can have histograms 
without the graphics overhead, for example in a batch program. The 
choice to give each histogram has its own painter rather than a central 
singleton painter, allows two histograms to be drawn in two threads 
without overwriting the painter’s values. When a displayed histogram is 
filled again, you do not have to call the <code>Draw</code> method again. The image is refreshed the next time the pad is updated. A pad is updated after one of these three actions:</p>
<ul>
<li><p>A carriage control on the ROOT command line</p></li>
<li><p>A click inside the pad</p></li>
<li><p>A call to <strong><code>TPad</code></strong><code>::Update()</code></p></li>
</ul>
<p>By default, the <strong><code>TH1</code></strong><code>::Draw</code> clears the pad before drawing the new image of the histogram. You can use the <code>"SAME"</code>
 option to leave the previous display intact and superimpose the new 
histogram. The same histogram can be drawn with different graphics 
options in different pads. When a displayed histogram is deleted, its 
image is automatically removed from the pad. To create a copy of the 
histogram when drawing it, you can use <strong><code>TH1</code></strong><code>::DrawClone()</code>. This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use <strong><code>TH1</code></strong><code>::DrawNormalized()</code> to draw a normalized copy of a histogram.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb69-1" title="1">TH1 *TH1::DrawNormalized(<span class="dt">Option_t</span> *option,<span class="dt">Double_t</span> norm) <span class="at">const</span></a></code></pre></div>
<p>A clone of this histogram is normalized to norm and drawn with 
option. A pointer to the normalized histogram is returned. The contents 
of the histogram copy are scaled such that the new sum of weights 
(excluding under and overflow) is equal to <code>norm</code> .</p>
<p>Note that the returned normalized histogram is not added to the list 
of histograms in the current directory in memory. It is the user’s 
responsibility to delete this histogram. The <code>kCanDelete</code> bit
 is set for the returned object. If a pad containing this copy is 
cleared, the histogram will be automatically deleted. See “Draw Options”
 for the list of options.</p>
<h3 id="setting-the-style"><span class="header-section-number">3.8.1</span> Setting the Style</h3>
<p>Histograms use the current style <strong><em><code>gStyle</code></em></strong>, which is the global object of class <strong><code>TStyle</code></strong>. To change the current style for histograms, the <strong><code>TStyle</code></strong> class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb70-1" title="1">   <span class="dt">void</span> SetHistFillColor(<span class="dt">Color_t</span> color = <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb70-2" title="2">   <span class="dt">void</span> SetHistFillStyle(<span class="dt">Style_t</span> styl = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb70-3" title="3">   <span class="dt">void</span> SetHistLineColor(<span class="dt">Color_t</span> color = <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb70-4" title="4">   <span class="dt">void</span> SetHistLineStyle(<span class="dt">Style_t</span> styl = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb70-5" title="5">   <span class="dt">void</span> SetHistLineWidth(<span class="dt">Width_t</span> width = <span class="dv">1</span>)</a></code></pre></div>
<p>When you change the current style and would like to propagate the change to a previously created histogram you can call <strong><code>TH1</code></strong><code>::UseCurrentStyle()</code>. You will need to call <code>UseCurrentStyle()</code> on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use <strong><em><code>gROOT</code></em></strong><code>::ForceStyle</code>
 and all histograms read after this call will be updated to use the 
current style. See “Graphics and the Graphical User Interface”. When a 
histogram is automatically created as a result of a <strong><code>TTree</code></strong><code>::Draw</code>
 , the style of the histogram is inherited from the tree attributes and 
the current style is ignored. The tree attributes are the ones set in 
the current <strong><code>TStyle</code></strong> at the time the tree was created. You can change the existing tree to use the current style, by calling <strong><code>TTree</code></strong><code>::UseCurrentStyle()</code> .</p>
<h3 id="draw-options"><span class="header-section-number">3.8.2</span> Draw Options</h3>
<p>The following draw options are supported on all histogram classes:</p>
<ul>
<li><p>“<code>AXIS</code>”: Draw only the axis.</p></li>
<li><p>“<code>HIST</code>”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use <code>HIST</code> together with the required option (e.g.&nbsp;“<code>HIST SAME C</code>”).</p></li>
<li><p>“<code>SAME</code>”: Superimpose on previous picture in the same pad.</p></li>
<li><p>“<code>CYL</code>”: Use cylindrical coordinates.</p></li>
<li><p>“<code>POL</code>”: Use polar coordinates.</p></li>
<li><p>“<code>SPH</code>”: Use spherical coordinates.</p></li>
<li><p>“<code>PSR</code>”: Use pseudo-rapidity/phi coordinates.</p></li>
<li><p>“<code>LEGO</code>”: Draw a lego plot with hidden line removal.</p></li>
<li><p>“<code>LEGO1</code>”: Draw a lego plot with hidden surface removal.</p></li>
<li><p>“<code>LEGO2</code>”: Draw a lego plot using colors to show the cell contents.</p></li>
<li><p>“<code>SURF</code>”: Draw a surface plot with hidden line removal.</p></li>
<li><p>“<code>SURF1</code>”: Draw a surface plot with hidden surface removal.</p></li>
<li><p>“<code>SURF2</code>”: Draw a surface plot using colors to show the cell contents.</p></li>
<li><p>“<code>SURF3</code>”: Same as <code>SURF</code> with a contour view on the top.</p></li>
<li><p>“<code>SURF4</code>”: Draw a surface plot using <code>Gouraud</code> shading.</p></li>
<li><p>“<code>SURF5</code>”: Same as <code>SURF3</code> but only the colored contour is drawn. Used with option <code>CYL</code> , <code>SPH</code> or <code>PSR</code>
 it allows to draw colored contours on a sphere, a cylinder or in a 
pseudo rapidly space. In Cartesian or polar coordinates, option <code>SURF3</code> is used.</p></li>
</ul>
<p>The following options are supported for 1-D histogram classes:</p>
<ul>
<li><p>“<code>AH</code>”: Draw the histogram, but not the axis labels and tick marks</p></li>
<li><p>“<code>B</code>”: Draw a bar chart</p></li>
<li><p>“<code>C</code>”: Draw a smooth curve through the histogram bins</p></li>
<li><p>“<code>E</code>”: Draw the error bars</p></li>
<li><p>“<code>E0</code>”: Draw the error bars including bins with 0 contents</p></li>
<li><p>“<code>E1</code>”: Draw the error bars with perpendicular lines at the edges</p></li>
<li><p>“<code>E2</code>”: Draw the error bars with rectangles</p></li>
<li><p>“<code>E3</code>”: Draw a fill area through the end points of the vertical error bars</p></li>
<li><p>“<code>E4</code>”: Draw a smoothed filled area through the end points of the error bars</p></li>
<li><p>“<code>L</code>”: Draw a line through the bin contents</p></li>
<li><p>“<code>P</code>”: Draw a (poly)marker at each bin using the histogram’s current marker style</p></li>
<li><p>“<code>P0</code>”: Draw current marker at each bin including empty bins</p></li>
<li><p>“<code>PIE</code>”: Draw a Pie Chart</p></li>
<li><p>“<code>*H</code>”: Draw histogram with a * at each bin</p></li>
<li><p>“<code>LF2</code>”: Draw histogram as with option “<code>L</code>” but with a fill area. Note that “<code>L</code>” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.</p></li>
<li><p>“<code>9</code>”: Force histogram to be drawn in high resolution 
mode. By default, the histogram is drawn in low resolution in case the 
number of bins is greater than the number of pixels in the current pad</p></li>
<li><p>“<code>][</code>”: Draw histogram without the vertical lines for 
the first and the last bin. Use it when superposing many histograms on 
the same picture.</p></li>
</ul>
<p>The following options are supported for 2-D histogram classes:</p>
<ul>
<li><p>“<code>ARR</code>”: Arrow mode. Shows gradient between adjacent cells</p></li>
<li><p>“<code>BOX</code>”: Draw a box for each cell with surface proportional to contents</p></li>
<li><p>“<code>BOX1</code>”: A sunken button is drawn for negative values, a raised one for positive values</p></li>
<li><p>“<code>COL</code>”: Draw a box for each cell with a color scale varying with contents</p></li>
<li><p>“<code>COLZ</code>”: Same as “<code>COL</code>” with a drawn color palette</p></li>
<li><p>“<code>CONT</code>”: Draw a contour plot (same as <code>CONT0</code> )</p></li>
<li><p>“<code>CONTZ</code>”: Same as “<code>CONT</code>” with a drawn color palette</p></li>
<li><p>“<code>CONT0</code>”: Draw a contour plot using surface colors to distinguish contours</p></li>
<li><p>“<code>CONT1</code>”: Draw a contour plot using line styles to distinguish contours</p></li>
<li><p>“<code>CONT2</code>”: Draw a contour plot using the same line style for all contours</p></li>
<li><p>“<code>CONT3</code>”: Draw a contour plot using fill area colors</p></li>
<li><p>“<code>CONT4</code>”: Draw a contour plot using surface colors (<code>SURF2</code> option at theta = 0)</p></li>
<li><p><code>"CONT5":</code> Use Delaunay triangles to compute the contours</p></li>
<li><p>“<code>LIST</code>”: Generate a list of <strong><code>TGraph</code></strong> objects for each contour</p></li>
<li><p>“<code>FB</code>”: To be used with <code>LEGO</code> or <code>SURFACE</code> , suppress the Front-Box</p></li>
<li><p>“<code>BB</code>”: To be used with <code>LEGO</code> or <code>SURFACE</code> , suppress the Back-Box</p></li>
<li><p>“<code>A</code>”: To be used with <code>LEGO</code> or <code>SURFACE</code> , suppress the axis</p></li>
<li><p>“<code>SCAT</code>”: Draw a scatter-plot (default)</p></li>
<li><p>“<code>SPEC</code>”: Use <strong><code>TSpectrum2Painter</code></strong> tool for drawing</p></li>
<li><p>“<code>TEXT</code>”: Draw bin contents as text (format set via <code>gStyle-&gt;SetPaintTextFormat)</code> .</p></li>
<li><p>“<code>TEXTnn</code>”: Draw bin contents as text at angle <code>nn</code> ( <code>0&lt;nn&lt;90</code> ).</p></li>
<li><p>“<code>[cutg]</code>”: Draw only the sub-range selected by the <strong><code>TCutG</code></strong> name “<code>cutg</code>”.</p></li>
<li><p>“<code>Z</code>”: The “<code>Z</code>” option can be specified with the options: <code>BOX</code>, <code>COL</code>, <code>CONT</code>, <code>SURF</code>, and <code>LEGO</code> to display the color palette with an axis indicating the value of the corresponding color on the right side of the picture.</p></li>
</ul>
<p>The following options are supported for 3-D histogram classes:</p>
<ul>
<li><p>" " : Draw a 3D scatter plot.</p></li>
<li><p>“<code>BOX</code>”: Draw a box for each cell with volume proportional to contents</p></li>
<li><p>“<code>LEGO</code>”: Same as “<code>BOX</code>”</p></li>
<li><p>“<code>ISO</code>”: Draw an iso surface</p></li>
<li><p>“<code>FB</code>”: Suppress the Front-Box</p></li>
<li><p>“<code>BB</code>”: Suppress the Back-Box</p></li>
<li><p>“<code>A</code>”: Suppress the axis</p></li>
</ul>
<p>Most options can be concatenated without spaces or commas, for example, if <code>h</code> is a histogram pointer:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb71-1" title="1">  h-&gt;Draw(<span class="st">"E1SAME"</span>);</a>
<a class="sourceLine" id="cb71-2" title="2">  h-&gt;Draw(<span class="st">"e1same"</span>);</a></code></pre></div>
<p>The options are not case sensitive. The options <code>BOX</code> , <code>COL</code> and <code>COLZ</code> use the color palette defined in the current style (see <strong><code>TStyle</code></strong><code>::SetPalette</code>). The options <code>CONT</code> , <code>SURF</code> , and <code>LEGO</code> have by default 20 equidistant contour levels, you can change the number of levels with <strong><code>TH1</code></strong><code>::SetContour</code>. You can also set the default drawing option with <strong><code>TH1</code></strong><code>::SetOption</code> . To see the current option use <strong><code>TH1</code></strong><code>::GetOption</code> . For example:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb72-1" title="1">   h-&gt;SetOption(<span class="st">"lego"</span>);</a>
<a class="sourceLine" id="cb72-2" title="2">   h-&gt;Draw(); <span class="co">// will use the lego option</span></a>
<a class="sourceLine" id="cb72-3" title="3">   h-&gt;Draw(<span class="st">"scat"</span>) <span class="co">// will use the scatter plot option</span></a></code></pre></div>
<h4 id="the-scatter-plot-option"><span class="header-section-number">3.8.2.1</span> The SCATter Plot Option</h4>
<p>By default, 2D histograms are drawn as scatter plots. For each cell <code>(i,j)</code>
 a number of points proportional to the cell content are drawn. A 
maximum of 500 points per cell are drawn. If the maximum is above 500 
contents are normalized to 500.</p>
<h4 id="the-arrow-option"><span class="header-section-number">3.8.2.2</span> The ARRow Option</h4>
<p>The <code>ARR</code> option shows the gradient between adjacent cells. For each cell <code>(i,j)</code> an arrow is drawn. The orientation of the arrow follows the cell gradient.</p>
<h4 id="the-box-option"><span class="header-section-number">3.8.2.3</span> The BOX Option</h4>
<p>For each cell <code>(i,j)</code> a box is drawn with surface 
proportional to contents. The size of the box is proportional to the 
absolute value of the cell contents. The cells with negative contents 
are drawn with an X on top of the boxes. With option <code>BOX1</code> a
 button is drawn for each cell with surface proportional to contents’ 
absolute value. A sunken button is drawn for negative values, a raised 
one for positive values.</p>
<h4 id="the-error-bars-options"><span class="header-section-number">3.8.2.4</span> The ERRor Bars Options</h4>
<ul>
<li><p><code>"E"</code> Default. Draw only error bars, without markers</p></li>
<li><p><code>"E0"</code> Draw also bins with 0 contents (turn off the symbols clipping).</p></li>
<li><p><code>"E1"</code> Draw small lines at the end of error bars</p></li>
<li><p><code>"E2"</code> Draw error rectangles</p></li>
<li><p><code>"E3"</code> Draw a fill area through the end points of vertical error bars</p></li>
<li><p><code>"E4"</code> Draw a smoothed filled area through the end points of error bars</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/0300002F.png" alt="The “E1” bars’ option"><figcaption>The “E1” bars’ option</figcaption>
</figure>
<p>Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use <code>gStyle-&gt;SetErrorX(dx)</code> to control the size of the error along x. The parameter <code>dx</code> is a percentage of bin width for errors along <code>X</code>. Set <code>dx=0</code> to suppress the error along <code>X</code>. Use <code>gStyle-&gt;SetEndErrorSize(np)</code> to control the size of the lines at the end of the error bars (when option 1 is used). By default <code>np=1</code> (<code>np</code> represents the number of pixels).</p>
<h4 id="the-color-option"><span class="header-section-number">3.8.2.5</span> The Color Option</h4>
<p>For each cell <code>(i,j)</code> a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (<strong><em><code>gStyle</code></em></strong> ). The color palette in <strong><code>TStyle</code></strong> can be modified with <strong><code>TStyle</code></strong><code>::SetPalette</code> .</p>
<figure>
<img src="ROOTUsersGuide_files/02000030.png" alt="Different draw options"><figcaption>Different draw options</figcaption>
</figure>
<h4 id="the-text-option"><span class="header-section-number">3.8.2.6</span> The TEXT Option</h4>
<p>For each cell <code>(i,j)</code> the cell content is printed. The text attributes are:</p>
<ul>
<li><p>Text font = current font set by <strong><code>TStyle</code></strong></p></li>
<li><p>Text size= 0.02 * pad-height * marker-size</p></li>
<li><p>Text color= marker color</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/02000031.png" alt="The TEXT option"><figcaption>The TEXT option</figcaption>
</figure>
<h4 id="the-contour-options"><span class="header-section-number">3.8.2.7</span> The CONTour Options</h4>
<p>The following contour options are supported:</p>
<ul>
<li><p><code>"CONT":</code> Draw a contour plot (same as CONT0)</p></li>
<li><p><code>"CONT0":</code> Draw a contour plot using surface colors to distinguish contours</p></li>
<li><p><code>"CONT1":</code> Draw a contour plot using line styles to distinguish contours</p></li>
<li><p><code>"CONT2":</code> Draw a contour plot using the same line style for all contours</p></li>
<li><p><code>"CONT3":</code> Draw a contour plot using fill area colors</p></li>
<li><p><code>"CONT4":</code>Draw a contour plot using surface colors (SURF2 option at theta = 0); see also options “<code>AITOFF</code>”, “<code>MERCATOR</code>”, etc. below</p></li>
<li><p><code>"CONT5":</code> Use Delaunay triangles to compute the contours</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/02000032.png" alt="Different contour options"><figcaption>Different contour options</figcaption>
</figure>
<p>The default number of contour levels is 20 equidistant levels. It can be changed with <strong><code>TH1</code></strong><code>::SetContour</code>. When option “<code>LIST</code>” is specified together with option “<code>CONT</code>”, all points used for contour drawing, are saved in the <strong><code>TGraph</code></strong> object and are accessible in the following way:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb73-1" title="1">   TObjArray *contours =</a>
<a class="sourceLine" id="cb73-2" title="2">      gROOT-&gt;GetListOfSpecials()-&gt;FindObject(<span class="st">"contours"</span>);</a>
<a class="sourceLine" id="cb73-3" title="3">   <span class="dt">Int_t</span> ncontours = contours-&gt;GetSize(); TList *list =</a>
<a class="sourceLine" id="cb73-4" title="4">   (TList*)contours-&gt;At(i);</a></code></pre></div>
<p>Where “<code>i</code>” is a contour number and list contains a list of <strong><code>TGraph</code></strong> objects. For one given contour, more than one disjoint poly-line may be generated. The <strong><code>TGraph</code></strong> numbers per contour are given by <code>list-&gt;GetSize()</code>. Here we show how to access the first graph in the list.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb74-1" title="1">   TGraph *gr1 = (TGraph*)list-&gt;First();</a></code></pre></div>
<ul>
<li><p>“<code>AITOFF</code>”: Draw a contour via an AITOFF projection</p></li>
<li><p>“<code>MERCATOR</code>”: Draw a contour via a Mercator projection</p></li>
<li><p>“<code>SINUSOIDAL</code>”: Draw a contour via a Sinusoidal projection</p></li>
<li><p>“<code>PARABOLIC</code>”: Draw a contour via a Parabolic projection</p></li>
</ul>
<p>The tutorial macro <code>earth.C</code> uses these four options and produces the following picture:</p>
<figure>
<img src="ROOTUsersGuide_files/03000033.png" alt="The earth.C macro output"><figcaption>The <code>earth.C</code> macro output</figcaption>
</figure>
<h4 id="the-lego-options"><span class="header-section-number">3.8.2.8</span> The LEGO Options</h4>
<p>In a lego plot, the cell contents are drawn as 3D boxes, with the height of the box proportional to the cell content.</p>
<figure>
<img src="ROOTUsersGuide_files/02000034.png" alt="“LEGO” and “SURF” options"><figcaption>“LEGO” and “SURF” options</figcaption>
</figure>
<ul>
<li><p>“<code>LEGO</code>”: Draw a lego plot with hidden line removal</p></li>
<li><p>“<code>LEGO1</code>”: Draw a lego plot with hidden surface removal</p></li>
<li><p>“<code>LEGO2</code>”: Draw a lego plot using colors to show the cell contents</p></li>
</ul>
<p>A lego plot can be represented in several coordinate systems; the 
default system is Cartesian coordinates. Other possible coordinate 
systems are <code>CYL</code> , <code>POL</code> , <code>SPH</code> , and <code>PSR</code> .</p>
<ul>
<li><p>“<code>CYL</code>”: Cylindrical coordinates: x-coordinate is mapped on the angle; y-coordinate - on the cylinder length.</p></li>
<li><p>“<code>POL</code>”: Polar coordinates: x-coordinate is mapped on the angle; y-coordinate - on the radius.</p></li>
<li><p>“<code>SPH</code>”: Spherical coordinates: x-coordinate is mapped on the latitude; y-coordinate - on the longitude.</p></li>
<li><p>“<code>PSR</code>”: PseudoRapidity/Phi coordinates: x-coordinate is mapped on Phi.</p></li>
</ul>
<p>With <strong><code>TStyle</code></strong><code>::SetPalette</code> the color palette can be changed. We suggest you use palette 1 with the call:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb75-1" title="1">   gStyle-&gt;SetPalette(<span class="dv">1</span>);</a></code></pre></div>
<h4 id="the-surface-options"><span class="header-section-number">3.8.2.9</span> The SURFace Options</h4>
<p>In a surface plot, cell contents are represented as a mesh. The 
height of the mesh is proportional to the cell content. A surface plot 
can be represented in several coordinate systems. The default is 
Cartesian coordinates, and the other possible systems are <code>CYL</code>, <code>POL</code>, <code>SPH</code>, and <code>PSR</code> . The following picture uses <code>SURF1</code> . With <strong><code>TStyle</code></strong><code>::SetPalette</code> the color palette can be changed. We suggest you use palette 1 with the call:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb76-1" title="1">   gStyle-&gt;SetPalette(<span class="dv">1</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/02000035.png" alt="Different surface options"><figcaption>Different surface options</figcaption>
</figure>
<ul>
<li><p>“<code>SURF</code>”: Draw a surface plot with hidden line removal</p></li>
<li><p>“<code>SURF1</code>”: Draw a surface plot with hidden surface removal</p></li>
<li><p>“<code>SURF2</code>”: Draw a surface plot using colors to show the cell contents</p></li>
<li><p>“<code>SURF3</code>”: Same as <code>SURF</code> with a contour view on the top</p></li>
<li><p>“<code>SURF4</code>”: Draw a surface plot using <code>Gouraud</code> shading</p></li>
<li><p>“<code>SURF5</code>”: Same as <code>SURF3</code> but only the colored contour is drawn. Used with options <code>CYL</code> , <code>SPH</code> or <code>PSR</code>
 it allows to draw colored contours on a sphere, a cylinder or in a 
pseudo rapidly space. In Cartesian or polar coordinates, option <code>SURF3</code> is used.</p></li>
</ul>
<h4 id="the-bar-options"><span class="header-section-number">3.8.2.10</span> The BAR Options</h4>
<p>When the option “<code>bar</code>” or “<code>hbar</code>” is specified, a bar chart is drawn.</p>
<p>The options for vertical bar chart are “<code>bar</code>”, “<code>bar0</code>”, “<code>bar1</code>”, “<code>bar2</code>”, “<code>bar3</code>”, “<code>bar4</code>”.</p>
<figure>
<img src="ROOTUsersGuide_files/02000036.png" alt="Vertical bar charts"><figcaption>Vertical bar charts</figcaption>
</figure>
<ul>
<li>The bar is filled with the histogram fill color.</li>
<li>The left side of the bar is drawn with a light fill color.</li>
<li>The right side of the bar is drawn with a dark fill color.</li>
<li>The percentage of the bar drawn with either the light or dark color is:
<ul>
<li>0 per cent for option <code>"bar"</code> or <code>"bar0"</code></li>
<li>10 per cent for option <code>"bar1"</code></li>
<li>20 per cent for option <code>"bar2"</code></li>
<li>30 per cent for option <code>"bar3"</code></li>
<li>40 per cent for option <code>"bar4"</code></li>
</ul></li>
</ul>
<p>Use <strong><code>TH1</code></strong><code>::SetBarWidth()</code> to control the bar width (default is the bin width). Use <strong><code>TH1</code></strong><code>::SetBarOffset</code> to control the bar offset (default is 0). See the example <code>$ROOTSYS/tutorials/hist/hbars.C</code></p>
<p>The options for the horizontal bar chart are “<code>hbar</code>”, “<code>hbar0</code>”, “<code>hbar1</code>”, “<code>hbar2</code>”, “<code>hbar3</code>”, and “<code>hbar4</code>”.</p>
<ul>
<li>A horizontal bar is drawn for each bin.</li>
<li>The bar is filled with the histogram fill color.</li>
<li>The bottom side of the bar is drawn with a light fill color.</li>
<li>The top side of the bar is drawn with a dark fill color.</li>
<li>The percentage of the bar drawn with either the light or dark color is:
<ul>
<li>0 per cent for option “<code>hbar</code>” or “<code>hbar0</code>”</li>
<li>10 per cent for option “<code>hbar1</code>”</li>
<li>20 per cent for option “<code>hbar2</code>”</li>
<li>30 per cent for option “<code>hbar3</code>”</li>
<li>40 per cent for option “<code>hbar4</code>”</li>
</ul></li>
</ul>
<p>Use <strong><code>TH1</code></strong><code>::SetBarWidth</code> to control the bar width (default is the bin width). Use <strong><code>TH1</code></strong><code>::SetBarOffset</code> to control the bar offset (default is 0). See the example <code>$ROOTSYS/tutorials/hist/hbars.C</code></p>
<figure>
<img src="ROOTUsersGuide_files/02000037.png" alt="Horizontal bar charts"><figcaption>Horizontal bar charts</figcaption>
</figure>
<h4 id="the-z-option-display-the-color-palette-on-the-pad"><span class="header-section-number">3.8.2.11</span> The Z Option: Display the Color Palette on the Pad</h4>
<p>The “<code>Z</code>” option can be specified with the options: <code>COL</code>, <code>CONT</code>, <code>SURF</code>, and <code>LEGO</code>
 to display the color palette with an axis indicating the value of the 
corresponding color on the right side of the picture. If there is not 
enough space on the right side, you can increase the size of the right 
margin by calling <strong><code>TPad</code></strong><code>::SetRightMargin()</code>.
 The attributes used to display the palette axis values are taken from 
the Z axis of the object. For example, you can set the labels size on 
the palette axis with:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb77-1" title="1">   hist-&gt;GetZaxis()-&gt;SetLabelSize();</a></code></pre></div>
<h4 id="setting-the-color-palette"><span class="header-section-number">3.8.2.12</span> Setting the Color Palette</h4>
<p>You can set the color palette with <strong><code>TStyle</code></strong><code>::SetPalette</code> , e.g.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb78-1" title="1">   gStyle-&gt;SetPalette(ncolors,colors);</a></code></pre></div>
<p>For example, the option <code>COL</code> draws a 2-D histogram with 
cells represented by a box filled with a color index, which is a 
function of the cell content. If the cell content is N, the color index 
used will be the color number in <code>colors[N]</code> . If the maximum cell content is greater than <code>ncolors</code> , all cell contents are scaled to <code>ncolors</code>. If <code>ncolors&lt;=0</code>, a default palette of 50 colors is defined. This palette is recommended for pads, labels. It defines:</p>
<ul>
<li>Index 0 to 9: shades of gray</li>
<li>Index 10 to 19:shades of brown</li>
<li>Index 20 to 29:shades of blue</li>
<li>Index 30 to 39: shades of red</li>
<li>Index 40 to 49:basic colors</li>
</ul>
<p>The color numbers specified in this palette can be viewed by 
selecting the menu entry Colors in the View menu of the canvas menu bar.
 The color’s red, green, and blue values can be changed via <strong><code>TColor</code></strong><code>::SetRGB</code>.</p>
<p>If <code>ncolors == 1 &amp;&amp; colors == 0</code>, then a Pretty Palette with a spectrum violet to red is created with 50 colors. That’s the default rain bow palette.</p>
<p>Other predefined palettes with 255 colors are available when <code>colors == 0</code>. The following value of <code>ncolors</code> (with <code>colors = 0</code>) give access to:</p>
<ul>
<li><code>ncolors = 51</code> : Deep Sea palette.</li>
<li><code>ncolors = 52</code> : Grey Scale palette.</li>
<li><code>ncolors = 53</code> : Dark Body Radiator palette.</li>
<li><code>ncolors = 54</code> : Two-color hue palette palette. (dark blue through neutral gray to bright yellow)</li>
<li><code>ncolors = 55</code> : Rain Bow palette.</li>
<li><code>ncolors = 56</code> : Inverted Dark Body Radiator palette.</li>
</ul>
<p>The color numbers specified in the palette can be viewed by selecting
 the item “colors” in the “VIEW” menu of the canvas toolbar. The color 
parameters can be changed via <code>TColor::SetRGB</code>.</p>
<p>Note that when drawing a 2D histogram <code>h2</code> with the option “<code>COL</code>” or “<code>COLZ</code>” or with any “<code>CONT</code>” options using the color map, the number of colors used is defined by the number of contours <code>n</code> specified with: <code>h2-&gt;SetContour(n)</code></p>
<h4 id="tpaletteaxis"><span class="header-section-number">3.8.2.13</span> TPaletteAxis</h4>
<p>A <strong><code>TPaletteAxis</code></strong>object is used to display
 the color palette when drawing 2D histograms. The object is 
automatically created when drawing a 2D histogram when the option “<code>z</code>” is specified. It is added to the histogram list of functions. It can be retrieved and its attributes can be changed with:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb79-1" title="1">   TPaletteAxis *palette=(TPaletteAxis*)h-&gt;FindObject(<span class="st">"palette"</span>);</a></code></pre></div>
<p>The palette can be interactively moved and resized. The context menu 
can be used to set the axis attributes. It is possible to select a range
 on the axis, to set the min/max in z.</p>
<h4 id="the-spec-option"><span class="header-section-number">3.8.2.14</span> The SPEC Option</h4>
<p>The “SPEC” option offers a large set of options/attributes to 
visualize 2D histograms thanks to “operators” following the “SPEC” 
keyword. For example, to draw the 2-D histogram <code>h2</code> using all default attributes except the viewing angles, one can do:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb80-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC a(30,30,0)"</span>);</a></code></pre></div>
<p>The operators’ names are case insensitive (i.e.&nbsp;one can use “a” 
or “A”) and their parameters are separated by coma “,”. Operators can be
 put in any order in the option and must be separated by a space " ". No
 space characters should be put in an operator. All the available 
operators are described below.</p>
<p>The way how a 2D histogram will be painted is controlled by two 
parameters: the “Display modes groups” and the “Display Modes”. “Display
 modes groups” can take the following values:</p>
<ul>
<li>0 = Simple - simple display modes using one color only</li>
<li>1 = Light - the shading is carried out according to the position of the fictive light source</li>
<li>2 = Height - the shading is carried out according to the channel contents</li>
<li>3 = LightHeight - combination of two previous shading algorithms (one can control the weight between both algorithms).</li>
</ul>
<p>“Display modes” can take the following values:</p>
<ul>
<li>1 = Points</li>
<li>2 = Grid</li>
<li>3 = Contours</li>
<li>4 = Bars</li>
<li>5 = LinesX</li>
<li>6 = LinesY</li>
<li>7 = BarsX</li>
<li>8 = BarsY</li>
<li>9 = Needles</li>
<li>10 = Surface</li>
<li>11 = Triangles</li>
</ul>
<p>These parameters can be set by using the “<code>dm</code>” operator in the option.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb81-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC dm(1,2)"</span>);</a></code></pre></div>
<p>The above example draws the histogram using the “Light Display mode 
group” and the “Grid Display mode”. The following tables summarize all 
the possible combinations of both groups:</p>
<table style="width:72%;">
<colgroup>
<col style="width: 16%">
<col style="width: 9%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 6%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td>Points</td>
<td>Grid</td>
<td>Contours</td>
<td>Bars</td>
<td>LinesX</td>
<td>LinesY</td>
</tr>
<tr class="even">
<td>Simple</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr class="odd">
<td>Light</td>
<td>x</td>
<td>x</td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
<td>x</td>
</tr>
<tr class="even">
<td>Height</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr class="odd">
<td>LightHeight</td>
<td>x</td>
<td>x</td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<table style="width:72%;">
<colgroup>
<col style="width: 18%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 15%">
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td>BarsX</td>
<td>BarsY</td>
<td>Needles</td>
<td>Surface</td>
<td>Triangles</td>
</tr>
<tr class="even">
<td>Simple</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
</tr>
<tr class="odd">
<td>Light</td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
<td>x</td>
</tr>
<tr class="even">
<td>Height</td>
<td>x</td>
<td>x</td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
<td>x</td>
</tr>
<tr class="odd">
<td>LightHeight</td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>The “Pen Attributes” can be changed using <code>pa(color,style,width)</code>. Next example sets line color to 2, line type to 1 and line width to 2. Note that if <code>pa()</code> is not specified, the histogram line attributes are used:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb82-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC dm(1,2) pa(2,1,2)"</span>);</a></code></pre></div>
<p>The number of “Nodes” can be changed with <code>n(nodesx,nodesy)</code>. Example:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb83-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC n(40,40)"</span>);</a></code></pre></div>
<p>Sometimes the displayed region is rather large. When displaying all 
channels the pictures become very dense and complicated. It is very 
difficult to understand the overall shape of data. “<code>n(nx,ny)</code>” allows to change the density of displayed channels. Only the channels coinciding with given nodes are displayed.</p>
<p>The visualization “Angles” can be changed with “<code>a(alpha,beta,view)</code>”: “<code>alpha</code>” is the angle between the bottom horizontal screen line and the displayed space on the right side of the picture and “<code>beta</code>” on the left side, respectively. One can rotate the 3-d space around the vertical axis using the “<code>view</code>” parameter. Allowed values are 0, 90, 180 and 270 degrees.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb84-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC n(40,40) dm(0,1) a(30,30,0)"</span>);</a></code></pre></div>
<p>The operator “<code>zs(scale)</code>” changes the scale of the Z-axis. The possible values are:</p>
<ul>
<li>0 = Linear (default),</li>
<li>1 = Log,</li>
<li>2 = Sqrt.</li>
</ul>
<p>If <code>gPad-&gt;SetLogz()</code> has been set, the log scale on Z-axis is set automatically, i.e.&nbsp;there is no need for using the <code>zs()</code> operator. Note that the X and Y axis are always linear.</p>
<p>The operator “<code>ci(r,g,b</code>)” defines the colors increments (<code>r</code>, <code>g</code> and <code>b</code>
 are floats). For sophisticated shading (Light, Height and LightHeight 
Display Modes Groups) the color palette starts from the basic pen color 
(see <code>pa()</code> function). There is a predefined number of color 
levels (256). Color in every level is calculated by adding the 
increments of the <code>r</code> , <code>g</code> , <code>b</code> 
components to the previous level. Using this function one can change the
 color increments between two neighboring color levels. The function 
does not apply on the Simple Display Modes Group. The default values 
are: (1,1,1).</p>
<p>The operator “<code>ca(color_algorithm)</code>” allows to choose the 
Color Algorithm. To define the colors one can use one of the following 
color algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a 
component reaches the limit value one can choose either smooth 
transition (by decreasing the limit value) or a sharp modulo transition 
(continuing with 0 value). This allows various visual effects. One can 
choose from the following set of the algorithms:</p>
<ul>
<li>0 = RGB Smooth,</li>
<li>1 = RGB Modulo,</li>
<li>2 = CMY Smooth,</li>
<li>3 = CMY Modulo,</li>
<li>4 = CIE Smooth</li>
<li>5 = CIE Modulo,</li>
<li>6 = YIQ Smooth,</li>
<li>7 = YIQ Modulo,</li>
<li>8 = HVS Smooth,</li>
<li>9 = HVS Modulo</li>
</ul>
<p>This function does not apply on Simple display modes group. Default 
value is 0. Example choosing CMY Modulo to paint the 2D histogram:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb85-1" title="1">   h2-&gt;Draw(<span class="st">"SPEC c1(3) dm(0,1) a(30,30,0)"</span>);</a></code></pre></div>
<p>The operator “<code>lp(x,y,z)</code>” sets the light position. In 
Light and LightHeight display modes groups the color palette is 
calculated according to the fictive light source position in 3-d space. 
Using this function one can change the source’s position and thus 
achieve various graphical effects. This function does not apply for 
Simple and Height display modes groups. Default is: <code>lp(1000,1000,100)</code> .</p>
<p>The operator “<code>s(shading,shadow)</code>” allows to set the 
shading. The surface picture is composed of triangles. The edges of the 
neighboring triangles can be smoothed (shaded). The shadow can be 
painted as well. The function does not apply on Simple display modes 
group. The possible values for shading are:</p>
<ul>
<li>0 = Not Shaded,</li>
<li>1 = Shaded.</li>
</ul>
<p>The possible values for shadow are:</p>
<ul>
<li>0 = Shadows are not painted,</li>
<li>1 = Shadows are painted.</li>
</ul>
<p>Default values: <code>s(1,0)</code> .</p>
<p>The operator “<code>b(bezier)</code>” sets the Bezier smoothing. For 
Simple display modes group and for Grid, LinesX and LinesY display modes
 one can smooth data using Bezier smoothing algorithm. The function does
 not apply on other display modes groups and display modes. Possible 
values are: 0 = No bezier smoothing, 1 = Bezier smoothing. Default value
 is: <code>b(0)</code>.</p>
<p>The operator “<code>cw(width)</code>” sets the contour width. This 
function applies only on for the Contours display mode. One can change 
the width between horizontal slices and thus their density. Default 
value: <code>cw(50)</code> .</p>
<p>The operator “<code>lhw(weight)</code>” sets the light height weight.
 For LightHeight display modes group one can change the weight between 
both shading algorithms. The function does not apply on other display 
modes groups. Default value is <code>lhw(0.5)</code> .</p>
<p>The operator “<code>cm(enable,color,width,height,style)</code>” 
allows to draw a marker on each node. In addition to the surface drawn 
using any above given algorithm one can display channel marks. One can 
control the color as well as the width, height (in pixels) and the style
 of the marks. The parameter <code>enable</code> can be set to 0 = Channel marks are not drawn or 1 = Channel marks drawn. The possible styles are:</p>
<ul>
<li>1 = Dot,</li>
<li>2 = Cross,</li>
<li>3 = Star,</li>
<li>4 = Rectangle,</li>
<li>5 = X,</li>
<li>6 = Diamond,</li>
<li>7 = Triangle.</li>
</ul>
<p>The operator “<code>cg(enable,color)</code>” channel grid. In 
addition to the surface drawn using any above given algorithm one can 
display grid using the color parameter. The parameter enable can be set 
to:</p>
<ul>
<li>0 = Grid not drawn,</li>
<li>1 = Grid drawn.</li>
</ul>
<p>See the example in <code>$ROOTSYS/tutorials/spectrum/spectrumpainter.C</code> .</p>
<figure>
<img src="ROOTUsersGuide_files/03000038.png" alt="The picture produced by spectrumpainter.C macro"><figcaption>The picture produced by spectrumpainter.C macro</figcaption>
</figure>
<h4 id="d-histograms"><span class="header-section-number">3.8.2.15</span> 3-D Histograms</h4>
<p>By default a 3D scatter plot is drawn. If the “BOX” option is 
specified, a 3D box with a volume proportional to the cell content is 
drawn.</p>
<h3 id="drawing-a-sub-range-of-a-2-d-histogram"><span class="header-section-number">3.8.3</span> Drawing a Sub-range of a 2-D Histogram</h3>
<figure>
<img src="ROOTUsersGuide_files/02000039.png" alt="The picture produced by fit2a.C macro"><figcaption>The picture produced by fit2a.C macro</figcaption>
</figure>
<p>Using a <strong><code>TCutG</code></strong> object, it is possible to
 draw a 2D histogram sub-range. One must create a graphical cut (mouse 
or C++) and specify the name of the cut between “<code>[</code>” and “<code>]</code>” in the Draw option.</p>
<p>For example, with a <strong><code>TCutG</code></strong>named “<code>cutg</code>”, one can call:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb86-1" title="1">   myhist-&gt;Draw(<span class="st">"surf1 [cutg]"</span>);</a></code></pre></div>
<p>Or, assuming two graphical cuts with name “<code>cut1</code>” and “<code>cut2</code>”, one can do:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb87-1" title="1">   h1.Draw(<span class="st">"lego"</span>);</a>
<a class="sourceLine" id="cb87-2" title="2">   h2.Draw(<span class="st">"[cut1,-cut2],surf,same"</span>);</a></code></pre></div>
<p>The second <code>Draw</code> will superimpose on top of the first lego plot a subset of <code>h2</code>using the “<code>surf</code>” option with:</p>
<ul>
<li>all the bins inside <code>cut1</code></li>
<li>all the bins outside <code>cut2</code></li>
</ul>
<p>Up to 16 cuts may be specified in the cut string delimited by <code>"[..]"</code>. Currently only the following drawing options are sensitive to the cuts option: <code>col</code> , <code>box</code> , <code>scat</code> , <code>hist</code> , <code>lego</code> , <code>surf</code> and <code>cartesian</code> coordinates only. See a complete example in the tutorial <code>$ROOTSYS/tutorials/fit/fit2a.C</code> .</p>
<h3 id="superimposing-histograms-with-different-scales"><span class="header-section-number">3.8.4</span> Superimposing Histograms with Different Scales</h3>
<p>The following script creates two histograms; the second histogram is 
the bins integral of the first one. It shows a procedure to draw the two
 histograms in the same pad and it draws the scale of the second 
histogram using a new vertical axis on the right side.</p>
<figure>
<img src="ROOTUsersGuide_files/0300003A.png" alt="Superimposed histograms with different scales"><figcaption>Superimposed histograms with different scales</figcaption>
</figure>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb88-1" title="1"><span class="dt">void</span> twoscales() {</a>
<a class="sourceLine" id="cb88-2" title="2">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"different scales hists"</span>,<span class="dv">600</span>,<span class="dv">400</span>);</a>
<a class="sourceLine" id="cb88-3" title="3">   <span class="co">//create, fill and draw h1</span></a>
<a class="sourceLine" id="cb88-4" title="4">   gStyle-&gt;SetOptStat(kFALSE);</a>
<a class="sourceLine" id="cb88-5" title="5">   TH1F *h1 = <span class="kw">new</span> TH1F(<span class="st">"h1"</span>,<span class="st">"my histogram"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb88-6" title="6">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;<span class="dv">10000</span>;i++) h1-&gt;Fill(gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">1</span>));</a>
<a class="sourceLine" id="cb88-7" title="7">   h1-&gt;Draw();</a>
<a class="sourceLine" id="cb88-8" title="8">   c1-&gt;Update();</a>
<a class="sourceLine" id="cb88-9" title="9">   <span class="co">//create hint1 filled with the bins integral of h1</span></a>
<a class="sourceLine" id="cb88-10" title="10">   TH1F *hint1 = <span class="kw">new</span> TH1F(<span class="st">"hint1"</span>,<span class="st">"h1 bins integral"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb88-11" title="11">   <span class="dt">Float_t</span> sum = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb88-12" title="12">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">1</span>;i&lt;=<span class="dv">100</span>;i++) {</a>
<a class="sourceLine" id="cb88-13" title="13">      sum += h1-&gt;GetBinContent(i);</a>
<a class="sourceLine" id="cb88-14" title="14">      hint1-&gt;SetBinContent(i,sum);</a>
<a class="sourceLine" id="cb88-15" title="15">   }</a>
<a class="sourceLine" id="cb88-16" title="16">   <span class="co">//scale hint1 to the pad coordinates</span></a>
<a class="sourceLine" id="cb88-17" title="17">   <span class="dt">Float_t</span> rightmax = <span class="fl">1.1</span>*hint1-&gt;GetMaximum();</a>
<a class="sourceLine" id="cb88-18" title="18">   <span class="dt">Float_t</span> scale    = gPad-&gt;GetUymax()/rightmax;</a>
<a class="sourceLine" id="cb88-19" title="19">   hint1-&gt;SetLineColor(kRed);</a>
<a class="sourceLine" id="cb88-20" title="20">   hint1-&gt;Scale(scale);</a>
<a class="sourceLine" id="cb88-21" title="21">   hint1-&gt;Draw(<span class="st">"same"</span>);</a>
<a class="sourceLine" id="cb88-22" title="22">   <span class="co">//draw an axis on the right side</span></a>
<a class="sourceLine" id="cb88-23" title="23">   TGaxis*axis = <span class="kw">new</span> TGaxis(gPad-&gt;GetUxmax(),gPad-&gt;GetUymin(),</a>
<a class="sourceLine" id="cb88-24" title="24">                            gPad-&gt;GetUxmax(),gPad-&gt;GetUymax(),</a>
<a class="sourceLine" id="cb88-25" title="25">                            <span class="dv">0</span>,rightmax,<span class="dv">510</span>,<span class="st">"+L"</span>);</a>
<a class="sourceLine" id="cb88-26" title="26">   axis-&gt;SetLineColor(kRed);</a>
<a class="sourceLine" id="cb88-27" title="27">   axis-&gt;SetLabelColor(kRed);</a>
<a class="sourceLine" id="cb88-28" title="28">   axis-&gt;Draw();</a>
<a class="sourceLine" id="cb88-29" title="29">}</a></code></pre></div>
<h3 id="statistics-display"><span class="header-section-number">3.8.5</span> Statistics Display</h3>
<p>By default, a histogram drawing includes the statistics box. Use <strong><code>TH1</code></strong><code>::SetStats(kFALSE)</code> to eliminate the statistics box. If the statistics box is drawn, <code>gStyle-&gt;SetOptStat(mode)</code> allow you to select the type of displayed information <code>.</code> The parameter <code>mode</code> has up to nine digits that can be set OFF (0) or ON as follows:</p>
<p><code>mode = ksiourmen</code> (<code>default =000001111</code>)</p>
<ul>
<li><code>n</code> = 1 the name of histogram is printed</li>
<li><code>e</code> = 1 the number of entries</li>
<li><code>m</code> = 1 the mean value</li>
<li><code>m</code> = 2 the mean and mean error values</li>
<li><code>r</code> = 1 the root mean square (RMS)</li>
<li><code>r</code> = 2 the RMS and RMS error</li>
<li><code>u</code> = 1 the number of underflows</li>
<li><code>o</code> = 1 the number of overflows</li>
<li><code>i</code> = 1 the integral of bins</li>
<li><code>s</code> = 1 the skewness</li>
<li><code>s</code> = 2 the skewness and the skewness error</li>
<li><code>k</code> = 1 the kurtosis</li>
<li><code>k</code> = 2 the kurtosis and the kurtosis error</li>
</ul>
<p>Never call <code>SetOptStat(0001111)</code> , but <code>SetOptStat(1111)</code> , because <code>0001111</code> will be taken as an octal number.</p>
<p>The method <strong><code>TStyle</code></strong><code>::SetOptStat(Option_t*option)</code> can also be called with a character string as a parameter. The parameter <code>option</code> can contain:</p>
<ul>
<li><code>n</code> for printing the name of histogram</li>
<li><code>e</code> the number of entries</li>
<li><code>m</code> the mean value</li>
<li><code>M</code> the mean and mean error values</li>
<li><code>r</code> the root mean square (RMS)</li>
<li><code>R</code> the RMS and RMS error</li>
<li><code>u</code> the number of underflows</li>
<li><code>o</code> the number of overflows</li>
<li><code>i</code> the integral of bins</li>
<li><code>s</code> the skewness</li>
<li><code>S</code> the skewness and the skewness error</li>
<li><code>k</code> the kurtosis</li>
<li><code>K</code> the kurtosis and the kurtosis error</li>
</ul>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb89-1" title="1">   gStyle-&gt;SetOptStat(<span class="st">"ne"</span>);   <span class="co">// prints the histogram name and number</span></a>
<a class="sourceLine" id="cb89-2" title="2">                               <span class="co">// of entries</span></a>
<a class="sourceLine" id="cb89-3" title="3">   gStyle-&gt;SetOptStat(<span class="st">"n"</span>);    <span class="co">// prints the histogram name</span></a>
<a class="sourceLine" id="cb89-4" title="4">   gStyle-&gt;SetOptStat(<span class="st">"nemr"</span>); <span class="co">// the default value</span></a></code></pre></div>
<p>With the option <code>"same"</code>, the statistic box is not redrawn. With the option <code>"sames"</code>, it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where <code>h</code> is the histogram pointer):</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb90-1" title="1">root[] TPaveStats *s =</a>
<a class="sourceLine" id="cb90-2" title="2">            (TPaveStats*)h-&gt;GetListOfFunctions()-&gt;FindObject(<span class="st">"stats"</span>);</a>
<a class="sourceLine" id="cb90-3" title="3">root[] s-&gt;SetX1NDC (newx1); <span class="co">// new x start position</span></a>
<a class="sourceLine" id="cb90-4" title="4">root[] s-&gt;SetX2NDC (newx2); <span class="co">// new x end position</span></a></code></pre></div>
<h3 id="setting-line-fill-marker-and-text-attributes"><span class="header-section-number">3.8.6</span> Setting Line, Fill, Marker, and Text Attributes</h3>
<p>The histogram classes inherit from the attribute classes: <strong><code>TAttLine</code></strong>, <strong><code>TAttFill</code></strong>, <strong><code>TAttMarker</code></strong> and <strong><code>TAttText</code></strong>. See the description of these classes for the list of options.</p>
<h3 id="setting-tick-marks-on-the-axis"><span class="header-section-number">3.8.7</span> Setting Tick Marks on the Axis</h3>
<p>The <strong><code>TPad</code></strong><code>::SetTicks()</code> method specifies the type of tick marks on the axis. Let <code>tx=gPad-&gt;GetTickx()</code> and <code>ty=gPad-&gt;GetTicky()</code>.</p>
<ul>
<li><code>tx</code> = 1; tick marks on top side are drawn (inside)</li>
<li><code>tx</code> = 2; tick marks and labels on top side are drawn</li>
<li><code>ty</code> = 1; tick marks on right side are drawn (inside)</li>
<li><code>ty</code> = 2; tick marks and labels on right side are drawn</li>
<li><code>tx=ty=0</code> by default only the left Y axis and X bottom axis are drawn</li>
</ul>
<p>Use <strong><code>TPad</code></strong><code>::SetTicks(tx,ty)</code> to set these options. See also the methods of <strong><code>TAxis</code></strong>
 that set specific axis attributes. If multiple color-filled histograms 
are drawn on the same pad, the fill area may hide the axis tick marks. 
One can force the axis redrawing over all the histograms by calling:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb91-1" title="1">   gPad-&gt;RedrawAxis();</a></code></pre></div>
<h3 id="giving-titles-to-the-x-y-and-z-axis"><span class="header-section-number">3.8.8</span> Giving Titles to the X, Y and Z Axis</h3>
<p>Because the axis title is an attribute of the axis, you have to get the axis first and then call <strong><code>TAxis</code></strong><code>::SetTitle</code>.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb92-1" title="1">   h-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"X axis title"</span>);</a>
<a class="sourceLine" id="cb92-2" title="2">   h-&gt;GetYaxis()-&gt;SetTitle(<span class="st">"Y axis title"</span>);</a>
<a class="sourceLine" id="cb92-3" title="3">   h-&gt;GetZaxis()-&gt;SetTitle(<span class="st">"Z axis title"</span>);</a></code></pre></div>
<p>The histogram title and the axis titles can be any <strong><code>TLatex</code></strong>
 string. The titles are part of the persistent histogram. For example if
 you wanted to write E with a subscript (T) you could use this:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb93-1" title="1">   h-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"E_{T}"</span>);</a></code></pre></div>
<p>For a complete explanation of the Latex mathematical expressions, see
 “Graphics and the Graphical User Interface”. It is also possible to 
specify the histogram title and the axis titles at creation time. These 
titles can be given in the “title” parameter. They must be separated by “<strong>;</strong>”:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb94-1" title="1">   TH1F* h=<span class="kw">new</span> TH1F(<span class="st">"h"</span>,<span class="st">"Histogram title;X Axis;Y Axis;Z Axis"</span>,</a>
<a class="sourceLine" id="cb94-2" title="2">                    <span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>Any title can be omitted:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb95-1" title="1">   TH1F* h=<span class="kw">new</span> TH1F(<span class="st">"h"</span>,<span class="st">"Histogram title;;Y Axis"</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb95-2" title="2">   TH1F* h=<span class="kw">new</span> TH1F(<span class="st">"h"</span>,<span class="st">";;Y Axis"</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>The method <code>SetTitle</code> has the same syntax:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb96-1" title="1">   h-&gt;SetTitle(<span class="st">"Histogram title;An other X title Axis"</span>);</a></code></pre></div>
<h2 id="making-a-copy-of-an-histogram"><span class="header-section-number">3.9</span> Making a Copy of an Histogram</h2>
<p>Like for any other ROOT object derived from <strong><code>TObject</code></strong> , the <code>Clone</code> method can be used. This makes an identical copy of the original histogram including all associated errors and functions:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb97-1" title="1">   TH1F *hnew = (TH1F*)h-&gt;Clone(); <span class="co">// renaming is recommended,</span></a>
<a class="sourceLine" id="cb97-2" title="2">   hnew-&gt;SetName(<span class="st">"hnew"</span>);          <span class="co">// because otherwise you will have</span></a>
<a class="sourceLine" id="cb97-3" title="3">                                   <span class="co">// two histograms with the same</span></a>
<a class="sourceLine" id="cb97-4" title="4">                                   <span class="co">// name</span></a></code></pre></div>
<h2 id="normalizing-histograms"><span class="header-section-number">3.10</span> Normalizing Histograms</h2>
<p>You can scale a histogram ( <strong><code>TH1</code></strong> <code>*h</code> ) such that the bins integral is equal to the normalization parameter norm:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb98-1" title="1">   <span class="dt">Double_t</span> scale = norm/h-&gt;Integral();</a>
<a class="sourceLine" id="cb98-2" title="2">   h-&gt;Scale(scale);</a></code></pre></div>
<h2 id="savingreading-histograms-tofrom-a-file"><span class="header-section-number">3.11</span> Saving/Reading Histograms to/from a File</h2>
<p>The following statements create a ROOT file and store a histogram on the file. Because <strong><code>TH1</code></strong> derives from <strong><code>TNamed</code></strong> , the key identifier on the file is the histogram name:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb99-1" title="1">   TFile f(<span class="st">"histos.root"</span>,<span class="st">"new"</span>);</a>
<a class="sourceLine" id="cb99-2" title="2">   TH1F h1(<span class="st">"hgaus"</span>,<span class="st">"histo from a gaussian"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb99-3" title="3">   h1.FillRandom(<span class="st">"gaus"</span>,<span class="dv">10000</span>);</a>
<a class="sourceLine" id="cb99-4" title="4">   h1-&gt;Write();</a></code></pre></div>
<p>To read this histogram in another ROOT session, do:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb100-1" title="1">   TFile f(<span class="st">"histos.root"</span>);</a>
<a class="sourceLine" id="cb100-2" title="2">   TH1F *h = (TH1F*)f.Get(<span class="st">"hgaus"</span>);</a></code></pre></div>
<p>One can save all histograms in memory to the file by:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb101-1" title="1">   file-&gt;Write();</a></code></pre></div>
<p>For a more detailed explanation, see “Input/Output”.</p>
<h2 id="miscellaneous-operations"><span class="header-section-number">3.12</span> Miscellaneous Operations</h2>
<ul>
<li><p><strong><code>TH1</code></strong><code>::KolmogorovTest(</code> <strong><code>TH1</code></strong><code>* h2,Option_t *option)</code> is statistical test of compatibility in shape between two histograms. The parameter <code>option</code> is a character string that specifies:</p></li>
<li><p>“<code>U</code>” include Underflows in test (also for 2-dim)</p></li>
<li><p>“<code>O</code>” include Overflows (also valid for 2-dim)</p></li>
<li><p>“<code>N</code>” include comparison of normalizations</p></li>
<li><p>“<code>D</code>” put out a line of “Debug” printout</p></li>
<li><p>“<code>M</code>” return the maximum Kolmogorov distance instead of <code>prob</code></p></li>
<li><p>“<code>X</code>” run the pseudo experiments post-processor with 
the following procedure: it makes pseudo experiments based on random 
values from the parent distribution and compare the KS distance of the 
pseudo experiment to the parent distribution. Bin the KS distances in a 
histogram, and then take the integral of all the KS values above the 
value obtained from the original data to Monte Carlo distribution. The 
number of pseudo-experiments NEXPT is currently fixed at 1000. The 
function returns the integral. Note that this option “<code>X</code>” is much slower.</p></li>
<li><p><strong><code>TH1</code></strong><code>::Smooth</code> - smoothes the bin contents of a 1D histogram.</p></li>
<li><p><strong><code>TH1</code></strong><code>::Integral(Option_t *opt)-</code>returns the integral of bin contents in a given bin range. If the option “<code>width</code>” is specified, the integral is the sum of the bin contents multiplied by the bin width in <code>x</code> .</p></li>
<li><p><strong><code>TH1</code></strong><code>::GetMean(int axis)</code> - returns the mean value along axis.</p></li>
<li><p><strong><code>TH1</code></strong><code>::GetStdDev(int axis)</code> - returns the sigma distribution along axis.</p></li>
<li><p><strong><code>TH1</code></strong><code>::GetRMS(int axis)</code> - returns the Root Mean Square along axis.</p></li>
<li><p><strong><code>TH1</code></strong><code>::GetEntries()</code> - returns the number of entries.</p></li>
<li><strong><code>TH1</code></strong><code>::GetAsymmetry(</code><strong><code>TH1</code></strong> <code>*h2,Double_t c2,Double_tdc2)</code>
<ul>
<li>returns an histogram containing the asymmetry of this histogram with <code>h2</code>, where the asymmetry is defined as:</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb102-1" title="1">   Asymmetry = (h1 - h2)/(h1 + h2); <span class="co">//where h1 = this</span></a></code></pre></div>
<ul>
<li>It works for <code>1D</code> , <code>2D</code> , etc. histograms. The parameter <code>c2</code> is an optional argument that gives a relative weight between the two histograms, and <code>dc</code> <code>2</code>
 is the error on this weight. This is useful, for example, when forming 
an asymmetry between two histograms from two different data sets that 
need to be normalized to each other in some way. The function calculates
 the errors assuming Poisson statistics on <code>h1</code> and <code>h2</code> (that is, <code>dh=sqrt(h)</code>). In the next example we assume that <code>h1</code> and <code>h2</code> are already filled:</li>
</ul>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb103-1" title="1">   h3 = h1-&gt;GetAsymmetry(h2);</a></code></pre></div>
<ul>
<li><p>Then <code>h3</code> is created and filled with the asymmetry between <code>h1</code> and <code>h2</code> ; <code>h1</code> and <code>h2</code> are left intact.</p></li>
<li><p>Note that the user’s responsibility is to manage the created histograms.</p></li>
<li><p><strong><code>TH1</code></strong><code>::Reset()</code> - resets the bin contents and errors of a histogram</p></li>
</ul>
<h2 id="important-note-on-returned-statistics-getmean-getstddev-etc."><span class="header-section-number">3.13</span> Important note on returned statistics (<code>GetMean</code>, <code>GetStdDev</code>, etc.)</h2>
<p>By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. <strong>This means the values returned by <code>GetMean</code>, <code>GetStdDev</code>, etc., are those of the dataset used to fill the histogram</strong>, not those of the binned content of the histogram itself, <strong>unless one of the axes has been zoomed</strong>. (See the documentation on <code>TH1::GetStats()</code>.)
 This is useful if you want to keep track of the mean and standard 
deviation of the dataset you are visualizing with the histogram, but it 
can lead to some unintuitive results.</p>
<p>For example, suppose you have a histogram with one bin between 0 and 
100, then you fill it with a Gaussian dataset with mean 20 and standard 
deviation 2:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb104-1" title="1">TH1F * h = <span class="kw">new</span> TH1F(<span class="st">"h"</span>, <span class="st">"h"</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">100</span>);</a>
<a class="sourceLine" id="cb104-2" title="2"><span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10000</span>; i++) h-&gt;Fill(gRandom-&gt;Gaus(<span class="dv">20</span>, <span class="dv">2</span>));</a></code></pre></div>
<p>Right now, <code>h-&gt;GetMean()</code> will return 20 and <code>h-&gt;GetStdDev()</code> will return 2; ROOT calculated these values as we filled <code>h</code>. Next, zoom in on the Gaussian:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb105-1" title="1">h-&gt;GetXaxis()-&gt;SetRangeUser(<span class="dv">10</span>, <span class="dv">30</span>);</a></code></pre></div>
<p>Now, <code>h-&gt;GetMean()</code> will return 50 and <code>h-&gt;GetStdDev()</code> will return 0. What happened? Well, <code>GetMean</code> and <code>GetStdDev</code> (and many other <code>TH1</code> functions) return the statistics for <em>bins in range</em>;
 this is because the histogram only stores the contents of its bins, not
 the coordinates of the values used to fill it. So even though <code>h</code> has only one bin and it’s still included in the range, ROOT returns the binned statistics because <code>SetRangeUser</code> set the bit <code>TAxis::kAxisRange</code> to 1. <em>This remains true even if you zoom out:</em></p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb106-1" title="1">h-&gt;GetXaxis()-&gt;SetRangeUser(<span class="dv">0</span>, <span class="dv">100</span>);</a></code></pre></div>
<p>still results in <code>GetMean</code> and <code>GetStdDev</code> returning 50 and 0, respectively, because, even though this is the original range of the histogram, <em>the X axis has still been assigned a range</em>. To mark the X axis as having no range, you can call</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb107-1" title="1">h-&gt;GetXaxis()-&gt;SetRange();</a></code></pre></div>
<p>without arguments or with arguments <code>(0, 0)</code>. This sets the bit <code>TAxis::kAxisRange</code> to 0, and ROOT again uses the statistics calculated at fill time: <code>GetMean</code> and <code>GetStdDev</code> now return 20 and 2, respectively.</p>
<p>If you want ROOT to consistently return the statistics of the binned 
dataset stored in the histogram and not those of the dataset used to 
fill it, you can call <code>TH1::ResetStats</code>. This will delete the
 statistics originally calculated at fill time and replace them with 
those calculated from the bins; note that you cannot later retrieve the 
original statistics–they are lost. Continuing the example above,</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb108-1" title="1">h-&gt;ResetStats();</a>
<a class="sourceLine" id="cb108-2" title="2">h-&gt;GetXaxis()-&gt;SetRange();</a></code></pre></div>
<p>results in <code>GetMean</code> and <code>GetStdDev</code> returning 50 and 0, respectively. If you fill the histogram again, the statistics will be a mix of binned and unbinned:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb109-1" title="1">h-&gt;ResetStats();</a>
<a class="sourceLine" id="cb109-2" title="2">h-&gt;GetXaxis()-&gt;SetRange();</a>
<a class="sourceLine" id="cb109-3" title="3"><span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10000</span>; i++) h-&gt;Fill(<span class="dv">85</span>);</a></code></pre></div>
<p>results in <code>GetMean</code> and <code>GetStdDev</code> returning 67.5 and 17.5, respectively; you must call <code>TH1::ResetStats</code> again to get consistent binned statistics.</p>
<h2 id="alphanumeric-bin-labels"><span class="header-section-number">3.14</span> Alphanumeric Bin Labels</h2>
<p>By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead.</p>
<h3 id="option-1-setbinlabel"><span class="header-section-number">3.14.1</span> Option 1: SetBinLabel</h3>
<p>To set an alphanumeric bin label call:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb110-1" title="1">   TAxis::SetBinLabel(bin,label);</a></code></pre></div>
<p>This can always be done before or after filling. Bin labels will be automatically drawn with the histogram.</p>
<figure>
<img src="ROOTUsersGuide_files/0600003B.png" alt="Histograms with alphanumeric bin labels"><figcaption>Histograms with alphanumeric bin labels</figcaption>
</figure>
<p>See example in <code>$ROOTSYS/tutorials/hist/hlabels1.C</code> , <code>hlabels2.C</code></p>
<h3 id="option-2-fill"><span class="header-section-number">3.14.2</span> Option 2: Fill</h3>
<p>You can also call a <code>Fill()</code> function with one of the arguments being a string:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb111-1" title="1">   hist1-&gt;Fill(somename,weigth);</a>
<a class="sourceLine" id="cb111-2" title="2">   hist2-&gt;Fill(x,somename,weight);</a>
<a class="sourceLine" id="cb111-3" title="3">   hist2-&gt;Fill(somename,y,weight);</a>
<a class="sourceLine" id="cb111-4" title="4">   hist2-&gt;Fill(somenamex,somenamey,weight);</a></code></pre></div>
<h3 id="option-3-ttreedraw"><span class="header-section-number">3.14.3</span> Option 3: TTree::Draw</h3>
<p>You can use a char* variable type to histogram strings with <strong><code>TTree</code></strong><code>::Draw()</code>.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb112-1" title="1">   <span class="co">// here "Nation" and "Division" are two char* branches of a Tree</span></a>
<a class="sourceLine" id="cb112-2" title="2">   tree.Draw(<span class="st">"Nation::Division"</span>, <span class="st">""</span>, <span class="st">"text"</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/0200003C.png" alt="Using a *char variable type in TTree::Draw"><figcaption>Using a *char variable type in TTree::Draw</figcaption>
</figure>
<p>There is an example in <code>$ROOTSYS/tutorials/tree/cernstaff.C.</code></p>
<p>If a variable is defined as <code>char*</code> it is drawn as a string by default. You change that and draw the value of <code>char[0]</code> as an integer by adding an arithmetic operation to the expression as shown below.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb113-1" title="1">   <span class="co">// draw the integer value of MyChar[0] where "MyChar" is char[5]</span></a>
<a class="sourceLine" id="cb113-2" title="2">   tree.Draw(<span class="st">"MyChar + 0"</span>);</a></code></pre></div>
<h3 id="sort-options"><span class="header-section-number">3.14.4</span> Sort Options</h3>
<p>When using the options 2 or 3 above, the labels are automatically added to the list (<strong><code>THashList</code></strong>)
 of labels for a given axis. By default, an axis is drawn with the order
 of bins corresponding to the filling sequence. It is possible to 
reorder the axis alphabetically or by increasing or decreasing values. 
The reordering can be triggered via the <strong><code>TAxis</code></strong> context menu by selecting the menu item “<code>LabelsOption</code>” or by calling directly.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb114-1" title="1">   TH1::LabelsOption(option,axis);</a></code></pre></div>
<p>Here <code>axis</code> may be X, Y, or Z. The parameter <code>option</code> may be:</p>
<ul>
<li>“<code>a</code>” sort by alphabetic order</li>
<li>“<code>&gt;</code>” sort by decreasing values</li>
<li>“<code>&lt;</code>” sort by increasing values</li>
<li>“<code>h</code>” draw labels horizontal</li>
<li>“<code>v</code>” draw labels vertical</li>
<li>“<code>u</code>” draw labels up (end of label right adjusted)</li>
<li>“<code>d</code>” draw labels down (start of label left adjusted)</li>
</ul>
<p>When using the option second above, new labels are added by doubling 
the current number of bins in case one label does not exist yet. When 
the filling is terminated, it is possible to trim the number of bins to 
match the number of active labels by calling:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb115-1" title="1">   TH1::LabelsDeflate(axis);</a></code></pre></div>
<p>Here <code>axis</code> may be X, Y, or Z. This operation is automatic when using <strong><code>TTree</code></strong><code>::Draw</code>
 . Once bin labels have been created, they become persistent if the 
histogram is written to a file or when generating the C++ code via <code>SavePrimitive</code> .</p>
<h2 id="histogram-stacks"><span class="header-section-number">3.15</span> Histogram Stacks</h2>
<p>A <strong><code>THStack</code></strong> is a collection of <strong><code>TH1</code></strong> (or derived) objects. Use <strong><code>THStack</code></strong><code>::Add(</code> <strong><code>TH1</code></strong> <code>*h)</code> to add a histogram to the stack. The <strong><code>THStack</code></strong> does not own the objects in the list.</p>
<figure>
<img src="ROOTUsersGuide_files/0300003D.png" alt="Stacked histograms"><figcaption>Stacked histograms</figcaption>
</figure>
<p>By default, <strong><code>THStack</code></strong><code>::Draw</code> draws the histograms stacked as shown in the left pad in the picture above. If the option <code>"nostack"</code> is used, the histograms are superimposed as if they were drawn one at a time using the <code>"same"</code> draw option <code>.</code> The right pad in this picture illustrates the <strong><code>THStack</code></strong> drawn with the <code>"nostack"</code> option.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb116-1" title="1">   hs-&gt;Draw(<span class="st">"nostack"</span>);</a></code></pre></div>
<p>Next is a simple example, for a more complex one see <code>$ROOTSYS/tutorials/hist/hstack.C.</code></p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb117-1" title="1">{</a>
<a class="sourceLine" id="cb117-2" title="2">   THStack hs(<span class="st">"hs"</span>,<span class="st">"test stacked histograms"</span>);</a>
<a class="sourceLine" id="cb117-3" title="3">   TH1F *h1 = <span class="kw">new</span> TH1F(<span class="st">"h1"</span>,<span class="st">"test hstack"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb117-4" title="4">   h1-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">20000</span>);</a>
<a class="sourceLine" id="cb117-5" title="5">   h1-&gt;SetFillColor(kRed);</a>
<a class="sourceLine" id="cb117-6" title="6">   hs.Add(h1);</a>
<a class="sourceLine" id="cb117-7" title="7">   TH1F *h2 = <span class="kw">new</span> TH1F(<span class="st">"h2"</span>,<span class="st">"test hstack"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb117-8" title="8">   h2-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">15000</span>);</a>
<a class="sourceLine" id="cb117-9" title="9">   h2-&gt;SetFillColor(kBlue);</a>
<a class="sourceLine" id="cb117-10" title="10">   hs.Add(h2);</a>
<a class="sourceLine" id="cb117-11" title="11">   TH1F *h3 = <span class="kw">new</span> TH1F(<span class="st">"h3"</span>,<span class="st">"test hstack"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb117-12" title="12">   h3-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">10000</span>);</a>
<a class="sourceLine" id="cb117-13" title="13">   h3-&gt;SetFillColor(kGreen);</a>
<a class="sourceLine" id="cb117-14" title="14">   hs.Add(h3);</a>
<a class="sourceLine" id="cb117-15" title="15">   TCanvas c1(<span class="st">"c1"</span>,<span class="st">"stacked hists"</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">900</span>);</a>
<a class="sourceLine" id="cb117-16" title="16">   c1.Divide (<span class="dv">1</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb117-17" title="17">   c1.cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb117-18" title="18">   hs.Draw();</a>
<a class="sourceLine" id="cb117-19" title="19">   c1.cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb117-20" title="20">   hs-&gt;Draw(<span class="st">"nostack"</span>);</a>
<a class="sourceLine" id="cb117-21" title="21">}</a></code></pre></div>
<h2 id="th2poly"><span class="header-section-number">3.16</span> TH2Poly</h2>
<p><code>TH2Poly</code> is a 2D Histogram class allowing to define polygonal bins of arbitrary shape.</p>
<p>Each bin in the <code>TH2Poly</code> histogram is a <code>TH2PolyBin</code> object. <code>TH2PolyBin</code> is a very simple class containing the vertices and contents of the polygonal bin as well as several related functions.</p>
<p>Bins are defined using one of the <code>AddBin()</code> methods. The bin definition should be done before filling.</p>
<p>The following very simple macro shows how to build and fill a <code>TH2Poly</code>:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb118-1" title="1">{</a>
<a class="sourceLine" id="cb118-2" title="2">   TH2Poly *h2p = <span class="kw">new</span> TH2Poly();</a>
<a class="sourceLine" id="cb118-3" title="3">   <span class="dt">Double_t</span> x1[] = {<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">5</span>};</a>
<a class="sourceLine" id="cb118-4" title="4">   <span class="dt">Double_t</span> y1[] = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">5</span>};</a>
<a class="sourceLine" id="cb118-5" title="5">   <span class="dt">Double_t</span> x2[] = {<span class="dv">0</span>, -<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb118-6" title="6">   <span class="dt">Double_t</span> y2[] = {<span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, -<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb118-7" title="7">   <span class="dt">Double_t</span> x3[] = {<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">2.4</span>};</a>
<a class="sourceLine" id="cb118-8" title="8">   <span class="dt">Double_t</span> y3[] = {<span class="dv">4</span>, <span class="fl">3.7</span>, <span class="dv">1</span>, <span class="fl">4.7</span>, <span class="fl">3.5</span>};</a>
<a class="sourceLine" id="cb118-9" title="9">   h2p-&gt;AddBin(<span class="dv">3</span>, x1, y1);</a>
<a class="sourceLine" id="cb118-10" title="10">   h2p-&gt;AddBin(<span class="dv">3</span>, x2, y2);</a>
<a class="sourceLine" id="cb118-11" title="11">   h2p-&gt;AddBin(<span class="dv">3</span>, x3, y3);</a>
<a class="sourceLine" id="cb118-12" title="12">   h2p-&gt;Fill( <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>);      <span class="co">// fill bin 1</span></a>
<a class="sourceLine" id="cb118-13" title="13">   h2p-&gt;Fill(-<span class="fl">0.5</span>, -<span class="fl">0.5</span>, <span class="dv">7</span>); <span class="co">// fill bin 2</span></a>
<a class="sourceLine" id="cb118-14" title="14">   h2p-&gt;Fill(-<span class="fl">0.7</span>, -<span class="fl">0.5</span>, <span class="dv">1</span>); <span class="co">// fill bin 2</span></a>
<a class="sourceLine" id="cb118-15" title="15">   h2p-&gt;Fill( <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>);      <span class="co">// fill bin 3</span></a>
<a class="sourceLine" id="cb118-16" title="16">}</a></code></pre></div>
<p>More examples can bin found in <code>$ROOTSYS/tutorials/hist/th2poly*.C</code></p>
<figure>
<img src="ROOTUsersGuide_files/th2poly1.png" alt="A TH2Poly histogram example"><figcaption>A TH2Poly histogram example</figcaption>
</figure>
<h2 id="profile-histograms"><span class="header-section-number">3.17</span> Profile Histograms</h2>
<p>Profile histograms are in many cases an elegant replacement of 
two-dimensional histograms. The relationship of two quantities X and Y 
can be visualized by a two-dimensional histogram or a scatter-plot; its 
representation is not particularly satisfactory, except for sparse data.
 If Y is an unknown [but single-valued] function of X, it can be 
displayed by a profile histogram with much better precision than by a 
scatter-plot. Profile histograms display the mean value of Y and its RMS
 for each bin in X. The following shows the contents [capital letters] 
and the values shown in the graphics [small letters] of the elements for
 bin j. When you fill a profile histogram with <strong><code>TProfile</code></strong><code>.Fill(x,y)</code> :</p>
<ul>
<li><p><code>H[j]</code> will contain for each bin <code>j</code> the sum of the y values for this bin</p></li>
<li><p><code>L[j]</code> contains the number of entries in the bin <code>j</code></p></li>
<li><p><code>e[j]</code> or <code>s[j]</code> will be the resulting error depending on the selected option. See “Build Options”.</p></li>
</ul>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb119-1" title="1">E[j] = sum Y**<span class="dv">2</span></a>
<a class="sourceLine" id="cb119-2" title="2">L[j] = number of entries in bin J</a>
<a class="sourceLine" id="cb119-3" title="3">H[j] = sum Y</a>
<a class="sourceLine" id="cb119-4" title="4">h[j] = H[j] / L[j]</a>
<a class="sourceLine" id="cb119-5" title="5">s[j] = sqrt[E[j] / L[j] - h[j]**<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb119-6" title="6">e[j] = s[j] / sqrt[L[j]]</a></code></pre></div>
<p>In the special case where <code>s[j]</code> is zero, when there is only one entry per bin, <code>e[j]</code> is computed from the average of the <code>s[j]</code> for all bins. This approximation is used to keep the bin during a fit operation. The <strong><code>TProfile</code></strong> constructor takes up to eight arguments. The first five parameters are similar to <strong><code>TH1D</code></strong> constructor.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb120-1" title="1">TProfile(<span class="at">const</span> <span class="dt">char</span> *name,<span class="at">const</span> <span class="dt">char</span> *title,<span class="dt">Int_t</span> nbinsx,</a>
<a class="sourceLine" id="cb120-2" title="2">         <span class="dt">Double_t</span> xlow, <span class="dt">Double_t</span> xup, <span class="dt">Double_t</span> ylow, <span class="dt">Double_t</span> yup,</a>
<a class="sourceLine" id="cb120-3" title="3">         <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>All values of <code>y</code> are accepted at filling time. To fill a profile histogram, you must use <strong><code>TProfile</code></strong><code>::Fill</code> function. Note that when filling the profile histogram the method <strong><code>TProfile</code></strong><code>::Fill</code> checks if the variable <code>y</code> is between <code>fYmin</code> and <code>fYmax</code>. If a minimum or maximum value is set for the Y scale before filling, then all values below <code>ylow</code> or above <code>yup</code>
 will be discarded. Setting the minimum or maximum value for the Y scale
 before filling has the same effect as calling the special <strong><code>TProfile</code></strong> constructor above where <code>ylow</code> and <code>yup</code> are specified.</p>
<h3 id="build-options"><span class="header-section-number">3.17.1</span> Build Options</h3>
<p>The last parameter is the build option. If a bin has N data points 
all with the same value Y, which is the case when dealing with integers,
 the spread in Y for that bin is zero, and the uncertainty assigned is 
also zero, and the bin is ignored in making subsequent fits. If <code>SQRT(Y)</code> was the correct error in the case above, then <code>SQRT(Y)/SQRT(N)</code> would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (<code>spread = s[j]</code>) should have an uncertainty <code>SQRT(Y)/SQRT(N)</code>. Now, is <code>SQRT(Y)/SQRT(N)</code>
 really the correct uncertainty ? That it is only in the case where the Y
 variable is some sort of counting statistics, following a Poisson 
distribution. This is the default case. However, Y can be any variable 
from an original <code>NTUPLE</code>, and does not necessarily follow a 
Poisson distribution. The computation of errors is based on Y = values 
of data points; N = number of data points.</p>
<ul>
<li><p><code>' '</code> - the default is blank, the errors are:</p></li>
<li><p><code>spread/SQRT(N)</code> for a non-zero spread</p></li>
<li><p><code>SQRT(Y)/SQRT(N)</code> for a spread of zero and some data points</p></li>
<li><p><code>0</code> for no data points</p></li>
<li><p>‘ <code>s</code> ’ - errors are:</p></li>
<li><p><code>spread</code> for a non-zero spread</p></li>
<li><p><code>SQRT(Y)</code> for a Spread of zero and some data points</p></li>
<li><p><code>0</code> for no data points</p></li>
<li><p>‘ <code>i</code> ’ - errors are:</p></li>
<li><p><code>spread/SQRT(N)</code> for a non-zero spread</p></li>
<li><p><code>1/SQRT(12*N)</code> for a Spread of zero and some data points</p></li>
<li><p><code>0</code> for no data points</p></li>
<li><p>‘ <code>G</code> ’ - errors are:</p></li>
<li><p><code>spread/SQRT(N)</code> for a non-zero spread</p></li>
<li><p><code>sigma/SQRT(N)</code> for a spread of zero and some data points</p></li>
<li><p><code>0</code> for no data points</p></li>
</ul>
<p>The option ’ <code>i</code> ’ is used for integer Y values with the uncertainty of <span class="math inline">\(\pm 0.5\)</span>,
 assuming the probability that Y takes any value between Y-0.5 and Y+0.5
 is uniform (the same argument for Y uniformly distributed between Y and
 Y+1). An example is an ADC measurement. The ‘<code>G</code>’ option is 
useful, if all Y variables are distributed according to some known 
Gaussian of standard deviation Sigma. For example when all Y’s are 
experimental quantities measured with the same instrument with precision
 Sigma. The next figure shows the graphic output of this simple example 
of a profile histogram.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb121-1" title="1">{</a>
<a class="sourceLine" id="cb121-2" title="2">   <span class="co">// Create a canvas giving the coordinates and the size</span></a>
<a class="sourceLine" id="cb121-3" title="3">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>, <span class="st">"Profile example"</span>,<span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb121-4" title="4"></a>
<a class="sourceLine" id="cb121-5" title="5">   <span class="co">// Create a profile with the name, title, the number of bins,</span></a>
<a class="sourceLine" id="cb121-6" title="6">   <span class="co">// the low and high limit of the x-axis and the low and high</span></a>
<a class="sourceLine" id="cb121-7" title="7">   <span class="co">// limit of the y-axis.</span></a>
<a class="sourceLine" id="cb121-8" title="8">   <span class="co">// No option is given so the default is used.</span></a>
<a class="sourceLine" id="cb121-9" title="9">   hprof = <span class="kw">new</span> TProfile(<span class="st">"hprof"</span>,</a>
<a class="sourceLine" id="cb121-10" title="10">                        <span class="st">"Profile of pz versus px"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb121-11" title="11"></a>
<a class="sourceLine" id="cb121-12" title="12">   <span class="co">// Fill the profile 25000 times with random numbers</span></a>
<a class="sourceLine" id="cb121-13" title="13">   <span class="dt">Float_t</span> px, py, pz;</a>
<a class="sourceLine" id="cb121-14" title="14">   <span class="cf">for</span> ( <span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">25000</span>; i++) {</a>
<a class="sourceLine" id="cb121-15" title="15">      <span class="co">// Use the random number generator to get two numbers following</span></a>
<a class="sourceLine" id="cb121-16" title="16">      <span class="co">// a gaussian distribution with mean=0 and sigma=1</span></a>
<a class="sourceLine" id="cb121-17" title="17">      gRandom-&gt;Rannor(px,py);</a>
<a class="sourceLine" id="cb121-18" title="18">      pz = px*px + py*py;</a>
<a class="sourceLine" id="cb121-19" title="19">      hprof-&gt;Fill(px,pz,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb121-20" title="20">   }</a>
<a class="sourceLine" id="cb121-21" title="21">   hprof-&gt;Draw();</a>
<a class="sourceLine" id="cb121-22" title="22">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/0300003E.png" alt="A profile histogram example"><figcaption>A profile histogram example</figcaption>
</figure>
<h3 id="drawing-a-profile-without-error-bars"><span class="header-section-number">3.17.2</span> Drawing a Profile without Error Bars</h3>
<p>To draw a profile histogram and not show the error bars use the “<code>HIST</code>” option in the <strong><code>TProfile</code></strong><code>::Draw</code> method. This will draw the outline of the <strong><code>TProfile</code></strong>.</p>
<h3 id="create-a-profile-from-a-2d-histogram"><span class="header-section-number">3.17.3</span> Create a Profile from a 2D Histogram</h3>
<p>You can make a profile from a histogram using the methods <strong><code>TH2</code></strong><code>::ProfileX</code> and <strong><code>TH2</code></strong><code>::ProfileY</code>.</p>
<h3 id="create-a-histogram-from-a-profile"><span class="header-section-number">3.17.4</span> Create a Histogram from a Profile</h3>
<p>To create a regular histogram from a profile histogram, use the method <strong><code>TProfile</code></strong><code>::ProjectionX</code> .This example instantiates a <strong><code>TH1D</code></strong> object by copying the <code>TH1D</code> piece of <strong><code>TProfile</code></strong>.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb122-1" title="1">   TH1D *sum = myProfile.ProjectionX();</a></code></pre></div>
<p>You can do the same with a 2D profile using the method <strong><code>TProfile2D</code></strong><code>::ProjectionXY</code> .</p>
<h3 id="generating-a-profile-from-a-ttree"><span class="header-section-number">3.17.5</span> Generating a Profile from a TTree</h3>
<p>The <code>'prof'</code> and <code>'profs'</code> options in the <strong><code>TTree</code></strong><code>::Draw</code> method generate a profile histogram ( <strong><code>TProfile</code></strong> ), given a two dimensional expression in the tree, or a <strong><code>TProfile2D</code></strong> given a three dimensional expression. See “Trees”. Note that you can specify <code>'prof'</code> or <code>'profs'</code> : <code>'prof'</code> generates a <strong><code>TProfile</code></strong> with error on the mean, <code>'profs'</code> generates a <strong><code>TProfile</code></strong> with error on the spread.</p>
<h3 id="d-profiles"><span class="header-section-number">3.17.6</span> 2D Profiles</h3>
<p>The class for a 2D Profile is called <strong><code>TProfile2D</code></strong>
 . It is in many cases an elegant replacement of a three-dimensional 
histogram. The relationship of three measured quantities X, Y and Z can 
be visualized by a three-dimensional histogram or scatter-plot; its 
representation is not particularly satisfactory, except for sparse data.
 If Z is an unknown (but single-valued) function of (X,Y), it can be 
displayed with a <strong><code>TProfile2D</code></strong> with better precision than by a scatter-plot. A <strong><code>TProfile2D</code></strong>
 displays the mean value of Z and its RMS for each cell in X, Y. The 
following shows the cumulated contents (capital letters) and the values 
displayed (small letters) of the elements for cell <code>i,j</code>.</p>
<p>When you fill a profile histogram with <strong><code>TProfile2D</code></strong><code>.Fill(x,y,z)</code>:</p>
<ul>
<li><p><code>E[i,j]</code> contains for each bin <code>i,j</code> the sum of the z values for this bin</p></li>
<li><p><code>L[i,j]</code> contains the number of entries in the bin j</p></li>
<li><p><code>e[j]</code> or <code>s[j]</code> will be the resulting error depending on the selected option. See “Build Options”.</p></li>
</ul>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb123-1" title="1">E[i,j] = sum z</a>
<a class="sourceLine" id="cb123-2" title="2">L[i,j] = sum l</a>
<a class="sourceLine" id="cb123-3" title="3">h[i,j] = H[i,j ] / L[i,j]</a>
<a class="sourceLine" id="cb123-4" title="4">s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb123-5" title="5">e[i,j] = s[i,j] / sqrt[L[i,j]]</a></code></pre></div>
<p>In the special case where <code>s[i,j]</code> is zero, when there is only one entry per cell, <code>e[i,j]</code> is computed from the average of the <code>s[i,j]</code> for all cells. This approximation is used to keep the cell during a fit operation.</p>
<figure>
<img src="ROOTUsersGuide_files/0800003F.png" alt="A TProfile2D histogram example"><figcaption>A TProfile2D histogram example</figcaption>
</figure>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb124-1" title="1">{</a>
<a class="sourceLine" id="cb124-2" title="2">   <span class="co">// Creating a Canvas and a TProfile2D</span></a>
<a class="sourceLine" id="cb124-3" title="3">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,</a>
<a class="sourceLine" id="cb124-4" title="4">                             <span class="st">"Profile histogram example"</span>,</a>
<a class="sourceLine" id="cb124-5" title="5">                              <span class="dv">200</span>, <span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb124-6" title="6">   hprof2d = <span class="kw">new</span> TProfile2D(<span class="st">"hprof2d"</span>,</a>
<a class="sourceLine" id="cb124-7" title="7">                            <span class="st">"Profile of pz versus px and py"</span>,</a>
<a class="sourceLine" id="cb124-8" title="8">                             <span class="dv">40</span>,-<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">40</span>,-<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb124-9" title="9"></a>
<a class="sourceLine" id="cb124-10" title="10">   <span class="co">// Filling the TProfile2D with 25000 points</span></a>
<a class="sourceLine" id="cb124-11" title="11">   <span class="dt">Float_t</span> px, py, pz;</a>
<a class="sourceLine" id="cb124-12" title="12">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">25000</span>; i++) {</a>
<a class="sourceLine" id="cb124-13" title="13">      gRandom-&gt;Rannor(px,py);</a>
<a class="sourceLine" id="cb124-14" title="14">      pz = px*px + py*py;</a>
<a class="sourceLine" id="cb124-15" title="15">      hprof2d-&gt;Fill(px,py,pz,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb124-16" title="16">   }</a>
<a class="sourceLine" id="cb124-17" title="17">   hprof2d-&gt;Draw();</a>
<a class="sourceLine" id="cb124-18" title="18">}</a></code></pre></div>
<h2 id="iso-surfaces"><span class="header-section-number">3.18</span> Iso Surfaces</h2>
<p>Paint one Gouraud shaded 3d iso surface though a 3d histogram at the value computed as follow: <code>SumOfWeights/(NbinsX*NbinsY*NbinsZ)</code>.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb125-1" title="1"><span class="dt">void</span> hist3d() {</a>
<a class="sourceLine" id="cb125-2" title="2">   TH3D *h3 = <span class="kw">new</span> TH3D(<span class="st">"h3"</span>, <span class="st">"h3"</span>, <span class="dv">20</span>, -<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">20</span>, -<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb125-3" title="3">   <span class="dt">Double_t</span> x,y,z;</a>
<a class="sourceLine" id="cb125-4" title="4">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10000</span>; i++) {</a>
<a class="sourceLine" id="cb125-5" title="5">      gRandom-&gt;</a>
<a class="sourceLine" id="cb125-6" title="6">      Rannor(x,y);</a>
<a class="sourceLine" id="cb125-7" title="7">      z=x*x+y*y;</a>
<a class="sourceLine" id="cb125-8" title="8">      h3-&gt;Fill(x,y,z);</a>
<a class="sourceLine" id="cb125-9" title="9">   }</a>
<a class="sourceLine" id="cb125-10" title="10">   h3-&gt;Draw(<span class="st">"iso"</span>);</a>
<a class="sourceLine" id="cb125-11" title="11">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000040.png" alt="Iso surfaces"><figcaption>Iso surfaces</figcaption>
</figure>
<h2 id="d-implicit-functions"><span class="header-section-number">3.19</span> 3D Implicit Functions</h2>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb126-1" title="1">   TF3 *fun3 = <span class="kw">new</span> TF3(<span class="st">"fun3"</span>,<span class="st">"sin(x*x+y*y+z*z-36)"</span>,-<span class="dv">2</span>,<span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb126-2" title="2">   fun3-&gt;Draw();</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000041.png" alt="3D implicit function"><figcaption>3D implicit function</figcaption>
</figure>
<h2 id="tpie"><span class="header-section-number">3.20</span> TPie</h2>
<p>The <strong><code>TPie</code></strong> class allows to create a Pie Chart representation of a one dimensional data set. The data can come from an array of <code>Double_t</code> (or <code>Float_t</code> ) or from a 1D-histogram. The possible options to draw a <strong><code>TPie</code></strong> are:</p>
<ul>
<li><p>“<code>R</code>” Paint the labels along the central “<code>R</code>”adius of slices.</p></li>
<li><p>“<code>T</code>” Paint the labels in a direction “<code>T</code>”angent to circle that describes the TPie.</p></li>
<li><p>“<code>3D</code>” Draw the pie-chart with a pseudo 3D effect.</p></li>
<li><p>“<code>NOL</code>” No OutLine: do not draw the slices’ outlines; any property over the slices’ line is ignored.</p></li>
</ul>
<p>The method <code>SetLabelFormat()</code> is used to customize the label format. The format string must contain one of these modifiers:</p>
<ul>
<li><ul>
<li><code>%txt</code> : to print the text label associated with the slice</li>
</ul></li>
<li><ul>
<li><code>%val</code> : to print the numeric value of the slice</li>
</ul></li>
<li><ul>
<li><code>%frac</code> : to print the relative fraction of this slice</li>
</ul></li>
<li><ul>
<li><code>%perc</code> : to print the % of this slice</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb127-1" title="1">   mypie-&gt;SetLabelFormat(<span class="st">"</span><span class="sc">%tx</span><span class="st">t (</span><span class="sc">%f</span><span class="st">rac)"</span>);</a></code></pre></div>
<p>See the macro <code>$ROOTSYS/tutorials/graphics/piechart.C</code> .</p>
<figure>
<img src="ROOTUsersGuide_files/03000042.png" alt="The picture generated by tutorial macro piechart.C"><figcaption>The picture generated by tutorial macro piechart.C</figcaption>
</figure>
<h2 id="the-user-interface-for-histograms"><span class="header-section-number">3.21</span> The User Interface for Histograms</h2>
<p>The classes <strong><code>T</code></strong> <strong><code>H1</code></strong> <strong><code>Editor</code></strong> and <strong><code>T</code></strong> <strong><code>H2</code></strong> <strong><code>Editor</code></strong> provides the user interface for setting histogram’s attributes and rebinning interactively.</p>
<h3 id="th1editor"><span class="header-section-number">3.21.1</span> TH1Editor</h3>
<p><img src="ROOTUsersGuide_files/03000043.png"></p>
<h4 id="the-style-tab"><span class="header-section-number">3.21.1.1</span> The Style Tab</h4>
<h5 id="title"><span class="header-section-number">3.21.1.1.1</span> Title</h5>
<p>sets the title of the histogram.</p>
<h5 id="plot"><span class="header-section-number">3.21.1.1.2</span> Plot</h5>
<p>draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.</p>
<h5 id="error"><span class="header-section-number">3.21.1.1.3</span> Error</h5>
<p>add different error bars to the histogram (no errors, simple, etc.).</p>
<h5 id="add"><span class="header-section-number">3.21.1.1.4</span> Add</h5>
<p>further things which can be added to the histogram (None, simple/smooth line, fill area, etc.)</p>
<h4 id="d-plot"><span class="header-section-number">3.21.1.2</span> 2-D Plot</h4>
<h5 id="simple-drawing"><span class="header-section-number">3.21.1.2.1</span> Simple Drawing</h5>
<p>draw a simple histogram without errors (= “HIST” draw option). In 
combination with some other draw options an outer line is drawn on top 
of the histogram</p>
<h5 id="show-markers"><span class="header-section-number">3.21.1.2.2</span> Show markers</h5>
<p>draw a marker on to of each bin (=“P” draw option).</p>
<h5 id="draw-bar-chart"><span class="header-section-number">3.21.1.2.3</span> Draw bar chart</h5>
<p>draw a bar chart (=“B” draw option).</p>
<h5 id="bar-option"><span class="header-section-number">3.21.1.2.4</span> Bar option</h5>
<p>draw a bar chart (=“BAR” draw option); if selected, it will show an 
additional interface elements for bars: width, offset, percentage and 
the possibility to draw horizontal bars.</p>
<h4 id="d-plot-1"><span class="header-section-number">3.21.1.3</span> 3-D Plot</h4>
<h5 id="add-1"><span class="header-section-number">3.21.1.3.1</span> Add</h5>
<p>set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).</p>
<h5 id="coords"><span class="header-section-number">3.21.1.3.2</span> Coords</h5>
<p>set the coordinate system (Cartesian, Spheric, etc.).</p>
<h5 id="error-1"><span class="header-section-number">3.21.1.3.3</span> Error</h5>
<p>same as for 2D plot.</p>
<h5 id="bar"><span class="header-section-number">3.21.1.3.4</span> Bar</h5>
<p>set the bar attributes: width and offset.</p>
<h5 id="horizontal-bar"><span class="header-section-number">3.21.1.3.5</span> Horizontal Bar</h5>
<p>draw a horizontal bar chart.</p>
<h4 id="the-binning-tab"><span class="header-section-number">3.21.1.4</span> The Binning tab</h4>
<p>The binning tab has two different layouts. One is for a histogram, 
which is not drawn from an ntuple. The other one is available for a 
histogram, which is drawn from an ntuple. In this case, the rebin 
algorithm can create a rebinned histogram from the original data i.e. 
the ntuple.</p>
<p><img src="ROOTUsersGuide_files/03000045.png"></p>
<p>To see the differences do:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb128-1" title="1">   TFile f(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb128-2" title="2">   hpx-&gt;Draw(<span class="st">"BAR1"</span>); <span class="co">// non ntuple histogram</span></a>
<a class="sourceLine" id="cb128-3" title="3">   ntuple-&gt;Draw(<span class="st">"px"</span>);<span class="co">// ntuple histogram</span></a></code></pre></div>
<h4 id="non-ntuple-histogram"><span class="header-section-number">3.21.1.5</span> Non ntuple histogram</h4>
<p>Rebin with a slider and the number of bins (shown in the field below 
the slider). The number of bins can be changed to any number, which 
divides the number of bins of the original histogram. A click on the 
Apply button will delete the origin histogram and will replace it by the
 rebinned one on the screen. A click on the Ignore button will restore 
the origin histogram.</p>
<h4 id="histogram-drawn-from-an-ntuple"><span class="header-section-number">3.21.1.6</span> Histogram drawn from an ntuple</h4>
<h5 id="rebin"><span class="header-section-number">3.21.1.6.1</span> Rebin</h5>
<p> with the slider, the number of bins can be enlarged by a factor of 2, 3, 4, 5 (moving to the right) or reduced by a factor of <span class="math inline">\(\frac{1}{2}\)</span>, <span class="math inline">\(\frac{1}{3}\)</span>, <span class="math inline">\(\frac{1}{4}\)</span>, <span class="math inline">\(\frac{1}{5}\)</span>.</p>
<h5 id="binoffset-with-a-binoffset-slider"><span class="header-section-number">3.21.1.6.2</span> BinOffset with a BinOffset slider</h5>
<p>the origin of the histogram can be changed within one binwidth. Using
 this slider the effect of binning the data into bins can be made 
visible (statistical fluctuations).</p>
<h5 id="axis-range"><span class="header-section-number">3.21.1.6.3</span> Axis Range</h5>
<p>with a double slider it is possible to zoom into the specified axis 
range. It is also possible to set the upper and lower limit in fields 
below the slider.</p>
<h5 id="delayed-drawing"><span class="header-section-number">3.21.1.6.4</span> Delayed drawing</h5>
<p>all the Binning sliders can set to delay draw mode. Then the changes 
on the histogram are only updated, when the Slider is released. This 
should be activated if the redrawing of the histogram is time consuming.</p>
<h3 id="th2editor"><span class="header-section-number">3.21.2</span> TH2Editor</h3>
<p><img src="ROOTUsersGuide_files/03000047.png"></p>
<h4 id="style-tab"><span class="header-section-number">3.21.2.1</span> Style Tab:</h4>
<h5 id="title-1"><span class="header-section-number">3.21.2.1.1</span> Title</h5>
<p>set the title of the histogram</p>
<h5 id="histogram"><span class="header-section-number">3.21.2.1.2</span> Histogram</h5>
<p>change the draw options of the histogram.</p>
<h5 id="plot-1"><span class="header-section-number">3.21.2.1.3</span> Plot</h5>
<p>draw a 2D or 3D plot of the histogram; according to the dimension, the drawing possibilities are different.</p>
<h4 id="d-plot-2"><span class="header-section-number">3.21.2.2</span> 2-D Plot</h4>
<h5 id="contour"><span class="header-section-number">3.21.2.2.1</span> Contour</h5>
<p>draw a contour plot (None, Cont0…5)</p>
<h5 id="cont"><span class="header-section-number">3.21.2.2.2</span> Cont #</h5>
<p>set the number of Contours;</p>
<h5 id="arrow"><span class="header-section-number">3.21.2.2.3</span> Arrow</h5>
<p>set the arrow mode and shows the gradient between adjacent cells;</p>
<h5 id="col"><span class="header-section-number">3.21.2.2.4</span> Col</h5>
<p>a box is drawn for each cell with a color scale varying with contents;</p>
<h5 id="text"><span class="header-section-number">3.21.2.2.5</span> Text</h5>
<p>draw bin contents as text;</p>
<h5 id="box"><span class="header-section-number">3.21.2.2.6</span> Box</h5>
<p>a box is drawn for each cell with surface proportional to contents;</p>
<h5 id="scat"><span class="header-section-number">3.21.2.2.7</span> Scat</h5>
<p>draw a scatter-plot (default);</p>
<h5 id="palette"><span class="header-section-number">3.21.2.2.8</span> Palette</h5>
<p>the color palette is drawn.</p>
<h4 id="d-plot-3"><span class="header-section-number">3.21.2.3</span> 3-D Plot</h4>
<h5 id="type"><span class="header-section-number">3.21.2.3.1</span> Type</h5>
<p>set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf, Surf1…5)</p>
<h5 id="coords-1"><span class="header-section-number">3.21.2.3.2</span> Coords</h5>
<p>set the coordinate system (Cartesian, Spheric, etc.);</p>
<h5 id="cont-1"><span class="header-section-number">3.21.2.3.3</span> Cont #</h5>
<p>set the number of Contours (for e.g.&nbsp;Lego2 draw option);</p>
<h5 id="errors"><span class="header-section-number">3.21.2.3.4</span> Errors</h5>
<p>draw errors in a Cartesian lego plot;</p>
<h5 id="palette-1"><span class="header-section-number">3.21.2.3.5</span> Palette</h5>
<p>draw the color palette;</p>
<h5 id="front"><span class="header-section-number">3.21.2.3.6</span> Front</h5>
<p>draw the front box of a Cartesian lego plot;</p>
<h5 id="back"><span class="header-section-number">3.21.2.3.7</span> Back</h5>
<p>draw the back box of a Cartesian lego plot;</p>
<h5 id="bar-1"><span class="header-section-number">3.21.2.3.8</span> Bar</h5>
<p>change the bar attributes: the width and offset.</p>
<h4 id="rebinning-tab"><span class="header-section-number">3.21.2.4</span> Rebinning Tab</h4>
<p>The Rebinning tab has two different layouts. One is for a histogram 
that is not drawn from an ntuple; the other one is available for a 
histogram, which is drawn from an ntuple. In this case, the rebin 
algorithm can create a rebinned histogram from the original data i.e. 
the ntuple. To see the differences do for example:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb129-1" title="1">   TFile f (<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb129-2" title="2">   hpxpy-&gt;Draw(<span class="st">"Lego2"</span>); <span class="co">// non ntuple histogram</span></a>
<a class="sourceLine" id="cb129-3" title="3">   ntuple-&gt;Draw(<span class="st">"px:py"</span>,<span class="st">""</span>,<span class="st">"Lego2"</span>); <span class="co">// ntuple histogram</span></a></code></pre></div>
<h4 id="non-ntuple-histogram-1"><span class="header-section-number">3.21.2.5</span> Non-ntuple histogram:</h4>
<p>Rebin with sliders (one for the x, one for the y-axis) and the number
 of bins (shown in the field below them can be changed to any number, 
which divides the number of bins of the original histogram. Selecting 
the Apply button will delete the origin histogram and will replace it by
 the rebinned one on the screen. Selecting the Ignore the origin 
histogram will be restored.</p>
<p><img src="ROOTUsersGuide_files/03000049.png"></p>
<h4 id="histogram-drawn-from-an-ntuple-1"><span class="header-section-number">3.21.2.6</span> Histogram drawn from an ntuple</h4>
<h5 id="rebin-1"><span class="header-section-number">3.21.2.6.1</span> Rebin</h5>
<p> with the sliders the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of <span class="math inline">\(\frac{1}{2}\)</span>, <span class="math inline">\(\frac{1}{3}\)</span>, <span class="math inline">\(\frac{1}{4}\)</span>, <span class="math inline">\(\frac{1}{5}\)</span>.</p>
<h5 id="binoffset"><span class="header-section-number">3.21.2.6.2</span> BinOffset</h5>
<p>with the BinOffset slider the origin of the histogram can be changed 
within one binwidth. Using this slider the effect of binning the data 
into bins can be made visible (=&gt; statistical fluctuations).</p>
<h5 id="axis-range-1"><span class="header-section-number">3.21.2.6.3</span> Axis Range</h5>
<p>with a double slider that gives the possibility for zooming. It is 
also possible to set the upper and lower limit in fields below the 
slider.</p>
<h5 id="delayed-drawing-1"><span class="header-section-number">3.21.2.6.4</span> Delayed drawing</h5>
<p>all the binning sliders can be set to delay draw mode. Then the 
changes on the histogram are only updated, when the Slider is released. 
This should be activated if the redrawing of the histogram is too time 
consuming.</p>
<h1 id="graphs"><span class="header-section-number">4</span> Graphs</h1>
<p>A graph is a graphics object made of two arrays X and Y, holding the x,y coordinates of <code>n</code> points. There are several graph classes; they are <strong><code>TGraph</code></strong>, <strong><code>TGraphErrors</code></strong>, <strong><code>TGraphAsymmErrors</code></strong>, and <strong><code>TMultiGraph</code></strong>.</p>
<h2 id="tgraph"><span class="header-section-number">4.1</span> TGraph</h2>
<p>The <strong><code>TGraph</code></strong> class supports the general 
case with non-equidistant points, and the special case with equidistant 
points. Graphs are created with the <strong><code>TGraph</code></strong>
 constructor. First, we define the arrays of coordinates and then create
 the graph. The coordinates can be arrays of doubles or floats.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb130-1" title="1">   <span class="dt">Int_t</span> n = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb130-2" title="2">   <span class="dt">Double_t</span> x[n], y[n];</a>
<a class="sourceLine" id="cb130-3" title="3">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;n; i++) {</a>
<a class="sourceLine" id="cb130-4" title="4">      x[i] = i*<span class="fl">0.1</span>;</a>
<a class="sourceLine" id="cb130-5" title="5">      y[i] = <span class="dv">10</span>*sin(x[i]+<span class="fl">0.2</span>);</a>
<a class="sourceLine" id="cb130-6" title="6">   }</a>
<a class="sourceLine" id="cb130-7" title="7">   TGraph *gr1 = <span class="kw">new</span> TGraph (n, x, y);</a></code></pre></div>
<p>An alternative constructor takes only the number of points <code>n</code>. It is expected that the coordinates will be set later.</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb131-1" title="1">TGraph *gr2 = <span class="kw">new</span> TGraph(n);</a></code></pre></div>
<p>The default constructor can also be used. Further calls to <code>SetPoint()</code> will extend the internal vectors.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb132-1" title="1">TGraph *gr3 = <span class="kw">new</span> TGraph();</a></code></pre></div>
<h3 id="graph-draw-options"><span class="header-section-number">4.1.1</span> Graph Draw Options</h3>
<p>The various drawing options for a graph are explained in <code>TGraph::PaintGraph</code>. They are:</p>
<ul>
<li><p>“<code>L</code>” A simple poly-line between every points is drawn</p></li>
<li><p>“<code>F</code>” A fill area is drawn</p></li>
<li><p>“<code>F1</code>” Idem as “<code>F</code>” but fill area is no more repartee around X=0 or Y=0</p></li>
<li><p>“<code>F2</code>” draw a fill area poly line connecting the center of bins</p></li>
<li><p>“<code>A</code>” Axis are drawn around the graph</p></li>
<li><p>“<code>C</code>” A smooth curve is drawn</p></li>
<li><p>“<code>*</code>” A star is plotted at each point</p></li>
<li><p>“<code>P</code>” The current marker of the graph is plotted at each point</p></li>
<li><p>“<code>B</code>” A bar chart is drawn at each point</p></li>
<li><p>“<code>[]</code>” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the <strong><code>TGraphAsymmErrors</code></strong>.</p></li>
<li><p>“<code>1</code>” <code>ylow</code> <code>=</code> <code>rwymin</code></p></li>
</ul>
<p>The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.</p>
<h4 id="continuous-line-axis-and-stars-ac"><span class="header-section-number">4.1.1.1</span> Continuous Line, Axis and Stars (AC*)</h4>
<figure>
<img src="ROOTUsersGuide_files/0300004B.png" alt="A graph drawn with axis, * markers and continuous line (option AC*)"><figcaption>A graph drawn with axis, * markers and continuous line (option AC*)</figcaption>
</figure>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb133-1" title="1">{</a>
<a class="sourceLine" id="cb133-2" title="2">   <span class="dt">Int_t</span> n = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb133-3" title="3">   <span class="dt">Double_t</span> x[n], y[n];</a>
<a class="sourceLine" id="cb133-4" title="4">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;n;i++) {</a>
<a class="sourceLine" id="cb133-5" title="5">      x[i] = i*<span class="fl">0.1</span>;</a>
<a class="sourceLine" id="cb133-6" title="6">      y[i] = <span class="dv">10</span>*sin(x[i]+<span class="fl">0.2</span>);</a>
<a class="sourceLine" id="cb133-7" title="7">   }</a>
<a class="sourceLine" id="cb133-8" title="8"></a>
<a class="sourceLine" id="cb133-9" title="9">   <span class="co">// create graph</span></a>
<a class="sourceLine" id="cb133-10" title="10">   TGraph *gr  = <span class="kw">new</span> TGraph(n,x,y);</a>
<a class="sourceLine" id="cb133-11" title="11">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"Graph Draw Options"</span>,</a>
<a class="sourceLine" id="cb133-12" title="12">                             <span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">600</span>,<span class="dv">400</span>);</a>
<a class="sourceLine" id="cb133-13" title="13"></a>
<a class="sourceLine" id="cb133-14" title="14">   <span class="co">// draw the graph with axis, continuous line, and put</span></a>
<a class="sourceLine" id="cb133-15" title="15">   <span class="co">// a * at each point</span></a>
<a class="sourceLine" id="cb133-16" title="16">   gr-&gt;Draw(<span class="st">"AC*"</span>);</a>
<a class="sourceLine" id="cb133-17" title="17">}</a></code></pre></div>
<h4 id="bar-graphs-ab"><span class="header-section-number">4.1.1.2</span> Bar Graphs (AB)</h4>
<figure>
<img src="ROOTUsersGuide_files/0300004C.png" alt="A graph drawn with axis and bar (option AB)"><figcaption>A graph drawn with axis and bar (option AB)</figcaption>
</figure>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb134-1" title="1">root[] TGraph *gr1 = <span class="kw">new</span> TGraph(n,x,y);</a>
<a class="sourceLine" id="cb134-2" title="2">root[] gr1-&gt;SetFillColor(<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb134-3" title="3">root[] gr1-&gt;Draw(<span class="st">"AB"</span>);</a></code></pre></div>
<p>This code will only work if n, x, and y is defined. The previous 
example defines these. You need to set the fill color, because by 
default the fill color is white and will not be visible on a white 
canvas. You also need to give it an axis, or the bar chart will not be 
displayed properly.</p>
<h4 id="filled-graphs-af"><span class="header-section-number">4.1.1.3</span> Filled Graphs (AF)</h4>
<figure>
<img src="ROOTUsersGuide_files/0300004D.png" alt="A graph drawn with axis and fill (option AF)"><figcaption>A graph drawn with axis and fill (option AF)</figcaption>
</figure>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb135-1" title="1">root[] TGraph *gr3 = <span class="kw">new</span> TGraph(n,x,y);</a>
<a class="sourceLine" id="cb135-2" title="2">root[] gr3-&gt;SetFillColor(<span class="dv">45</span>);</a>
<a class="sourceLine" id="cb135-3" title="3">root[] gr3-&gt;Draw(<span class="st">"AF"</span>)</a></code></pre></div>
<p>This code will only work if <code>n</code>, <code>x</code>, <code>y</code>are
 defined. The first example defines them. You need to set the fill 
color, because by default the fill color is white and will not be 
visible on a white canvas. You also need to give it an axis, or the 
filled polygon will not be displayed properly.</p>
<h4 id="marker-options"><span class="header-section-number">4.1.1.4</span> Marker Options</h4>
<figure>
<img src="ROOTUsersGuide_files/0300004E.png" alt="Graph markers created in different ways"><figcaption>Graph markers created in different ways</figcaption>
</figure>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb136-1" title="1">{</a>
<a class="sourceLine" id="cb136-2" title="2">   <span class="dt">Int_t</span> n = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb136-3" title="3">   <span class="dt">Double_t</span> x[n], y[n];</a>
<a class="sourceLine" id="cb136-4" title="4"></a>
<a class="sourceLine" id="cb136-5" title="5">   <span class="co">// build the arrays with the coordinate of points</span></a>
<a class="sourceLine" id="cb136-6" title="6">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;n; i++) {</a>
<a class="sourceLine" id="cb136-7" title="7">      x[i] = i*<span class="fl">0.1</span>;</a>
<a class="sourceLine" id="cb136-8" title="8">      y[i] = <span class="dv">10</span>*sin(x[i]+<span class="fl">0.2</span>);</a>
<a class="sourceLine" id="cb136-9" title="9">   }</a>
<a class="sourceLine" id="cb136-10" title="10"></a>
<a class="sourceLine" id="cb136-11" title="11">   <span class="co">// create graphs</span></a>
<a class="sourceLine" id="cb136-12" title="12">   TGraph *gr3  = <span class="kw">new</span> TGraph(n,x,y);</a>
<a class="sourceLine" id="cb136-13" title="13">   TCanvas *c1 = <span class="kw">new</span> TCanvas (<span class="st">"c1"</span>,<span class="st">"Graph Draw Options"</span>,</a>
<a class="sourceLine" id="cb136-14" title="14">                               <span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">600</span>,<span class="dv">400</span>);</a>
<a class="sourceLine" id="cb136-15" title="15"></a>
<a class="sourceLine" id="cb136-16" title="16">   <span class="co">// draw the graph with the axis,contineous line, and put</span></a>
<a class="sourceLine" id="cb136-17" title="17">   <span class="co">// a marker using the graph's marker style at each point</span></a>
<a class="sourceLine" id="cb136-18" title="18">   gr3-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb136-19" title="19">   c1-&gt;cd(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb136-20" title="20">   gr3-&gt;Draw(<span class="st">"APL"</span>);</a>
<a class="sourceLine" id="cb136-21" title="21"></a>
<a class="sourceLine" id="cb136-22" title="22">   <span class="co">// get the points in the graph and put them into an array</span></a>
<a class="sourceLine" id="cb136-23" title="23">   <span class="dt">Double_t</span> *nx = gr3-&gt;GetX();</a>
<a class="sourceLine" id="cb136-24" title="24">   <span class="dt">Double_t</span> *ny = gr3-&gt;GetY();</a>
<a class="sourceLine" id="cb136-25" title="25"></a>
<a class="sourceLine" id="cb136-26" title="26">   <span class="co">// create markers of different colors</span></a>
<a class="sourceLine" id="cb136-27" title="27">   <span class="cf">for</span> (<span class="dt">Int_t</span> j=<span class="dv">2</span>; j&lt;n-<span class="dv">1</span>; j++) {</a>
<a class="sourceLine" id="cb136-28" title="28">      TMarker *m = <span class="kw">new</span> TMarker(nx[j], <span class="fl">0.5</span>*ny[j], <span class="dv">22</span>);</a>
<a class="sourceLine" id="cb136-29" title="29">      m-&gt;SetMarkerSize(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb136-30" title="30">      m-&gt;SetMarkerColor(<span class="dv">31</span>+j);</a>
<a class="sourceLine" id="cb136-31" title="31">      m-&gt;Draw();</a>
<a class="sourceLine" id="cb136-32" title="32">   }</a>
<a class="sourceLine" id="cb136-33" title="33">}</a></code></pre></div>
<h2 id="superimposing-two-graphs"><span class="header-section-number">4.2</span> Superimposing Two Graphs</h2>
<p>To super impose two graphs you need to draw the axis only once, and 
leave out the “A” in the draw options for the second graph. Next is an 
example:</p>
<figure>
<img src="ROOTUsersGuide_files/0300004F.png" alt="Superimposing two graphs"><figcaption>Superimposing two graphs</figcaption>
</figure>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb137-1" title="1">{</a>
<a class="sourceLine" id="cb137-2" title="2">   <span class="dt">Int_t</span> n = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb137-3" title="3">   <span class="dt">Double_t</span> x[n], y[n], x1[n], y1[n];</a>
<a class="sourceLine" id="cb137-4" title="4"></a>
<a class="sourceLine" id="cb137-5" title="5">   <span class="co">// create a blue graph with a cos function</span></a>
<a class="sourceLine" id="cb137-6" title="6">   gr1-&gt;SetLineColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb137-7" title="7">   gr1-&gt;Draw(<span class="st">"AC*"</span>);</a>
<a class="sourceLine" id="cb137-8" title="8"></a>
<a class="sourceLine" id="cb137-9" title="9">   <span class="co">// superimpose the second graph by leaving out the axis option "A"</span></a>
<a class="sourceLine" id="cb137-10" title="10">   gr2-&gt;SetLineWidth(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb137-11" title="11">   gr2-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb137-12" title="12">   gr2-&gt;SetLineColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb137-13" title="13">   gr2-&gt;Draw(<span class="st">"CP"</span>);</a>
<a class="sourceLine" id="cb137-14" title="14">}</a></code></pre></div>
<h2 id="graphs-with-error-bars"><span class="header-section-number">4.3</span> Graphs with Error Bars</h2>
<p>A <strong><code>TGraphErrors</code></strong> is a <strong><code>TGraph</code></strong> with error bars. The various draw format options of <code>TGraphErrors::Paint()</code> are derived from <strong><code>TGraph</code></strong>.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb138-1" title="1"><span class="dt">void</span> TGraphErrors::Paint(<span class="dt">Option_t</span> *option)</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000050.png" alt="Graphs with different draw options of error bars"><figcaption>Graphs with different draw options of error bars</figcaption>
</figure>
<p>In addition, it can be drawn with the “<code>Z</code>” option to leave off the small lines at the end of the error bars. If option contains “<code>&gt;</code>”, an arrow is drawn at the end of the error bars. If option contains “<code>|&gt;</code>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.</p>
<p>The option “<code>[]</code>” is interesting to superimpose systematic
 errors on top of the graph with the statistical errors. When it is 
specified, only the end vertical/horizontal lines of the error bars are 
drawn.</p>
<p>To control the size of the lines at the end of the error bars (when option 1 is chosen) use <code>SetEndErrorSize(np)</code>. By default <code>np=1</code>; <code>np</code> represents the number of pixels.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb139-1" title="1">gStyle-&gt;SetEndErrorSize(np);</a></code></pre></div>
<p>The four parameters of <strong><code>TGraphErrors</code></strong> are: <code>X, Y</code> (as in <strong><code>TGraph</code></strong>), <code>X</code>-errors, and <code>Y</code>-errors - the size of the errors in the <code>x</code> and <code>y</code> direction. Next example is <code>$ROOTSYS/tutorials/graphs/gerrors.C.</code></p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb140-1" title="1">{</a>
<a class="sourceLine" id="cb140-2" title="2">   c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"A Simple Graph with error bars"</span>,<span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb140-3" title="3">   c1-&gt;SetGrid();</a>
<a class="sourceLine" id="cb140-4" title="4"></a>
<a class="sourceLine" id="cb140-5" title="5">   <span class="co">// create the coordinate arrays</span></a>
<a class="sourceLine" id="cb140-6" title="6">   <span class="dt">Int_t</span> n = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb140-7" title="7">   <span class="dt">Float_t</span> x[n]  = {-<span class="fl">.22</span>,<span class="fl">.05</span>,<span class="fl">.25</span>,<span class="fl">.35</span>,<span class="fl">.5</span>,<span class="fl">.61</span>,<span class="fl">.7</span>,<span class="fl">.85</span>,<span class="fl">.89</span>,<span class="fl">.95</span>};</a>
<a class="sourceLine" id="cb140-8" title="8">   <span class="dt">Float_t</span> y[n]  = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb140-9" title="9"></a>
<a class="sourceLine" id="cb140-10" title="10">   <span class="co">// create the error arrays</span></a>
<a class="sourceLine" id="cb140-11" title="11">   <span class="dt">Float_t</span> ex[n] = {<span class="fl">.05</span>,<span class="fl">.1</span>,<span class="fl">.07</span>,<span class="fl">.07</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.07</span>,<span class="fl">.08</span>,<span class="fl">.05</span>};</a>
<a class="sourceLine" id="cb140-12" title="12">   <span class="dt">Float_t</span> ey[n] = {<span class="fl">.8</span>,<span class="fl">.7</span>,<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>,<span class="fl">.7</span>,<span class="fl">.8</span>};</a>
<a class="sourceLine" id="cb140-13" title="13"></a>
<a class="sourceLine" id="cb140-14" title="14">   <span class="co">// create the TGraphErrors and draw it</span></a>
<a class="sourceLine" id="cb140-15" title="15">   gr = <span class="kw">new</span> TGraphErrors(n,x,y,ex,ey);</a>
<a class="sourceLine" id="cb140-16" title="16">   gr-&gt;SetTitle(<span class="st">"TGraphErrors Example"</span>);</a>
<a class="sourceLine" id="cb140-17" title="17">   gr-&gt;SetMarkerColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb140-18" title="18">   gr-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb140-19" title="19">   gr-&gt;Draw(<span class="st">"ALP"</span>);</a>
<a class="sourceLine" id="cb140-20" title="20">   c1-&gt;Update();</a>
<a class="sourceLine" id="cb140-21" title="21">}</a></code></pre></div>
<h2 id="graphs-with-asymmetric-error-bars"><span class="header-section-number">4.4</span> Graphs with Asymmetric Error Bars</h2>
<figure>
<img src="ROOTUsersGuide_files/03000052.png" alt="A graph with asymmetric error bars"><figcaption>A graph with asymmetric error bars</figcaption>
</figure>
<p>A <strong><code>TGraphAsymmErrors</code></strong> is a <strong><code>TGraph</code></strong> with asymmetric error bars. It inherits the various draw format options from <strong><code>TGraph</code></strong>. Its method <code>Paint(Option_t *option)</code> paints the <strong><code>TGraphAsymmErrors</code></strong> with the current attributes. You can set the following additional options for drawing:</p>
<ul>
<li><p>“<code>z</code>” or “<code>Z</code>”the horizontal and vertical small lines are not drawn at the end of error bars</p></li>
<li><p>“<code>&gt;</code>”an arrow is drawn at the end of the error bars</p></li>
<li><p>“<code>|&gt;</code>”a full arrow is drawn at the end of the error bar; its size is <span class="math inline">\(\frac{2}{3}\)</span> of the marker size</p></li>
<li><p>“<code>[]</code>”only the end vertical/horizontal lines of the 
error bars are drawn; this option is interesting to superimpose 
systematic errors on top of a graph with statistical errors.</p></li>
</ul>
<p>The constructor has six arrays as parameters: X and Y as <strong>TGraph</strong>
 and low X-errors and high X-errors, low Y-errors and high Y-errors. The
 low value is the length of the error bar to the left and down, the high
 value is the length of the error bar to the right and up.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb141-1" title="1">{</a>
<a class="sourceLine" id="cb141-2" title="2">   c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"A Simple Graph with error bars"</span>,</a>
<a class="sourceLine" id="cb141-3" title="3">                    <span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb141-4" title="4">   c1-&gt;SetGrid();</a>
<a class="sourceLine" id="cb141-5" title="5"></a>
<a class="sourceLine" id="cb141-6" title="6">   <span class="co">// create the arrays for the points</span></a>
<a class="sourceLine" id="cb141-7" title="7">   <span class="dt">Int_t</span> n = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb141-8" title="8">   <span class="dt">Double_t</span> x[n]  = {-<span class="fl">.22</span>,<span class="fl">.05</span>,<span class="fl">.25</span>,<span class="fl">.35</span>,<span class="fl">.5</span>, <span class="fl">.61</span>,<span class="fl">.7</span>,<span class="fl">.85</span>,<span class="fl">.89</span>,<span class="fl">.95</span>};</a>
<a class="sourceLine" id="cb141-9" title="9">   <span class="dt">Double_t</span> y[n]  = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb141-10" title="10"></a>
<a class="sourceLine" id="cb141-11" title="11">   <span class="co">// create the arrays with high and low errors</span></a>
<a class="sourceLine" id="cb141-12" title="12">   <span class="dt">Double_t</span> exl[n] = {<span class="fl">.05</span>,<span class="fl">.1</span>,<span class="fl">.07</span>,<span class="fl">.07</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.07</span>,<span class="fl">.08</span>,<span class="fl">.05</span>};</a>
<a class="sourceLine" id="cb141-13" title="13">   <span class="dt">Double_t</span> eyl[n] = {<span class="fl">.8</span>,<span class="fl">.7</span>,<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>,<span class="fl">.7</span>,<span class="fl">.8</span>};</a>
<a class="sourceLine" id="cb141-14" title="14">   <span class="dt">Double_t</span> exh[n] = {<span class="fl">.02</span>,<span class="fl">.08</span>,<span class="fl">.05</span>,<span class="fl">.05</span>,<span class="fl">.03</span>,<span class="fl">.03</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.03</span>};</a>
<a class="sourceLine" id="cb141-15" title="15">   <span class="dt">Double_t</span> eyh[n] = {<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.3</span>,<span class="fl">.2</span>,<span class="fl">.2</span>,<span class="fl">.3</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>};</a>
<a class="sourceLine" id="cb141-16" title="16"></a>
<a class="sourceLine" id="cb141-17" title="17">   <span class="co">// create TGraphAsymmErrors with the arrays</span></a>
<a class="sourceLine" id="cb141-18" title="18">   gr = <span class="kw">new</span> TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);</a>
<a class="sourceLine" id="cb141-19" title="19">   gr-&gt;SetTitle(<span class="st">"TGraphAsymmErrors Example"</span>);</a>
<a class="sourceLine" id="cb141-20" title="20">   gr-&gt;SetMarkerColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb141-21" title="21">   gr-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb141-22" title="22">   gr-&gt;Draw(<span class="st">"ALP"</span>);</a>
<a class="sourceLine" id="cb141-23" title="23">}</a></code></pre></div>
<h2 id="graphs-with-asymmetric-bent-errors"><span class="header-section-number">4.5</span> Graphs with Asymmetric Bent Errors</h2>
<figure>
<img src="ROOTUsersGuide_files/03000053.png" alt="A graph with asymmetric bent error bars"><figcaption>A graph with asymmetric bent error bars</figcaption>
</figure>
<p>A <strong><code>TGraphBentErrors</code></strong> is a <strong><code>TGraph</code></strong> with bent, asymmetric error bars. The various format options to draw a <strong><code>TGraphBentErrors</code></strong> are explained in <strong><code>TGraphBentErrors::Paint</code> method. The <code>TGraphBentErrors</code></strong> is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “<code>z</code>” or “<code>Z</code>” is specified, these small lines are not drawn. If the option “<code>X</code>” is specified, the errors are not drawn (the <code>TGraph::Paint</code> method equivalent).</p>
<ul>
<li><p>if option contains “<code>&gt;</code>”, an arrow is drawn at the end of the error bars</p></li>
<li><p>if option contains “<code>|&gt;</code>”, a full arrow is drawn at the end of the error bars</p></li>
<li><p>the size of the arrow is set to 2/3 of the marker size</p></li>
<li><p>if option “<code>[]</code>” is specified, only the end 
vertical/horizontal lines of the error bars are drawn. This option is 
interesting to superimpose systematic errors on top of a graph with 
statistical errors.</p></li>
</ul>
<p>This figure has been generated by the following macro:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb142-1" title="1">{</a>
<a class="sourceLine" id="cb142-2" title="2">   <span class="dt">Int_t</span> n = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb142-3" title="3">   <span class="dt">Double_t</span> x[n] = {-<span class="fl">0.22</span>,<span class="fl">0.05</span>,<span class="fl">0.25</span>,<span class="fl">0.35</span>,<span class="fl">0.5</span>,<span class="fl">0.61</span>,<span class="fl">0.7</span>,<span class="fl">0.85</span>,<span class="fl">0.89</span>,<span class="fl">0.95</span>};</a>
<a class="sourceLine" id="cb142-4" title="4">   <span class="dt">Double_t</span> y[n] = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb142-5" title="5">   <span class="dt">Double_t</span> exl[n] = {<span class="fl">.05</span>,<span class="fl">.1</span>,<span class="fl">.07</span>,<span class="fl">.07</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.07</span>,<span class="fl">.08</span>,<span class="fl">.05</span>};</a>
<a class="sourceLine" id="cb142-6" title="6">   <span class="dt">Double_t</span> eyl[n] = {<span class="fl">.8</span>,<span class="fl">.7</span>,<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>,<span class="fl">.7</span>,<span class="fl">.8</span>};</a>
<a class="sourceLine" id="cb142-7" title="7">   <span class="dt">Double_t</span> exh[n] = {<span class="fl">.02</span>,<span class="fl">.08</span>,<span class="fl">.05</span>,<span class="fl">.05</span>,<span class="fl">.03</span>,<span class="fl">.03</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.03</span>};</a>
<a class="sourceLine" id="cb142-8" title="8">   <span class="dt">Double_t</span> eyh[n] = {<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.3</span>,<span class="fl">.2</span>,<span class="fl">.2</span>,<span class="fl">.3</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>};</a>
<a class="sourceLine" id="cb142-9" title="9">   <span class="dt">Double_t</span> exld[n] = {<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>};</a>
<a class="sourceLine" id="cb142-10" title="10">   <span class="dt">Double_t</span> eyld[n] = {<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>};</a>
<a class="sourceLine" id="cb142-11" title="11">   <span class="dt">Double_t</span> exhd[n] = {<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>};</a>
<a class="sourceLine" id="cb142-12" title="12">   <span class="dt">Double_t</span> eyhd[n] = {<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.0</span>,<span class="fl">.05</span>,<span class="fl">.0</span>};</a>
<a class="sourceLine" id="cb142-13" title="13">   gr = <span class="kw">new</span> TGraphBentErrors(n,x,y,</a>
<a class="sourceLine" id="cb142-14" title="14">                             exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);</a>
<a class="sourceLine" id="cb142-15" title="15">   gr-&gt;SetTitle(<span class="st">"TGraphBentErrors Example"</span>);</a>
<a class="sourceLine" id="cb142-16" title="16">   gr-&gt;SetMarkerColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb142-17" title="17">   gr-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb142-18" title="18">   gr-&gt;Draw(<span class="st">"ALP"</span>);</a>
<a class="sourceLine" id="cb142-19" title="19">}</a></code></pre></div>
<h2 id="tgraphpolar"><span class="header-section-number">4.6</span> TGraphPolar</h2>
<p>The <strong><code>TGraphPolar</code></strong> class creates a polar graph (including error bars). A <strong><code>TGraphPolar</code></strong> is a <strong><code>TGraphErrors</code></strong> represented in polar coordinates. It uses the class <strong><code>TGraphPolargram</code></strong> to draw the polar axis.</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb143-1" title="1">{</a>
<a class="sourceLine" id="cb143-2" title="2">   TCanvas *CPol = <span class="kw">new</span> TCanvas(<span class="st">"CPol"</span>,<span class="st">"TGraphPolar Examples"</span>,<span class="dv">700</span>,<span class="dv">700</span>);</a>
<a class="sourceLine" id="cb143-3" title="3">   <span class="dt">Double_t</span> rmin=<span class="dv">0</span>;</a>
<a class="sourceLine" id="cb143-4" title="4">   <span class="dt">Double_t</span> rmax=TMath::Pi()*<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb143-5" title="5">   <span class="dt">Double_t</span> r[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb143-6" title="6">   <span class="dt">Double_t</span> theta[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb143-7" title="7">   TF1 * fp1 = <span class="kw">new</span> TF1(<span class="st">"fplot"</span>,<span class="st">"cos(x)"</span>,rmin,rmax);</a>
<a class="sourceLine" id="cb143-8" title="8">   <span class="cf">for</span> (<span class="dt">Int_t</span> ipt = <span class="dv">0</span>; ipt &lt; <span class="dv">1000</span>; ipt++) {</a>
<a class="sourceLine" id="cb143-9" title="9">      r[ipt] = ipt*(rmax-rmin)/<span class="dv">1000</span>+rmin;</a>
<a class="sourceLine" id="cb143-10" title="10">      theta[ipt] = fp1-&gt;Eval(r[ipt]);</a>
<a class="sourceLine" id="cb143-11" title="11">   }</a>
<a class="sourceLine" id="cb143-12" title="12">   TGraphPolar * grP1 = <span class="kw">new</span> TGraphPolar(<span class="dv">1000</span>,r,theta);</a>
<a class="sourceLine" id="cb143-13" title="13">   grP1-&gt;SetLineColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb143-14" title="14">   grP1-&gt;Draw(<span class="st">"AOL"</span>);</a>
<a class="sourceLine" id="cb143-15" title="15">}</a></code></pre></div>
<p>The TGraphPolar drawing options are:</p>
<p>“O” Polar labels are paint orthogonally to the polargram radius.</p>
<p>“P” Polymarker are paint at each point position.</p>
<p>“E” Paint error bars.</p>
<p>“F” Paint fill area (closed polygon).</p>
<p>“A”Force axis redrawing even if a polagram already exists.</p>
<figure>
<img src="ROOTUsersGuide_files/03000054.png" alt="A polar graph"><figcaption>A polar graph</figcaption>
</figure>
<h2 id="tgraph-exclusion-zone"><span class="header-section-number">4.7</span> TGraph Exclusion Zone</h2>
<p>When a graph is painted with the option “<code>C</code>” or “<code>L</code>”,
 it is possible to draw a filled area on one side of the line. This is 
useful to show exclusion zones. This drawing mode is activated when the 
absolute value of the graph line width (set thanks to <code>SetLineWidth</code>) is greater than 99. In that case the line width number is interpreted as <code>100*ff+ll = ffll</code>. The two-digit numbers “<code>ll</code>” represent the normal line width whereas “<code>ff</code>” is the filled area width. The sign of “<code>ffll</code>”
 allows flipping the filled area from one side of the line to the other.
 The current fill area attributes are used to draw the hatched zone.</p>
<figure>
<img src="ROOTUsersGuide_files/03000055.png" alt="Graphs with exclusion zones"><figcaption>Graphs with exclusion zones</figcaption>
</figure>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb144-1" title="1">{</a>
<a class="sourceLine" id="cb144-2" title="2">   c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"Exclusion graphs examples"</span>,<span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb144-3" title="3">   c1-&gt;SetGrid();</a>
<a class="sourceLine" id="cb144-4" title="4"></a>
<a class="sourceLine" id="cb144-5" title="5">   <span class="co">// create the multigraph</span></a>
<a class="sourceLine" id="cb144-6" title="6">   TMultiGraph *mg = <span class="kw">new</span> TMultiGraph();</a>
<a class="sourceLine" id="cb144-7" title="7">   mg-&gt;SetTitle(<span class="st">"Exclusion graphs"</span>);</a>
<a class="sourceLine" id="cb144-8" title="8"></a>
<a class="sourceLine" id="cb144-9" title="9">   <span class="co">// create the graphs points</span></a>
<a class="sourceLine" id="cb144-10" title="10">   <span class="at">const</span> <span class="dt">Int_t</span> n = <span class="dv">35</span>;</a>
<a class="sourceLine" id="cb144-11" title="11">   <span class="dt">Double_t</span> x1[n], x2[n], x3[n], y1[n], y2[n], y3[n];</a>
<a class="sourceLine" id="cb144-12" title="12">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;n;i++) {</a>
<a class="sourceLine" id="cb144-13" title="13">      x1[i] = i*<span class="fl">0.1</span>; y1[i] = <span class="dv">10</span>*sin(x1[i]);</a>
<a class="sourceLine" id="cb144-14" title="14">      x2[i] = x1[i]; y2[i] = <span class="dv">10</span>*cos(x1[i]);</a>
<a class="sourceLine" id="cb144-15" title="15">      x3[i] = x1[i]+<span class="fl">.5</span>; y3[i] = <span class="dv">10</span>*sin(x1[i])-<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb144-16" title="16">   }</a>
<a class="sourceLine" id="cb144-17" title="17"></a>
<a class="sourceLine" id="cb144-18" title="18">   <span class="co">// create the 1st TGraph</span></a>
<a class="sourceLine" id="cb144-19" title="19">   gr1 = <span class="kw">new</span> TGraph(n,x1,y1);</a>
<a class="sourceLine" id="cb144-20" title="20">   gr1-&gt;SetLineColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb144-21" title="21">   gr1-&gt;SetLineWidth(<span class="dv">1504</span>);</a>
<a class="sourceLine" id="cb144-22" title="22">   gr1-&gt;SetFillStyle(<span class="dv">3005</span>);</a>
<a class="sourceLine" id="cb144-23" title="23"></a>
<a class="sourceLine" id="cb144-24" title="24">   <span class="co">// create the 2nd TGraph</span></a>
<a class="sourceLine" id="cb144-25" title="25">   gr2 = <span class="kw">new</span> TGraph(n,x2,y2);</a>
<a class="sourceLine" id="cb144-26" title="26">   gr2-&gt;SetLineColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb144-27" title="27">   gr2-&gt;SetLineWidth(-<span class="dv">2002</span>);</a>
<a class="sourceLine" id="cb144-28" title="28">   gr2-&gt;SetFillStyle(<span class="dv">3004</span>);</a>
<a class="sourceLine" id="cb144-29" title="29">   gr2-&gt;SetFillColor(<span class="dv">9</span>);</a>
<a class="sourceLine" id="cb144-30" title="30"></a>
<a class="sourceLine" id="cb144-31" title="31">   <span class="co">// create the 3rd TGraph</span></a>
<a class="sourceLine" id="cb144-32" title="32">   gr3 = <span class="kw">new</span> TGraph(n,x3,y3);</a>
<a class="sourceLine" id="cb144-33" title="33">   gr3-&gt;SetLineColor(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb144-34" title="34">   gr3-&gt;SetLineWidth(-<span class="dv">802</span>);</a>
<a class="sourceLine" id="cb144-35" title="35">   gr3-&gt;SetFillStyle(<span class="dv">3002</span>);</a>
<a class="sourceLine" id="cb144-36" title="36">   gr3-&gt;SetFillColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb144-37" title="37"></a>
<a class="sourceLine" id="cb144-38" title="38">   <span class="co">// put the graphs in the multigraph</span></a>
<a class="sourceLine" id="cb144-39" title="39">   mg-&gt;Add(gr1);</a>
<a class="sourceLine" id="cb144-40" title="40">   mg-&gt;Add(gr2);</a>
<a class="sourceLine" id="cb144-41" title="41">   mg-&gt;Add(gr3);</a>
<a class="sourceLine" id="cb144-42" title="42"></a>
<a class="sourceLine" id="cb144-43" title="43">   <span class="co">// draw the multigraph</span></a>
<a class="sourceLine" id="cb144-44" title="44">   mg-&gt;Draw(<span class="st">"AC"</span>);</a>
<a class="sourceLine" id="cb144-45" title="45">}</a></code></pre></div>
<h2 id="tgraphqq"><span class="header-section-number">4.8</span> TGraphQQ</h2>
<p>A <strong><code>TGraphQQ</code></strong> allows drawing 
quantile-quantile plots. Such plots can be drawn for two datasets, or 
for one dataset and a theoretical distribution function.</p>
<h3 id="two-datasets"><span class="header-section-number">4.8.1</span> Two Datasets</h3>
<figure>
<img src="ROOTUsersGuide_files/03000056.png" alt="Examples of qq-plots of 2 datasets"><figcaption>Examples of qq-plots of 2 datasets</figcaption>
</figure>
<p>Quantile-quantile plots are used to determine whether two samples 
come from the same distribution. A qq-plot draws the quantiles of one 
dataset against the quantile of the other. The quantiles of the dataset 
with fewer entries are on Y-axis, with more entries - on X-axis. A 
straight line, going through 0.25 and 0.75 quantiles is also plotted for
 reference. It represents a robust linear fit, not sensitive to the 
extremes of the datasets. If the datasets come from the same 
distribution, points of the plot should fall approximately on the 45 
degrees line. If they have the same distribution function, but different
 parameters of location or scale, they should still fall on the straight
 line, but not the 45 degrees one.</p>
<p>The greater their departure from the straight line, the more evidence
 there is that the datasets come from different distributions. The 
advantage of qq-plot is that it not only shows that the underlying 
distributions are different, but, unlike the analytical methods, it also
 gives information on the nature of this difference: heavier tails, 
different location/scale, different shape, etc.</p>
<h3 id="one-dataset"><span class="header-section-number">4.8.2</span> One Dataset</h3>
<figure>
<img src="ROOTUsersGuide_files/03000057.png" alt="Examples of qq-plots of 1 dataset"><figcaption>Examples of qq-plots of 1 dataset</figcaption>
</figure>
<p>Quantile-quantile plots are used to determine if the dataset comes 
from the specified theoretical distribution, such as normal. A qq-plot 
draws quantiles of the dataset against quantiles of the specified 
theoretical distribution. Note, that density, not CDF should be 
specified a straight line, going through 0.25 and 0.75 quantiles could 
also be plotted for reference. It represents a robust linear fit, not 
sensitive to the extremes of the dataset. As in the two datasets case, 
departures from straight line indicate departures from the specified 
distribution. Next picture shows an example of a qq-plot of a dataset 
from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function. 
Fitting parameters are estimates of the distribution mean and sigma.</p>
<h2 id="tmultigraph"><span class="header-section-number">4.9</span> TMultiGraph</h2>
<figure>
<img src="ROOTUsersGuide_files/03000058.png" alt="A multigraph example"><figcaption>A multigraph example</figcaption>
</figure>
<p>A <strong><code>TMultiGraph</code></strong> is a collection of <strong><code>TGraph</code></strong> (or derived) objects. Use <code>TMultiGraph::Add</code>to add a new graph to the list. The <strong><code>TMultiGraph</code></strong> owns the objects in the list. The drawing and fitting options are the same as for <strong><code>TGraph</code></strong>.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb145-1" title="1">{</a>
<a class="sourceLine" id="cb145-2" title="2">   <span class="co">// create the points</span></a>
<a class="sourceLine" id="cb145-3" title="3">   <span class="dt">Int_t</span> n = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb145-4" title="4">   <span class="dt">Double_t</span> x[n]  = {-<span class="fl">.22</span>,<span class="fl">.05</span>,<span class="fl">.25</span>,<span class="fl">.35</span>,<span class="fl">.5</span>,<span class="fl">.61</span>,<span class="fl">.7</span>,<span class="fl">.85</span>,<span class="fl">.89</span>,<span class="fl">.95</span>};</a>
<a class="sourceLine" id="cb145-5" title="5">   <span class="dt">Double_t</span> y[n]  = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb145-6" title="6">   <span class="dt">Double_t</span> x2[n]  = {-<span class="fl">.12</span>,<span class="fl">.15</span>,<span class="fl">.35</span>,<span class="fl">.45</span>,<span class="fl">.6</span>,<span class="fl">.71</span>,<span class="fl">.8</span>,<span class="fl">.95</span>,<span class="fl">.99</span>,<span class="fl">1.05</span>};</a>
<a class="sourceLine" id="cb145-7" title="7">   <span class="dt">Double_t</span> y2[n]  = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb145-8" title="8"></a>
<a class="sourceLine" id="cb145-9" title="9">   <span class="co">// create the width of errors in x and y direction</span></a>
<a class="sourceLine" id="cb145-10" title="10">   <span class="dt">Double_t</span> ex[n] = {<span class="fl">.05</span>,<span class="fl">.1</span>,<span class="fl">.07</span>,<span class="fl">.07</span>,<span class="fl">.04</span>,<span class="fl">.05</span>,<span class="fl">.06</span>,<span class="fl">.07</span>,<span class="fl">.08</span>,<span class="fl">.05</span>};</a>
<a class="sourceLine" id="cb145-11" title="11">   <span class="dt">Double_t</span> ey[n] = {<span class="fl">.8</span>,<span class="fl">.7</span>,<span class="fl">.6</span>,<span class="fl">.5</span>,<span class="fl">.4</span>,<span class="fl">.4</span>,<span class="fl">.5</span>,<span class="fl">.6</span>,<span class="fl">.7</span>,<span class="fl">.8</span>};</a>
<a class="sourceLine" id="cb145-12" title="12"></a>
<a class="sourceLine" id="cb145-13" title="13">   <span class="co">// create two graphs</span></a>
<a class="sourceLine" id="cb145-14" title="14">   TGraph *gr1 = <span class="kw">new</span> TGraph(n,x2,y2);</a>
<a class="sourceLine" id="cb145-15" title="15">   TGraphErrors *gr2 = <span class="kw">new</span> TGraphErrors(n,x,y,ex,ey);</a>
<a class="sourceLine" id="cb145-16" title="16"></a>
<a class="sourceLine" id="cb145-17" title="17">   <span class="co">// create a multigraph and draw it</span></a>
<a class="sourceLine" id="cb145-18" title="18">   TMultiGraph  *mg  = <span class="kw">new</span> TMultiGraph();</a>
<a class="sourceLine" id="cb145-19" title="19">   mg-&gt;Add(gr1);</a>
<a class="sourceLine" id="cb145-20" title="20">   mg-&gt;Add(gr2);</a>
<a class="sourceLine" id="cb145-21" title="21">   mg-&gt;Draw(<span class="st">"ALP"</span>);</a>
<a class="sourceLine" id="cb145-22" title="22">}</a></code></pre></div>
<h2 id="tgraph2d"><span class="header-section-number">4.10</span> TGraph2D</h2>
<figure>
<img src="ROOTUsersGuide_files/03000059.png" alt="Delaunay triangles and Voronoï diagram"><figcaption>Delaunay triangles and Voronoï diagram</figcaption>
</figure>
<p>This class is a set of <code>N</code> points <code>x[i]</code>, <code>y[i]</code>, <code>z[i]</code>
 in a non-uniform grid. Several visualization techniques are 
implemented, including Delaunay triangulation. Delaunay triangulation is
 defined as follow: ‘for a set <code>S</code> of points in the Euclidean plane, the unique triangulation <code>DT(S)</code> of <code>S</code> such that no point in <code>S</code> is inside the circum-circle of any triangle in <code>DT(S)</code>. <code>DT(S)</code> is the dual of the Voronoï diagram of <code>S</code>. If n is the number of points in <code>S</code>, the Voronoï diagram of S is the partitioning of the plane containing <code>S</code>
 points into n convex polygons such that each polygon contains exactly 
one point and every point in a given polygon is closer to its central 
point than to any other. A Voronoï diagram is sometimes also known as a 
Dirichlet tessellation.</p>
<p>The <strong><code>TGraph2D</code></strong> class has the following constructors:</p>
<ul>
<li>With an arrays’ dimension <code>n</code> and three arrays <code>x</code>, <code>y</code>, and <code>z</code> (can be arrays of doubles, floats, or integers):</li>
</ul>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb146-1" title="1">   TGraph2D *g = <span class="kw">new</span> TGraph2D(n,x,y,z);</a></code></pre></div>
<ul>
<li>With an array dimension only:</li>
</ul>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb147-1" title="1">   TGraph2D *g = <span class="kw">new</span> TGraph2D(n);</a></code></pre></div>
<ul>
<li>Internal arrays are filled with the method <code>SetPoint</code> at the position “<code>i</code>” with the values <code>x</code>, <code>y</code>, <code>z</code>:</li>
</ul>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb148-1" title="1">   g-&gt;SetPoint(i,x,y,z);</a></code></pre></div>
<ul>
<li>Without parameters; the method <code>SetPoint</code> must be used to fill the internal arrays.</li>
</ul>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb149-1" title="1">   TGraph2D *g = <span class="kw">new</span> TGraph2D();</a></code></pre></div>
<ul>
<li>From a file:</li>
</ul>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb150-1" title="1">   TGraph2D *g = <span class="kw">new</span> TGraph2D(<span class="st">"graph.dat"</span>);</a></code></pre></div>
<p>The arrays are read from the ASCII file “<code>graph.dat</code>” according to a specified format. The format’s default value is “<code>%lg %lg %lg</code>”. Note that in any of last three cases, the <code>SetPoint</code> method can be used to change a data point or to add a new one. If the data point index (<code>i</code>) is greater than the size of the internal arrays, they are automatically extended.</p>
<p>Specific drawing options can be used to paint a <strong><code>TGraph2D</code></strong>:</p>
<ul>
<li><p>“<code>TRI</code>” the Delaunay triangles are drawn using filled 
area. A hidden surface drawing technique is used. The surface is painted
 with the current fill area color. The edges of the triangles are 
painted with the current line color;</p></li>
<li><p>“<code>TRIW</code>”the Delaunay triangles are drawn as wire frame;</p></li>
<li><p>“<code>TRI1</code>” the Delaunay triangles are painted with color levels. The edges of the triangles are painted with the current line color;</p></li>
<li><p>“<code>TRI2</code>” the Delaunay triangles are painted with color levels;</p></li>
<li><p>“<code>P</code>”draws a marker at each vertex;</p></li>
<li><p>“<code>P0</code>” draws a circle at each vertex. Each circle background is white.</p></li>
</ul>
<p>A <strong><code>TGraph2D</code></strong> can be also drawn with ANY 
options valid for 2D histogram drawing. In this case, an intermediate 2D
 histogram is filled using the Delaunay triangles technique to 
interpolate the data set. <strong><code>TGraph2D</code></strong> linearly interpolate a <code>Z</code> value for any <code>(X,Y)</code> point given some existing <code>(X,Y,Z)</code> points. The existing <code>(X,Y,Z)</code> points can be randomly scattered. The algorithm works by joining the existing points to make Delaunay triangles in <code>(X,Y)</code>. These are then used to define flat planes in <code>(X,Y,Z)</code>
 over which to interpolate. The interpolated surface thus takes the form
 of tessellating triangles at various angles. Output can take the form 
of a 2D histogram or a vector. The triangles found can be drawn in 3D. 
This software cannot be guaranteed to work under all circumstances. It 
was originally written to work with a few hundred points in an<code>XY</code> space with similar <code>X</code> and <code>Y</code> ranges.</p>
<figure>
<img src="ROOTUsersGuide_files/0300005A.png" alt="Graph2D drawn with option “surf1” and “tri1 p0”"><figcaption>Graph2D drawn with option “surf1” and “tri1 p0”</figcaption>
</figure>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb151-1" title="1">{</a>
<a class="sourceLine" id="cb151-2" title="2">   TCanvas *c = <span class="kw">new</span> TCanvas(<span class="st">"c"</span>,<span class="st">"Graph2D example"</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">700</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb151-3" title="3">   <span class="dt">Double_t</span> x, y, z, P = <span class="fl">6.</span>;</a>
<a class="sourceLine" id="cb151-4" title="4">   <span class="dt">Int_t</span> np = <span class="dv">200</span>;</a>
<a class="sourceLine" id="cb151-5" title="5">   TGraph2D *dt = <span class="kw">new</span> TGraph2D();</a>
<a class="sourceLine" id="cb151-6" title="6">   TRandom *r = <span class="kw">new</span> TRandom();</a>
<a class="sourceLine" id="cb151-7" title="7"></a>
<a class="sourceLine" id="cb151-8" title="8">   <span class="cf">for</span> (<span class="dt">Int_t</span> N=<span class="dv">0</span>; N&lt;np; N++) {</a>
<a class="sourceLine" id="cb151-9" title="9">      x = <span class="dv">2</span>*P*(r-&gt;Rndm(N))-P;</a>
<a class="sourceLine" id="cb151-10" title="10">      y = <span class="dv">2</span>*P*(r-&gt;Rndm(N))-P;</a>
<a class="sourceLine" id="cb151-11" title="11">      z = (sin(x)/x)*(sin(y)/y)+<span class="fl">0.2</span>;</a>
<a class="sourceLine" id="cb151-12" title="12">      dt-&gt;SetPoint(N,x,y,z);</a>
<a class="sourceLine" id="cb151-13" title="13">   }</a>
<a class="sourceLine" id="cb151-14" title="14">   gStyle-&gt;SetPalette(<span class="dv">55</span>);</a>
<a class="sourceLine" id="cb151-15" title="15">   dt-&gt;Draw(<span class="st">"surf1"</span>);       <span class="co">// use "surf1" to generate the left picture</span></a>
<a class="sourceLine" id="cb151-16" title="16">}                           <span class="co">// use "tri1 p0" to generate the right one</span></a></code></pre></div>
<p>A more complete example is <code>$ROOTSYS/tutorials/fit/graph2dfit.C</code> that produces the next figure.</p>
<figure>
<img src="ROOTUsersGuide_files/0300005C.png" alt="Output of macro graph2dfit.C"><figcaption>Output of macro graph2dfit.C</figcaption>
</figure>
<h2 id="tgraph2derrors"><span class="header-section-number">4.11</span> TGraph2DErrors</h2>
<p>A <strong><code>TGraph2DErrors</code></strong> is a <strong><code>TGraph2D</code></strong> with errors. It is useful to perform fits with errors on a 2D graph. An example is the macro <code>$ROOTSYS/tutorials/graphs/graph2derrorsfit.C</code>.</p>
<h2 id="fitting-a-graph"><span class="header-section-number">4.12</span> Fitting a Graph</h2>
<p>The graph <code>Fit</code> method in general works the same way as the <code>TH1::Fit</code>. See “Fitting Histograms”.</p>
<h2 id="setting-the-graphs-axis-title"><span class="header-section-number">4.13</span> Setting the Graph’s Axis Title</h2>
<p>To give the axis of a graph a title you need to draw the graph first,
 only then does it actually have an axis object. Once drawn, you set the
 title by getting the axis and calling the <code>TAxis::SetTitle</code> method, and if you want to center it, you can call the <code>TAxis::CenterTitle</code> method.</p>
<p>Assuming that <code>n, x,</code> and <code>y</code> are defined. Next code sets the titles of the <code>x</code> and <code>y</code> axes.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb152-1" title="1">root[] gr5 = <span class="kw">new</span> TGraph(n,x,y)</a>
<a class="sourceLine" id="cb152-2" title="2">root[] gr5-&gt;Draw()</a>
<a class="sourceLine" id="cb152-3" title="3">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a>
<a class="sourceLine" id="cb152-4" title="4">root[] gr5-&gt;Draw(<span class="st">"ALP"</span>)</a>
<a class="sourceLine" id="cb152-5" title="5">root[] gr5-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"X-Axis"</span>)</a>
<a class="sourceLine" id="cb152-6" title="6">root[] gr5-&gt;GetYaxis()-&gt;SetTitle(<span class="st">"Y-Axis"</span>)</a>
<a class="sourceLine" id="cb152-7" title="7">root[] gr5-&gt;GetXaxis()-&gt;CenterTitle()</a>
<a class="sourceLine" id="cb152-8" title="8">root[] gr5-&gt;GetYaxis()-&gt;CenterTitle()</a>
<a class="sourceLine" id="cb152-9" title="9">root[] gr5-&gt;Draw(<span class="st">"ALP"</span>)</a></code></pre></div>
<p>For more graph examples see the scripts: <code>$ROOTSYS/tutorials</code> directory <code>graph.C</code>, <code>gerrors.C</code>, <code>zdemo.C</code>, and <code>gerrors2.C</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/0300005D.png" alt="A graph with axis titles"><figcaption>A graph with axis titles</figcaption>
</figure>
<h2 id="zooming-a-graph"><span class="header-section-number">4.14</span> Zooming a Graph</h2>
<p>To zoom a graph you can create a histogram with the desired axis 
range first. Draw the empty histogram and then draw the graph using the 
existing axis from the histogram.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb153-1" title="1">{</a>
<a class="sourceLine" id="cb153-2" title="2">   c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"A Zoomed Graph"</span>,<span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb153-3" title="3">   hpx = <span class="kw">new</span> TH2F(<span class="st">"hpx"</span>,<span class="st">"Zoomed Graph Example"</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="dv">10</span>,<span class="fl">1.0</span>,<span class="fl">8.0</span>);</a>
<a class="sourceLine" id="cb153-4" title="4">   hpx-&gt;SetStats(kFALSE);   <span class="co">// no statistics</span></a>
<a class="sourceLine" id="cb153-5" title="5">   hpx-&gt;Draw();</a>
<a class="sourceLine" id="cb153-6" title="6">   <span class="dt">Int_t</span> n = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb153-7" title="7">   <span class="dt">Double_t</span> x[n] = {-<span class="fl">.22</span>,<span class="fl">.05</span>,<span class="fl">.25</span>,<span class="fl">.35</span>,<span class="fl">.5</span>,<span class="fl">.61</span>,<span class="fl">.7</span>,<span class="fl">.85</span>,<span class="fl">.89</span>,<span class="fl">.95</span>};</a>
<a class="sourceLine" id="cb153-8" title="8">   <span class="dt">Double_t</span> y[n] = {<span class="dv">1</span>,<span class="fl">2.9</span>,<span class="fl">5.6</span>,<span class="fl">7.4</span>,<span class="dv">9</span>,<span class="fl">9.6</span>,<span class="fl">8.7</span>,<span class="fl">6.3</span>,<span class="fl">4.5</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb153-9" title="9">   gr = <span class="kw">new</span> TGraph(n,x,y);</a>
<a class="sourceLine" id="cb153-10" title="10">   gr-&gt;SetMarkerColor(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb153-11" title="11">   gr-&gt;SetMarkerStyle(<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb153-12" title="12">   gr-&gt;Draw(<span class="st">"LP"</span>);<span class="co">// and draw it without an axis</span></a>
<a class="sourceLine" id="cb153-13" title="13">}</a></code></pre></div>
<p>The next example is the same graph as above with a zoom in the x and y directions.</p>
<figure>
<img src="ROOTUsersGuide_files/0300005E.png" alt="A zoomed graph"><figcaption>A zoomed graph</figcaption>
</figure>
<h2 id="the-user-interface-for-graphs"><span class="header-section-number">4.15</span> The User Interface for Graphs</h2>
<p>The class <strong><code>TGraphEditor</code></strong> provides the user interface for setting the following graph attributes interactively:</p>
<ul>
<li><p>Title text entry field … sets the title of the graph.</p></li>
<li><p>Shape radio button group - sets the graph shapes:</p>
<ul>
<li><em>No Line</em>: draw unconnected points;</li>
<li><em>Smooth Line</em>: a smooth curve;</li>
<li><em>Simple Line</em>: a simple poly-line;</li>
<li><em>Bart Chart</em>: a bar chart at each point.</li>
<li><em>Fill Area</em>: a fill area is drawn.</li>
</ul></li>
<li><p>Show Marker - sets markers as visible or invisible.</p></li>
<li><p>Exclusion Zone - specifies the exclusion zone parameters&nbsp;:</p>
<ul>
<li><em>’+-‘ check button</em>: sets on which side of the line the exclusion zone will be drawn;</li>
<li><em>Width combo box</em>: defines the width of the zone.</li>
</ul></li>
</ul>
<p><img src="ROOTUsersGuide_files/0300005F.png"></p>
<h1 id="fitting-histograms"><span class="header-section-number">5</span> Fitting Histograms</h1>
<p>To fit a histogram you can use the Fit Panel on a visible histogram via the context menu, or you can use the <code>TH1::Fit</code>
 method. The Fit Panel, which is limited, is best for prototyping. The 
histogram needs to be drawn in a pad before the Fit Panel is invoked. 
The method <code>TH1::Fit</code> is more powerful and is used in scripts and programs.</p>
<h2 id="the-fit-method"><span class="header-section-number">5.1</span> The Fit Method</h2>
<p>The Fit method is implemented in ROOT for the histogram classes <strong><code>TH1</code></strong>, the sparse histogram classes, <code>THnSparse</code>, the graph classes, <code>TGraph</code>, <code>TGraph2D</code> and <code>TMultiGraph</code> for fitting a collection of Graphs with the same function.</p>
<h3 id="the-th1fit-method"><span class="header-section-number">5.1.1</span> The TH1::Fit Method</h3>
<p>To fit a histogram programmatically, you can use the <code>TH1::Fit</code> method. Here is the signatures of <code>TH1::Fit</code> and an explanation of the parameters:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb154-1" title="1">   TFitResultPtr Fit(TF1 *function, <span class="dt">Option_t</span> *option, <span class="dt">Option_t</span> *goption,</a>
<a class="sourceLine" id="cb154-2" title="2">            <span class="dt">Axis_t</span> xxmin, <span class="dt">Axis_t</span>  xxmax)</a></code></pre></div>
<ul>
<li><p><code>function</code> a pointer to the fitted function (the fit 
model) object. One can also use the function name. This name may be one 
of ROOT pre-defined function names or a user-defined function. See the 
next paragraph for the list of pre-defined functions.</p></li>
<li><p><code>*option:</code> The second parameter is the fitting option. Here is the list of fitting options:</p>
<ul>
<li><p>“<code>W</code>” Set all weights to 1 for non empty bins; ignore error bars</p></li>
<li><p>“<code>WW</code>” Set all weights to 1 including empty bins; ignore error bars</p></li>
<li><p>“<code>I</code>” Use integral of function in bin instead of value at bin center</p></li>
<li><p>“<code>L</code>” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts</p></li>
<li><p>“<code>WL</code>” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.</p></li>
<li><p>“<code>P</code>” Use Pearson chi-square method, using expected errors instead of the observed one given by <code>TH1::GetBinError</code> (default case). The expected error is instead estimated from the square-root of the bin function value.</p></li>
<li><p>“<code>Q</code>” Quiet mode (minimum printing)</p></li>
<li><p>“<code>V</code>” Verbose mode (default is between Q and V)</p></li>
<li><p>“<code>S</code>” The result of the fit is returned in the <code>TFitResultPtr</code>.</p></li>
<li><p>“<code>E</code>” Perform better errors estimation using the Minos technique</p></li>
<li><p>“<code>M</code>” Improve fit results, by using the <em>IMPROVE</em> algorithm of TMinuit.</p></li>
<li><p>“<code>R</code>” Use the range specified in the function range</p></li>
<li><p>“<code>N</code>” Do not store the graphics function, do not draw</p></li>
<li><p>“<code>0</code>” Do not plot the result of the fit. By default the fitted function is drawn unless the option “<code>N</code>” above is specified.</p></li>
<li><p>“<code>+</code>” Add this new fitted function to the list of 
fitted functions (by default, the previous function is deleted and only 
the last one is kept)</p></li>
<li><p>“<code>B</code>”Use this option when you want to fix one or more parameters and the fitting function is a predefined one, like <code>polN</code>, <code>expo</code>, <code>landau</code>, <code>gaus</code>. Note that in case of pre-defined functions some default initial values and limits are set.</p></li>
<li><p>“<code>C</code>”In case of linear fitting, don’t calculate the chisquare (saves time).</p></li>
<li><p>“<code>F</code>”If fitting a linear function (e.g.&nbsp;<code>polN</code>), switch to use the default minimizer (e.g.&nbsp;<code>Minuit</code>). By default, <code>polN</code> functions are fitted by the linear fitter.</p></li>
</ul></li>
<li><p><code>*goption:</code>The third parameter is the graphics option that is the same as in the <code>TH1::Draw</code> (see the chapter Draw Options).</p></li>
<li><p><code>xxmin</code>, <code>xxmax:</code>Thee fourth and fifth parameters specify the range over which to apply the fit.</p></li>
</ul>
<p>By default, the fitted function object is added to the histogram and is drawn in the current pad.</p>
<h3 id="the-tgraphfit-method"><span class="header-section-number">5.1.2</span> The TGraph::Fit Method</h3>
<p>The signature for fitting a TGraph is exactly the same as for the <strong><code>TH1</code></strong>. Only some options apply only for fitting histograms, these are the options “<code>L</code>”, “<code>WL</code>” and “<code>I</code>”. These options apply instead only for <code>TGraph::Fit</code>, the rest of options (appart from “<code>L</code>”, “<code>WL</code>” and “<code>I</code>” are the same)</p>
<ul>
<li><p><code>TGraph</code> specific <em>options</em></p>
<ul>
<li><p>“<code>EX0</code>” When fitting a <code>TGraphErrors</code> or a <code>TgraphAsymErrors</code> the errors on the coordinates are not used in the fit</p></li>
<li>“<code>ROB</code>” in case of linear fitting use the Robust fitting.
 Compute the LTS regression coefficients (robust (resistant) 
regression), using the default fraction of good points.</li>
<li><p>“<code>ROB=0.x</code>” as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points.</p></li>
</ul></li>
</ul>
<h2 id="the-tf1-function-class"><span class="header-section-number">5.2</span> The <code>TF1</code> function class</h2>
<p>Here we will show how to create the <strong><code>TF1</code></strong> class that is used for fitting histograms and graphs.</p>
<h3 id="fit-with-a-predefined-function"><span class="header-section-number">5.2.1</span> Fit with a Predefined Function</h3>
<p>To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of <code>TH1::Fit</code>. For example, this line fits histogram object <code>hist</code> with a Gaussian.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb155-1" title="1">root[] hist.Fit(<span class="st">"gaus"</span>);</a></code></pre></div>
<p>The initial parameter values (and eventual limits) for pre-defined 
functions are set automatically. For overriding the default limits 
values use the fit option <code>B</code>.</p>
<p>The list of pre-defined functions that can be used with the <code>Fit</code> method is the following:</p>
<ul>
<li><p>“<code>gaus</code>” Gaussian function with 3 parameters: <code>f(x) = p0*exp(-0.5*((x-p1)/p2)^2)</code></p></li>
<li><p>“<code>expo</code>”An Exponential with 2 parameters: <code>f(x) = exp(p0+p1*x)</code></p></li>
<li><p>“<code>pol</code><em><code>N</code></em>” A polynomial of degree <em>N</em>, where N is a number between 0 and 9: <code>f(x) = p0 + p1*x + p2*x2 +...</code></p></li>
<li><p>“<code>chebyshev</code><em><code>N</code></em>” A Chebyshev polynomial of degree <em>N</em>, where N is a number between 0 and 9: <code>f(x) = p0 + p1*x + p2*(2*x2-1) +...</code></p></li>
<li><p>“<code>landau</code>” Landau function with mean and sigma. This function has been adapted from the <code>CERNLIB</code> routine <code>G110 denlan</code> (see <code>TMath::Landau</code>).</p></li>
<li><p>“<code>gausn</code>” Normalized form of the gaussian function with 3 parameters <code>f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI))</code></p></li>
</ul>
<h3 id="creating-user-defined-functions-tf1"><span class="header-section-number">5.2.2</span> Creating User-Defined Functions (TF1)</h3>
<p>You can create a <strong><code>TF1</code></strong> object and use it in the call the <code>TH1::Fit</code>. The parameter in to the <code>Fit</code> method is the NAME of the <strong><code>TF1</code></strong> object. There are three ways to create a <strong><code>TF1</code></strong>.</p>
<ul>
<li><p>Using C++ expression using x with a fixed set of operators and functions defined in <strong><code>TFormula</code></strong>.</p></li>
<li><p>Same as first one, with parameters</p></li>
<li><p>Using a function that you have defined. This can be a free 
function or a functor object or a particular member function of a class.</p></li>
</ul>
<h4 id="creating-a-tf1-with-a-formula"><span class="header-section-number">5.2.2.1</span> Creating a TF1 with a Formula</h4>
<p>Let’s look at the first case. Here we call the <strong><code>TF1</code></strong> constructor by giving it the formula: <code>sin(x)/x</code>.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb156-1" title="1">root[] TF1  *f1 = <span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"sin(x)/x"</span>,<span class="dv">0</span>,<span class="dv">10</span>)</a></code></pre></div>
<p>You can also use a <strong><code>TF1</code></strong> object in the constructor of another <strong><code>TF1</code></strong>.</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb157-1" title="1">root[] TF1  *f2 = <span class="kw">new</span> TF1(<span class="st">"f2"</span>,<span class="st">"f1*2"</span>,<span class="dv">0</span>,<span class="dv">10</span>)</a></code></pre></div>
<h4 id="creating-a-tf1-with-parameters"><span class="header-section-number">5.2.2.2</span> Creating a TF1 with Parameters</h4>
<p>The second way to construct a <strong><code>TF1</code></strong> is to add parameters to the expression. Here we use two parameters:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb158-1" title="1">root[] TF1 *f1 = <span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"[0]*x*sin([1]*x)"</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000060.png" alt="The function x*sin(x)"><figcaption>The function <code>x*sin(x)</code></figcaption>
</figure>
<p>The parameter index is enclosed in square brackets. To set the initial parameters explicitly you can use:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb159-1" title="1">root[] f1-&gt;SetParameter(<span class="dv">0</span>,<span class="dv">10</span>);</a></code></pre></div>
<p>This sets parameter 0 to 10. You can also use <code>SetParameters</code> to set multiple parameters at once.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb160-1" title="1">root[] f1-&gt;SetParameters(<span class="dv">10</span>,<span class="dv">5</span>);</a></code></pre></div>
<p>This sets parameter 0 to 10 and parameter 1 to 5. We can now draw the <strong><code>TF1</code></strong>:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb161-1" title="1">root[] f1-&gt;Draw()</a></code></pre></div>
<h4 id="creating-a-tf1-with-a-user-function"><span class="header-section-number">5.2.2.3</span> Creating a TF1 with a User Function</h4>
<p>The third way to build a <strong><code>TF1</code></strong> is to define a function yourself and then pass the function pointer to the constructor. A function for a <strong><code>TF1</code></strong> constructor needs to have this exact signature:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb162-1" title="1"><span class="dt">Double_t</span> fitf(<span class="dt">Double_t</span> *x,<span class="dt">Double_t</span> *par)</a></code></pre></div>
<p>The two parameters are:</p>
<ul>
<li><p><code>x</code> a pointer to the dimension array. Each element contains a dimension. For a 1D histogram only <code>x[0]</code> is used, for a 2D histogram <code>x[0]</code> and <code>x[1]</code> is used, and for a 3D histogram <code>x[0]</code>, <code>x[1]</code>, and <code>x[2]</code>
 are used. For histograms, only 3 dimensions apply, but this method is 
also used to fit other objects, for example an ntuple could have 10 
dimensions.</p></li>
<li><p><code>par</code> a pointer to the parameters array. This array 
contains the current values of parameters when it is called by the 
fitting function.</p></li>
</ul>
<p>The following script <code>$ROOTSYS/tutorials/fit/myfit.C</code> illustrates how to fit a 1D histogram with a user-defined function. First we declare the function.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb163-1" title="1">   <span class="co">// define a function with 3 parameters</span></a>
<a class="sourceLine" id="cb163-2" title="2">   <span class="dt">Double_t</span> fitf(<span class="dt">Double_t</span> *x,<span class="dt">Double_t</span> *par) {</a>
<a class="sourceLine" id="cb163-3" title="3">      <span class="dt">Double_t</span> arg = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb163-4" title="4">      <span class="cf">if</span> (par[<span class="dv">2</span>]!=<span class="dv">0</span>) arg = (x[<span class="dv">0</span>] - par[<span class="dv">1</span>])/par[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb163-5" title="5">      <span class="dt">Double_t</span> fitval = par[<span class="dv">0</span>]*TMath::Exp(-<span class="fl">0.5</span>*arg*arg);</a>
<a class="sourceLine" id="cb163-6" title="6">      <span class="cf">return</span> fitval;</a>
<a class="sourceLine" id="cb163-7" title="7">   }</a></code></pre></div>
<p>Now we use the function:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb164-1" title="1">   <span class="co">// this function uses fitf to fit a histogram</span></a>
<a class="sourceLine" id="cb164-2" title="2">   <span class="dt">void</span> fitexample() {</a>
<a class="sourceLine" id="cb164-3" title="3"></a>
<a class="sourceLine" id="cb164-4" title="4">      <span class="co">// open a file and get a histogram</span></a>
<a class="sourceLine" id="cb164-5" title="5">      TFile *f = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb164-6" title="6">      TH1F *hpx = (TH1F*)f-&gt;Get(<span class="st">"hpx"</span>);</a>
<a class="sourceLine" id="cb164-7" title="7"></a>
<a class="sourceLine" id="cb164-8" title="8">      <span class="co">// Create a TF1 object using the function defined above.</span></a>
<a class="sourceLine" id="cb164-9" title="9">      <span class="co">// The last three parameters specify the number of parameters</span></a>
<a class="sourceLine" id="cb164-10" title="10">      <span class="co">// for the function.</span></a>
<a class="sourceLine" id="cb164-11" title="11">      TF1 *func = <span class="kw">new</span> TF1(<span class="st">"fit"</span>,fitf,-<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb164-12" title="12">      <span class="co">// set the parameters to the mean and RMS of the histogram</span></a>
<a class="sourceLine" id="cb164-13" title="13">      func-&gt;SetParameters(<span class="dv">500</span>,hpx-&gt;GetMean(),hpx-&gt;GetRMS());</a>
<a class="sourceLine" id="cb164-14" title="14"></a>
<a class="sourceLine" id="cb164-15" title="15">      <span class="co">// give the parameters meaningful names</span></a>
<a class="sourceLine" id="cb164-16" title="16">      func-&gt;SetParNames (<span class="st">"Constant"</span>,<span class="st">"Mean_value"</span>,<span class="st">"Sigma"</span>);</a>
<a class="sourceLine" id="cb164-17" title="17"></a>
<a class="sourceLine" id="cb164-18" title="18">      <span class="co">// call TH1::Fit with the name of the TF1 object</span></a>
<a class="sourceLine" id="cb164-19" title="19">      hpx-&gt;Fit(<span class="st">"fit"</span>);</a>
<a class="sourceLine" id="cb164-20" title="20">   }</a></code></pre></div>
<p>You can create a <strong><code>TF1</code></strong> also from a C++ function object (functor) with parameters A <strong><code>TF1</code></strong> can be created from any C++ class implementing this member function:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb165-1" title="1"><span class="dt">double</span> <span class="kw">operator</span>()(<span class="dt">double</span> *x, <span class="dt">double</span> *p)</a></code></pre></div>
<p>The advantage of the function object is that it can have a state and 
reference therefore what-ever other object the user needs, without using
 globals. This is an example to define first the function object</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb166-1" title="1"><span class="kw">class</span>  MyFunctionObject {</a>
<a class="sourceLine" id="cb166-2" title="2"> <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb166-3" title="3">  <span class="co">// use constructor to customize your function object</span></a>
<a class="sourceLine" id="cb166-4" title="4">  MyFunctionObject(......) { ......}</a>
<a class="sourceLine" id="cb166-5" title="5"></a>
<a class="sourceLine" id="cb166-6" title="6">   <span class="dt">double</span> <span class="kw">operator</span>() (<span class="dt">double</span> *x, <span class="dt">double</span> *p) {</a>
<a class="sourceLine" id="cb166-7" title="7">      <span class="co">// function implementation using class data members</span></a>
<a class="sourceLine" id="cb166-8" title="8">   }</a>
<a class="sourceLine" id="cb166-9" title="9">};</a></code></pre></div>
<p>and then use it to create the <strong><code>TF1</code></strong>:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb167-1" title="1">   MyFunctionObject fobj(....);       <span class="co">// create the function object</span></a>
<a class="sourceLine" id="cb167-2" title="2">   TF1 * f = <span class="kw">new</span> TF1(<span class="st">"f"</span>,fobj,xmin,xmax,npar);    <span class="co">// create TF1 class with n-parameters and range [xmin,xmax]</span></a></code></pre></div>
<p>If using C++11, one can create a <strong><code>TF1</code></strong> also from a C++ <code>lambda</code> function:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb168-1" title="1"><span class="co">// create TF1 class with 2 parameters and range [xmin,xmax] using a lambda</span></a>
<a class="sourceLine" id="cb168-2" title="2">TF1 * f = <span class="kw">new</span> TF1(<span class="st">"f"</span>,[](<span class="dt">double</span>*x,<span class="dt">double</span>*p){<span class="cf">return</span> p[<span class="dv">0</span>] + p[<span class="dv">1</span>]*x[<span class="dv">0</span>];},xmin,xmax,<span class="dv">2</span>);</a></code></pre></div>
<h2 id="configuring-the-fit"><span class="header-section-number">5.3</span> Configuring the Fit</h2>
<p>We will show here some configuration actions that can or must be done when fitting histogram or graph using the <code>Fit</code> method.</p>
<h3 id="fixing-and-setting-parameters-bounds"><span class="header-section-number">5.3.1</span> Fixing and Setting Parameters’ Bounds</h3>
<p>Parameters must be initialized before invoking the <code>Fit</code> method. The setting of the parameter initial values is automatic for the predefined functions: <code>poln</code>, <code>exp</code>, <code>gaus</code>, and <code>landau</code>. You can fix one or more parameters by specifying the “B” option when calling the <code>Fit</code>
 method. When a function is not predefined, the fit parameters must be 
initialized to some value as close as possible to the expected values 
before calling the fit function.</p>
<p>To set bounds for one parameter, use <code>TF1::SetParLimits</code>:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb169-1" title="1">   func-&gt;SetParLimits(<span class="dv">0</span>,-<span class="dv">1</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>When the lower and upper limits are equal, the parameter is fixed. Next two statements fix parameter 4 at 10.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb170-1" title="1">   func-&gt;SetParameter(<span class="dv">4</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb170-2" title="2">   func-&gt;SetParLimits(<span class="dv">4</span>,<span class="dv">10</span>,<span class="dv">10</span>);</a></code></pre></div>
<p>However, to fix a parameter to 0, one must call the <code>FixParameter</code> function:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb171-1" title="1">   func-&gt;SetParameter(<span class="dv">4</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb171-2" title="2">   func-&gt;FixParameter(<span class="dv">4</span>,<span class="dv">0</span>);</a></code></pre></div>
<p>Note that you are not forced to set the limits for all parameters. 
For example, if you fit a function with 6 parameters, you can:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb172-1" title="1">   func-&gt;SetParameters(<span class="dv">0</span>,<span class="fl">3.1</span>,<span class="fl">1.e-6</span>,-<span class="fl">1.5</span>,<span class="dv">0</span>,<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb172-2" title="2">   func-&gt;SetParLimits(<span class="dv">3</span>,-<span class="dv">10</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb172-3" title="3">   func-&gt;FixParameter(<span class="dv">4</span>,<span class="dv">0</span>);</a></code></pre></div>
<p>With this setup, parameters 0<code>-&gt;</code>2 can vary freely, parameter 3 has boundaries [-10, 4] with initial value -1.5, and parameter 4 is fixed to 0.</p>
<h3 id="fitting-sub-ranges"><span class="header-section-number">5.3.2</span> Fitting Sub Ranges</h3>
<p>By default, <code>TH1::Fit</code> will fit the function on the defined histogram range. You can specify the option “<code>R</code>” in the second parameter of <code>TH1::Fit</code> to restrict the fit to the range specified in the <strong><code>TF1</code></strong> constructor. In this example, the fit will be limited to -3 to 3, the range specified in the <strong><code>TF1</code></strong> constructor.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb173-1" title="1">root[] TF1 *f1 = <span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"[0]*x*sin([1]*x)"</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb173-2" title="2">root[] hist-&gt;Fit(<span class="st">"f1"</span>,<span class="st">"R"</span>);</a></code></pre></div>
<p>You can also specify a range in the call to <code>TH1::Fit</code>:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb174-1" title="1">root[] hist-&gt;Fit(<span class="st">"f1"</span>,<span class="st">""</span>,<span class="st">""</span>,-<span class="dv">2</span>,<span class="dv">2</span>)</a></code></pre></div>
<p>See macros <code>$ROOTSYS/tutorials/fit/myfit.C</code> and <code>multifit.C</code> as more completed examples.</p>
<h3 id="fitting-multiple-sub-ranges"><span class="header-section-number">5.3.3</span> Fitting Multiple Sub Ranges</h3>
<p>The script for this example is <code>$ROOTSYS/tutorials/fit/multifit.C</code>.
 It shows how to use several Gaussian functions with different 
parameters on separate sub ranges of the same histogram. To use a 
Gaussian, or any other ROOT built in function, on a sub range you need 
to define a new <strong><code>TF1</code></strong>. Each is ‘derived’ from the canned function <code>gaus</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/03000062.png" alt="Fitting a histogram with several Gaussian functions"><figcaption>Fitting a histogram with several Gaussian functions</figcaption>
</figure>
<p>First, four <strong><code>TF1</code></strong> objects are created - one for each sub-range:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb175-1" title="1">   g1 = <span class="kw">new</span> TF1(<span class="st">"m1"</span>,<span class="st">"gaus"</span>,<span class="dv">85</span>,<span class="dv">95</span>);</a>
<a class="sourceLine" id="cb175-2" title="2">   g2 = <span class="kw">new</span> TF1(<span class="st">"m2"</span>,<span class="st">"gaus"</span>,<span class="dv">98</span>,<span class="dv">108</span>);</a>
<a class="sourceLine" id="cb175-3" title="3">   g3 = <span class="kw">new</span> TF1(<span class="st">"m3"</span>,<span class="st">"gaus"</span>,<span class="dv">110</span>,<span class="dv">121</span>);</a>
<a class="sourceLine" id="cb175-4" title="4">   <span class="co">// The total is the sum of the three, each has 3 parameters</span></a>
<a class="sourceLine" id="cb175-5" title="5">   total = <span class="kw">new</span> TF1(<span class="st">"mstotal"</span>,<span class="st">"gaus(0)+gaus(3)+gaus(6)"</span>,<span class="dv">85</span>,<span class="dv">125</span>);</a></code></pre></div>
<p>Next, we fill a histogram with bins defined in the array x.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb176-1" title="1">   <span class="co">// Create a histogram and set it's contents</span></a>
<a class="sourceLine" id="cb176-2" title="2">   h = <span class="kw">new</span> TH1F(<span class="st">"g1"</span>,<span class="st">"Example of several fits in subranges"</span>,</a>
<a class="sourceLine" id="cb176-3" title="3">                 np,<span class="dv">85</span>,<span class="dv">134</span>);</a>
<a class="sourceLine" id="cb176-4" title="4">   h-&gt;SetMaximum(<span class="dv">7</span>);</a>
<a class="sourceLine" id="cb176-5" title="5">   <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;np; i++) {</a>
<a class="sourceLine" id="cb176-6" title="6">      h-&gt;SetBinContent(i+<span class="dv">1</span>,x[i]);</a>
<a class="sourceLine" id="cb176-7" title="7">   }</a>
<a class="sourceLine" id="cb176-8" title="8">   <span class="co">// Define the parameter array for the total function</span></a>
<a class="sourceLine" id="cb176-9" title="9">   <span class="dt">Double_t</span> par[<span class="dv">9</span>];</a></code></pre></div>
<p>When fitting simple functions, such as a Gaussian, the initial values
 of the parameters are automatically computed by ROOT. In the more 
complicated case of the sum of 3 Gaussian functions, the initial values 
of parameters must be set. In this particular case, the initial values 
are taken from the result of the individual fits. The use of the “+” 
sign is explained below:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb177-1" title="1">   <span class="co">// Fit each function and add it to the list of functions</span></a>
<a class="sourceLine" id="cb177-2" title="2">   h-&gt;Fit(g1,<span class="st">"R"</span>);</a>
<a class="sourceLine" id="cb177-3" title="3">   h-&gt;Fit(g2,<span class="st">"R+"</span>);</a>
<a class="sourceLine" id="cb177-4" title="4">   h-&gt;Fit(g3,<span class="st">"R+"</span>);</a>
<a class="sourceLine" id="cb177-5" title="5"></a>
<a class="sourceLine" id="cb177-6" title="6">   <span class="co">// Get the parameters from the fit</span></a>
<a class="sourceLine" id="cb177-7" title="7">   g1-&gt;GetParameters(&amp;par[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb177-8" title="8">   g2-&gt;GetParameters(&amp;par[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb177-9" title="9">   g3-&gt;GetParameters(&amp;par[<span class="dv">6</span>]);</a>
<a class="sourceLine" id="cb177-10" title="10"></a>
<a class="sourceLine" id="cb177-11" title="11">   <span class="co">// Use the parameters on the sum</span></a>
<a class="sourceLine" id="cb177-12" title="12">   total-&gt;SetParameters(par);</a>
<a class="sourceLine" id="cb177-13" title="13">   h-&gt;Fit(total,<span class="st">"R+"</span>);</a></code></pre></div>
<h3 id="adding-functions-to-the-list"><span class="header-section-number">5.3.4</span> Adding Functions to the List</h3>
<p>The example <code>$ROOTSYS/tutorials/fit/multifit.C</code> also 
illustrates how to fit several functions on the same histogram. By 
default a Fit command deletes the previously fitted function in the 
histogram object. You can specify the option “+” in the second parameter
 to add the newly fitted function to the existing list of functions for 
the histogram.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb178-1" title="1">root[] hist-&gt;Fit(<span class="st">"f1"</span>,<span class="st">"+"</span>,<span class="st">""</span>,-<span class="dv">2</span>,<span class="dv">2</span>)</a></code></pre></div>
<p>Note that the fitted function(s) are saved with the histogram when it is written to a ROOT file.</p>
<h2 id="example-of-fit-combining-functions"><span class="header-section-number">5.4</span> Example of fit: Combining Functions</h2>
<p>You can combine functions to fit a histogram with their sum as it is illustrated in the macro <code>FitDemo.C</code> (<code>$ROOTSYS/tutorials/fit/FittingDemo.C)</code>. We have a function that is the combination of a background and Lorentzian peak. Each function contributes 3 parameters:</p>
<p><span class="math display">\[
y(E) = a_{1} + a_{2}E + a_{3}E^{2} + \frac{A_{p}(\frac{G}{2p})}
{(E-m)^{2} + (\frac{G}{2})^2 }
\]</span></p>
<p>BackgroundLorentzian Peak</p>
<p><code>par[0]</code> = <span class="math inline">\(a_{1}\)</span> <code>par[0]</code> = <span class="math inline">\(A_{p}\)</span></p>
<p><code>par[1]</code> = <span class="math inline">\(a_{2}\)</span> <code>par[1]</code> = <span class="math inline">\(G\)</span></p>
<p><code>par[2]</code> = <span class="math inline">\(a_{3}\)</span> <code>par[2]</code> = <span class="math inline">\(m\)</span></p>
<p>The combination function (<code>fitFunction</code>) has six parameters:</p>
<p><code>fitFunction = background(x,par) + LorentzianPeak(x,&amp;par[3])</code></p>
<p><code>par[0]=</code><span class="math inline">\(a_{1}\)</span> <code>par[1]=</code><span class="math inline">\(a_{2}\)</span> <code>par[2]=</code><span class="math inline">\(a_{3}\)</span> <code>par[3]=</code><span class="math inline">\(A_{p}\)</span> <code>par[4]=</code><span class="math inline">\(G\)</span> <code>par[5]=</code><span class="math inline">\(m\)</span></p>
<p>This script creates a histogram and fits it with the combination of 
two functions. First we define the two functions and the combination 
function:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb179-1" title="1">   <span class="co">// Quadratic background function</span></a>
<a class="sourceLine" id="cb179-2" title="2">   <span class="dt">Double_t</span> background(<span class="dt">Double_t</span> *x, <span class="dt">Double_t</span> *par) {</a>
<a class="sourceLine" id="cb179-3" title="3">      <span class="cf">return</span> par[<span class="dv">0</span>] + par[<span class="dv">1</span>]*x[<span class="dv">0</span>] + par[<span class="dv">2</span>]*x[<span class="dv">0</span>]*x[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb179-4" title="4">   }</a>
<a class="sourceLine" id="cb179-5" title="5"></a>
<a class="sourceLine" id="cb179-6" title="6">   <span class="co">// Lorentzian Peak function</span></a>
<a class="sourceLine" id="cb179-7" title="7">   <span class="dt">Double_t</span> lorentzianPeak(<span class="dt">Double_t</span> *x, <span class="dt">Double_t</span> *par) {</a>
<a class="sourceLine" id="cb179-8" title="8">      <span class="cf">return</span> (<span class="fl">0.5</span>*par[<span class="dv">0</span>]*par[<span class="dv">1</span>]/TMath::Pi()) / TMath::Max(<span class="fl">1.e-10</span>,</a>
<a class="sourceLine" id="cb179-9" title="9">      (x[<span class="dv">0</span>]-par[<span class="dv">2</span>])*(x[<span class="dv">0</span>]-par[<span class="dv">2</span>])+ <span class="fl">.25</span>*par[<span class="dv">1</span>]*par[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb179-10" title="10">   }</a>
<a class="sourceLine" id="cb179-11" title="11"></a>
<a class="sourceLine" id="cb179-12" title="12">   <span class="co">// Sum of background and peak function</span></a>
<a class="sourceLine" id="cb179-13" title="13">   <span class="dt">Double_t</span> fitFunction(<span class="dt">Double_t</span> *x, <span class="dt">Double_t</span> *par) {</a>
<a class="sourceLine" id="cb179-14" title="14">      <span class="cf">return</span> background(x,par) + lorentzianPeak(x,&amp;par[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb179-15" title="15">   }</a>
<a class="sourceLine" id="cb179-16" title="16"></a>
<a class="sourceLine" id="cb179-17" title="17">   <span class="dt">void</span> FittingDemo() {</a>
<a class="sourceLine" id="cb179-18" title="18">   <span class="co">// bevington exercise by P. Malzacher, modified by R. Brun</span></a>
<a class="sourceLine" id="cb179-19" title="19">   <span class="at">const</span> <span class="dt">int</span> nBins = <span class="dv">60</span>;</a>
<a class="sourceLine" id="cb179-20" title="20">   <span class="dt">Stat_t</span> data[nBins] = {  <span class="dv">6</span>, <span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">12</span>, <span class="dv">6</span>,<span class="dv">13</span>,<span class="dv">23</span>,<span class="dv">22</span>,<span class="dv">15</span>,<span class="dv">21</span>,</a>
<a class="sourceLine" id="cb179-21" title="21">   <span class="dv">23</span>,<span class="dv">26</span>,<span class="dv">36</span>,<span class="dv">25</span>,<span class="dv">27</span>,<span class="dv">35</span>,<span class="dv">40</span>,<span class="dv">44</span>,<span class="dv">66</span>,<span class="dv">81</span>,</a>
<a class="sourceLine" id="cb179-22" title="22">   <span class="dv">75</span>,<span class="dv">57</span>,<span class="dv">48</span>,<span class="dv">45</span>,<span class="dv">46</span>,<span class="dv">41</span>,<span class="dv">35</span>,<span class="dv">36</span>,<span class="dv">53</span>,<span class="dv">32</span>,</a>
<a class="sourceLine" id="cb179-23" title="23">   <span class="dv">40</span>,<span class="dv">37</span>,<span class="dv">38</span>,<span class="dv">31</span>,<span class="dv">36</span>,<span class="dv">44</span>,<span class="dv">42</span>,<span class="dv">37</span>,<span class="dv">32</span>,<span class="dv">32</span>,</a>
<a class="sourceLine" id="cb179-24" title="24">   <span class="dv">43</span>,<span class="dv">44</span>,<span class="dv">35</span>,<span class="dv">33</span>,<span class="dv">33</span>,<span class="dv">39</span>,<span class="dv">29</span>,<span class="dv">41</span>,<span class="dv">32</span>,<span class="dv">44</span>,</a>
<a class="sourceLine" id="cb179-25" title="25">   <span class="dv">26</span>,<span class="dv">39</span>,<span class="dv">29</span>,<span class="dv">35</span>,<span class="dv">32</span>,<span class="dv">21</span>,<span class="dv">21</span>,<span class="dv">15</span>,<span class="dv">25</span>,<span class="dv">15</span>};</a>
<a class="sourceLine" id="cb179-26" title="26">   TH1F *histo = <span class="kw">new</span> TH1F(<span class="st">"example_9_1"</span>,</a>
<a class="sourceLine" id="cb179-27" title="27">   <span class="st">"Lorentzian Peak on Quadratic Background"</span>,<span class="dv">60</span>,<span class="dv">0</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb179-28" title="28"></a>
<a class="sourceLine" id="cb179-29" title="29">   <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; nBins;  i++) {</a>
<a class="sourceLine" id="cb179-30" title="30">      <span class="co">// we use these methods to explicitly set the content</span></a>
<a class="sourceLine" id="cb179-31" title="31">      <span class="co">// and error instead of using the fill method.</span></a>
<a class="sourceLine" id="cb179-32" title="32">      histo-&gt;SetBinContent(i+<span class="dv">1</span>,data[i]);</a>
<a class="sourceLine" id="cb179-33" title="33">      histo-&gt;SetBinError(i+<span class="dv">1</span>,TMath::Sqrt(data[i]));</a>
<a class="sourceLine" id="cb179-34" title="34">   }</a>
<a class="sourceLine" id="cb179-35" title="35">   <span class="co">// create a TF1 with the range from 0 to 3 and 6 parameters</span></a>
<a class="sourceLine" id="cb179-36" title="36">   TF1 *fitFcn = <span class="kw">new</span> TF1(<span class="st">"fitFcn"</span>,fitFunction,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">6</span>);</a>
<a class="sourceLine" id="cb179-37" title="37"></a>
<a class="sourceLine" id="cb179-38" title="38">   <span class="co">// first try without starting values for the parameters</span></a>
<a class="sourceLine" id="cb179-39" title="39">   <span class="co">// this defaults to 1 for each param.</span></a>
<a class="sourceLine" id="cb179-40" title="40">   histo-&gt;Fit(<span class="st">"fitFcn"</span>);</a>
<a class="sourceLine" id="cb179-41" title="41">   <span class="co">// this results in an ok fit for the polynomial function however</span></a>
<a class="sourceLine" id="cb179-42" title="42">   <span class="co">// the non-linear part (Lorentzian</span></a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000070.png" alt="The output of the FittingDemo() example"><figcaption>The output of the FittingDemo() example</figcaption>
</figure>
<h2 id="result-of-the-fit"><span class="header-section-number">5.5</span> Result of the fit</h2>
<p>Here we will show how to obtain the result of the fit (fitted 
function, parameter values, errors and eventually the covariance and 
correlation matrix).</p>
<h3 id="associated-function"><span class="header-section-number">5.5.1</span> Associated Function</h3>
<p>One or more objects (typically a <strong><code>TF1\*</code></strong>) can be added to the list of functions (<code>fFunctions</code>) associated to each histogram. A call to <code>TH1::Fit</code> adds the fitted function to this list. Given a histogram <code>h</code>, one can retrieve the associated function with:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb180-1" title="1">   TF1 *myfunc = h-&gt;GetFunction(<span class="st">"myfunc"</span>);</a></code></pre></div>
<h3 id="access-to-the-fit-parameters-and-results"><span class="header-section-number">5.5.2</span> Access to the Fit Parameters and Results</h3>
<p>If the histogram (or graph) is made persistent, the list of 
associated functions is also persistent. Retrieve a pointer to the 
function with the <code>TH1::GetFunction()</code> method. Then you can retrieve the fit parameters from the function (<strong><code>TF1</code></strong>) with calls such as:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb181-1" title="1">root[] TF1 *fit = hist-&gt;GetFunction(function_name);</a>
<a class="sourceLine" id="cb181-2" title="2">root[] <span class="dt">Double_t</span> chi2 = fit-&gt;GetChisquare();</a>
<a class="sourceLine" id="cb181-3" title="3"><span class="co">// value of the first parameter</span></a>
<a class="sourceLine" id="cb181-4" title="4">root[] <span class="dt">Double_t</span> p1 = fit-&gt;GetParameter(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb181-5" title="5"><span class="co">// error of the first parameter</span></a>
<a class="sourceLine" id="cb181-6" title="6">root[] <span class="dt">Double_t</span> e1 = fit-&gt;GetParError(<span class="dv">0</span>);</a></code></pre></div>
<p>Using the fit option <code>S</code> one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph <code>TFitResult</code>.</p>
<h3 id="associated-errors"><span class="header-section-number">5.5.3</span> Associated Errors</h3>
<p>By default, for each bin, the sum of weights is computed at fill time. One can also call <code>TH1::Sumw2</code>
 to force the storage and computation of the sum of the square of 
weights per bin. If Sumw2 has been called, the error per bin is computed
 as the <code>sqrt(sum of squares of weights)</code>; otherwise, the error is set equal to the <code>sqrt(bin content)</code>. To return the error for a given bin number, do:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb182-1" title="1">   <span class="dt">Double_t</span> error = h-&gt;GetBinError(bin);</a></code></pre></div>
<p>Empty bins are excluded in the fit when using the Chi-square fit 
method. When fitting an histogram representing counts (i.e with Poisson 
statistics) it is recommended to use the Log-Likelihood method (option ‘<code>L</code>’ or “<code>WL</code>”),
 particularly in case of low statistics. When the histogram has been 
filled with weights different than one, a weighted likelihood method can
 be used and the errors retrieved from the fit are corrected following a
 procedure described in paragraph 8.5.2 of the book, <em>F. James, Statistical Methods in Experimental Physics, 2nd Edition</em>.</p>
<h3 id="fit-statistics"><span class="header-section-number">5.5.4</span> Fit Statistics</h3>
<p>You can change the statistics box to display the fit parameters with the <code>TStyle::SetOptFit(mode)</code> method. This parameter has four digits: <code>mode = pcev</code> (<code>default = 0111</code>)</p>
<ul>
<li><code>p</code> = 1 print probability</li>
<li><code>c</code> = 1 print Chi-square/number of degrees of freedom</li>
<li><code>e</code> = 1 print errors (if <code>e=1</code>, <code>v</code> must be 1)</li>
<li><code>v</code> = 1 print name/values of parameters</li>
</ul>
<p>For example, to print the fit probability, parameter names/values, and errors, use:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb183-1" title="1">   gStyle-&gt;SetOptFit(<span class="dv">1011</span>);</a></code></pre></div>
<h2 id="the-fit-panel"><span class="header-section-number">5.6</span> The Fit Panel</h2>
<figure>
<img src="ROOTUsersGuide_files/03000061.png" alt="The Fit Panel"><figcaption>The Fit Panel</figcaption>
</figure>
<p>To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.</p>
<p>The new Fit Panel GUI is available in ROOT v5.14. Its goal is to 
replace the old Fit Panel and to provide more user friendly way for 
performing, exploring and comparing fits.</p>
<p>By design, this user interface is planned to contain two tabs: 
“General” and “Minimization”. Currently, the “General” tab provides user
 interface elements for setting the fit function, fit method and 
different fit, draw, print options. The “Minimization tab” provides the 
option to set the Minimizer to use in the fit and its specific options.</p>
<p>The new fit panel is a modeless dialog, i.e.&nbsp;when opened, it 
does not prevent users from interacting with other windows. Its first 
prototype is a singleton application. When the Fit Panel is activated, 
users can select an object for fitting in the usual way, i.e.&nbsp;by 
left-mouse click on it. If the selected object is suitable for fitting, 
the fit panel is connected with this object and users can perform fits 
by setting different parameters and options.</p>
<h3 id="function-choice-and-settings"><span class="header-section-number">5.6.1</span> Function Choice and Settings</h3>
<p><em>‘Predefined’ combo box</em> - contains a list of predefined 
functions in ROOT. You have a choice of several polynomials, a Gaussian,
 a Landau, and an Exponential function. The default one is Gaussian.</p>
<p><em>‘Operation’ radio button group</em> defines the selected operational mode between functions:</p>
<p><em>Nop</em> - no operation (default);</p>
<p><em>Add</em> - addition;</p>
<p><em>Conv</em> - convolution (will be implemented in the future).</p>
<p>Users can enter the function expression into the text entry field 
below the ‘Predefined’ combo box. The entered string is checked after 
the Enter key was pressed and an error message shows up, if the function
 string is not accepted.</p>
<p>‘<em>Set Parameters</em>’ button opens a dialog for parameters settings, which will be explained later.</p>
<h3 id="fitter-settings"><span class="header-section-number">5.6.2</span> Fitter Settings</h3>
<p><em>‘Method’ combo box</em> currently provides only two fit model 
choices: Chi-square and Binned Likelihood. The default one is 
Chi-square. The Binned Likelihood is recommended for bins with low 
statistics.</p>
<p><em>‘Linear Fit’ check button</em> sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e.&nbsp;fit option “<code>F</code>” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - <code>polN)</code>.</p>
<p><em>‘Robust’ number entry</em> sets the robust value when fitting graphs.</p>
<p><em>‘No Chi-square’ check button</em> switch On/Off the fit option “<code>C</code>” - do not calculate Chi-square (for Linear fitter).</p>
<p><em>‘Integral’ check button</em> switch On/Off the option “<code>I</code>” - use integral of function instead of value in bin center.</p>
<p><em>‘Best Errors’</em> sets On/Off the option “<code>E</code>” - better errors estimation by using Minos technique.</p>
<p><em>‘All weights = 1’</em> sets On/Off the option “<code>W</code>”- all weights set to 1 excluding empty bins; error bars ignored.</p>
<p><em>‘Empty bins, weights=1’</em> sets On/Off the option “<code>WW</code>” - all weights equal to 1 including empty bins; error bars ignored.</p>
<p><em>‘Use range’</em> sets On/Off the option “<code>R</code>” - fit 
only data within the specified function range. Sliders settings are used
 if this option is set to On. Users can change the function range values
 by pressing the left mouse button near to the left/right slider edges. 
It is possible to change both values simultaneously by pressing the left
 mouse button near to the slider center and moving it to a new position.</p>
<p><em>‘Improve fit results’</em> sets On/Off the option “<code>M</code>”- after minimum is found, search for a new one.</p>
<p><em>‘Add to list’</em> sets On/Off the option “<code>+</code>”- add 
function to the list without deleting the previous one. When fitting a 
histogram, the function is attached to the histogram’s list of 
functions. By default, the previously fitted function is deleted and 
replaced with the most recent one, so the list only contains one 
function. Setting this option to On will add the newly fitted function 
to the existing list of functions for the histogram. Note that the 
fitted functions are saved with the histogram when it is written to a 
ROOT file. By default, the function is drawn on the pad displaying the 
histogram.</p>
<h3 id="draw-options-1"><span class="header-section-number">5.6.3</span> Draw Options</h3>
<p><em>‘SAME’</em> sets On/Off function drawing on the same pad. When a fit is executed, the image of the function is drawn on the current pad.</p>
<p><em>‘No drawing’</em> sets On/Off the option “<code>0</code>”- do not draw the fit results.</p>
<p><em>‘Do not store/draw’</em> sets On/Off option “<code>N</code>”- do not store the function and do not draw it.</p>
<h3 id="advances-options"><span class="header-section-number">5.6.4</span> Advances Options</h3>
<p>The advance option button is enabled only after having performed the 
fit and provides additional drawing options that can be used after 
having done the fit. These new drawing tools, which can be selected by 
the “Advanced Drawing Tool” panel that pops up when clicking the 
“Advanced” button, are:</p>
<ul>
<li><p><em>Contour</em>: to plot the confidence contour of two chosen 
parameters. One can select the number of points to draw the contour 
(more points might require more time to compute it), the parameters and 
the desired confidence level .</p></li>
<li><p><em>Scan</em> : to plot a scan of the minimization function 
(likelihood or chi-squared) around the minimum as function of the chosen
 parameter.</p></li>
<li><p><em>Conf Interval</em> : to plot the confidence interval of the 
fitted function as a filled coloured band around its central value. One 
can select the desired confidence level for the band to be plotted.</p></li>
</ul>
<h3 id="print-options"><span class="header-section-number">5.6.5</span> Print Options</h3>
<p>This set of options specifies the amount of feedback printed on the root command line after performed fits.</p>
<p><em>‘Verbose’</em> - prints fit results after each iteration.</p>
<p><em>‘Quiet’</em> - no fit information is printed.</p>
<p><em>‘Default’</em> - between Verbose and Quiet.</p>
<h3 id="command-buttons"><span class="header-section-number">5.6.6</span> Command Buttons</h3>
<p><em>Fit button</em> - performs a fit taking different option settings via the Fit Panel interface.</p>
<p><em>Reset</em> - sets the GUI elements and related fit settings to the default ones.</p>
<p><em>Close</em> - closes the Fit panel window.</p>
<h3 id="minimization-options"><span class="header-section-number">5.6.7</span> Minimization Options</h3>
<p>With this tab one can select specific options for minimization. These include</p>
<ul>
<li>The minimizer library ( <em>Minuit</em>, <em>Minuit2</em>, <em>Fumili</em>, <em>GSL</em>, <em>Genetics</em> )</li>
<li>The method (algorithm) for minimization. For example for Minuit one can choose between (<em>Migrad</em>, <em>Simplex</em> or <em>Scan</em>)</li>
<li>Error definition</li>
<li>Minimization tolerance</li>
<li>Number of iterations/function calls</li>
<li>Print Level: (<em>Default</em>, <em>Verbose</em> or <em>Quiet</em>).</li>
</ul>
<h2 id="new-rootfit-classes"><span class="header-section-number">5.7</span> New ROOT::Fit classes</h2>
<p>The fitting of the data objects in ROOT, histograms, graphs and tree 
is performed via some common classes, which are defined in the <code>ROOT::Fit</code> namespace. These classes can be classified in the following groups:</p>
<ul>
<li>User classes driving the fit: <code>ROOT::Fit::Fitter</code> for executing the fit, <code>ROOT::Fit::FitConfig</code> for configuring the fit, <code>ROOT::Fit::ParameterSettings</code> to define the properties of the fit parameters (initial values, bounds, etc..), <code>ROOT::Fit::FitResult</code> for storing the result of the fit.</li>
<li>Data classes containing the data sets used in the fitting. These classes are the<code>ROOT::Fit::BinData</code>for
 describing bin data sets, thus data points containing both coordinates 
and a corresponding value/weight with optionally an error on the value 
or the coordinate and the <code>ROOT::Fit::UnBinData</code> for 
un-binned data sets, which consists only of a vector of coordinate 
values. The coordinate values can be one-dimensional (i.e.&nbsp;one 
entry per event) or multi-dimensional (N entries per event).</li>
<li>Function classes defining the type of fit (the objective function used for fitting):
<ul>
<li><code>ROOT::Fit::Chi2FCN</code> for chi2 (least-square fits),</li>
<li><code>ROOT::Fit::PoissonLikelihoodFCN</code> for binned likelihood fits of histograms,</li>
<li><code>ROOT::Fit::LogLikelihoodFCN</code> for generic un-binned 
likelihood fits. These classes are templated on the type of function 
interface they implement (see later). User convenient typedefs are also 
provided. They derive from the common generic interface 
multi-dimensional for function evaluation, <code>ROOT::Math::IBaseFunctionMultiDim</code>.</li>
</ul></li>
</ul>
<p>In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, <code>ROOT::Math::IParametricFunctionMultiDim</code> to define the fit model function and use the <code>ROOT::Math::Minimizer</code>
 interface to perform the minimization of the objective function. More 
information about the function interface and the multi-dimensional 
minimization in ROOT is given in the Mathematical Library chapter.</p>
<p>Here we present a detailed description of the <code>ROOT::Fit</code> classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like <code>TH1::Fit</code>
 allow are more fine control to configure and customise the fits. For 
example, using these classes a combined fit of several histograms can be
 performed.</p>
<p>To understand how these class work, let’s go through a simple example, such as fitting an histogram.</p>
<p>When fitting an histogram, instead of using <code>TH1::Fit</code> we will show in the following hot wo use the <code>ROOT::Fit</code>
 classes. We will show how to perform the following different type of 
fits with the histogram data: * a least square fit using the observed 
errors (Neyman chi-squared); * a least square fit using the expected 
errors from the function (Pearson chi-squared); * a binned likelihood 
fit; * an extended unbinned likelihood fits, if the histogram has been 
set to store in the buffer the original data used to fill it.</p>
<p>Let’s go through all the steps required for performing these fits using the <code>ROOT::Fit::Fitter</code>
 class. These steps are: 1. Create the input fit data object. 2. Create 
the input model function. 3. Configure the fit. 4. Perform the data 
fitting. 5. Examine the result.</p>
<h3 id="creating-the-input-fit-data"><span class="header-section-number">5.7.1</span> Creating the input fit data</h3>
<p>We have two types of input data, binned data (class <code>ROOT::Fit::BinData</code>) used for least square (chi-square) fits of histograms or <code>TGraph</code> objects or un-binned data (class <code>ROOT::Fit::UnBinData</code>) used for fitting vectors of data points (e.g.&nbsp;from a <code>TTree</code>).</p>
<h4 id="using-binned-data"><span class="header-section-number">5.7.1.1</span> Using Binned data</h4>
<p>Let’s suppose we have an histogram, represented as a <strong><code>TH1</code></strong> type object (it can be one or multi-dimensional). The following shows how to create and fill a <code>ROOT:Fit::BinData</code> object.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb184-1" title="1">   ROOT::Fit::DataOptions opt;</a>
<a class="sourceLine" id="cb184-2" title="2">   opt.fIntegral = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb184-3" title="3">   ROOT::Fit::BinData data(opt);</a>
<a class="sourceLine" id="cb184-4" title="4">   <span class="co">// fill the bin data using the histogram</span></a>
<a class="sourceLine" id="cb184-5" title="5">   <span class="co">// we can do this using the following helper function from the Hist library</span></a>
<a class="sourceLine" id="cb184-6" title="6">   TH1 * h1 = (TH1*) gDirectory-&gt;Get(<span class="st">"myHistogram"</span>);</a>
<a class="sourceLine" id="cb184-7" title="7">   ROOT::Fit::FillData(data, h1);</a></code></pre></div>
<p>In this code example, we have used the utility function of the <em>Hist</em> library, <code>ROOT::Fit::FillData</code> to fill the <code>BinData</code> object. The <code>ROOT::Fit::FillData</code> is defined in the headerfile <code>HFitInterface.h</code> and it has a signature for all different ROOT objects, like <code>TH1</code>, <code>THnBase</code>, <code>TGraph</code>, <code>TGraph2D</code> and <code>TMultiGraph</code> It is possible to specify, when creating the <code>BinData</code>
 object, the data range we want to use and some fitting options we want 
to apply to fill in the object and later when fitting. The fit data 
options are controlled by the <code>ROOT::Fit::DataOptions</code> class, the range by the <code>ROOT::Fit::DataRange</code> class.</p>
<p>Here is an example how to specify the input option to use the 
integral of the function value in the bin instead of using the function 
value evaluated at the bin center, when doing the fit and to use a range
 beween the ‘xmin’ and ‘xmax’ values.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb185-1" title="1">   ROOT::Fit::DataOptions opt;</a>
<a class="sourceLine" id="cb185-2" title="2">   opt.fIntegral = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb185-3" title="3">   ROOT::Fit::DataRange range(xmin,xmax);</a>
<a class="sourceLine" id="cb185-4" title="4">   ROOT::Fit::BinData data(opt,range);</a>
<a class="sourceLine" id="cb185-5" title="5">   <span class="co">// fill the bin data using the histogram</span></a>
<a class="sourceLine" id="cb185-6" title="6">   <span class="co">// we can do this using the following helper function from the Hist library</span></a>
<a class="sourceLine" id="cb185-7" title="7">   TH1 * h1 = (TH1*) gDirectory-&gt;Get(<span class="st">"myHistogram"</span>);</a>
<a class="sourceLine" id="cb185-8" title="8">   ROOT::Fit::FillData(data, h1);</a></code></pre></div>
<p>The list of possible fit options available is the following:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb186-1" title="1">   ROOT::Fit::DataOptions opt;</a>
<a class="sourceLine" id="cb186-2" title="2">   opt.fIntegral = <span class="kw">true</span>;      <span class="co">// use integral of bin content instead of bin center (default is false).</span></a>
<a class="sourceLine" id="cb186-3" title="3">   opt.fBinVolume = <span class="kw">true</span>;     <span class="co">// normalize data by the bin volume (default is false).</span></a>
<a class="sourceLine" id="cb186-4" title="4">                              <span class="co">//  This is for fitting density functions in histograms with variable bin sizes.</span></a>
<a class="sourceLine" id="cb186-5" title="5">   opt.fUseRange  =<span class="kw">true</span>;      <span class="co">// use the function range when creating the fit data (default is false).</span></a>
<a class="sourceLine" id="cb186-6" title="6">   opt.fExpErrors = <span class="kw">true</span>;     <span class="co">// use the expected errors estimated from the function values</span></a>
<a class="sourceLine" id="cb186-7" title="7">                              <span class="co">//  assuming Poisson statistics and not the observed errors (default is false).</span></a>
<a class="sourceLine" id="cb186-8" title="8">   opt.fUseEmpty = <span class="kw">true</span>;      <span class="co">// use empty bins when fitting (default is false). If fExpErrors</span></a>
<a class="sourceLine" id="cb186-9" title="9">                              <span class="co">//  is not set an arbitrary error = 1 is assigned to those bins.</span></a>
<a class="sourceLine" id="cb186-10" title="10">   opt.fErrors1 = <span class="kw">true</span>;       <span class="co">// Set all measured errors to 1 (default is false).</span></a>
<a class="sourceLine" id="cb186-11" title="11">   opt.fCoordErrors = <span class="kw">false</span>;  <span class="co">// When available coordinate errors are not used in the fit</span></a>
<a class="sourceLine" id="cb186-12" title="12">                              <span class="co">//  (default is true: the errors are used when they are available,</span></a>
<a class="sourceLine" id="cb186-13" title="13">                              <span class="co">//  e.g. fitting a TGraphErrors).</span></a>
<a class="sourceLine" id="cb186-14" title="14">   opt.fAsymErrors = <span class="kw">false</span>;   <span class="co">// When available asymmetric errors are considered in the fit</span></a>
<a class="sourceLine" id="cb186-15" title="15">                              <span class="co">//  (default is true, the asymmetric errors are used when they are available,</span></a>
<a class="sourceLine" id="cb186-16" title="16">                              <span class="co">//  e.g. fitting a TGraphAsymmErrors).</span></a></code></pre></div>
<p>The <code>ROOT::Fit::DataRange</code> class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function <code>DataRange::AddRange(icoord,xmin,xmax)</code> adds a range in the coordinate <code>icoord</code> with lower value <code>xmin</code> and upper value <code>xmax</code>:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb187-1" title="1">   ROOT::Fit::DataRange range;</a>
<a class="sourceLine" id="cb187-2" title="2">   range.AddRange(icoordinate, xmin, xmax);</a></code></pre></div>
<h4 id="using-un-binned-data"><span class="header-section-number">5.7.1.2</span> Using Un-Binned data</h4>
<p>The unbinned data sets are represented with the <code>ROOT::Fit::UnBinData</code> class. For creating un-binned data sets, a <code>ROOT::Fit::UnBinData</code> object, one has two possibilities: 1. Copy the data inside <code>ROOT::Fit::UnBinData</code>. One can create an empty <code>UnBinData</code> object, iterate on the data and add the data point one by one, or directly create the <code>UnBinData</code> object from a data iterator. In this case an input <code>ROOT::Fit::DataRange</code> object is passed in order to copy the data according to the given range. 2. Use <code>ROOT::Fit::UnBinData</code> as a wrapper to an external data storage. In this case the <code>UnBinData</code>
 object is created from an iterator or pointers to the data and the data
 are not copied inside. In this case the data cannot be selected 
according to a specified range. All the data points will be included in 
the fit.</p>
<p>The <code>ROOT::Fit::UnBinData</code> class supports also weighted data. In addition to the data points (coordinates), which can be of arbitrary <code>k</code>
 dimensions, the class can be constructed from a vector of weights. This
 is an example of taking data from an histogram buffer of a <strong><code>TH1</code></strong> object:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb188-1" title="1">    <span class="dt">double</span> * buffer = histogram-&gt;GetBuffer();</a>
<a class="sourceLine" id="cb188-2" title="2">    <span class="co">// number of entry is first entry in the buffer</span></a>
<a class="sourceLine" id="cb188-3" title="3">    <span class="dt">int</span> n = buffer[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb188-4" title="4">    <span class="co">// when creating the data object it is important to create with the size of the data</span></a>
<a class="sourceLine" id="cb188-5" title="5">    ROOT::Fit::UnBinData data(n);</a>
<a class="sourceLine" id="cb188-6" title="6">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i)</a>
<a class="sourceLine" id="cb188-7" title="7">        data.add(buffer[<span class="dv">2</span>*i+<span class="dv">1</span>]);  <span class="co">// the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......</span></a></code></pre></div>
<p>Instead in this example we will create a 2-dim <code>UnBinData</code> object with the contents from a ROOT <code>TTree</code></p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb189-1" title="1">    TFile * file = TFile::Open(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb189-2" title="2">    TTree *ntuple = <span class="dv">0</span>; file-&gt;GetObject(<span class="st">"ntuple"</span>,ntuple);</a>
<a class="sourceLine" id="cb189-3" title="3">    <span class="co">// select from the tree the data we want to use for fitting</span></a>
<a class="sourceLine" id="cb189-4" title="4">    <span class="co">// we use TTree::Draw  for this</span></a>
<a class="sourceLine" id="cb189-5" title="5">    <span class="dt">int</span> nevt = ntuple-&gt;Draw(<span class="st">"px:py"</span>,<span class="st">""</span>,<span class="st">"goff"</span>);</a>
<a class="sourceLine" id="cb189-6" title="6">    <span class="dt">double</span> * x = ntuple-&gt;GetV1();</a>
<a class="sourceLine" id="cb189-7" title="7">    <span class="dt">double</span> * y = ntuple-&gt;GetV2();</a>
<a class="sourceLine" id="cb189-8" title="8">    ROOT::Fit::UnBinData data(nevt, x, y );</a></code></pre></div>
<h3 id="creating-the-fit-model"><span class="header-section-number">5.7.2</span> Creating the Fit model</h3>
<p>In order to fit a data sets we need a model to describe our data, 
e.g.&nbsp;a probability density function describing our observed data or
 an hypothetical function describing the relation between the 
independent variables <strong><code>X</code></strong> and the single dependent variable <code>Y</code>. We can have an arbitrary number <code>k</code> of independent variables. For example, when fitting a <code>k</code>-dimensional histogram, the independent variables <strong><code>X</code></strong> are the bin center coordinates and <code>Y</code> is the bin weight.</p>
<p>The model function needs to be expressed as function of some unknown 
parameters. The fitting will find the best parameter value to describe 
the observed data.</p>
<p>We can use the ROOT <strong><code>TF1</code></strong> class, the parametric function class, to describe the model function. However the <code>ROOT::Fit::Fitter</code> class, to be independent of the ROOT <em><code>Hist</code></em> library, takes as input a more general parametric function object, the interface (abstract) class <code>ROOT::Math::IParametricFunctionMultiDim</code>, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class <code>ROOT::Math::IBaseFunctionMultiDim</code>, with methods to set/retrieve parameter values and to evaluate the function given the independent vector of values <strong><code>X</code></strong> and vector of parameters <code>P</code>. More information about the different <code>ROOT::Math</code> function interfaces is available in the Mathematical Library chapter.</p>
<p>An end-user can convert a <strong><code>TF1</code></strong> object in a <code>ROOT::Math::IParametricFunctionMultiDim</code>, using the wrapper class <code>ROOT::Math::WrapperMultiTF1</code>:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb190-1" title="1">    TF1 * f1 = <span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"gaus"</span>);</a>
<a class="sourceLine" id="cb190-2" title="2">    ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1-&gt;GetNdim() );</a>
<a class="sourceLine" id="cb190-3" title="3">    ROOT::Fit::Fitter fitter;</a>
<a class="sourceLine" id="cb190-4" title="4">    fitter.SetFunction( fitFunction, <span class="kw">false</span>);</a></code></pre></div>
<p>When creating the wrapper, the parameter values stored in <strong><code>TF1</code></strong> will be copied in the <code>ROOT::Math::WrappedMultiTF1</code> object. The function object representing the model function is given to the <code>ROOT::Fitter</code> class using the <code>Fitter::SetFunction</code> method.</p>
<p>The user has also the possibility to provide a function object, which
 implements the derivatives of the function with respect to the 
parameters. This information might be useful for some types of fits. In 
this case he needs to provide the function object as a class deriving 
from the <code>ROOT::Math::IParametricGradFunctionMultiDim</code> interface. Note that the wrapper class <code>ROOT::Math::WrappedMultiTF1</code> implements also the gradient interface, using internally <code>TF1::GradientPar</code>, which is based on numerical differentiation, apart for the case of linear functions (i.e.&nbsp;when <code>TF1::IsLinear()</code> is <code>true</code>).
 The parameter derivatives of the model function can be useful to some 
minimization algorithms, such as Fumili. However, in general is better 
to leave the minimization algorithm (e.g.&nbsp;Minuit) to compute the 
needed derivatives using its own customised numerical differentiation 
algorithm. In order to not provide to the fitter the parameter 
derivatives, we explicitly passed in <code>Fitter::SetFunction</code> a <code>false</code> value.</p>
<h3 id="fit-configuration"><span class="header-section-number">5.7.3</span> Fit Configuration</h3>
<p>The configuration of the fit is done via the <code>ROOT::Fit::FitConfig</code> class and its contained <code>ROOT::Fit::ParameterSettings</code> class. These are the possible allowed fit configurations:</p>
<ul>
<li>setting the initial values of the parameters;</li>
<li>setting the parameter step sizes;</li>
<li>setting eventual parameter bounds;</li>
<li>setting the minimizer library and the particular algorithm to use;</li>
<li>setting different minimization options (print level, tolerance, max iterations, etc…)</li>
<li>setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values)</li>
</ul>
<p>The initial parameter values can be set directly in the input model 
function object. However, for setting parameter bounds and step sizes to
 values different than the automatically computed ones, one needs to use
 the <code>ROOT::Fit::ParameterSetting</code> class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb191-1" title="1">  fitter.SetFunction( fitFunction, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb191-2" title="2">  fitter.Config().ParSettings(<span class="dv">0</span>).SetLimits(<span class="dv">0</span>,<span class="fl">1.E6</span>);</a>
<a class="sourceLine" id="cb191-3" title="3">  fitter.Config().ParSettings(<span class="dv">2</span>).SetLowerLimit(<span class="dv">0</span>);</a></code></pre></div>
<p>Note that a <code>ROOT::Fit::ParameterSettings</code> objects exists for each fit parameter and it created by the <code>ROOT::Fit::FitConfig</code>
 class, after the model function has been set in the Fitter. Only when 
the function is set, the number of parameter is known and automatically 
the <code>FitConfig</code> creates the corresponding <code>ParameterSetting</code> objects.</p>
<p>When fitting, different minimizer can be used. The can be implemented
 in different libraries and loaded ar run time by the plug-in manager 
system of ROOT. Each different minimizer (e.g.&nbsp;<em>Minuit, Minuit2, Fumili,</em> etc.) consists of a different implementation of the <code>ROOT::Math::Minimizer</code> interface. Within the same minimizer, thus within the same class implementing the <code>Minimizer</code> interface, different algorithms can exist. For example in the case of Minuit, we have <em>Migrad, Simplex</em> or <em>Minimize</em>. The minimizer and its corresponding algorithm, when available, can be set by using the function <code>FitConfig::SetMinimizer("minimizerName")</code> or by using directly the <code>ROOT:Math::MinimizerOptions</code> class.</p>
<p>If the requested minimizer is not available in ROOT, the default one 
is used. The default minimizer type and algorithm can be specified by 
using the static function <code>ROOT::Math::MinimizerOptions::SetDefaultMinimizer("minimizerName")</code></p>
<h3 id="minimizer-libraries-and-algorithms"><span class="header-section-number">5.7.4</span> Minimizer Libraries and Algorithms</h3>
<p>The list of available minimizer libraries currently available in 
ROOT, with their corresponding available algorithms is the following 
one. Some minimizers (e.g.&nbsp;<em>Minuit</em>) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g.&nbsp;<em>Fumili</em>)</p>
<ul>
<li><strong><code>Minuit</code></strong> (library <em>libMinuit</em>). Old version of Minuit, based on the <code>TMinuit</code> class. The list of possible algorithms are:
<ul>
<li><em><code>Migrad</code></em> (default one)</li>
<li><em><code>Simplex</code></em></li>
<li><em><code>Minimize</code></em> (it is a combination of Migrad and Simplex)</li>
<li><em><code>MigradImproved</code></em></li>
<li><em><code>Scan</code></em></li>
<li><em><code>Seek</code></em></li>
</ul></li>
<li><strong><code>Minuit2</code></strong> (library <em>libMinuit2</em>). New C++ version of Minuit. The list of possible algorithm is :
<ul>
<li><em><code>Migrad</code></em> (default)</li>
<li><em><code>Simplex</code></em></li>
<li><em><code>Minimize</code></em></li>
<li><em><code>Scan</code></em></li>
<li><em><code>Fumili</code></em> . This is the same algorithm of <code>TFumili</code>, but implemented in the Minuit2 library.</li>
</ul></li>
<li><p><strong><code>Fumili</code></strong>. Implement a dedicated 
minimization algorithm for least-square and likelihood fits. It has 
requirements on the type of method function to be used. No specific 
algorithm exists</p></li>
<li><strong><code>GSLMultiMin</code></strong> (library <em>libMathMore</em>).
 Minimizer based on the Multidimensional Minimization routines of the 
Gnu Scientific Library (GSL). The list of available algorithms is
<ul>
<li><em><code>BFGS2</code></em> (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;</li>
<li><em><code>BFGS</code></em> : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;</li>
<li><em><code>ConjugateFR</code></em> : Fletcher-Reeves conjugate gradient algorithm;</li>
<li><em><code>ConjugatePR</code></em> : Polak-Ribiere conjugate gradient algorithm;</li>
<li><em><code>SteepestDescent</code></em>: steepest descent algorithm;</li>
</ul></li>
<li><p><strong><code>GSLMultiFit</code></strong> (library <em>libMathMore</em>). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits.</p></li>
<li><p><strong><code>GSLSimAn</code></strong> (library <em>libMathMore</em>). Minimizer based on simulated annealing.</p></li>
<li><p><strong><code>Genetic</code></strong> (library <em>libGenetic</em>). Genetic minimizer based on an algorithm implemented in the <em>TMVA</em> package.</p></li>
</ul>
<p>Each minimizer can be configured using the <code>ROOT::Math::MinimizerOptions</code> class. The list of possible option that can be set are:</p>
<ul>
<li><em>Minimizer type</em> (<code>MinimizerOptions::SetMinimizerType(const char *)</code>) .</li>
<li><em>Minimizer algorithm</em> (<code>MinimizerOptions::SetMinimizerAlgorithm(const char *)</code>).</li>
<li><em>Print Level</em> (<code>MinimizerOptions::SetPrintLevel(int )</code>) to set the verbose printing level (default is 0).</li>
<li><em>Tolerance</em> (<code>MinimizerOptions::SetTolerance(double )</code>) tolerance used to control the iterations.</li>
<li><em>Maximum number of function calls</em> (<code>MinimizerOptions::SetMaxFunctionCalls(int )</code>).</li>
<li><em>Maximum number of iterations</em> (<code>MinimizerOptions::SetMaxIterations(int )</code>). Note that this is not used by <em>Minuit</em></li>
<li><em>FCN Upper value for Error Definition</em> (<code>MinimizerOptions::SetErrorDef(double )</code>).
 Value in the minimization function used to compute the parameter 
errors. The default is to get the uncertainties at the 68% CL is a value
 of 1 for a chi-squared function minimization and 0.5 for a 
log-likelihood function.</li>
<li><em>Strategy</em> (<code>MinimizerOptions::SetStrategy(int )</code>), minimization strategy used. For each minimization strategy <em>Minuit</em>
 uses different configuration parameters (e.g.&nbsp;different 
requirements in computing derivatives, computing full Hessian (strategy =
 2) or an approximate version. The default is a value of 1. In this case
 the full Hessian matrix is computed only after the minimization.</li>
<li><em>Precision</em> (<code>MinimizerOptions::SetPrecision(double )</code>). Precision value in the evaluation of the minimization function. Default is numerical double precision.</li>
</ul>
<p>Note that not all the options are implemented by all the minimizers. For example in <em>Minuit</em>
 is possible to set the maximum number of function calls, but not the 
maximum number of iterations. The Strategy and the Precision options 
apply instead only for <em>Minuit</em> (and <em>Minuit2</em>).</p>
<p>The class supports also setting global default values for the options, by using the static functions <code>MinimizerOptions::SetDefault...</code> (for example <code>MinimizerOptions::SetDefaultPrintLevel(int )</code>). The static functions can be also used to set the minimizer options when using <code>TH1::Fit</code> or <code>TGraph::Fit</code>. The list of the current option values can be inspected by using <code>MinimizerOptions::Print</code>.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb192-1" title="1">ROOT::Math::MinimizerOptions() opt;</a>
<a class="sourceLine" id="cb192-2" title="2"><span class="co">// print the default minimizer option values</span></a>
<a class="sourceLine" id="cb192-3" title="3">opt.Print();</a></code></pre></div>
<p>In addition it is possible to provide extra options which might apply for a particular minimizer <code>MinimizerOptions::SetExtraOptions(const IOptions &amp; )</code>. See the documentation of the particular minimizer to use for the list of possible additional options available.</p>
<h3 id="performing-the-fit"><span class="header-section-number">5.7.5</span> Performing the Fit</h3>
<p>Here we have now all the required input ingredients for the fit, the 
data and the function to fit. Depending on these we have now several 
different way to perform the fit, using the corresponding methods of the
 <code>ROOT::Fit::Fitter</code> class and depending on the type of input data.</p>
<h4 id="available-fit-methods"><span class="header-section-number">5.7.5.1</span> Available fit methods</h4>
<ul>
<li><strong>Least-square fit</strong>: <code>Fitter::LeastSquare(const BinData &amp; )</code> or <code>Fitter::Fit(const Bindata &amp;)</code>. It requires the user to pass a <code>BinData</code> object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class <code>ROOT::Fit::Chi2FCN</code>.</li>
<li><strong>Binned Likelihood fit</strong> : <code>Fitter::LikelihoodFit(const Bindata &amp; )</code>. The user needs to pass a <code>BinData</code>
 object. It should be used when the data values follow a Poisson or a 
multinomial distribution. The Poisson case (extended fit) is the default
 and in this case the function normalization is also fit to the data. 
The Multi-nominal case can be selected by passing the optional <em>extended</em> boolean flag as <em>false</em>. This method is implemented by the class <code>ROOT::Fit:::PoissonLikelihoodFCN</code>.</li>
<li><strong>Un-Binned likelihood fit</strong>: <code>Fitter::LikelihoodFit(const UnBindata &amp;)</code>. The user needs to pass an <code>UnBinData</code>
 object. By default the fit is not extended (i.e.&nbsp;the normalization
 is not fitted to the data). As above the user can select an extended 
likelihood fit by passing the optional <em>extended</em> boolean flag as <em>true</em>. This method is implemented using the class <code>LogLikelihoodFCN</code></li>
<li><strong>Linear Fit</strong>: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the <em>Matrix</em> library), if the model function is linear in the parameters.</li>
</ul>
<h4 id="customised-fit-methods"><span class="header-section-number">5.7.5.2</span> Customised Fit methods</h4>
<p>Above we described the pre-defined methods used for fitting. A user 
can also implement its own fitting methods, thus its version of the 
chi-square or likelihood function he wants to minimize. In this case, 
the user does not really need to build as input a <code>ROOT::Fit</code>
 data set and model function as we described before. He can implements 
its own version of the method function using on its own data set objects
 and functions.</p>
<p>In this case <code>ROOT::Fit::Fitter::SetFCN</code> is used to set the method function and <code>ROOT::Fit::FitFCN</code> is used for fitting. The method function can be passed also in <code>ROOT::Fit::FitFCN</code>, but in this case a previously defined fitting configuration is used.</p>
<p>The possible type of method functions that are based in <code>ROOT::Fit::Fitter::SetFCN</code> are:</p>
<ul>
<li>A generic functor object implementing <code>operator()(const double * p)</code> where <strong><code>p</code></strong>
 is the parameter vectors. In this case one needs to pass the number of 
parameters, the function object and optionally a vector of initial 
parameter values. Other optional parameter include the size of the data 
sets and a flag specifying if it is a chi2 (least-square fit). In the 
last two parameters are given, the <code>chi2/ndf</code> can be computed after fitting the data.</li>
</ul>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb193-1" title="1"><span class="kw">template</span> &lt;<span class="kw">class</span> Function&gt;</a>
<a class="sourceLine" id="cb193-2" title="2"><span class="dt">bool</span> Fitter::SetFCN(<span class="dt">unsigned</span> <span class="dt">int</span> npar, Function &amp; f,</a>
<a class="sourceLine" id="cb193-3" title="3">                    <span class="at">const</span> <span class="dt">double</span> * initialParameters = <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb193-4" title="4">                    <span class="dt">unsigned</span> <span class="dt">int</span> dataSize=<span class="dv">0</span>, <span class="dt">bool</span> isChi2Fit = <span class="kw">false</span>)</a></code></pre></div>
<ul>
<li>A function object implementing the <code>ROOT::Math::IBaseFunctionMultiDim</code> interface:</li>
</ul>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb194-1" title="1"><span class="dt">bool</span> Fitter::SetFCN(<span class="at">const</span> ROOT::Math::IBaseFunctionMultiDim  &amp; f,</a>
<a class="sourceLine" id="cb194-2" title="2">                    <span class="at">const</span> <span class="dt">double</span> * initialParameters = <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb194-3" title="3">                    <span class="dt">unsigned</span> <span class="dt">int</span> dataSize=<span class="dv">0</span>, <span class="dt">bool</span> isChi2Fit = <span class="kw">false</span>)</a></code></pre></div>
<ul>
<li>A function object implementing the <code>ROOT::Math::FitMethodFunction</code> interface. This is an interface class extending the <code>ROOT::Math::IBaseFunctionMultiDim</code>
 with some extra functionality which can be used when fitting. This 
extra functionality is required by dedicated fitting algorithms like <em>Fumili</em> or <em>GSLMultiFit</em>.</li>
</ul>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb195-1" title="1"><span class="dt">bool</span> Fitter::SetFCN(<span class="at">const</span> ROOT::Math::FitMethodFunction  &amp; f,</a>
<a class="sourceLine" id="cb195-2" title="2">                    <span class="at">const</span> <span class="dt">double</span> * initialParameters = <span class="dv">0</span>, <span class="dt">unsigned</span> <span class="dt">int</span> dataSize=<span class="dv">0</span>)</a></code></pre></div>
<ul>
<li>A old-Minuit like FCN interface (i.e.&nbsp;a free function with the signature <code>fcn(int &amp;npar, double *gin, double &amp;f, double *u, int flag)</code>.</li>
</ul>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb196-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span>(* MinuitFCN)(<span class="dt">int</span> &amp;npar, <span class="dt">double</span> *gin, <span class="dt">double</span> &amp;f, <span class="dt">double</span> *u, <span class="dt">int</span> flag)</a>
<a class="sourceLine" id="cb196-2" title="2"><span class="dt">bool</span> Fitter::SetFCN(MinuitFCN fcn, <span class="dt">int</span> npar,</a>
<a class="sourceLine" id="cb196-3" title="3">                    <span class="at">const</span> <span class="dt">double</span> * initialParameters = <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb196-4" title="4">                    <span class="dt">unsigned</span> <span class="dt">int</span> dataSize=<span class="dv">0</span>, <span class="dt">bool</span> isChi2Fit = <span class="kw">false</span>)</a></code></pre></div>
<h3 id="fit-result"><span class="header-section-number">5.7.6</span> Fit Result</h3>
<p>The result of the fit is contained in the <code>ROOT::Fit::Result</code> object. A reference to the result object is obtained with the function <code>Fitter::Result()</code>. The <code>ROOT::Fit::FitResult</code>
 class provides an API for retrieving parameter values, errors, 
covariance and correlation matrix from the fit, minimum chi2/likelihood 
values, etc…</p>
<p>A <code>FitResult::Print</code> method is also available to print the result of the fit.</p>
<p>The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit.</p>
<p>One extra functionality offered by <code>ROOT::Fit::FitResult</code> is the possibility to compute the confidence intervals of the function after the fit. The function <code>ROOT::Fit::FitResult::GetConfidenceInterval</code> given an input data sets (e.g.&nbsp;a <code>BinData</code>
 object) and a confidence level value (e.g.&nbsp;68%) computes the 
lower/upper band values of the model function at the given data points.</p>
<h3 id="tfitresult"><span class="header-section-number">5.7.7</span> TFitResult</h3>
<p><code>TFitResult</code> is a class deriving from <code>ROOT::Fit::Result</code> and providing in addition some convenient methods to return a covariance or correlation matrix as a <code>TMatrixDSym</code> object. In addition <code>TFitResult</code> derives from <code>TNamed</code> and can be conveniently stored in a file.</p>
<p>When fitting an histogram ( a <strong><code>TH1</code></strong> object) or a graph (a <code>TGraph</code> object) it is possible to return a <code>TFitResult</code> via the <code>TFitResultPtr</code> object, which behaves as a smart pointer to a <code>TFitResult</code>. <code>TFitResultPtr</code> is the return object by <code>TH1::Fit</code> or <code>TGraph::Fit</code>.
 By default the TFitResultPtr contains only the status of the fit and 
can be obtained by an automatic conversion of the TFitResultPtr to an 
integer.</p>
<p>If the fit option <em><code>S</code></em> is instead used, <code>TFitResultPtr</code> contains the <code>TFitResult</code> and behaves as a smart pointer to it. This is an example:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb197-1" title="1"><span class="dt">int</span> fitStatus =  hist-&gt;Fit(myFunction);   <span class="co">// TFitResultPtr contains only the fit status</span></a>
<a class="sourceLine" id="cb197-2" title="2"></a>
<a class="sourceLine" id="cb197-3" title="3">TFitResultPtr r = hist-&gt;Fit(myFunction,<span class="st">"S"</span>);  <span class="co">// TFitResultPtr contains the TFitResult</span></a>
<a class="sourceLine" id="cb197-4" title="4">TMatrixDSym cov = r-&gt;GetCovarianceMatrix();   <span class="co">//  to access the covariance matrix</span></a>
<a class="sourceLine" id="cb197-5" title="5"><span class="dt">Double_t</span> chi2   = r-&gt;Chi2();                  <span class="co">// to retrieve the fit chi2</span></a>
<a class="sourceLine" id="cb197-6" title="6"><span class="dt">Double_t</span> par0   = r-&gt;Parameter(<span class="dv">0</span>);            <span class="co">// retrieve the value for the parameter 0</span></a>
<a class="sourceLine" id="cb197-7" title="7"><span class="dt">Double_t</span> err0   = r-&gt;ParError(<span class="dv">0</span>);             <span class="co">// retrieve the error for the parameter 0</span></a>
<a class="sourceLine" id="cb197-8" title="8">r-&gt;Print(<span class="st">"V"</span>);                                <span class="co">// print full information of fit including covariance matrix</span></a>
<a class="sourceLine" id="cb197-9" title="9">r-&gt;Write();                                   <span class="co">// store the result in a file</span></a></code></pre></div>
<h2 id="the-minimization-packages"><span class="header-section-number">5.8</span> The Minimization packages</h2>
<p>As explained before various minimization packages can be used when fitting in ROOT. We have seen before how to configure the <code>Fitter</code> class to use different minimization packages and different minimization options. When using the <code>Fit</code> method the minimization package (and its options) can be selected using the static methods of the <code>ROOT::Math::MinimizerOptions</code> class. For example to select <code>Minuit2</code> instead of <code>Minuit</code> for fitting an histogram do:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb198-1" title="1">ROOT::Math::MinimizerOptions::SetDefaultMinimizer(<span class="st">"Minuit2"</span>);</a>
<a class="sourceLine" id="cb198-2" title="2"><span class="co">// fit the histogram histo with the gaussian pre-defined function</span></a>
<a class="sourceLine" id="cb198-3" title="3">histo-&gt;Fit(<span class="st">"gaus"</span>);</a></code></pre></div>
<p>In the following we will give some brief description of the minimization packages. The packages all implement the <code>ROOT::Math::Minimizer</code>
 interface which can be use for finding the minimum of a 
multi-dimensional function. The interface is documented in the 
Mathematical Library Chapter.</p>
<p>In addition packages like Minuit or Minuit2 provide their own interfaces.</p>
<h2 id="minuit-old-tminuit-version"><span class="header-section-number">5.9</span> MINUIT (Old TMInuit Version)</h2>
<p>This package was originally written in FORTRAN by Fred James and part of <code>PACKLIB</code>
 (patch D506). It has been converted to a C++ class by René Brun. The 
current implementation in C++ is a straightforward conversion of the 
original FORTRAN version. The main changes are:</p>
<ul>
<li><p>The variables in the various <code>Minuit</code> labeled common blocks have been changed to the <strong><code>TMinuit</code></strong> class data members</p></li>
<li><p>The internal arrays with a maximum dimension depending on the 
maximum number of parameters are now data members’ arrays with a dynamic
 dimension such that one can fit very large problems by simply 
initializing the <strong><code>TMinuit</code></strong> constructor with the maximum number of parameters</p></li>
<li><p>The include file <code>Minuit.h</code> has been commented as much as possible using existing comments in the code or the printed documentation</p></li>
<li><p>The original <code>Minuit</code> subroutines are now member functions</p></li>
<li><p>Constructors and destructor have been added</p></li>
<li><p>Instead of passing the <code>FCN</code> function in the argument 
list, the addresses of this function is stored as pointer in the data 
members of the class. This is by far more elegant and flexible in an 
interactive environment. The member function <code>SetFCN</code> can be used to define this pointer</p></li>
<li><p>The ROOT static function <code>Printf</code> is provided to replace all format statements and to print on currently defined output file</p></li>
<li><p>The functions <code>SetObjectFit/GetObjectFit</code> can be used inside the <code>FCN</code> function to set/get a referenced object instead of using global variables</p></li>
<li><p>By default <code>fGraphicsMode</code> is true. When calling the <code>Minuit</code> functions such as <code>mncont</code>, <code>mnscan</code>, or any <code>Minuit</code> command invoking <code>mnplot</code>, <code>TMinuit::mnplot()</code> produces a <strong><code>TGraph</code></strong> object pointed by <code>fPlot</code>. One can retrieve this object with <strong><code>TMinuit</code></strong><code>::GetPlot().</code> For example:</p></li>
</ul>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb199-1" title="1">   h-&gt;Fit(<span class="st">"gaus"</span>);</a>
<a class="sourceLine" id="cb199-2" title="2">   gMinuit-&gt;Command(<span class="st">"SCAn 1"</span>);</a>
<a class="sourceLine" id="cb199-3" title="3">   TGraph *gr = (TGraph*)gMinuit-&gt;GetPlot();</a>
<a class="sourceLine" id="cb199-4" title="4">   gr-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb199-5" title="5">   gr-&gt;Draw(<span class="st">"alp"</span>);</a></code></pre></div>
<ul>
<li>To set <code>Minuit</code> in no graphics mode, call</li>
</ul>
<div class="sourceCode" id="cb200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb200-1" title="1">   gMinuit-&gt;SetGraphicsMode(kFALSE);</a></code></pre></div>
<h3 id="basic-concepts-of-minuit"><span class="header-section-number">5.9.1</span> Basic Concepts of Minuit</h3>
<p>The <code>Minuit</code> package acts on a multi parameter FORTRAN function to which one must give the generic name <code>FCN</code>. In the ROOT implementation, the function <code>FCN</code> is defined via the <code>Minuit</code> <code>SetFCN</code> member function when an histogram fitting is invoked. The value of <code>FCN</code> will in general depend on one or more variable parameters.</p>
<h3 id="the-transformation-of-limited-parameters"><span class="header-section-number">5.9.2</span> The Transformation of Limited Parameters</h3>
<p>For variable parameters with limits, <code>Minuit</code> uses the following transformation:</p>
<p><code>Pint = arcsin(2((Pext-a)/(b-a))-1)</code></p>
<p><code>Pext = a+((b-a)/(2))(sinPint+1)</code></p>
<p>so that the internal value <code>Pint</code> can take on any value, 
while the external value Pext can take on values only between the lower 
limit a and the ext upper limit b. Since the transformation is 
necessarily non-linear, it would transform a nice linear problem into a 
nasty non-linear one, which is the reason why limits should be avoided 
if not necessary. In addition, the transformation does require some 
computer time, so it slows down the computation a little bit, and more 
importantly, it introduces additional numerical inaccuracy into the 
problem in addition to what is introduced in the numerical calculation 
of the FCN value. The effects of non-linearity and numerical round off 
both become more important as the external value gets closer to one of 
the limits (expressed as the distance to nearest limit divided by 
distance between limits). The user must therefore be aware of the fact 
that, for example, if they put limits of (0, 1010) on a parameter, then 
the values 0.0 and 1. 0 will be indistinguishable to the accuracy of 
most machines.</p>
<p>The transformation also affects the parameter error matrix, of 
course, so Minuit does a transformation of the error matrix (and the 
‘’parabolic’’ parameter errors) when there are parameter limits. Users 
should however realize that the transformation is only a linear 
approximation, and that it cannot give a meaningful result if one or 
more parameters is very close to a limit, where <span class="math inline">\(\frac{\partial Pext}{\partial Pint} \neq 0\)</span>. Therefore, it is recommended that:</p>
<ul>
<li><p>Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values</p></li>
<li><p>When a satisfactory minimum has been found using limits, the 
limits should then be removed if possible, in order to perform or 
re-perform the error analysis without limits</p></li>
</ul>
<h3 id="how-to-get-the-right-answer-from-minuit"><span class="header-section-number">5.9.3</span> How to Get the Right Answer from Minuit</h3>
<p><code>Minuit</code> offers the user a choice of several minimization algorithms. The <code>MIGRAD</code>
 algorithm is in general the best minimized for nearly all functions. It
 is a variable-metric method with inexact line search, a stable metric 
updating scheme, and checks for positive-definiteness. Its main weakness
 is that it depends heavily on knowledge of the first derivatives, and 
fails miserably if they are very inaccurate.</p>
<p>If parameter limits are needed, in spite of the side effects, then 
the user should be aware of the following techniques to alleviate 
problems caused by limits:</p>
<h4 id="getting-the-right-minimum-with-limits"><span class="header-section-number">5.9.3.1</span> Getting the Right Minimum with Limits</h4>
<p>If MIGRAD converges normally to a point where no parameter is near 
one of its limits, then the existence of limits has probably not 
prevented <code>Minuit</code> from finding the right minimum. On the 
other hand, if one or more parameters is near its limit at the minimum, 
this may be because the true minimum is indeed at a limit, or it may be 
because the minimized has become ‘’blocked’’ at a limit. This may 
normally happen only if the parameter is so close to a limit (internal 
value at an odd multiple of <span class="math inline">\(\pm \frac{\pi}{2}\)</span> that <code>Minuit</code>
 prints a warning to this effect when it prints the parameter values. 
The minimized can become blocked at a limit, because at a limit the 
derivative seen by the minimized <span class="math inline">\(\frac{\partial F}{\partial Pint}\)</span> is zero no matter what the real derivative <span class="math inline">\(\frac{\partial F}{\partial Pext}\)</span> is.</p>
<p><span class="math display">\[
\left(\frac{\partial F}{\partial Pint}\right) =
\left(\frac{\partial F}{\partial Pext}\right)
\left(\frac{\partial Pext}{\partial Pint}\right) =
\left(\frac{\partial F}{\partial Pext}\right) = 0
\]</span></p>
<h4 id="getting-the-right-parameter-errors-with-limits"><span class="header-section-number">5.9.3.2</span> Getting the Right Parameter Errors with Limits</h4>
<p>In the best case, where the minimum is far from any limits, <code>Minuit</code>
 will correctly transform the error matrix, and the parameter errors it 
reports should be accurate and very close to those you would have got 
without limits. In other cases (which should be more common, since 
otherwise you would not need limits), the very meaning of parameter 
errors becomes problematic. Mathematically, since the limit is an 
absolute constraint on the parameter, a parameter at its limit has no 
error, at least in one direction. The error matrix, which can assign 
only symmetric errors, then becomes essentially meaningless.</p>
<h4 id="interpretation-of-parameter-errors"><span class="header-section-number">5.9.3.3</span> Interpretation of Parameter Errors</h4>
<p>There are two kinds of problems that can arise: the reliability of <code>Minuit</code>’s error estimates, and their statistical interpretation, assuming they are accurate.</p>
<h4 id="statistical-interpretation"><span class="header-section-number">5.9.3.4</span> Statistical Interpretation</h4>
<p>For discussion of basic concepts, such as the meaning of the elements
 of the error matrix, or setting of exact confidence levels see the 
articles:</p>
<ul>
<li><p>F.James. Determining the statistical Significance of experimental
 Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981</p></li>
<li><p>W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. <em>Statistical Methods in Experimental Physics. North-Holland, 1971</em></p></li>
</ul>
<h3 id="reliability-of-minuit-error-estimates"><span class="header-section-number">5.9.4</span> Reliability of Minuit Error Estimates</h3>
<p><code>Minuit</code> always carries around its own current estimates 
of the parameter errors, which it will print out on request, no matter 
how accurate they are at any given point in the execution. For example, 
at initialization, these estimates are just the starting step sizes as 
specified by the user. After a <code>HESSE</code> step, the errors are usually quite accurate, unless there has been a problem. <code>Minuit</code>, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked <code>CURRENT GUESS ERROR</code> are only working values not to be believed, and <code>APPROXIMATE ERROR</code> means that they have been calculated but there is reason to believe that they may not be accurate.</p>
<p>If no mitigating adjective is given, then at least <code>Minuit</code> believes the errors are accurate, although there is always a small chance that <code>Minuit</code> has been fooled. Some visible signs that <code>Minuit</code> may have been fooled:</p>
<ul>
<li><p>Warning messages produced during the minimization or error analysis</p></li>
<li><p>Failure to find new minimum</p></li>
<li><p>Value of EDM too big (estimated Distance to Minimum)</p></li>
<li><p>Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others</p></li>
<li><p>Correlation coefficients very close to one (greater than 0.99). 
This indicates both an exceptionally difficult problem, and one which 
has been badly parameterized so that individual errors are not very 
meaningful because they are so highly correlated</p></li>
<li><p>Parameter at limit. This condition, signaled by a <code>Minuit</code>
 warning message, may make both the function minimum and parameter 
errors unreliable. See the discussion above ‘Getting the right parameter
 errors with limits’</p></li>
</ul>
<p>The best way to be absolutely sure of the errors is to use 
‘’independent’’ calculations and compare them, or compare the calculated
 errors with a picture of the function. Theoretically, the covariance 
matrix for a ‘’physical’’ function must be positive-definite at the 
minimum, although it may not be so for all points far away from the 
minimum, even for a well-determined physical problem. Therefore, if <code>MIGRAD</code> reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:</p>
<h4 id="a-non-physical-region"><span class="header-section-number">5.9.4.1</span> A Non-physical Region</h4>
<p>On its way to the minimum, <code>MIGRAD</code> may have traversed a 
region that has unphysical behavior, which is of course not a serious 
problem as long as it recovers and leaves such a region.</p>
<h4 id="an-underdetermined-problem"><span class="header-section-number">5.9.4.2</span> An Underdetermined Problem</h4>
<p>If the matrix is not positive-definite even at the minimum, this may 
mean that the solution is not well defined, for example that there are 
more unknowns than there are data points, or that the parameterization 
of the fit contains a linear dependence. If this is the case, then <code>Minuit</code>
 (or any other program) cannot solve your problem uniquely. The error 
matrix will necessarily be largely meaningless, so the user must remove 
the under determinedness by reformulating the parameterization. <code>Minuit</code> cannot do this itself.</p>
<h4 id="numerical-inaccuracies"><span class="header-section-number">5.9.4.3</span> Numerical Inaccuracies</h4>
<p>It is possible that the apparent lack of positive-definiteness is due
 to excessive round off errors in numerical calculations (in the user 
function), or not enough precision. This is unlikely in general, but 
becomes more likely if the number of free parameters is very large, or 
if the parameters are badly scaled (not all of the same order of 
magnitude), and correlations are large. In any case, whether the 
non-positive-definiteness is real or only numerical is largely 
irrelevant, since in both cases the error matrix will be unreliable and 
the minimum suspicious.</p>
<h4 id="an-ill-posed-problem"><span class="header-section-number">5.9.4.4</span> An Ill-posed Problem</h4>
<p>For questions of parameter dependence, see the discussion above on 
positive-definiteness. Possible other mathematical problems are the 
following:</p>
<ul>
<li><p>Excessive numerical round off - be especially careful of 
exponential and factorial functions which get big very quickly and lose 
accuracy.</p></li>
<li><p>Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables.</p></li>
</ul>
<h2 id="minuit2-package"><span class="header-section-number">5.10</span> Minuit2 Package</h2>
<p><code>Minuit2</code> is a new object-oriented implementation, written in C++, of the popular <code>MINUIT</code> minimization package. Compared with the <strong><code>TMinuit</code></strong> class, which is a direct conversion from FORTRAN to C++, <code>Minuit2</code>
 is a complete redesign and re-implementation of the package. This new 
version provides all the functionality present in the old FORTRAN 
version, with almost equivalent numerical accuracy and computational 
performances. Furthermore, it contains some fixes and small improvements
 and this new functionality: * The possibility to set single side 
parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI 
Minimization Package”), which is an optimized method for least square 
and log likelihood minimizations.</p>
<p>Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the <a href="https://root.cern/root/htmldoc/guides/users-guide/MINUIT%20Web%20Site">MINUIT Web Site</a> and in particular at the following documentation page at <a href="http://www.cern.ch/minuit/doc/doc.html" class="uri">http://www.cern.ch/minuit/doc/doc.html</a>.</p>
<p>A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses <code>Minuit2</code> for fitting via the <code>Minuit2Minimizer</code> class which implements the <code>ROOT::Math::Minimizer</code> interface.</p>
<p><code>Minuit2</code> is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.</p>
<p>Examples on how to use the <code>Minuit2</code> and <code>Fumili2</code> plug-ins are provided in the tutorials’ directory <code>$ROOTSYS/tutorials/fit</code>: <code>minuit2FitBench.C</code>, <code>minuit2FitBench2D.C</code> and <code>minuit2GausFit.C</code>. More information on the classes and functions present in <code>Minuit2</code> is available at <a href="https://root.cern/root/htmldoc/guides/users-guide/online%20reference%20documentation">online reference documentation</a>.</p>
<p>Useful information on MINUIT and minimization in general is provided in the following documents:</p>
<p>F. James, <em>Minuit Tutorial on Function Minimization</em> ( <a href="http://seal.cern.ch/documents/minuit/mntutorial.pdf" class="uri">http://seal.cern.ch/documents/minuit/mntutorial.pdf</a>); F. James, <em>The Interpretation of Errors in Minuit</em> ( <a href="http://seal.cern.ch/documents/minuit/mnerror.pdf" class="uri">http://seal.cern.ch/documents/minuit/mnerror.pdf</a>);</p>
<h2 id="fumili-minimization-package"><span class="header-section-number">5.11</span> FUMILI Minimization Package</h2>
<p>FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values <span class="math inline">\(F_{i}\)</span> are fitted with theoretical functions <span class="math inline">\(f_{i}(\vec{x_{i}},\vec{\theta})\)</span>, where <span class="math inline">\(\vec{x_{i}}\)</span> are coordinates, and <span class="math inline">\(\vec{\theta}\)</span> - vector of parameters. For better convergence Chi-square function has to be the following form</p>
<p><span class="math display">\[
\frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}
\left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}
{\sigma_{i}}\right)^{2}
\]</span></p>
<p>where <span class="math inline">\(\sigma_{i}\)</span> are errors of the measured function. The minimum condition is:</p>
<p><span class="math display">\[
\frac{\partial \chi^{2}}{\partial \theta_{i}} =
\sum_{j=1}^{n}
\frac{1}{\sigma_{j}^{2}} . \frac{\partial f_{i}}{\partial \theta_{i}}
\left[ (\vec{x_{j}},\vec{\theta})
 - F_{j}\right] = 0, i = 1 ... m
\]</span></p>
<p>where <span class="math inline">\(m\)</span> is the quantity of 
parameters. Expanding left part of this equation over parameter 
increments and retaining only linear terms one gets</p>
<p><span class="math display">\[
\left(\frac{\partial \chi^{2}}{\theta_{i}}\right)
_{\theta = \vec{\theta}^{0}} +
\sum_{k}
\left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}
\partial \theta_{k}}\right)
_{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0
\]</span></p>
<p>here <span class="math inline">\(\vec{\theta}^{0}\)</span> is some initial value of parameters. In general case:</p>
<p><span class="math display">\[
{\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=
\sum^n_{j=1}{\frac{1}{\sigma^2_j}}
{\frac{\partial f_j}{\theta_i}} {\frac{\partial f_j}{\theta_k}} +
\sum^n_{j=1}{\frac{(f_j - F_j)}{\sigma^2_j}}\cdot
{\frac{\partial^2f_j}{\partial\theta_i\partial\theta_k}}
\]</span></p>
<p>In FUMILI algorithm for second derivatives of Chi-square approximate 
expression is used when last term in previous equation is discarded. It 
is often done, not always wittingly, and sometimes causes troubles, for 
example, if user wants to limit parameters with positive values by 
writing down <span class="math inline">\(\theta_i^2\)</span> instead of <span class="math inline">\(\theta_i\)</span>. FUMILI will fail if one tries minimize <span class="math inline">\(\chi^2 = g^2(\vec\theta)\)</span> where g is arbitrary function.</p>
<p>Approximate value is:</p>
<p><span class="math display">\[
{\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=
\sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}
{\frac{\partial f_j}{\theta_k}}
\]</span></p>
<p>Then the equations for parameter increments are:</p>
<p><span class="math display">\[
\left(\frac{\partial\chi^2}{\partial\theta_i}\right)_
{\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =
 0, \qquad i=1\ldots m
\]</span></p>
<p>Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter <span class="math inline">\({\vec\theta}^0\)</span> a parallelepiped <span class="math inline">\(P_0\)</span> is built with the center at <span class="math inline">\({\vec\theta}^0\)</span> and axes parallel to coordinate axes <span class="math inline">\(\theta_i\)</span>. The lengths of parallelepiped sides along i-th axis is <span class="math inline">\(2b_i\)</span>, where <span class="math inline">\(b_i\)</span> is such a value that the functions <span class="math inline">\(f_j(\vec\theta)\)</span> are quasi-linear all over the parallelepiped.</p>
<p>FUMILI takes into account simple linear inequalities in the form:</p>
<p><span class="math display">\[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]</span></p>
<p>They form parallelepiped <span class="math inline">\(P\)</span> (<span class="math inline">\(P_0\)</span> may be deformed by <span class="math inline">\(P\)</span>).
 Very similar step formulae are used in FUMILI for negative logarithm of
 the likelihood function with the same idea - linearization of function 
argument.</p>
<h2 id="neural-networks"><span class="header-section-number">5.12</span> Neural Networks</h2>
<h3 id="introduction-1"><span class="header-section-number">5.12.1</span> Introduction</h3>
<p>Neural Networks are used in various fields for data analysis and 
classification, both for research and commercial institutions. Some 
randomly chosen examples are image analysis, financial movements’ 
predictions and analysis, or sales forecast and product shipping 
optimization. In particles physics neural networks are mainly used for 
classification tasks (signal over background discrimination). A vast 
majority of commonly used neural networks are multilayer perceptrons. 
This implementation of multilayer perceptrons is inspired from the <code>MLPfit</code> package, which remains one of the fastest tools for neural networks studies.</p>
<h3 id="the-mlp"><span class="header-section-number">5.12.2</span> The MLP</h3>
<p>The multilayer perceptron is a simple feed-forward network with the following structure showed on the left.</p>
<p><img src="ROOTUsersGuide_files/0300008D.png"></p>
<p>It is made of neurons characterized by a bias and weighted links in 
between - let’s call those links synapses. The input neurons receive the
 inputs, normalize them and forward them to the first hidden layer. Each
 neuron in any subsequent layer first computes a linear combination of 
the outputs of the previous layer. The output of the neuron is then 
function of that combination with f being linear for output neurons or a
 sigmoid for hidden layers.</p>
<p>Such a structure is very useful because of two theorems:</p>
<p>1- A linear combination of <code>sigmoids</code> can approximate any continuous function.</p>
<p>2- Trained with <code>output=1</code> for the signal and 0 for the background, the approximated function of inputs <code>X</code> is the probability of signal, knowing <code>X</code>.</p>
<h3 id="learning-methods"><span class="header-section-number">5.12.3</span> Learning Methods</h3>
<p>The aim of all learning methods is to minimize the total error on a 
set of weighted examples. The error is defined as the sum in quadrate, 
divided by two, of the error on each individual output neuron. In all 
methods implemented in this library, one needs to compute the first 
derivative of that error with respect to the weights. Exploiting the 
well-known properties of the derivative, one can express this derivative
 as the product of the local partial derivative by the weighted sum of 
the outputs derivatives (for a neuron) or as the product of the input 
value with the local partial derivative of the output neuron (for a 
synapse). This computation is called “back-propagation of the errors”. 
Six learning methods are implemented.</p>
<h4 id="stochastic-minimization"><span class="header-section-number">5.12.3.1</span> Stochastic Minimization</h4>
<p>This is the most trivial learning method. The Robbins-Monro 
stochastic approximation is applied to multilayer perceptrons. The 
weights are updated after each example according to the formula:</p>
<p><span class="math display">\[
w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)
\]</span></p>
<p>with:</p>
<p><span class="math display">\[
\Delta w_{ij}(t) = - \eta \left(
\frac{\partial e_p}{\partial w_{ij}} + \delta \right) +
\epsilon \Delta w_{ij}(t-1)
\]</span></p>
<p>The parameters for this method are <code>Eta</code>, <code>EtaDecay</code>, <code>Delta</code> and <code>Epsilon</code>.</p>
<h4 id="steepest-descent-with-fixed-step-size-batch-learning"><span class="header-section-number">5.12.3.2</span> Steepest Descent With Fixed Step Size (Batch Learning)</h4>
<p>It is the same as the stochastic minimization, but the weights are 
updated after considering all the examples, with the total derivative <code>dEdw</code>. The parameters for this method are <code>Eta</code>, <code>EtaDecay</code>, <code>Delta</code> and <code>Epsilon</code>.</p>
<h4 id="steepest-descent-algorithm"><span class="header-section-number">5.12.3.3</span> Steepest Descent Algorithm</h4>
<p>Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is <code>Tau</code>. Lower <code>Tau</code> = higher precision = slower search. A value <code>Tau=3</code> seems reasonable.</p>
<h4 id="conjugate-gradients-with-the-polak-ribiere-updating-formula"><span class="header-section-number">5.12.3.4</span> Conjugate Gradients With the Polak-Ribiere Updating Formula</h4>
<p>Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are <code>Tau</code> and <code>Reset</code>, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Polak-Ribiere formula).</p>
<h4 id="conjugate-gradients-with-the-fletcher-reeves-updating-formula"><span class="header-section-number">5.12.3.5</span> Conjugate Gradients With the Fletcher-Reeves Updating Formula</h4>
<p>Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are <code>Tau</code> and <code>Reset</code>,
 which defines the epochs where the direction is reset to the steepest 
descent (estimated by using the Fletcher-Reeves formula).</p>
<h4 id="the-broyden-fletcher-goldfarb-shanno-bfgs-method"><span class="header-section-number">5.12.3.6</span> The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method</h4>
<p>It implies the computation of a <code>NxN</code> matrix, but seems more powerful at least for less than 300 weights. Parameters are <code>Tau</code> and <code>Reset</code>, which defines the epochs where the direction is reset to the steepest descent.</p>
<h3 id="using-the-network"><span class="header-section-number">5.12.4</span> Using the Network</h3>
<p>Neural network are build from a set of “samples”. A sample is a set 
of values defining the inputs and the corresponding output that the 
network should ideally provide. In ROOT this is a <strong><code>TTree</code></strong>
 entry. The first thing to be decided is the network layout. This layout
 is described in a string where the layers are separated by semicolons. 
The input/output layers are defined by giving the expression for each 
neuron, separated by comas. Hidden layers are just described by the 
number of neurons.</p>
<p>In addition, input and output layer formulas can be preceded by ‘@’ (e.g.&nbsp;“<span class="citation" data-cites="out">@out</span>”) if one wants to normalize the corresponding value. Also, if the string ends with ‘<code>!</code>’,
 output neurons are set up for classification, i.e.&nbsp;with a sigmoid 
(1 neuron) or softmax (more neurons) activation function.</p>
<p>Many questions on the good usage of neural network, including rules 
of dumb to determine the best network topology are addressed at <a href="ftp://ftp.sas.com/pub/neural/FAQ.html" class="uri">ftp://ftp.sas.com/pub/neural/FAQ.html</a></p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb201-1" title="1">   <span class="co">// a simple network: 2 inputs, 10 hidden and 1 normalized</span></a>
<a class="sourceLine" id="cb201-2" title="2">   <span class="co">// output neuron</span></a>
<a class="sourceLine" id="cb201-3" title="3">   TMultiLayerPerceptron network(<span class="st">"r,z:10:@Br"</span>,tree);</a></code></pre></div>
<p>Expressions are evaluated as for <code>TTree::Draw()</code>. Input and outputs are taken from the <strong><code>TTree</code></strong> associated with the network. This <strong><code>TTree</code></strong> can be given as argument of the constructor or defined later with <code>TMultiLayerPerceptron::SetData()</code>. Events can also be weighted. The weight expression can be given in the constructor or set later with the method <code>SetWeight()</code> of the class <strong><code>TMultiLayerPerceptron</code></strong>.
 Two datasets must be defined before learning the network: a training 
dataset that is used when minimizing the error, and a test dataset that 
will avoid bias. Those two datasets can be built aside and then given to
 the network, or can be built from a standard expression. By default, 
half of the events are put in both datasets.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb202-1" title="1">   <span class="co">// a more complex 4:8:1 network</span></a>
<a class="sourceLine" id="cb202-2" title="2">   <span class="co">// the ptsumf branch is used as weigh;</span></a>
<a class="sourceLine" id="cb202-3" title="3">   <span class="co">// default event lists are explicit</span></a>
<a class="sourceLine" id="cb202-4" title="4">   TMultiLayerPerceptron  network(<span class="st">"m,pt,acol,acopl:8:type"</span>,<span class="st">"pt"</span>,tree,</a>
<a class="sourceLine" id="cb202-5" title="5">                                  <span class="st">"Entry$%2"</span>,<span class="st">"Entry$/2"</span>);</a></code></pre></div>
<p>The method <code>TMultiLayerPerceptron::SetLearningMethod()</code> defines the learning method. Learning methods are:</p>
<pre><code>TMultiLayerPerceptron::kStochastic,
TMultiLayerPerceptron::kBatch,
TMultiLayerPerceptron::kSteepestDescent,
TMultiLayerPerceptron::kRibierePolak,
TMultiLayerPerceptron::kFletcherReeves,
TMultiLayerPerceptron::kBFGS      // default</code></pre>
<p>The training can start with <code>TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).</code> The first argument is the number of epochs while option is a string that can contain “<code>text</code>” (simple text output), “<code>graph</code>” (evaluating graphical training curves), “<code>update</code> <code>=</code> <code>X</code>” (step for the text/graph output update) or “<code>+</code>” (will skip the randomization and start from the previous values). All combinations are available.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb204-1" title="1">   network.Train(<span class="dv">1000</span>,<span class="st">"text,graph,update=10"</span>); <span class="co">// full output every</span></a>
<a class="sourceLine" id="cb204-2" title="2">                                               <span class="co">// 10 epochs</span></a>
<a class="sourceLine" id="cb204-3" title="3">   network.Train(<span class="dv">100</span>,<span class="st">"text,+"</span>);                <span class="co">// 100 more epochs</span></a>
<a class="sourceLine" id="cb204-4" title="4">   <span class="co">//starts with existing weights</span></a></code></pre></div>
<p>The weights can be saved to a file (<code>DumpWeights</code>) and then reloaded (<code>LoadWeights</code>) to a new compatible network. The output can also be evaluated (<code>Evaluate</code>) for a given output neuron and an array of double input parameters or the network can be exported (<code>Export</code>) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.</p>
<h3 id="examples"><span class="header-section-number">5.12.5</span> Examples</h3>
<p>An example of how to use <strong><code>TMultiLayerPerceptron</code></strong> is the macro <code>mlpHiggs.C</code> in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at <code>LEP</code>, a neural network is build, which can make the difference between <code>WW</code> events and events containing a Higgs boson. Starting with a <strong><code>TFile</code></strong> containing two <strong><code>TTree</code></strong>s: one for the signal, the other for the background, a simple script is used:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb205-1" title="1">   <span class="dt">void</span> mlpHiggs(<span class="dt">Int_t</span> ntrain=<span class="dv">100</span>) {</a>
<a class="sourceLine" id="cb205-2" title="2">      <span class="cf">if</span> (!gROOT-&gt;GetClass(<span class="st">"TMultiLayerPerceptron"</span>))</a>
<a class="sourceLine" id="cb205-3" title="3">      gSystem-&gt;Load(<span class="st">"libMLP"</span>);</a>
<a class="sourceLine" id="cb205-4" title="4">      <span class="co">// prepare inputs - the 2 trees are merged into one, and a</span></a>
<a class="sourceLine" id="cb205-5" title="5">      <span class="co">// "type" branch, equal to 1 for the signal and 0 for the</span></a>
<a class="sourceLine" id="cb205-6" title="6">      <span class="co">// background is added</span></a>
<a class="sourceLine" id="cb205-7" title="7">      TFile input(<span class="st">"mlpHiggs.root"</span>);</a>
<a class="sourceLine" id="cb205-8" title="8">      TTree *signal = (TTree *)input.Get(<span class="st">"sig_filtered"</span>);</a>
<a class="sourceLine" id="cb205-9" title="9">      TTree *background = (TTree *)input.Get(<span class="st">"bg_filtered"</span>);</a>
<a class="sourceLine" id="cb205-10" title="10">      TTree *simu = <span class="kw">new</span> TTree(<span class="st">"MonteCarlo"</span>,</a>
<a class="sourceLine" id="cb205-11" title="11">                              <span class="st">"Filtered Monte Carlo Events"</span>);</a>
<a class="sourceLine" id="cb205-12" title="12">      ...</a></code></pre></div>
<p>Since the input is a <strong><code>TTree</code></strong> and we are starting from two different <strong><code>TTree</code></strong>s (with different names), they are first merged into one, and a “<code>type</code>” branch is added, that says whether there is a signal or a background event. Those irrelevant details are skipped here.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb206-1" title="1">      ...</a>
<a class="sourceLine" id="cb206-2" title="2">      TMultiLayerPerceptron *mlp = <span class="kw">new</span> TMultiLayerPerceptron(</a>
<a class="sourceLine" id="cb206-3" title="3">            <span class="st">"msumf,ptsumf, acolin, acopl:8:type"</span>,<span class="st">"ptsumf"</span>,simu,</a>
<a class="sourceLine" id="cb206-4" title="4">            <span class="st">"Entry$%2"</span>,<span class="st">"Entry$/2"</span>);</a>
<a class="sourceLine" id="cb206-5" title="5">      mlp-&gt;Train(ntrain, <span class="st">"text,graph,update=10"</span>);</a></code></pre></div>
<p>The neural network is instantiated and trained. “<code>ptsumf</code>”
 is used as a weight, and the standard event lists are explicit. The 
network that is then build has four input neurons, eight additional ones
 in the only hidden layer and one single output neuron.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb207-1" title="1">      <span class="co">// Use the NN to plot the results for each sample</span></a>
<a class="sourceLine" id="cb207-2" title="2">      TH1F *bg = <span class="kw">new</span> TH1F(<span class="st">"bgh"</span>,<span class="st">"NN output"</span>,<span class="dv">50</span>,-<span class="fl">.5</span>,<span class="fl">1.5</span>);</a>
<a class="sourceLine" id="cb207-3" title="3">      TH1F *sig = <span class="kw">new</span> TH1F(<span class="st">"sigh"</span>,<span class="st">"NN output"</span>,<span class="dv">50</span>,-<span class="fl">.5</span>,<span class="fl">1.5</span>);</a>
<a class="sourceLine" id="cb207-4" title="4">      bg-&gt;SetDirectory(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb207-5" title="5">      sig-&gt;SetDirectory(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb207-6" title="6">      <span class="dt">Double_t</span> params[<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb207-7" title="7">      <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; background-&gt;GetEntries(); i++) {</a>
<a class="sourceLine" id="cb207-8" title="8">         background-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb207-9" title="9">         params[<span class="dv">0</span>] = msumf;    params[<span class="dv">1</span>] = ptsumf;</a>
<a class="sourceLine" id="cb207-10" title="10">         params[<span class="dv">2</span>] = acolin;   params[<span class="dv">3</span>] = acopl;</a>
<a class="sourceLine" id="cb207-11" title="11">         bg-&gt;Fill(mlp-&gt;Evaluate(<span class="dv">0</span>,params));</a>
<a class="sourceLine" id="cb207-12" title="12">      }</a>
<a class="sourceLine" id="cb207-13" title="13">      <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; signal-&gt;GetEntries(); i++) {</a>
<a class="sourceLine" id="cb207-14" title="14">         signal-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb207-15" title="15">         params[<span class="dv">0</span>] = msumf;</a>
<a class="sourceLine" id="cb207-16" title="16">         params[<span class="dv">1</span>] = ptsumf;</a>
<a class="sourceLine" id="cb207-17" title="17">         params[<span class="dv">2</span>] = acolin;</a>
<a class="sourceLine" id="cb207-18" title="18">         params[<span class="dv">3</span>] = acopl;</a>
<a class="sourceLine" id="cb207-19" title="19">         sig-&gt;Fill(mlp-&gt;Evaluate(<span class="dv">0</span>,params));</a>
<a class="sourceLine" id="cb207-20" title="20">      }</a>
<a class="sourceLine" id="cb207-21" title="21">      TCanvas *cv = <span class="kw">new</span> TCanvas(<span class="st">"NNout_cv"</span>,<span class="st">"Neural net output"</span>);</a>
<a class="sourceLine" id="cb207-22" title="22">      bg-&gt;SetFillStyle(<span class="dv">3008</span>);</a>
<a class="sourceLine" id="cb207-23" title="23">      bg-&gt;SetFillColor(kBlue);</a>
<a class="sourceLine" id="cb207-24" title="24">      sig-&gt;SetFillStyle(<span class="dv">3003</span>);</a>
<a class="sourceLine" id="cb207-25" title="25">      sig-&gt;SetFillColor(kRed);</a>
<a class="sourceLine" id="cb207-26" title="26">      bg-&gt;SetStats(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb207-27" title="27">      sig-&gt;SetStats(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb207-28" title="28">      bg-&gt;Draw();</a>
<a class="sourceLine" id="cb207-29" title="29">      sig-&gt;Draw(<span class="st">"same"</span>);</a>
<a class="sourceLine" id="cb207-30" title="30">      TLegend *legend = <span class="kw">new</span> TLegend(<span class="fl">.75</span>,<span class="fl">.80</span>,<span class="fl">.95</span>,<span class="fl">.95</span>);</a>
<a class="sourceLine" id="cb207-31" title="31">      legend-&gt;AddEntry(bg,<span class="st">"Background(WW)"</span>);</a>
<a class="sourceLine" id="cb207-32" title="32">      legend-&gt;AddEntry(sig,<span class="st">"Signal(Higgs)"</span>);</a>
<a class="sourceLine" id="cb207-33" title="33">      legend-&gt;Draw();</a></code></pre></div>
<p>The neural net output is then used to display the final difference 
between background and signal events. The figure “The neural net output”
 shows this plot.</p>
<figure>
<img src="ROOTUsersGuide_files/image144.png" alt="The neural net output"><figcaption>The neural net output</figcaption>
</figure>
<p>As it can be seen, this is a quite efficient technique. As mentioned 
earlier, neural networks are also used for fitting function. For some 
application with a cylindrical symmetry, a magnetic field simulation 
gives as output the angular component of the potential vector <code>A</code>, as well as the radial and <code>z</code> components of the <code>B</code> field.</p>
<p>One wants to fit those distributions with a function in order to plug them into the <code>Geant</code>
 simulation code. Polynomial fits could be tried, but it seems difficult
 to reach the desired precision over the full range. One could also use a
 <code>spline</code> interpolation between known points. In all cases, the resulting field would not be <code>C</code>-infinite.</p>
<p>An example of output (for Br) is shown. First the initial function 
can be seen as the target. Then, the resulting (normalized) neural net 
output. In order to ease the learning, the “normalize output” was used 
here. The initial amplitude can be recovered by multiplying by the 
original RMS and then shifting by the original mean.</p>
<figure>
<img src="ROOTUsersGuide_files/image145.jpg" alt="The original and the neural net for Br"><figcaption>The original and the neural net for Br</figcaption>
</figure>
<h1 id="a-little-c"><span class="header-section-number">6</span> A Little C++</h1>
<p></p>
<p>This chapter introduces you to some useful insights into C++, to 
allow you to use some of the most advanced features in ROOT. It is in no
 case a full course in C++.</p>
<h2 id="classes-methods-and-constructors-1"><span class="header-section-number">6.1</span> Classes, Methods and Constructors</h2>
<p>C++ extends C with the notion of a class. If you’re used to structures in C, a class is a <code>struct</code>
 that is a group of related variables, which is extended with functions 
and routines specific to this structure (class). What is the interest? 
Consider a <code>struct</code> that is defined this way:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb208-1" title="1">   <span class="kw">struct</span> Line {</a>
<a class="sourceLine" id="cb208-2" title="2">      <span class="dt">float</span> x1;</a>
<a class="sourceLine" id="cb208-3" title="3">      <span class="dt">float</span> y1;</a>
<a class="sourceLine" id="cb208-4" title="4">      <span class="dt">float</span> x2;</a>
<a class="sourceLine" id="cb208-5" title="5">      <span class="dt">float</span> y2;</a>
<a class="sourceLine" id="cb208-6" title="6">   }</a></code></pre></div>
<p>This structure represents a line to be drawn in a graphical window. <code>(x1,y1)</code> are the coordinates of the first point, <code>(x2,y2)</code>
 the coordinates of the second point. In the standard C, if you want to 
draw effectively such a line, you first have to define a structure and 
initialize the points (you can try this):</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb209-1" title="1">   Line firstline;</a>
<a class="sourceLine" id="cb209-2" title="2">   firstline.x1 = <span class="fl">0.2</span>;</a>
<a class="sourceLine" id="cb209-3" title="3">   firstline.y1 = <span class="fl">0.2</span>;</a>
<a class="sourceLine" id="cb209-4" title="4">   firstline.x2 = <span class="fl">0.8</span>;</a>
<a class="sourceLine" id="cb209-5" title="5">   firstline.y2 = <span class="fl">0.9</span>;</a></code></pre></div>
<p>This defines a line going from the point <code>(0.2,0.2)</code> to the point <code>(0.8,0.9)</code>. To draw this line, you will have to write a function, say <code>LineDraw(Line l)</code> and call it with your object as argument:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb210-1" title="1">   LineDraw(firstline);</a></code></pre></div>
<p>In C++, we would not do that. We would instead define a class like this:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb211-1" title="1">   <span class="kw">class</span> TLine {</a>
<a class="sourceLine" id="cb211-2" title="2">      <span class="dt">Double_t</span> x1;</a>
<a class="sourceLine" id="cb211-3" title="3">      <span class="dt">Double_t</span> y1;</a>
<a class="sourceLine" id="cb211-4" title="4">      <span class="dt">Double_t</span> x2;</a>
<a class="sourceLine" id="cb211-5" title="5">      <span class="dt">Double_t</span> y2;</a>
<a class="sourceLine" id="cb211-6" title="6">      TLine(<span class="dt">int</span> x1, <span class="dt">int</span> y1, <span class="dt">int</span> x2, <span class="dt">int</span> y2);</a>
<a class="sourceLine" id="cb211-7" title="7">      <span class="dt">void</span> Draw();</a>
<a class="sourceLine" id="cb211-8" title="8">   }</a></code></pre></div>
<p>Here we added two functions, that we will call methods or member functions, to the <strong><code>TLine</code></strong>
 class. The first method is used for initializing the line objects we 
would build. It is called a constructor. The second one is the <code>Draw</code> method itself. Therefore, to build and draw a line, we have to do:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb212-1" title="1">   TLine l(<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.8</span>,<span class="fl">0.9</span>);</a>
<a class="sourceLine" id="cb212-2" title="2">   l.Draw();</a></code></pre></div>
<p>The first line builds the object <code>l</code> by calling its constructor. The second line calls the <strong><code>TLine</code></strong><code>::Draw()</code> method of this object. You don’t need to pass any parameters to this method since it applies to the object <code>l</code>, which knows the coordinates of the line. These are internal variables <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> that were initialized by the constructor.</p>
<h2 id="inheritance-and-data-encapsulation"><span class="header-section-number">6.2</span> Inheritance and Data Encapsulation</h2>
<p>We have defined a <strong><code>TLine</code></strong> class that 
contains everything necessary to draw a line. If we want to draw an 
arrow, is it so different from drawing a line? We just have to draw a 
triangle at one end. It would be very inefficient to define the class <strong><code>TArrow</code></strong> from scratch. Fortunately, inheritance allows a class to be defined from an existing class. We would write something like:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb213-1" title="1">   <span class="kw">class</span> TArrow : <span class="kw">public</span> TLine {</a>
<a class="sourceLine" id="cb213-2" title="2">      <span class="dt">int</span> ArrowHeadSize;</a>
<a class="sourceLine" id="cb213-3" title="3">      <span class="dt">void</span> Draw();</a>
<a class="sourceLine" id="cb213-4" title="4">      <span class="dt">void</span> SetArrowSize(<span class="dt">int</span> arrowsize);</a>
<a class="sourceLine" id="cb213-5" title="5">   }</a></code></pre></div>
<p>The keyword “<code>public</code>” will be explained later. The class <strong><code>TArrow</code></strong> now contains everything that the class <strong><code>TLine</code></strong> does, and a couple of more things, the size of the arrowhead and a function that can change it. The Draw method of <strong><code>TArrow</code></strong> will draw the head and call the draw method of <strong><code>TLine</code></strong>. We just have to write the code for drawing the head!</p>
<h3 id="method-overriding"><span class="header-section-number">6.2.1</span> Method Overriding</h3>
<p>Giving the same name to a method (remember: method = member function of a class) in the child class (<strong><code>TArrow</code></strong>) as in the parent (<strong><code>TLine</code></strong>) does not give any problem. This is called <strong>overriding</strong> a method. Draw in <strong><code>TArrow</code></strong> overrides Draw in <strong><code>TLine</code></strong>. There is no possible ambiguity since, when one calls the <code>Draw()</code> method; this applies to an object whose type is known. Suppose we have an object <code>l</code> of type <strong><code>TLine</code></strong> and an object <code>a</code> of type <strong><code>TArrow</code></strong>. When you want to draw the line, you do:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb214-1" title="1">   l.Draw();</a></code></pre></div>
<p><code>Draw()</code> from <strong><code>TLine</code></strong> is called. If you do:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb215-1" title="1">   a.Draw();</a></code></pre></div>
<p><code>Draw()</code> from <strong><code>TArrow</code></strong> is called and the arrow <code>a</code> is drawn.</p>
<h3 id="data-encapsulation"><span class="header-section-number">6.2.2</span> Data Encapsulation</h3>
<p>We have seen previously the keyword “<code>public</code>”. This keyword means that every name declared public is seen by the outside world. This is opposed to “<code>private</code>” that means only the class where the name was declared private could see this name. For example, suppose we declare in <strong><code>TArrow</code></strong> the variable <code>ArrowHeadSize</code> private.</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb216-1" title="1">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb216-2" title="2">      <span class="dt">int</span> ArrowHeadSize;</a></code></pre></div>
<p>Then, only the methods (i.e.&nbsp;member functions) of <strong><code>TArrow</code></strong> will be able to access this variable. Nobody else will see it. Even the classes that we could derive from <strong><code>TArrow</code></strong> will not see it. On the other hand, if we declare the method <code>Draw()</code>
 as public, everybody will be able to see it and use it. You see that 
the character public or private does not depend of the type of argument.
 It can be a data member, a member function, or even a class. For 
example, in the case of <strong><code>TArrow</code></strong>, the base class <strong><code>TLine</code></strong> is declared as public:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb217-1" title="1">   <span class="kw">class</span> TArrow : <span class="kw">public</span> TLine { ...</a></code></pre></div>
<p>This means that all methods of <strong><code>TArrow</code></strong> will be able to access all methods of <strong><code>TLine</code></strong>, but this will be also true for anybody in the outside world. Of course, this is true if <strong><code>TLine</code></strong> accepts the outside world to see its methods/data members. If something is declared private in <strong><code>TLine</code></strong>, nobody will see it, not even <strong><code>TArrow</code></strong> members, even if <strong><code>TLine</code></strong> is declared as a public base class.</p>
<p>What if <strong><code>TLine</code></strong> is declared “<code>private</code>” instead of “<code>public</code>” ? Well, it will behave as any other name declared private in <strong><code>TArrow</code></strong>: only the data members and methods of <strong><code>TArrow</code></strong> will be able to access <strong><code>TLine</code></strong>,
 its methods and data members, nobody else. This may seem a little bit 
confusing and readers should read a good C++ book if they want more 
details. Especially since, besides public and private, a member can be 
protected. Usually, one puts private the methods that the class uses 
internally, like some utilities classes, and that the programmer does 
not want to be seen in the outside world.</p>
<p>With “good” C++ practice (which we have tried to use in ROOT), all 
data members of a class are private. This is called data encapsulation 
and is one of the strongest advantages of Object Oriented Programming 
(OOP). Private data members of a class are not visible, except to the 
class itself. So, from the outside world, if one wants to access those 
data members, one should use so called “getters” and “setters” methods, 
which are special methods used only to get or set the data members. The 
advantage is that if the programmers want to modify the inner workings 
of their classes, they can do so without changing what the user sees. 
The user does not even have to know that something has changed (for the 
better, hopefully). For example, in our <strong><code>TArrow</code></strong> class, we would have set the data member <code>ArrowHeadSize</code> private. The setter method is <code>SetArrowSize()</code>, we do not need a getter method:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb218-1" title="1">   <span class="kw">class</span> TArrow : <span class="kw">public</span> TLine {</a>
<a class="sourceLine" id="cb218-2" title="2">      <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb218-3" title="3">         <span class="dt">int</span> ArrowHeadSize;</a>
<a class="sourceLine" id="cb218-4" title="4">      <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb218-5" title="5">         <span class="dt">void</span> Draw();</a>
<a class="sourceLine" id="cb218-6" title="6">         <span class="dt">void</span> SetArrowSize(<span class="dt">int</span> arrowsize);</a>
<a class="sourceLine" id="cb218-7" title="7">   }</a></code></pre></div>
<p>To define an arrow object you call the constructor. This will also call the constructor of <strong><code>TLine</code></strong>, which is the parent class of <strong><code>TArrow</code></strong>, automatically. Then we can call any of the line or arrow public methods:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb219-1" title="1">root[] TArrow *myarrow = <span class="kw">new</span> TArrow(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">89</span>,<span class="dv">124</span>);</a>
<a class="sourceLine" id="cb219-2" title="2">root[] myarrow-&gt;SetArrowSize(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb219-3" title="3">root[] myarrow-&gt;Draw();</a></code></pre></div>
<h2 id="creating-objects-on-the-stack-and-heap"><span class="header-section-number">6.3</span> Creating Objects on the Stack and Heap</h2>
<p>To explain how objects are created on the stack and on the heap we will use the <code>Quad</code> class. You can find the definition in <code>$ROOTSYS/tutorials/quadp/Quad.h</code> and <code>Quad.cxx</code>. The <code>Quad</code> class has four methods. The constructor and destructor, <code>Evaluate</code> that evaluates <code>ax**2 + bx +c</code>, and <code>Solve</code> which solves the quadratic equation <code>ax**2 + bx +c = 0</code>.</p>
<p><code>Quad.h</code> :</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb220-1" title="1">   <span class="kw">class</span> Quad {</a>
<a class="sourceLine" id="cb220-2" title="2">      <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb220-3" title="3">         Quad(<span class="dt">Float_t</span> a, <span class="dt">Float_t</span> b, <span class="dt">Float_t</span> c);</a>
<a class="sourceLine" id="cb220-4" title="4">         ~Quad();</a>
<a class="sourceLine" id="cb220-5" title="5">         <span class="dt">Float_t</span> Evaluate(<span class="dt">Float_t</span> x) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb220-6" title="6">         <span class="dt">void</span> Solve() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb220-7" title="7">      <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb220-8" title="8">         <span class="dt">Float_t</span> fA;</a>
<a class="sourceLine" id="cb220-9" title="9">         <span class="dt">Float_t</span> fB;</a>
<a class="sourceLine" id="cb220-10" title="10">         <span class="dt">Float_t</span> fC;</a>
<a class="sourceLine" id="cb220-11" title="11">   };</a></code></pre></div>
<p><code>Quad.cxx</code>:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb221-1" title="1">   <span class="pp">#include </span><span class="im">&lt;iostream.h&gt;</span></a>
<a class="sourceLine" id="cb221-2" title="2">   <span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></a>
<a class="sourceLine" id="cb221-3" title="3">   <span class="pp">#include </span><span class="im">"Quad.h"</span></a>
<a class="sourceLine" id="cb221-4" title="4"></a>
<a class="sourceLine" id="cb221-5" title="5">   Quad::Quad(<span class="dt">Float_t</span> a, <span class="dt">Float_t</span> b, <span class="dt">Float_t</span> c) {</a>
<a class="sourceLine" id="cb221-6" title="6">      fA = a;</a>
<a class="sourceLine" id="cb221-7" title="7">      fB = b;</a>
<a class="sourceLine" id="cb221-8" title="8">      fC = c;</a>
<a class="sourceLine" id="cb221-9" title="9">   }</a>
<a class="sourceLine" id="cb221-10" title="10">   Quad::~Quad() {</a>
<a class="sourceLine" id="cb221-11" title="11">      Cout &lt;&lt;<span class="st">"deleting object with coeffts: "</span>&lt;&lt; fA &lt;&lt; <span class="st">","</span> &lt;&lt; fB &lt;&lt; <span class="st">","</span></a>
<a class="sourceLine" id="cb221-12" title="12">                                             &lt;&lt; fC &lt;&lt; endl;</a>
<a class="sourceLine" id="cb221-13" title="13">   }</a>
<a class="sourceLine" id="cb221-14" title="14">   <span class="dt">Float_t</span> Quad::Evaluate(<span class="dt">Float_t</span> x) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb221-15" title="15">      <span class="cf">return</span> fA*x*x + fB*x + fC;</a>
<a class="sourceLine" id="cb221-16" title="16">   }</a>
<a class="sourceLine" id="cb221-17" title="17">   <span class="dt">void</span> Quad::Solve() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb221-18" title="18">      <span class="dt">Float_t</span> temp = fB*fB - <span class="fl">4.</span>*fA*fC;</a>
<a class="sourceLine" id="cb221-19" title="19">      <span class="cf">if</span> ( temp &gt; <span class="fl">0.</span> ) {</a>
<a class="sourceLine" id="cb221-20" title="20">         temp = sqrt( temp );</a>
<a class="sourceLine" id="cb221-21" title="21">         cout &lt;&lt; <span class="st">"There are two roots: "</span> &lt;&lt; ( -fB - temp ) / (<span class="fl">2.</span>*fA)</a>
<a class="sourceLine" id="cb221-22" title="22">         &lt;&lt; <span class="st">" and "</span> &lt;&lt; ( -fB + temp ) / (<span class="fl">2.</span>*fA) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb221-23" title="23">      } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb221-24" title="24">         <span class="cf">if</span> ( temp == <span class="fl">0.</span> ) {</a>
<a class="sourceLine" id="cb221-25" title="25">            cout &lt;&lt; <span class="st">"There are two equal roots: "</span> &lt;&lt; -fB / (<span class="fl">2.</span>*fA)</a>
<a class="sourceLine" id="cb221-26" title="26">                                                  &lt;&lt; endl;</a>
<a class="sourceLine" id="cb221-27" title="27">         } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb221-28" title="28">            cout &lt;&lt; <span class="st">"There are no roots"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb221-29" title="29">         }</a>
<a class="sourceLine" id="cb221-30" title="30">      }</a>
<a class="sourceLine" id="cb221-31" title="31">   }</a></code></pre></div>
<p>Let us first look how we create an object. When we create an object by:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb222-1" title="1">root[] Quad my_object(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a></code></pre></div>
<p>We are creating an object on the stack. A FORTRAN programmer may be 
familiar with the idea; it is not unlike a local variable in a function 
or subroutine. Although there are still a few old timers who do not know
 it, FORTRAN is under no obligation to save local variables once the 
function or subroutine returns unless the SAVE statement is used. If not
 then it is likely that FORTRAN will place them on the stack and they 
will “pop off” when the RETURN statement is reached. To give an object 
more permanence it has to be placed on the heap.</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb223-1" title="1">root[] .L Quad.cxx</a>
<a class="sourceLine" id="cb223-2" title="2">root[] Quad *my_objptr = <span class="kw">new</span> Quad(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a></code></pre></div>
<p>The second line declares a pointer to <code>Quad</code> called <code>my_objptr</code>.
 From the syntax point of view, this is just like all the other 
declarations we have seen so far, i.e.&nbsp;this is a stack variable. 
The value of the pointer is set equal to</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb224-1" title="1"><span class="kw">new</span> Quad(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a></code></pre></div>
<p><code>new</code>, despite its looks, is an operator and creates an object or variable of the type that comes next, <code>Quad</code>
 in this case, on the heap. Just as with stack objects it has to be 
initialized by calling its constructor. The syntax requires that the 
argument list follows the type. This one statement has brought two items
 into existence, one on the heap and one on the stack. The heap object 
will live until the delete operator is applied to it.</p>
<p>There is no FORTRAN parallel to a heap object; variables either come 
or go as control passes in and out of a function or subroutine, or, like
 a COMMON block variables, live for the lifetime of the program. 
However, most people in HEP who use FORTRAN will have experience of a 
memory manager and the act of creating a bank is a good equivalent of a 
heap object. For those who know systems like ZEBRA, it will come as a 
relief to learn that objects do not move, C++ does not garbage collect, 
so there is never a danger that a pointer to an object becomes invalid 
for that reason. However, having created an object, it is the user’s 
responsibility to ensure that it is deleted when no longer needed, or to
 pass that responsibility onto to some other object. Failing to do that 
will result in a memory leak, one of the most common and most 
hard-to-find C++ bugs.</p>
<p>To send a message to an object via a pointer to it, you need to use the “<code>-&gt;</code>” operator e.g.:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb225-1" title="1">root[] my_objptr-&gt;Solve();</a></code></pre></div>
<p>Although we chose to call our pointer <code>my_objptr</code>, to 
emphasize that it is a pointer, heap objects are so common in an 
object-oriented program that pointer names rarely reflect the fact - you
 have to be careful that you know if you are dealing with an object or 
its pointer! Fortunately, the compiler won’t tolerate an attempt to do 
something like:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb226-1" title="1">root[] my_objptr.Solve();</a></code></pre></div>
<p>As we have seen, heap objects have to be accessed via pointers, 
whereas stack objects can be accessed directly. They can also be 
accessed via pointers:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb227-1" title="1">root[] Quad stack_quad(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a>
<a class="sourceLine" id="cb227-2" title="2">root[] Quad *stack_ptr = &amp;stack_quad;</a>
<a class="sourceLine" id="cb227-3" title="3">root[] stack_ptr-&gt;Solve();</a></code></pre></div>
<p>Here we have a <code>Quad</code> pointer that has been initialized 
with the address of a stack object. Be very careful if you take the 
address of stack objects. As we shall see soon, they are deleted 
automatically, which could leave you with an illegal pointer. Using it 
will corrupt and may as well crash the program!</p>
<p>It is time to look at the destruction of objects. A destructor is a 
special C++ function that releases resources for (or destroys) an object
 of a class. It is the opposite of a constructor that creates the object
 of a class when it is called. The compiler will provide a destructor 
that does nothing if none is provided. We will add one to our Quad class
 so that we can see when it is called. The class names the destructor 
but with a prefix ~ which is the C++ one’s complement i.e.&nbsp;bit wise
 complement, and hence has destruction overtones! We declare it in the 
.h file and define it in the <code>.cxx</code> file. It does not do much
 except print out that it has been called (still a useful debug 
technique despite today’s powerful debuggers!).</p>
<p>Now run root, load the Quad class and create a heap object:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb228-1" title="1">root[] .L Quad.cxx</a>
<a class="sourceLine" id="cb228-2" title="2">root[] Quad *my_objptr = <span class="kw">new</span> Quad(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a></code></pre></div>
<p>To delete the object:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb229-1" title="1">root[] <span class="kw">delete</span> my_objptr;</a>
<a class="sourceLine" id="cb229-2" title="2">root[] my_objptr = <span class="dv">0</span>;</a></code></pre></div>
<p>You should see the print out from its destructor. Setting the pointer
 to zero afterwards is not strictly necessary (and Cling does it 
automatically), but the object is no more accessible, and any attempt to
 use the pointer again will, as has already been stated, cause grief. So
 much for heap objects, but how are stack objects deleted? In C++, a 
stack object is deleted as soon as control leaves the innermost compound
 statement that encloses it. Therefore, it is singularly futile to do 
something like:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb230-1" title="1">root[] {  Quad my_object(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>); }</a></code></pre></div>
<p>Cling does not follow this rule; if you type in the above line, you 
will not see the destructor message. As explained in the Script lesson, 
you can load in compound statements, which would be a bit pointless if 
everything disappeared as soon as it was loaded! Instead, to reset the 
stack you have to type:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb231-1" title="1">root[] gROOT-&gt;Reset();</a></code></pre></div>
<p>This sends the Reset message via the global pointer to the ROOT 
object, which, amongst its many roles, acts as a resource manager. Start
 ROOT again and type in the following:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb232-1" title="1">root[] .L Quad.cxx</a>
<a class="sourceLine" id="cb232-2" title="2">root[] Quad my_object(<span class="fl">1.</span>,<span class="fl">2.</span>,-<span class="fl">3.</span>);</a>
<a class="sourceLine" id="cb232-3" title="3">root[] Quad *my_objptr = <span class="kw">new</span> Quad(<span class="fl">4.</span>,<span class="fl">5.</span>,-<span class="fl">6.</span>);</a>
<a class="sourceLine" id="cb232-4" title="4">root[] gROOT-&gt;Reset();</a></code></pre></div>
<p>You will see that this deletes the first object but not the second. We have also painted ourselves into a corner, as <code>my_objptr</code> was also on the stack. This command will fail.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb233-1" title="1">root[] my_objptr-&gt;Solve();</a></code></pre></div>
<p>Cling no longer knows what <code>my_objptr</code> is. This is a great
 example of a memory leak; the heap object exists but we have lost our 
way to access it. In general, this is not a problem. If any object will 
outlive the compound statement in which it was created then a more 
permanent pointer will point to it, which frequently is part of another 
heap object. See Resetting the Interpreter Environment in the chapter 
“Cling the C++ Interpreter”.</p>
<h1 id="the-c-interpreter-cling"><span class="header-section-number">7</span> The C++ Interpreter Cling</h1>
<p></p>
<p>ROOT has a C++ interpreter called <em>cling</em> built in. It is used
 for the prompt, both C++ and Python. It also serves as a source of 
information to store C++ objects, and provides the back-end for ROOT’s 
signal/slot and plug-in mechanisms.</p>
<p>This chapter focuses on the parts of <em>cling</em> that you will encounter while interacting with ROOT.</p>
<h2 id="the-root-prompt"><span class="header-section-number">7.1</span> The ROOT Prompt</h2>
<p>Start up a ROOT session by typing <code>root</code> at the system prompt.</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb234-1" title="1"><span class="er">$</span> root</a>
<a class="sourceLine" id="cb234-2" title="2">   -------------------------------------------------------------------------</a>
<a class="sourceLine" id="cb234-3" title="3">  | Welcome to ROOT <span class="fl">6.10</span>/<span class="bn">01</span>                             http:<span class="co">//root.cern.ch |</span></a>
<a class="sourceLine" id="cb234-4" title="4">  |                                            (c) <span class="dv">1995</span>-<span class="dv">2017</span>, The ROOT Team |</a>
<a class="sourceLine" id="cb234-5" title="5">  | Built <span class="cf">for</span> macosx64                                                      |</a>
<a class="sourceLine" id="cb234-6" title="6">  | From heads/v6-<span class="dv">10</span>-<span class="bn">00</span>-patches<span class="er">@</span>v6-<span class="dv">10</span>-<span class="bn">00</span>-<span class="dv">25</span>-g9f78c3a, Jul <span class="bn">03</span> <span class="dv">2017</span>, <span class="dv">11</span>:<span class="dv">39</span>:<span class="dv">44</span> |</a>
<a class="sourceLine" id="cb234-7" title="7">  | Try <span class="ch">'.</span><span class="er">help</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">demo</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">license</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">credits</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">quit</span><span class="ch">'</span>/<span class="ch">'.</span><span class="er">q</span><span class="ch">'</span>              |</a>
<a class="sourceLine" id="cb234-8" title="8">   -------------------------------------------------------------------------</a>
<a class="sourceLine" id="cb234-9" title="9"></a>
<a class="sourceLine" id="cb234-10" title="10">root [<span class="dv">0</span>]</a></code></pre></div>
<p>Now we create a <code>TLine</code> object:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb235-1" title="1">root [<span class="dv">1</span>] TLine l;</a>
<a class="sourceLine" id="cb235-2" title="2">root [<span class="dv">2</span>] l.Print()</a>
<a class="sourceLine" id="cb235-3" title="3">TLine  X1=<span class="fl">0.000000</span> Y1=<span class="fl">0.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb235-4" title="4">root [<span class="dv">3</span>] l.SetX1(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb235-5" title="5">root [<span class="dv">4</span>] l.SetY1(<span class="dv">11</span>)</a>
<a class="sourceLine" id="cb235-6" title="6">root [<span class="dv">5</span>] l.Print()</a>
<a class="sourceLine" id="cb235-7" title="7">TLine  X1=<span class="fl">10.000000</span> Y1=<span class="fl">11.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb235-8" title="8">root [<span class="dv">6</span>] .g l</a>
<a class="sourceLine" id="cb235-9" title="9">.g l</a>
<a class="sourceLine" id="cb235-10" title="10">ROOT_prompt_0     <span class="dv">1</span> (address: NA) <span class="kw">class</span> TLine l, size = <span class="dv">72</span></a>
<a class="sourceLine" id="cb235-11" title="11">root [<span class="dv">7</span>] l.GetX1();</a>
<a class="sourceLine" id="cb235-12" title="12">root [<span class="dv">8</span>] l.GetX1()</a>
<a class="sourceLine" id="cb235-13" title="13">(<span class="dt">Double_t</span>) <span class="fl">1.000000e+01</span></a></code></pre></div>
<p>Note some of the features of the ROOT prompt: - Terminating with ‘<code>;</code>‘ is not required, see “C++ Extensions To Ease Scripting” below. - <code>Emacs</code> style command line editing. - Raw interpreter commands start with a dot; <code>.g l</code> for instance shows the interpreter information on the global called <code>l</code>. - To show the result of an expression just do not type the trailing <code>;</code>.</p>
<p>For the further examples we will “abbreviate” <code>root [0]</code> etc by <code>root []</code>.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb236-1" title="1">root [] .<span class="kw">class</span> TLine</a>
<a class="sourceLine" id="cb236-2" title="2">===========================================================================</a>
<a class="sourceLine" id="cb236-3" title="3"><span class="kw">class</span> TLine</a>
<a class="sourceLine" id="cb236-4" title="4">SIZE: <span class="dv">72</span> <span class="dt">FILE</span>: TLine.h LINE: <span class="dv">39</span></a>
<a class="sourceLine" id="cb236-5" title="5">Base classes: --------------------------------------------------------</a>
<a class="sourceLine" id="cb236-6" title="6"><span class="bn">0x20</span>       <span class="kw">public</span> TAttBBox<span class="dv">2</span><span class="er">D</span></a>
<a class="sourceLine" id="cb236-7" title="7">List of member variables --------------------------------------------------</a>
<a class="sourceLine" id="cb236-8" title="8">TLine.h          <span class="dv">42</span> <span class="bn">0x28</span>       <span class="kw">protected</span>: <span class="dt">Double_t</span> fX<span class="dv">1</span></a>
<a class="sourceLine" id="cb236-9" title="9">TLine.h          <span class="dv">43</span> <span class="bn">0x30</span>       <span class="kw">protected</span>: <span class="dt">Double_t</span> fY<span class="dv">1</span></a>
<a class="sourceLine" id="cb236-10" title="10">TLine.h          <span class="dv">44</span> <span class="bn">0x38</span>       <span class="kw">protected</span>: <span class="dt">Double_t</span> fX<span class="dv">2</span></a>
<a class="sourceLine" id="cb236-11" title="11">TLine.h          <span class="dv">45</span> <span class="bn">0x40</span>       <span class="kw">protected</span>: <span class="dt">Double_t</span> fY<span class="dv">2</span></a>
<a class="sourceLine" id="cb236-12" title="12">TLine.h          <span class="dv">50</span> <span class="bn">0x0</span>      <span class="kw">public</span>: <span class="kw">enum</span> TLine::&lt;anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:<span class="dv">49</span>:<span class="dv">4</span>&gt; kLineNDC</a>
<a class="sourceLine" id="cb236-13" title="13">TLine.h          <span class="dv">51</span> <span class="bn">0x0</span>      <span class="kw">public</span>: <span class="kw">enum</span> TLine::&lt;anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:<span class="dv">49</span>:<span class="dv">4</span>&gt; kVertical</a>
<a class="sourceLine" id="cb236-14" title="14">TLine.h          <span class="dv">52</span> <span class="bn">0x0</span>      <span class="kw">public</span>: <span class="kw">enum</span> TLine::&lt;anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:<span class="dv">49</span>:<span class="dv">4</span>&gt; kHorizontal</a>
<a class="sourceLine" id="cb236-15" title="15">TLine.h          <span class="dv">94</span> <span class="bn">0x0</span>      <span class="kw">private</span>: <span class="at">static</span> <span class="kw">class</span> TClass *fgIsA</a>
<a class="sourceLine" id="cb236-16" title="16">List of member functions :---------------------------------------------------</a>
<a class="sourceLine" id="cb236-17" title="17">filename     line:size busy function type <span class="kw">and</span> name</a>
<a class="sourceLine" id="cb236-18" title="18">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: TLine();</a>
<a class="sourceLine" id="cb236-19" title="19">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: TLine(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2);</a>
<a class="sourceLine" id="cb236-20" title="20">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: TLine(<span class="at">const</span> TLine &amp;line);</a>
<a class="sourceLine" id="cb236-21" title="21">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> ~TLine() <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb236-22" title="22">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> Copy(<span class="kw">class</span> TObject &amp;line) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-23" title="23">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">Int_t</span> DistancetoPrimitive(<span class="dt">Int_t</span> px, <span class="dt">Int_t</span> py);</a>
<a class="sourceLine" id="cb236-24" title="24">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="kw">class</span> TLine *DrawLine(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2);</a>
<a class="sourceLine" id="cb236-25" title="25">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="kw">class</span> TLine *DrawLineNDC(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2);</a>
<a class="sourceLine" id="cb236-26" title="26">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> ExecuteEvent(<span class="dt">Int_t</span> event, <span class="dt">Int_t</span> px, <span class="dt">Int_t</span> py);</a>
<a class="sourceLine" id="cb236-27" title="27">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Double_t</span> GetX1() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-28" title="28">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Double_t</span> GetX2() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-29" title="29">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Double_t</span> GetY1() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-30" title="30">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Double_t</span> GetY2() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-31" title="31">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Bool_t</span> IsHorizontal();</a>
<a class="sourceLine" id="cb236-32" title="32">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">Bool_t</span> IsVertical();</a>
<a class="sourceLine" id="cb236-33" title="33">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> ls(<span class="dt">Option_t</span> *option = <span class="st">""</span>) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-34" title="34">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> Paint(<span class="dt">Option_t</span> *option = <span class="st">""</span>);</a>
<a class="sourceLine" id="cb236-35" title="35">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> PaintLine(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2);</a>
<a class="sourceLine" id="cb236-36" title="36">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> PaintLineNDC(<span class="dt">Double_t</span> u1, <span class="dt">Double_t</span> v1, <span class="dt">Double_t</span> u2, <span class="dt">Double_t</span> v2);</a>
<a class="sourceLine" id="cb236-37" title="37">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> Print(<span class="dt">Option_t</span> *option = <span class="st">""</span>) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-38" title="38">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SavePrimitive(<span class="bu">std::</span>ostream &amp;out, <span class="dt">Option_t</span> *option = <span class="st">""</span>);</a>
<a class="sourceLine" id="cb236-39" title="39">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetNDC(<span class="dt">Bool_t</span> isNDC = kTRUE);</a>
<a class="sourceLine" id="cb236-40" title="40">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> SetHorizontal(<span class="dt">Bool_t</span> set = kTRUE);</a>
<a class="sourceLine" id="cb236-41" title="41">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> SetVertical(<span class="dt">Bool_t</span> set = kTRUE);</a>
<a class="sourceLine" id="cb236-42" title="42">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetX1(<span class="dt">Double_t</span> x1);</a>
<a class="sourceLine" id="cb236-43" title="43">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetX2(<span class="dt">Double_t</span> x2);</a>
<a class="sourceLine" id="cb236-44" title="44">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetY1(<span class="dt">Double_t</span> y1);</a>
<a class="sourceLine" id="cb236-45" title="45">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetY2(<span class="dt">Double_t</span> y2);</a>
<a class="sourceLine" id="cb236-46" title="46">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="kw">struct</span> <span class="dt">Rectangle_t</span> GetBBox();</a>
<a class="sourceLine" id="cb236-47" title="47">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="kw">class</span> TPoint GetBBoxCenter();</a>
<a class="sourceLine" id="cb236-48" title="48">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxCenter(<span class="at">const</span> <span class="kw">class</span> TPoint &amp;p);</a>
<a class="sourceLine" id="cb236-49" title="49">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxCenterX(<span class="at">const</span> <span class="dt">Int_t</span> x);</a>
<a class="sourceLine" id="cb236-50" title="50">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxCenterY(<span class="at">const</span> <span class="dt">Int_t</span> y);</a>
<a class="sourceLine" id="cb236-51" title="51">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxX1(<span class="at">const</span> <span class="dt">Int_t</span> x);</a>
<a class="sourceLine" id="cb236-52" title="52">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxX2(<span class="at">const</span> <span class="dt">Int_t</span> x);</a>
<a class="sourceLine" id="cb236-53" title="53">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxY1(<span class="at">const</span> <span class="dt">Int_t</span> y);</a>
<a class="sourceLine" id="cb236-54" title="54">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> SetBBoxY2(<span class="at">const</span> <span class="dt">Int_t</span> y);</a>
<a class="sourceLine" id="cb236-55" title="55">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="kw">class</span> TClass *Class();</a>
<a class="sourceLine" id="cb236-56" title="56">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="at">const</span> <span class="dt">char</span> *Class_Name();</a>
<a class="sourceLine" id="cb236-57" title="57">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="dt">Version_t</span> Class_Version();</a>
<a class="sourceLine" id="cb236-58" title="58">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="dt">void</span> Dictionary();</a>
<a class="sourceLine" id="cb236-59" title="59">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="kw">class</span> TClass *IsA() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-60" title="60">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> ShowMembers(<span class="kw">class</span> TMemberInspector &amp;insp) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb236-61" title="61">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">virtual</span> <span class="dt">void</span> Streamer(<span class="kw">class</span> TBuffer &amp;);</a>
<a class="sourceLine" id="cb236-62" title="62">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> StreamerNVirtual(<span class="kw">class</span> TBuffer &amp;ClassDef_StreamerNVirtual_b);</a>
<a class="sourceLine" id="cb236-63" title="63">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="at">const</span> <span class="dt">char</span> *DeclFileName();</a>
<a class="sourceLine" id="cb236-64" title="64">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="dt">int</span> ImplFileLine();</a>
<a class="sourceLine" id="cb236-65" title="65">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="at">const</span> <span class="dt">char</span> *ImplFileName();</a>
<a class="sourceLine" id="cb236-66" title="66">(compiled)     (NA):(NA) <span class="dv">0</span> <span class="kw">public</span>: <span class="at">static</span> <span class="dt">int</span> DeclFileLine();</a>
<a class="sourceLine" id="cb236-67" title="67">root [] .&gt; test.log</a>
<a class="sourceLine" id="cb236-68" title="68">root [] l.Dump();</a>
<a class="sourceLine" id="cb236-69" title="69">root [] .&gt;</a>
<a class="sourceLine" id="cb236-70" title="70">root [] ?</a></code></pre></div>
<p>Here we see:</p>
<ul>
<li>Use <code>.class</code> as quick help and reference</li>
<li>Unix like I/O redirection using <code>.&gt; out.txt</code> and unredirection with <code>.&gt;</code></li>
<li>Use <code>?</code> to get help on all ‘‘raw’’ interpreter commands</li>
<li>Use @ to abort a multi-line command</li>
</ul>
<p>Now let us execute a multi-line command:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb237-1" title="1">root [] {</a>
<a class="sourceLine" id="cb237-2" title="2">root [] ? TLine l;</a>
<a class="sourceLine" id="cb237-3" title="3">root [] ? <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb237-4" title="4">root [] ?    l.SetX1(i);</a>
<a class="sourceLine" id="cb237-5" title="5">root [] ?    l.SetY1(i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb237-6" title="6">root [] ?    l.Print();</a>
<a class="sourceLine" id="cb237-7" title="7">root [] ? }</a>
<a class="sourceLine" id="cb237-8" title="8">root [] ? }</a>
<a class="sourceLine" id="cb237-9" title="9">TLine  X1=<span class="fl">0.000000</span> Y1=<span class="fl">1.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb237-10" title="10">TLine  X1=<span class="fl">1.000000</span> Y1=<span class="fl">2.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb237-11" title="11">TLine  X1=<span class="fl">2.000000</span> Y1=<span class="fl">3.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb237-12" title="12">TLine  X1=<span class="fl">3.000000</span> Y1=<span class="fl">4.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb237-13" title="13">TLine  X1=<span class="fl">4.000000</span> Y1=<span class="fl">5.000000</span> X2=<span class="fl">0.000000</span> Y2=<span class="fl">0.000000</span></a>
<a class="sourceLine" id="cb237-14" title="14">root [] .q</a></code></pre></div>
<p>Here we note:</p>
<ul>
<li>A multi-line command starts with a { and ends with a }.</li>
<li>Inside continuation, every line has to be correctly terminated with a ; (like in "real’’ C++).</li>
<li>All objects are created in <em>global</em> scope.</li>
<li>There is no way to back up; you are better off writing a script.</li>
<li>Use <code>.q</code> to exit root.</li>
</ul>
<h2 id="feeding-sources-files-to-root-c-scripts"><span class="header-section-number">7.2</span> Feeding Sources Files To ROOT: C++ Scripts</h2>
<p>ROOT script files (often called “Macros”) contain pure C++ code. They
 can contain a simple sequence of statements like in the multi command 
line example given above, but also arbitrarily complex class and 
function definitions.</p>
<p>The most frequent interaction with the ROOT prompt uses <code>.x</code> to “run” a file:</p>
<pre><code>root [] .x myScript.C</code></pre>
<p>This loads myScript.C into the interpreter and calls the function <code>myScript()</code>. You can pass arguments using <code>.x myScript.C(12, "A String")</code>.</p>
<p>Alternatively you can load the script and then run a function explicitly:</p>
<pre><code>root [] .L myScript.C
root [] myScript()</code></pre>
<p>The above is equivalent to <code>.x myScript.C</code>.</p>
<p>In a named script, the objects created on the stack are deleted when 
the function exits. In a common scenario you create a histogram in a 
named script on the stack. You draw the histogram, but when the function
 exits the canvas is empty and the histogram has disappeared. To avoid 
the histogram from disappearing you can create it on the heap (by using 
new). This will leave the histogram object intact, but the pointer in 
the named script scope will be “gone”. Since histograms (and trees) are 
added to the list of objects in the current directory, you can always 
retrieve them to delete them if needed.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb240-1" title="1">root[] TH1F *h = (TH1F*)gDirectory-&gt;Get(<span class="st">"myHist"</span>);              <span class="co">// or</span></a>
<a class="sourceLine" id="cb240-2" title="2">root[] TH1F *h = (TH1F*)gDirectory-&gt;GetList()-&gt;FindObject(<span class="st">"myHist"</span>);</a></code></pre></div>
<p>In addition, histograms and trees are automatically deleted when the 
current directory is closed. This will automatically take care of the 
clean up. See “Input/Output”.</p>
<h3 id="executing-a-script-from-a-script"><span class="header-section-number">7.2.1</span> Executing a Script From a Script</h3>
<p>You may want to execute a script conditionally inside another script.
 To do it you need to call the interpreter and you can do that with <code>TROOT::ProcessLine()</code>. The example <code>$ROOTSYS/tutorials/tree/cernstaff.C</code> calls a script to build the root file if it does not exist:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb241-1" title="1"><span class="dt">void</span> cernstaff() {</a>
<a class="sourceLine" id="cb241-2" title="2">   <span class="cf">if</span> (gSystem-&gt;AccessPathName(<span class="st">"cernstaff.root"</span>)) {</a>
<a class="sourceLine" id="cb241-3" title="3">      gROOT-&gt;ProcessLine(<span class="st">".x cernbuild.C"</span>);</a>
<a class="sourceLine" id="cb241-4" title="4">   }</a></code></pre></div>
<p><code>ProcessLine</code> takes a parameter, which is a pointer to an <code>int</code> or to a <code>TInterpreter::EErrorCode</code> to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in <code>enum TInterpreter::EErrorCode</code> with <code>TInterpreter::kSuccess</code> being the value for a successful execution.</p>
<h3 id="executing-a-script-from-the-invocation"><span class="header-section-number">7.2.2</span> Executing a Script From the Invocation</h3>
<p>Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:</p>
<pre><code>$ root -l -b 'myCode.C("some String", 12)'</code></pre>
<p>The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.</p>
<p>ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:</p>
<pre><code>$ root -l -b -e 'gROOT-&gt;ProcessLine(".x myCode.C(\"some String\", 12)");'</code></pre>
<h2 id="c-extensions-to-ease-scripting"><span class="header-section-number">7.3</span> C++ Extensions To Ease Scripting</h2>
<p>In the next example, we demonstrate three of the most important 
extensions ROOT and Cling make to C++. Start ROOT in the directory <code>$ROOTSYS/tutorials</code> (make sure to have first run <code>.x hsimple.C</code>):</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb244-1" title="1">root [<span class="dv">0</span>] f = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>)</a>
<a class="sourceLine" id="cb244-2" title="2">(<span class="kw">class</span> TFile *) <span class="bn">0x4045e690</span></a>
<a class="sourceLine" id="cb244-3" title="3">root [<span class="dv">1</span>] f-&gt;ls()</a>
<a class="sourceLine" id="cb244-4" title="4">TFile**         hsimple.root</a>
<a class="sourceLine" id="cb244-5" title="5">TFile*         hsimple.root</a>
<a class="sourceLine" id="cb244-6" title="6">KEY: TH1F     hpx;<span class="dv">1</span>   This is the px distribution</a>
<a class="sourceLine" id="cb244-7" title="7">KEY: TH2F     hpxpy;<span class="dv">1</span> py ps px</a>
<a class="sourceLine" id="cb244-8" title="8">KEY: THProfile        hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb244-9" title="9">KEY: TNtuple  ntuple;<span class="dv">1</span>        Demo ntuple</a>
<a class="sourceLine" id="cb244-10" title="10">root [<span class="dv">2</span>] hpx-&gt;Draw()</a>
<a class="sourceLine" id="cb244-11" title="11">Warning in &lt;MakeDefCanvas&gt;: creating a <span class="cf">default</span> canvas with name c<span class="dv">1</span></a>
<a class="sourceLine" id="cb244-12" title="12">root [<span class="dv">3</span>] .q</a></code></pre></div>
<p>The <code>root [0]</code> command shows the first extension; the declaration of <code>f</code> may be omitted as a shortcut for <code>auto</code>. Cling will correctly create <code>f</code> as pointer to object of class <code>TFile</code>. Nonetheless we recommend to use <code>auto f = new TFile("hsimple.root")</code>.</p>
<p>The second extension is more important. In case Cling cannot find an 
object being referenced, it will ask ROOT to search for an object with 
an identical name in the search path defined by <code>TROOT::FindObject()</code>.
 If ROOT finds the object, it returns a pointer to this object to Cling 
and a pointer to its class definition and Cling will execute the 
requested member function. This shortcut is quite natural for an 
interactive system and saves much typing. In this example, ROOT searches
 for <code>hpx</code> and finds it in <code>hsimple.root.</code></p>
<p>The next, fundamental extension is shown below. There is no need to 
put a semicolon at the end of a line. When you leave it off the value of
 the expression will be printed on the next line. For example:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb245-1" title="1">root[] <span class="dv">23</span>+<span class="dv">5</span></a>
<a class="sourceLine" id="cb245-2" title="2">(<span class="dt">int</span>)<span class="dv">28</span></a>
<a class="sourceLine" id="cb245-3" title="3">root[] <span class="dv">23</span>+<span class="dv">5</span>;</a>
<a class="sourceLine" id="cb245-4" title="4">root[] TMath::Sin</a>
<a class="sourceLine" id="cb245-5" title="5">(<span class="dt">Double_t</span> (*)(<span class="dt">Double_t</span>)) Function <span class="er">@</span><span class="bn">0x7ffff7ebb090</span></a>
<a class="sourceLine" id="cb245-6" title="6">  at include/TMath.h:<span class="dv">418</span>:</a>
<a class="sourceLine" id="cb245-7" title="7"><span class="kw">inline</span> <span class="dt">Double_t</span> TMath::Sin(<span class="dt">Double_t</span> x)</a>
<a class="sourceLine" id="cb245-8" title="8">   { <span class="cf">return</span> sin(x); }</a></code></pre></div>
<p>Be aware that these extensions do not work when a compiler replaces 
the interpreter. Your code will not compile, hence when writing large 
scripts, it is best to stay away from these shortcuts. It will save you 
from having problems compiling your scripts using a real C++ compiler.</p>
<h2 id="aclic-compiling-scripts-into-libraries"><span class="header-section-number">7.4</span> ACLiC: Compiling Scripts Into Libraries</h2>
<p>Instead of having Cling interpret your script there is a way to have 
your scripts compiled, linked and dynamically loaded using the C++ 
compiler and linker. The advantage of this is that your scripts will run
 with the speed of compiled C++ and that you can use language constructs
 that are not fully supported by Cling. On the other hand, you cannot 
use any Cling shortcuts (see “C++ Extensions To Ease Scripting” above) 
and for small scripts, the overhead of the compile/link cycle might be 
larger than just executing the script in the interpreter.</p>
<p>ACLiC will build a dictionary and a shared library from your C++ 
script, using the compiler and the compiler options that were used to 
compile the ROOT executable. You do not have to write a Makefile 
remembering the correct compiler options, and you do not have to exit 
ROOT.</p>
<h3 id="usage"><span class="header-section-number">7.4.1</span> Usage</h3>
<p>Before you can compile your interpreted script you need to add 
include statements for the classes used in the script. Once you did 
that, you can build and load a shared library containing your script. To
 load it use the command <code>.L</code> and append the file name with a <code>+</code>.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb246-1" title="1">root[] .L MyScript.C+</a></code></pre></div>
<p>The + option generates the shared library and names it by taking the 
name of the file “filename” but replacing the dot before the extension 
by an underscore and by adding the shared library extension for the 
current platform. For example on most platforms, <code>hsimple.cxx</code> will generate <code>hsimple_cxx.so</code>.</p>
<p>The + command rebuild the library only if the script or any of the 
files it includes are newer than the library. When checking the 
timestamp, ACLiC generates a dependency file which name is the same as 
the library name, just replacing the ‘so’ extension by the extension 
‘d’. For example on most platforms, <code>hsimple.cxx</code> will generate <code>hsimple_cxx.d</code>.</p>
<p>To ensure that the shared library is rebuilt you can use the ++ syntax:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb247-1" title="1">root[] .L MyScript.C++</a></code></pre></div>
<p>To build, load, and execute the function with the same name as the file you can use the <code>.x</code>
 command. This is the same as executing a named script; you can also 
provide parameters. The only difference is you need to append a + or a 
++.</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb248-1" title="1">root[] .x MyScript.C+(<span class="dv">4000</span>)</a>
<a class="sourceLine" id="cb248-2" title="2">Creating shared library /home/./MyScript_C.so</a></code></pre></div>
<p>You can select whether the script in compiled with debug symbol or 
with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or 
‘++’. Without the specification, the script is compiled with the same 
level of debugging symbol and optimization as the currently running ROOT
 executable. For example:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb249-1" title="1">root[] .L MyScript.C++g</a></code></pre></div>
<p>will compile <code>MyScript.C</code> with debug symbols; usually this means giving the <code>-g</code> option to compiler.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb250-1" title="1">root[] .L MyScript.C++O</a></code></pre></div>
<p>will compile <code>MyScript.C</code> with optimizations; usually this means giving the <code>-O</code> option to compiler. The syntax:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb251-1" title="1">root[] .L MyScript.C++</a></code></pre></div>
<p>is using the default optimization level. The initial default is to 
compile with the same level of optimization as the root executable 
itself. The default can be changed by:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb252-1" title="1">root[] gSystem-&gt;SetAclicMode(TSystem::kDebug);</a>
<a class="sourceLine" id="cb252-2" title="2">root[] gSystem-&gt;SetAclicMode(TSystem::kOpt);</a></code></pre></div>
<p>Note that the commands:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb253-1" title="1">root[] .L MyScript.C+g</a>
<a class="sourceLine" id="cb253-2" title="2">root[] .L MyScript.C+O</a></code></pre></div>
<p>respectively compile <code>MyScript.C</code> with debug and 
optimization if the library does not exist yet; they will not change the
 debug and the optimization level if the library already exist and it is
 up to date. To use ACLiC from compiled code or from inside another 
macro, we recommend using <code>gROOT-&gt;ProcessLine()</code>. For example, in one script you can use ACLiC to compile and load another script.</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb254-1" title="1">gROOT-&gt;ProcessLine(<span class="st">".L MyScript.C+"</span>)</a>
<a class="sourceLine" id="cb254-2" title="2">gROOT-&gt;ProcessLine(<span class="st">".L MyScript.C++"</span>)</a></code></pre></div>
<h3 id="setting-the-include-path"><span class="header-section-number">7.4.2</span> Setting the Include Path</h3>
<p>You can get the include path by typing:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb255-1" title="1">root[] .include</a></code></pre></div>
<p>You can append to the include path by typing:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb256-1" title="1">root[] .include <span class="er">$</span>HOME/mypackage/include</a></code></pre></div>
<p>In a script you can append to the include path:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb257-1" title="1">gSystem-&gt;AddIncludePath(<span class="st">" -I$HOME/mypackage/include "</span>)</a></code></pre></div>
<p>You can also overwrite the existing include path:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb258-1" title="1">gSystem-&gt;SetIncludePath(<span class="st">" -I$HOME/mypackage/include "</span>)</a></code></pre></div>
<p>The <code>$ROOTSYS/include</code> directory is automatically appended
 to the include path, so you do not have to worry about including it. To
 add library that should be used during linking of the shared library 
use something like:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb259-1" title="1">gSystem-&gt;AddLinkedLibs(<span class="st">"-L/my/path -lanylib"</span>);</a></code></pre></div>
<p>This is especially useful for static libraries. For shared ones you 
can also simply load them before trying to compile the script:</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb260-1" title="1">gSystem-&gt;Load(<span class="st">"mydir/mylib"</span>);</a></code></pre></div>
<p>ACLiC uses the directive <code>fMakeSharedLibs</code> to create the 
shared library. If loading the shared library fails, it tries to output a
 list of missing symbols by creating an executable (on some platforms 
like OSF, this does not HAVE to be an executable) containing the script.
 It uses the directive <code>fMakeExe</code> to do so. For both directives, before passing them to <code>TSystem::Exec()</code>, it expands the variables <code>$SourceFiles</code>, <code>$SharedLib</code>, <code>$LibName</code>, <code>$IncludePath</code>, <code>$LinkedLibs</code>, <code>$ExeName</code>and<code>$ObjectFiles</code>. See <code>SetMakeSharedLib()</code>
 for more information on those variables. When the file being passed to 
ACLiC is on a read only file system, ACLiC warns the user and creates 
the library in a temporary directory:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb261-1" title="1">root[] .L readonly/t.C++</a>
<a class="sourceLine" id="cb261-2" title="2">Warning in &lt;ACLiC&gt;: /scratch/aclic/subs/./readonly is <span class="kw">not</span> writable!</a>
<a class="sourceLine" id="cb261-3" title="3">Warning in &lt;ACLiC&gt;: Output will be written to /tmp</a>
<a class="sourceLine" id="cb261-4" title="4">Info in &lt;TUnixSystem::ACLiC&gt;: creating shared library</a>
<a class="sourceLine" id="cb261-5" title="5">/tmp<span class="co">//scratch/aclic/subs/./readonly/t_C.so</span></a></code></pre></div>
<p>To select the temporary directory ACLiC looks at <code>$TEMP</code>, <code>$TEMP_DIR</code>, <code>$TEMPDIR</code>, <code>$TMP</code>, <code>$TMPDIR</code>, <code>$TMP_DIR</code>or uses <code>/tmp (</code>or <code>C:/)</code>. Also, a new interface <code>TSystem::Get/SetBuildDir</code> is introduced to let users select an alternative ‘root’ for building of the ACLiC libraries. For <code>filename/full/path/name/macro.C</code>, the library is created as <code>fBuildDir/full/path/name/macro_C.so.</code></p>
<h3 id="dictionary-generation"><span class="header-section-number">7.4.3</span> Dictionary Generation</h3>
<p>You can direct what is added to the dictionary generated by ACLiC in 
two ways. The simplest way is to add at the end of script 
(i.e.&nbsp;after the symbols have been defined) something like:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb262-1" title="1"><span class="pp">#if defined(__ROOTCLING__)</span></a>
<a class="sourceLine" id="cb262-2" title="2"><span class="pp">#pragma link C++ class MyOtherClass;</span></a>
<a class="sourceLine" id="cb262-3" title="3"><span class="pp">#endif</span></a></code></pre></div>
<p>You can also write this portion of code in a file name <code>MyScript_linkdef.h</code> where the suffix <code>'_linkdef'</code>is the prefix defined by the key <code>‘ACLiC.Linkdef</code>‘ in the currently used resource file (usually <code>.rootrc</code>or<code>$ROOTSYS/etc/system.rootrc</code>) and the prefix is the name of your script.</p>
<p>The default behavior of <code>rootcling</code> is to not link in 
(i.e.&nbsp;generate the dictionary for) any of the symbols. In 
particular, this means that the following lines are, in the general 
case, unnecessary.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb263-1" title="1"><span class="pp">#pragma link off all globals;</span></a>
<a class="sourceLine" id="cb263-2" title="2"><span class="pp">#pragma link off all classes;</span></a>
<a class="sourceLine" id="cb263-3" title="3"><span class="pp">#pragma link off all functions;</span></a></code></pre></div>
<p>This also means that linking the instantiation of a class template:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb264-1" title="1"><span class="pp">#pragma link C++ class mytemplate&lt;int&gt;;</span></a></code></pre></div>
<p>ONLY links this specific class. You need to request the generation of the iterators explicitly.</p>
<p>See the documentation of <code>rootcling</code> for details how <code>pragma</code> can be used.</p>
<p>NOTE: You should not call ACLiC with a script that has a function called <code>main()</code>.</p>
<h3 id="intermediate-steps-and-files"><span class="header-section-number">7.4.4</span> Intermediate Steps and Files</h3>
<p>ACLiC executes two steps and a third one if needed. These are:</p>
<ul>
<li>Calling <code>rootcling</code> to create a dictionary using <code>rootcling</code>.</li>
<li>Calling the compiler to build the shared library from the script.</li>
<li>If there are errors, it calls the compiler to build a dummy executable to clearly report unresolved symbols.</li>
</ul>
<p>ACLiC makes a shared library with a dictionary containing the classes
 and functions declared in the script. It also adds the classes and 
functions declared in included files with the same name as the script 
file and any of the following extensions: <code>.h</code>, <code>.hh</code>, <code>.hpp</code>, <code>.hxx</code>, <code>.hPP</code>, <code>.hXX</code>. This means that, by default, you cannot combine scripts from different files into one library by using <code>#include</code>
 statements; you will need to compile each script separately. In a 
future release, we plan to add the global variables declared in the 
script to the dictionary also. If you are curious about the specific 
calls, you can raise the ROOT debug level: gDebug=3 and ACLiC will print
 these steps. If you need to keep the intermediate files around, for 
example when debugging the script using gdb, use gDebug=7.</p>
<h3 id="moving-between-interpreter-and-compiler"><span class="header-section-number">7.4.5</span> Moving between Interpreter and Compiler</h3>
<p>The best way to develop portable scripts is to make sure you can 
always run them with both, the interpreter and with ACLiC. To do so, do 
not use the Cling extensions and program around the Cling limitations. 
When it is not possible or desirable to program around the Cling 
limitations, you can use the C preprocessor symbols defined for Cling 
and <code>rootcling</code>.</p>
<p>The preprocessor symbol <code>__CLING__</code> is defined for both ROOT and <code>rootcling</code>. The symbol <code>__ROOTCLING__</code> (and <code>__MAKECINT__</code> for backward compatibility) is only defined in <code>rootcling</code>.</p>
<p>Use <code>!defined(__CLING__) || defined(__ROOTCLING__)</code> to bracket code that needs to be seen by the compiler and <code>rootcling</code>, but will be invisible to the interpreter.</p>
<p>Use <code>!defined(__CLING__)</code>to bracket code that should be seen only by the compiler and not by Cling nor <code>rootcling.</code>For example, the following will hide the declaration and initialization of the array <code>gArray</code> from both Cling and <code>rootcling</code>.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb265-1" title="1"><span class="pp">#if !defined(__CLING__)</span></a>
<a class="sourceLine" id="cb265-2" title="2"><span class="dt">int</span> gArray[] = { <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>};</a>
<a class="sourceLine" id="cb265-3" title="3"><span class="pp">#endif</span></a></code></pre></div>
<p>Because ACLiC calls <code>rootcling</code> to build a dictionary, the declaration of <code>gArray</code> will not be included in the dictionary, and consequently, <code>gArray</code> will not be available at the command line even if ACLiC is used. Cling and <code>rootcling</code> will ignore all statements between the <code>"#if !defined</code> <code>(__CLING__)"</code> and "<code>#endif"</code>. If you want to use <code>gArray</code>
 in the same script as its declaration, you can do so. However, if you 
want use the script in the interpreter you have to bracket the usage of <code>gArray</code> between <code>#if's,</code> since the definition is not visible. If you add the following preprocessor statements:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb266-1" title="1"><span class="pp">#if !defined(__CLING__)</span></a>
<a class="sourceLine" id="cb266-2" title="2"><span class="dt">int</span> gArray[] = { <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>};</a>
<a class="sourceLine" id="cb266-3" title="3"><span class="pp">#elif defined(__ROOTCLING__)</span></a>
<a class="sourceLine" id="cb266-4" title="4"><span class="dt">int</span> gArray[];</a>
<a class="sourceLine" id="cb266-5" title="5"><span class="pp">#endif</span></a></code></pre></div>
<p><code>gArray</code> will be visible to <code>rootcling</code> but still not visible to Cling. If you use ACLiC, <code>gArray</code> will be available at the command line and be initialized properly by the compiled code.</p>
<p>We recommend you always write scripts with the needed include 
statements. In most cases, the script will still run with the 
interpreter. However, a few header files are not handled very well by 
Cling.</p>
<p>These types of headers can be included in interpreted and compiled mode:</p>
<ul>
<li><p>The subset of standard C/C++ headers defined in <code>$ROOTSYS/Cling/include.</code></p></li>
<li><p>Headers of classes defined in a previously loaded library 
(including ROOT own). The defined class must have a name known to ROOT 
(i.e.&nbsp;a class with a <code>ClassDef</code>).</p></li>
</ul>
<p>Hiding header files from <code>rootcling</code> that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb267-1" title="1"><span class="pp">#ifndef __CLING__</span></a>
<a class="sourceLine" id="cb267-2" title="2"><span class="pp">#include </span><span class="im">"TTree.h"</span></a>
<a class="sourceLine" id="cb267-3" title="3"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb267-4" title="4"><span class="kw">class</span> TTree;</a>
<a class="sourceLine" id="cb267-5" title="5"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb267-6" title="6"></a>
<a class="sourceLine" id="cb267-7" title="7"><span class="kw">class</span> subTree : <span class="kw">public</span> TTree {</a>
<a class="sourceLine" id="cb267-8" title="8">};</a></code></pre></div>
<p>In this case, <code>rootcling</code> does not have enough information about the <code>TTree</code> class to produce the correct dictionary file. If you try this, <code>rootcling</code> and compiling will be error free, however, instantiating a <code>subTree</code> object from the Cling command line will cause a fatal error. In general, it is recommended to let <code>rootcling</code> see as many header files as possible.</p>
<h2 id="classes-defined-by-scripts"><span class="header-section-number">7.5</span> Classes Defined By Scripts</h2>
<p>Lets create a small class <code>TMyClass</code> and a derived class <code>TChild</code>. The virtual method <code>TMyClass::Print()</code>is overridden in <code>TChild</code>. Save this in file called <code>script4.C</code>.</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb268-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream.h&gt;</span></a>
<a class="sourceLine" id="cb268-2" title="2"></a>
<a class="sourceLine" id="cb268-3" title="3"><span class="kw">class</span> TMyClass {</a>
<a class="sourceLine" id="cb268-4" title="4">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb268-5" title="5">      <span class="dt">float</span>   fX;     <span class="co">//x position in centimeters</span></a>
<a class="sourceLine" id="cb268-6" title="6">      <span class="dt">float</span>   fY;     <span class="co">//y position in centimeters</span></a>
<a class="sourceLine" id="cb268-7" title="7">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb268-8" title="8">      TMyClass() { fX = fY = -<span class="dv">1</span>; }</a>
<a class="sourceLine" id="cb268-9" title="9">      <span class="kw">virtual</span> <span class="dt">void</span> Print() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb268-10" title="10">      <span class="dt">void</span> SetX(<span class="dt">float</span> x) { fX = x; }</a>
<a class="sourceLine" id="cb268-11" title="11">      <span class="dt">void</span> SetY(<span class="dt">float</span> y) { fY = y; }</a>
<a class="sourceLine" id="cb268-12" title="12">};</a>
<a class="sourceLine" id="cb268-13" title="13"><span class="dt">void</span> TMyClass::Print() <span class="at">const</span>  <span class="co">// parent print method</span></a>
<a class="sourceLine" id="cb268-14" title="14">{</a>
<a class="sourceLine" id="cb268-15" title="15">   cout &lt;&lt; <span class="st">"fX = "</span> &lt;&lt; fX &lt;&lt; <span class="st">", fY = "</span> &lt;&lt; fY &lt;&lt; endl;</a>
<a class="sourceLine" id="cb268-16" title="16">}</a>
<a class="sourceLine" id="cb268-17" title="17"><span class="kw">class</span> TChild : <span class="kw">public</span> TMyClass {</a>
<a class="sourceLine" id="cb268-18" title="18">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb268-19" title="19">      <span class="dt">void</span> Print() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb268-20" title="20">};</a>
<a class="sourceLine" id="cb268-21" title="21"><span class="dt">void</span> TChild::Print() <span class="at">const</span>  <span class="co">// child print metod</span></a>
<a class="sourceLine" id="cb268-22" title="22">{</a>
<a class="sourceLine" id="cb268-23" title="23">   cout &lt;&lt; <span class="st">"This is TChild::Print()"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb268-24" title="24">   TMyClass::Print();</a>
<a class="sourceLine" id="cb268-25" title="25">}</a></code></pre></div>
<p>To execute <code>script4.C</code> do:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb269-1" title="1">root[] .L script4.C</a>
<a class="sourceLine" id="cb269-2" title="2">root[] TMyClass *a = <span class="kw">new</span> TChild</a>
<a class="sourceLine" id="cb269-3" title="3">root[] a-&gt;Print()</a>
<a class="sourceLine" id="cb269-4" title="4">This is TChild::Print()</a>
<a class="sourceLine" id="cb269-5" title="5">fX = -<span class="dv">1</span>, fY = -<span class="dv">1</span></a>
<a class="sourceLine" id="cb269-6" title="6">root[] a-&gt;SetX(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb269-7" title="7">root[] a-&gt;SetY(<span class="dv">12</span>)</a>
<a class="sourceLine" id="cb269-8" title="8">root[] a-&gt;Print()</a>
<a class="sourceLine" id="cb269-9" title="9">This is TChild::Print()</a>
<a class="sourceLine" id="cb269-10" title="10">fX = <span class="dv">10</span>, fY = <span class="dv">12</span></a>
<a class="sourceLine" id="cb269-11" title="11">root[] .<span class="kw">class</span> TMyClass</a>
<a class="sourceLine" id="cb269-12" title="12">=====================================================</a>
<a class="sourceLine" id="cb269-13" title="13"><span class="kw">class</span> TMyClass</a>
<a class="sourceLine" id="cb269-14" title="14">size=<span class="bn">0x8</span> <span class="dt">FILE</span>:script4.C LINE:<span class="dv">3</span></a>
<a class="sourceLine" id="cb269-15" title="15">List of base <span class="kw">class</span>-----------------------------------</a>
<a class="sourceLine" id="cb269-16" title="16">List of member variable------------------------------</a>
<a class="sourceLine" id="cb269-17" title="17">Defined in TMyClass</a>
<a class="sourceLine" id="cb269-18" title="18"><span class="bn">0x0</span>        <span class="kw">private</span>: <span class="dt">float</span> fX</a>
<a class="sourceLine" id="cb269-19" title="19"><span class="bn">0x4</span>        <span class="kw">private</span>: <span class="dt">float</span> fY</a>
<a class="sourceLine" id="cb269-20" title="20">List of member function------------------------------</a>
<a class="sourceLine" id="cb269-21" title="21">Defined in TMyClass</a>
<a class="sourceLine" id="cb269-22" title="22">filename       line:size busy function type <span class="kw">and</span> name</a>
<a class="sourceLine" id="cb269-23" title="23">script4.C         <span class="dv">16</span>:<span class="dv">5</span>    <span class="dv">0</span> <span class="kw">public</span>: <span class="kw">class</span> TMyClass TMyClass(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb269-24" title="24">script4.C         <span class="dv">22</span>:<span class="dv">4</span>    <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> Print(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb269-25" title="25">script4.C         <span class="dv">12</span>:<span class="dv">1</span>    <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> SetX(<span class="dt">float</span> x);</a>
<a class="sourceLine" id="cb269-26" title="26">script4.C         <span class="dv">13</span>:<span class="dv">1</span>    <span class="dv">0</span> <span class="kw">public</span>: <span class="dt">void</span> SetY(<span class="dt">float</span> y);</a>
<a class="sourceLine" id="cb269-27" title="27">root[] .q</a></code></pre></div>
<p>As you can see, an interpreted class behaves just like a compiled 
class. See “Adding a Class” for ways how to add a class with a shared 
library and with ACLiC.</p>
<h2 id="inspecting-objects"><span class="header-section-number">7.6</span> Inspecting Objects</h2>
<p>An object of a class inheriting from <code>TObject</code> can be inspected, with the <code>Inspect()</code> method. The <code>TObject::Inspect</code> method creates a window listing the current values of the objects members. For example, the next picture is of <code>TFile</code>.</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb270-1" title="1">root[] TFile f(<span class="st">"staff.root"</span>)</a>
<a class="sourceLine" id="cb270-2" title="2">root[] f.Inspect()</a></code></pre></div>
<p>You can see the pointers are in red and can be clicked on to follow the pointer to the object. If you clicked on <code>fList</code>,
 the list of objects in memory and there were none, no new canvas would 
be shown. On top of the page are the navigation buttons to see the 
previous and next screen.</p>
<figure>
<img src="ROOTUsersGuide_files/03000092.png" alt="ROOT object inspector of TFile"><figcaption>ROOT object inspector of TFile</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/03000093.png" alt="The object inspector of fKeys, the list of keys in the memory"><figcaption>The object inspector of <code>fKeys</code>, the list of keys in the memory</figcaption>
</figure>
<h1 id="object-ownership"><span class="header-section-number">8</span> Object Ownership</h1>
<p>An object has ownership of another object if it has permission to 
delete it. Usually a collection or a parent object such as a pad holds 
ownership. To prevent memory leaks and multiple attempts to delete an 
object, you need to know which objects ROOT owns and which are owned by 
you.</p>
<p>The following rules apply to the ROOT classes.</p>
<ul>
<li><p>Histograms, trees, and event lists created by the user are owned by current directory (<strong><em><code>gDirectory</code></em></strong>). When the current directory is closed or deleted the objects it owns are deleted.</p></li>
<li><p>The <code>TROOT</code> master object (<strong><em><code>gROOT</code></em></strong>) has several collections of objects. Objects that are members of these collections are owned by <strong><em><code>gROOT</code></em></strong> see "Ownership by the Master TROOT Object (gROOT).</p></li>
<li><p>Objects created by another object, for example the function object (e.g.<strong><code>TF1</code></strong>) created by the <strong><code>TH1::Fit</code>method is owned by the histogram.</strong></p></li>
<li><p>An object created by <code>DrawCopy</code> methods, is owned by the pad it is drawn in.</p></li>
</ul>
<p>If an object fits none of these cases, the user has ownership. The 
next paragraphs describe each rule and user ownership in more detail.</p>
<h2 id="ownership-by-current-directory-gdirectory"><span class="header-section-number">8.1</span> Ownership by Current Directory (gDirectory)</h2>
<p>When a histogram, tree, or event list (<strong><code>TEventList</code></strong>)
 is created, it is added to the list of objects in the current directory
 by default. You can get the list of objects in a directory and retrieve
 a pointer to a specific object with the <code>GetList</code> method. This example retrieves a histogram.</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb271-1" title="1">   TH1F *h = (TH1F*)gDirectory-&gt;GetList()-&gt;FindObject(<span class="st">"myHist"</span>);</a></code></pre></div>
<p>The method <code>TDirectory::GetList()</code> returns a <strong><code>TList</code></strong>
 of objects in the directory. It looks in memory, and is implemented in 
all ROOT collections. You can change the directory of a histogram, tree,
 or event list with the <code>SetDirectory</code> method. Here we use a histogram for an example, but the same applies to trees and event lists.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb272-1" title="1">   h-&gt;SetDirectory(newDir);</a></code></pre></div>
<p>You can also remove a histogram from a directory by using <code>SetDirectory(0)</code>.
 Once a histogram is removed from the directory, it will not be deleted 
when the directory is closed. It is now your responsibility to delete 
this histogram once you have finished with it. To change the default 
that automatically adds the histogram to the current directory, you can 
call the static function:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb273-1" title="1">   TH1::AddDirectory(kFALSE);</a></code></pre></div>
<p>Not all histograms created here after will be added to the current 
directory. In this case, you own all histogram objects and you will need
 to delete them and clean up the references. You can still set the 
directory of a histogram by calling <code>SetDirectory</code> once it has been created as described above.</p>
<p>Note that, when a file goes out of scope or is closed all objects on its object list are deleted.</p>
<h2 id="ownership-by-the-master-troot-object-groot"><span class="header-section-number">8.2</span> Ownership by the Master TROOT Object (gROOT)</h2>
<p>The master object <strong><em><code>gROOT</code></em></strong><code>,</code>
 maintains several collections of objects. For example, a canvas is 
added to the collection of canvases and it is owned by the canvas 
collection.</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb274-1" title="1">TSeqCollection* fFiles        List of TFile</a>
<a class="sourceLine" id="cb274-2" title="2">TSeqCollection* fMappedFiles  List of TMappedFile</a>
<a class="sourceLine" id="cb274-3" title="3">TSeqCollection* fSockets      List of TSocket <span class="kw">and</span> TServerSocket</a>
<a class="sourceLine" id="cb274-4" title="4">TSeqCollection* fCanvases     List of TCanvas</a>
<a class="sourceLine" id="cb274-5" title="5">TSeqCollection* fStyles       List of TStyle</a>
<a class="sourceLine" id="cb274-6" title="6">TSeqCollection* fFunctions    List of TF1, TF2, TF3</a>
<a class="sourceLine" id="cb274-7" title="7">TSeqCollection* fTasks        List of TTask</a>
<a class="sourceLine" id="cb274-8" title="8">TSeqCollection* fColors       List of TColor</a>
<a class="sourceLine" id="cb274-9" title="9">TSeqCollection* fGeometries   List of geometries</a>
<a class="sourceLine" id="cb274-10" title="10">TSeqCollection* fBrowsers     List of TBrowser</a>
<a class="sourceLine" id="cb274-11" title="11">TSeqCollection* fSpecials     List of special objects</a>
<a class="sourceLine" id="cb274-12" title="12">TSeqCollection* fCleanups     List of recursiveRemove collections</a></code></pre></div>
<p>These collections are also displayed in the root folder of the <code>Object Browser</code>. Most of these collections are self explanatory. The special cases are the collections of specials and cleanups.</p>
<h3 id="the-collection-of-specials"><span class="header-section-number">8.2.1</span> The Collection of Specials</h3>
<p>This collection contains objects of the following classes: <strong><code>TCutG</code></strong>, <strong><code>TMultiDimFit</code></strong>, <strong><code>TPrincipal</code></strong>, <strong><code>TChains</code></strong>. In addition it contains the <strong><em><code>gHtml</code></em></strong> object, <strong><em><code>gMinuit</code></em></strong> objects, and the array of contours graphs (<strong><code>TGraph</code></strong>) created when calling the <code>Draw</code> method of a histogram with the <code>"CONT</code>, <code>LIST"</code> option.</p>
<h3 id="access-to-the-collection-contents"><span class="header-section-number">8.2.2</span> Access to the Collection Contents</h3>
<p>The current content for a collection listed above can be accessed with the corresponding <code>gROOT-&gt;GetListOf</code> method (for example <code>gROOT-&gt;GetListOfCanvases</code>). In addition, <code>gROOT-&gt;GetListOfBrowsables</code>
 returns a collection of all objects visible on the left side panel in 
the browser. See the image of the Object Browser in the next figure.</p>
<figure>
<img src="ROOTUsersGuide_files/03000094.png" alt="The ROOT Object Browser"><figcaption>The ROOT Object Browser</figcaption>
</figure>
<h2 id="ownership-by-other-objects"><span class="header-section-number">8.3</span> Ownership by Other Objects</h2>
<p>When an object creates another, the creating object is the owner of the created one. For example:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb275-1" title="1">myHisto-&gt;Fit(<span class="st">"gaus"</span>)</a></code></pre></div>
<p>The call to Fit copies the global <strong><code>TF1</code></strong> Gaussian function and attaches the copy to the histogram. When the histogram is deleted, the copy is deleted also.</p>
<p>When a pad is deleted or cleared, all objects in the pad with the <code>kCanDelete</code> bit set are deleted automatically. Currently the objects created by the <code>DrawCopy</code> methods, have the <code>kCanDelete</code> bit set and are therefore owned by the pad.</p>
<h2 id="ownership-by-the-user"><span class="header-section-number">8.4</span> Ownership by the User</h2>
<p>The user owns all objects not described in one of the above cases. <strong><code>TObject</code></strong> has two bits, <code>kCanDelete</code> and <code>kMustCleanup</code>, that influence how an object is managed (in <code>TObject::fBits)</code>. These are in an enumeration in <code>TObject.h.</code> To set these bits do:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb276-1" title="1">MyObject-&gt;SetBit(kCanDelete)</a>
<a class="sourceLine" id="cb276-2" title="2">MyObject-&gt;SetBit(kMustCleanup)</a></code></pre></div>
<p>The bits can be reset and tested with the <code>TObject::ResetBit</code> and <strong><code>TObject::TestBit</code> methods.</strong></p>
<h3 id="the-kcandelete-bit"><span class="header-section-number">8.4.1</span> The kCanDelete Bit</h3>
<p>The <strong><em><code>gROOT</code></em></strong> collections (see above) own their members and will delete them regardless of the <code>kCanDelete</code> bit. In all other collections, when the collection <code>Clear</code> method is called (i.e. <strong><code>TList::Clear())</code></strong>, members with the <code>kCanDelete</code> bit set, are deleted and removed from the collection. If the <code>kCanDelete</code> bit is not set, the object is only removed from the collection but not deleted.</p>
<p>If a collection <code>Delete</code> (<code>TList::Delete()</code>) method is called, all objects in the collection are deleted without considering the <code>kCanDelete</code> bit. It is important to realize that deleting the collection (i.e.&nbsp;delete <code>MyCollection</code>), DOES NOT delete the members of the collection.</p>
<p>If the user specified <code>MyCollection-&gt;SetOwner()</code> the collection owns the objects and delete <code>MyCollection</code> will delete all its members. Otherwise, you need to:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb277-1" title="1">   <span class="co">// delete all member objects in the collection</span></a>
<a class="sourceLine" id="cb277-2" title="2">   MyCollection-&gt;Delete();</a>
<a class="sourceLine" id="cb277-3" title="3"></a>
<a class="sourceLine" id="cb277-4" title="4">   <span class="co">// and delete the collection object</span></a>
<a class="sourceLine" id="cb277-5" title="5">   <span class="kw">delete</span> MyCollection;</a></code></pre></div>
<p>Note that <code>kCanDelete</code> is automatically set by the <code>DrawCopy</code> method and the user can set it for any object. For example, the user must manage all graphics primitives. If you want <strong><code>TCanvas</code></strong> to delete the primitive you created you have to set the <code>kCanDelete</code> bit.</p>
<p>The <code>kCanDelete</code> bit setting is displayed with <code>TObject::ls()</code>. The last number is either 1 or 0 and is the <code>kCanDelete</code> bit.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb278-1" title="1">root[] TCanvas MyCanvas(<span class="st">"MyCanvas"</span>)</a>
<a class="sourceLine" id="cb278-2" title="2">root[] MyCanvas.Divide(<span class="dv">2</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb278-3" title="3">root[] MyCanvas-&gt;cd(MyCanvas_1)</a>
<a class="sourceLine" id="cb278-4" title="4">root[] hstat.Draw()             <span class="co">// hstat is an existing TH1F</span></a>
<a class="sourceLine" id="cb278-5" title="5">root[] MyCanvas-&gt;cd(MyCanvas_2)</a>
<a class="sourceLine" id="cb278-6" title="6">root[] hstat.DrawCopy()         <span class="co">// DrawCopy sets the kCanDelete bit</span></a>
<a class="sourceLine" id="cb278-7" title="7">(<span class="kw">class</span> TH1*)<span class="bn">0x88e73f8</span></a>
<a class="sourceLine" id="cb278-8" title="8">root[] MyCanvas.ls()</a>
<a class="sourceLine" id="cb278-9" title="9">Canvas Name=MyCanvas ...</a>
<a class="sourceLine" id="cb278-10" title="10"> TCanvas ... Name= MyCanvas ...</a>
<a class="sourceLine" id="cb278-11" title="11">  TPad   ... Name= MyCanvas_1 ...</a>
<a class="sourceLine" id="cb278-12" title="12">   TFrame  ...</a>
<a class="sourceLine" id="cb278-13" title="13">   OBJ: TH1F    hstat   Event Histogram : <span class="dv">0</span></a>
<a class="sourceLine" id="cb278-14" title="14">   TPaveText   ... title</a>
<a class="sourceLine" id="cb278-15" title="15">   TPaveStats  ... stats</a>
<a class="sourceLine" id="cb278-16" title="16">  TPad ... Name= MyCanvas_2 ...</a>
<a class="sourceLine" id="cb278-17" title="17">   TFrame  ...</a>
<a class="sourceLine" id="cb278-18" title="18">   OBJ: TH1F    hstat   Event Histogram : <span class="dv">1</span></a>
<a class="sourceLine" id="cb278-19" title="19">   TPaveText   ... title</a>
<a class="sourceLine" id="cb278-20" title="20">TPaveStats  ... stats</a></code></pre></div>
<h3 id="the-kmustcleanup-bit"><span class="header-section-number">8.4.2</span> The kMustCleanup Bit</h3>
<p>When the <code>kMustCleanup</code> bit is set, the object destructor will remove the object and its references from all collections in the clean up collection (<strong><em><code>gROOT</code></em></strong><code>::fCleanups</code>). An object can be in several collections, for example if an object is in a browser and on two canvases. If the <code>kMustCleanup</code> bit is set, it will be removed automatically from the browser and both canvases when the destructor of the object is called.</p>
<p>The <code>kMustCleanup</code> bit is set:</p>
<ul>
<li><p>When an object is added to a pad (or canvas) in <code>TObject::AppendPad</code>.</p></li>
<li><p>When an object is added to a <strong><code>TBrowser</code></strong> with <strong><code>TBrowser</code></strong><code>::Add</code>.</p></li>
<li><p>When an object is added to a <code>TFolder with</code><strong><code>TFolder</code></strong><code>::Add</code>.</p></li>
<li><p>When creating an inspector canvas with <code>TInspectCanvas::Inspector</code>.</p></li>
<li><p>When creating a <strong><code>TCanvas</code></strong>.</p></li>
<li><p>When painting a frame for a pad, the frame’s <code>kMustCleanup</code> is set in <code>TPad::PaintPadFrame</code></p></li>
</ul>
<p>The user can add their own collection to the collection of clean ups,
 to take advantage of the automatic garbage collection. For example:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb279-1" title="1">   <span class="co">// create two list</span></a>
<a class="sourceLine" id="cb279-2" title="2">   TList *myList1, *myList2;</a>
<a class="sourceLine" id="cb279-3" title="3"></a>
<a class="sourceLine" id="cb279-4" title="4">   <span class="co">// add both to of clean ups</span></a>
<a class="sourceLine" id="cb279-5" title="5">   gROOT-&gt;GetListOfCleanUps()-&gt;Add(myList1);</a>
<a class="sourceLine" id="cb279-6" title="6">   gROOT-&gt;GetListOfCleanUps()-&gt;Add(myList2);</a>
<a class="sourceLine" id="cb279-7" title="7"></a>
<a class="sourceLine" id="cb279-8" title="8">   <span class="co">// assuming myObject is in myList1 and myList2, when calling:</span></a>
<a class="sourceLine" id="cb279-9" title="9">   <span class="kw">delete</span> myObject;</a>
<a class="sourceLine" id="cb279-10" title="10"></a>
<a class="sourceLine" id="cb279-11" title="11">   <span class="co">// the object is deleted from both lists</span></a></code></pre></div>
<h1 id="graphics-and-the-graphical-user-interface"><span class="header-section-number">9</span> Graphics and the Graphical User Interface</h1>
<p>Graphical capabilities of ROOT range from 2D objects (lines, 
polygons, arrows) to various plots, histograms, and 3D graphical 
objects. In this chapter, we are going to focus on principals of 
graphics and 2D objects. Plots and histograms are discussed in a chapter
 of their own.</p>
<h2 id="drawing-objects"><span class="header-section-number">9.1</span> Drawing Objects</h2>
<p>In ROOT, most objects derive from a base class <strong><code>TObject</code></strong>. This class has a virtual method <code>Draw()</code>
 so all objects are supposed to be able to be “drawn”. The basic 
whiteboard on which an object is drawn is called a canvas (defined by 
the class <strong><code>TCanvas</code></strong>). If several canvases 
are defined, there is only one active at a time. One draws an object in 
the active canvas by using the statement:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb280-1" title="1">object.Draw()</a></code></pre></div>
<p>This instructs the object “<code>object</code>” to draw itself. If no canvas is opened, a default one (named “<code>c1</code>”) is instantiated and is drawn.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb281-1" title="1">root[] TLine a(<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.6</span>,<span class="fl">0.6</span>)</a>
<a class="sourceLine" id="cb281-2" title="2">root[] a.Draw()</a>
<a class="sourceLine" id="cb281-3" title="3">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a></code></pre></div>
<p>The first statement defines a line and the second one draws it. A default canvas is drawn since there was no opened one.</p>
<h2 id="interacting-with-graphical-objects"><span class="header-section-number">9.2</span> Interacting with Graphical Objects</h2>
<p>When an object is drawn, one can interact with it. For example, the 
line drawn in the previous paragraph may be moved or transformed. One 
very important characteristic of ROOT is that transforming an object on 
the screen will also transform it in memory. One actually interacts with
 the real object, not with a copy of it on the screen. You can try for 
instance to look at the starting X coordinate of the line:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb282-1" title="1">root[] a.GetX1()</a>
<a class="sourceLine" id="cb282-2" title="2">(<span class="dt">double</span>)<span class="fl">1.000000000e-1</span></a></code></pre></div>
<p><code>X1</code> is the <code>x</code> value of the starting 
coordinate given in the definition above. Now move it interactively by 
clicking with the left mouse button in the line’s middle and try to do 
again:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb283-1" title="1">root[] a.GetX1()</a>
<a class="sourceLine" id="cb283-2" title="2">(<span class="dt">Double_t</span>)<span class="fl">1.31175468483816005e-01</span></a></code></pre></div>
<p>You do not obtain the same result as before, the coordinates of ‘<code>a</code>’ have changed. As said, interacting with an object on the screen changes the object in memory.</p>
<h3 id="moving-resizing-and-modifying-objects"><span class="header-section-number">9.2.1</span> Moving, Resizing and Modifying Objects</h3>
<p>Changing the graphic objects attributes can be done with the GUI or 
programmatically. First, let’s see how it is done in the GUI.</p>
<h4 id="the-left-mouse-button"><span class="header-section-number">9.2.1.1</span> The Left Mouse Button</h4>
<p>As was just seen moving or resizing an object is done with the left 
mouse button. The cursor changes its shape to indicate what may be done:</p>
<p>Point the object or one part of it: <img src="ROOTUsersGuide_files/02000095.jpg"> <img src="ROOTUsersGuide_files/02000096.jpg"></p>
<p>Rotate: <img src="ROOTUsersGuide_files/02000097.jpg"></p>
<p>Resize (exists also for the other directions): <img src="ROOTUsersGuide_files/02000098.jpg"> <img src="ROOTUsersGuide_files/02000099.jpg"></p>
<p>Enlarge (used for text): <img src="ROOTUsersGuide_files/0200009A.jpg"></p>
<p>Move: <img src="ROOTUsersGuide_files/0200009B.jpg"></p>
<p>Here are some examples of:</p>
<p>Moving: <img src="ROOTUsersGuide_files/0200009C.jpg"> Resizing: <img src="ROOTUsersGuide_files/0200009D.jpg"></p>
<p>Rotating: <img src="ROOTUsersGuide_files/0200009E.jpg"> <img src="ROOTUsersGuide_files/0300009F.png"></p>
<h4 id="with-c-statements-programmatically"><span class="header-section-number">9.2.1.2</span> With C++ Statements (Programmatically)</h4>
<p>How would one move an object in a script? Since there is a tight 
correspondence between what is seen on the screen and the object in 
memory, changing the object changes it on the screen. For example, try 
to do:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb284-1" title="1">root[] a.SetX1(<span class="fl">0.9</span>)</a></code></pre></div>
<p>This should change one of the coordinates of our line, but nothing 
happens on the screen. Why is that? In short, the canvas is not updated 
with each change for performance reasons. See “Updating the Pad”.</p>
<h3 id="selecting-objects"><span class="header-section-number">9.2.2</span> Selecting Objects</h3>
<h4 id="the-middle-mouse-button"><span class="header-section-number">9.2.2.1</span> The Middle Mouse Button</h4>
<p>Objects in a canvas, as well as in a pad, are stacked on top of each 
other in the order they were drawn. Some objects may become “active” 
objects, which mean they are reordered to be on top of the others. To 
interactively make an object “active”, you can use the middle mouse 
button. In case of canvases or pads, the border becomes highlighted when
 it is active.</p>
<h4 id="with-c-statements-programmatically-1"><span class="header-section-number">9.2.2.2</span> With C++ Statements (Programmatically)</h4>
<p>Frequently we want to draw in different canvases or pads. By default,
 the objects are drawn in the active canvas. To activate a canvas you 
can use the <code>TPad::cd()</code> method.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb285-1" title="1">root[] c1-&gt;cd()</a></code></pre></div>
<h3 id="context-menus-the-right-mouse-button"><span class="header-section-number">9.2.3</span> Context Menus: the Right Mouse Button</h3>
<p>The context menus are a way to interactively call certain methods of 
an object. When designing a class, the programmer can add methods to the
 context menu of the object by making minor changes to the header file.</p>
<h4 id="using-context-menus"><span class="header-section-number">9.2.3.1</span> Using Context Menus</h4>
<p>On a ROOT canvas, you can right-click on any object and see the context menu for it. The script <code>hsimple.C</code>
 draws a histogram. The image below shows the context menus for some of 
the objects on the canvas. Next picture shows that drawing a simple 
histogram involves as many as seven objects. When selecting a method 
from the context menu and that method has options, the user will be 
asked for numerical values or strings to fill in the option. For 
example, <code>TAxis::SetTitle</code> will prompt you for a string to use for the axis title.</p>
<figure>
<img src="ROOTUsersGuide_files/030000A0.png" alt="Context menus of different objects in a canvas"><figcaption>Context menus of different objects in a canvas</figcaption>
</figure>
<h4 id="structure-of-the-context-menus"><span class="header-section-number">9.2.3.2</span> Structure of the Context Menus</h4>
<p>The curious reader will have noticed that each entry in the context 
menu corresponds to a method of the class. Look for example to the menu 
named <code>TAxis::xaxis</code>. <code>xaxis</code> is the name of the object and <strong><code>TAxis</code></strong> the name of its class. If we look at the list of <strong><code>TAxis</code></strong> methods, for example in <a href="http://root.cern.ch/root/htmldoc/TAxis.html" class="uri">http://root.cern.ch/root/htmldoc/TAxis.html</a>, we see the methods <code>SetTimeDisplay()</code> and<code>UnZoom()</code>, which appear also in the context menu.</p>
<p>There are several divisions in the context menu, separated by lines. 
The top division is a list of the class methods; the second division is a
 list of the parent class methods. The subsequent divisions are the 
methods other parent classes in case of multiple inheritance. For 
example, see the <code>TPaveText::title context menu.</code> A <strong><code>TPaveText</code></strong> inherits from <strong><code>TAttLine</code></strong>, which has the method <code>SetLineAttributes()</code>.</p>
<h4 id="adding-context-menus-for-a-class"><span class="header-section-number">9.2.3.3</span> Adding Context Menus for a Class</h4>
<p>For a method to appear in the context menu of the object it has to be marked by <code>// *MENU*</code> in the header file. Below is the line from <code>TAttLine.h</code> that adds the <code>SetLineAttribute</code> method to the context menu.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb286-1" title="1"><span class="kw">virtual</span> <span class="dt">void</span>  SetLineAttributes(); <span class="co">// *MENU*</span></a></code></pre></div>
<p>Nothing else is needed, since Cling knows the classes and their 
methods. It takes advantage of that to create the context menu on the 
fly when the object is clicking on. If you click on an axis, ROOT will 
ask the interpreter what are the methods of the <strong><code>TAxis</code></strong> and which ones are set for being displayed in a context menu.</p>
<p>Now, how does the interpreter know this? Remember, when you build a class that you want to use in the ROOT environment, you use <code>rootcling</code>
 that builds the so-called stub functions and the dictionary. These 
functions and the dictionary contain the knowledge of the used classes. 
To do this, <code>rootcling</code> parses all the header files. ROOT has
 defined some special syntax to inform Cling of certain things, this is 
done in the comments so that the code still compiles with a C++ 
compiler.</p>
<p>For example, you have a class with a <code>Draw()</code> method, 
which will display itself. You would like a context menu to appear when 
on clicks on the image of an object of this class. The recipe is the 
following:</p>
<ul>
<li><p>The class has to contain the <code>ClassDef/ClassImp</code> macros</p></li>
<li><p>For each method you want to appear in the context menu, put a comment after the declaration containing <code>*MENU*</code> or <code>*TOGGLE*</code> depending on the behavior you expect. One usually uses Set methods (setters). The <code>*TOGGLE*</code> comment is used to toggle a <code>boolean</code> data field. In that case, it is safe to call the data field <code>fMyBool</code> where <code>MyBool</code> is the name of the setter <code>SetMyBool</code>. Replace <code>MyBool</code> with your own <code>boolean</code> variable.</p></li>
<li><p>You can specify arguments and the data members in which to store the arguments.</p></li>
</ul>
<p>For example:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb287-1" title="1"><span class="kw">class</span> MyClass : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb287-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb287-3" title="3">   <span class="dt">int</span>      fV1;   <span class="co">// first variable</span></a>
<a class="sourceLine" id="cb287-4" title="4">   <span class="dt">double</span>   fV2;   <span class="co">// second variable</span></a>
<a class="sourceLine" id="cb287-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb287-6" title="6">   <span class="dt">int</span>    GetV1() {<span class="cf">return</span> fV1;}</a>
<a class="sourceLine" id="cb287-7" title="7">   <span class="dt">double</span> GetV2() {<span class="cf">return</span> fV2;}</a>
<a class="sourceLine" id="cb287-8" title="8">   <span class="dt">void</span>   SetV1(<span class="dt">int</span> x1) { fV1 = x1;}     <span class="co">// *MENU*</span></a>
<a class="sourceLine" id="cb287-9" title="9">   <span class="dt">void</span>   SetV2(<span class="dt">double</span> d2) { fV2 = d2;}  <span class="co">// *MENU*</span></a>
<a class="sourceLine" id="cb287-10" title="10">   <span class="dt">void</span>   SetBoth(<span class="dt">int</span> x1, <span class="dt">double</span> d2) {fV1 = x1; fV2 = d2;}</a>
<a class="sourceLine" id="cb287-11" title="11"></a>
<a class="sourceLine" id="cb287-12" title="12">   ClassDef (MyClass,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb287-13" title="13">}</a></code></pre></div>
<p>To specify arguments:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb288-1" title="1"><span class="dt">void</span> SetXXX(<span class="dt">Int_t</span> x1, <span class="dt">Float_t</span> y2); <span class="co">//*MENU* *ARGS={x1=&gt;fV1}</span></a></code></pre></div>
<p>This statement is in the comment field, after the *MENU*. If there is
 more than one argument, these arguments are separated by commas, where 
fX1 and fY2 are data fields in the same class.</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb289-1" title="1"><span class="dt">void</span> SetXXX(<span class="dt">Int_t</span> x1, <span class="dt">Float_t</span> y2); <span class="co">//*MENU* *ARGS={x1=&gt;fX1,y2=&gt;fY2}</span></a></code></pre></div>
<p>If the arguments statement is present, the option dialog displayed when selecting <code>SetXXX field</code> will show the values of variables. We indicate to the system which argument corresponds to which data member of the class.</p>
<h3 id="executing-events-when-a-cursor-passes-on-top-of-an-object"><span class="header-section-number">9.2.4</span> Executing Events when a Cursor Passes on Top of an Object</h3>
<p>This paragraph is for class designers. When a class is designed, it 
is often desirable to include drawing methods for it. We will have a 
more extensive discussion about this, but drawing an object in a canvas 
or a pad consists in “attaching” the object to that pad. When one uses <code>object.Draw()</code>, the object is NOT painted at this moment. It is only attached to the active pad or canvas.</p>
<p>Another method should be provided for the object to be painted, the <code>Paint()</code> method. This is all explained in the next paragraph. As well as <code>Draw()</code> and <code>Paint()</code>, other methods may be provided by the designer of the class. When the mouse is moved or a button pressed/released, the <strong><code>TCanvas</code></strong> function named <code>HandleInput()</code>
 scans the list of objects in all it’s pads and for each object calls 
some standard methods to make the object react to the event (mouse 
movement, click or whatever).</p>
<p>The second one is <code>DistanceToPrimitive(px,py)</code>. This function computes a “distance” to an object from the mouse position at the pixel position (<code>px</code>, <code>py</code>,
 see definition at the end of this paragraph) and returns this distance 
in pixel units. The selected object will be the one with the shortest 
computed distance. To see how this works, select the “<code>Event Status</code>” item in the canvas “<code>Options</code>”
 menu. ROOT will display one status line showing the picked object. If 
the picked object is, for example, a histogram, the status line 
indicates the name of the histogram, the position <code>x,y</code> in histogram coordinates, the channel number and the channel content.</p>
<p>It is nice for the canvas to know what the closest object from the 
mouse is, but it’s even nicer to be able to make this object react. The 
third standard method to be provided is <code>ExecuteEvent()</code>. This method actually does the event reaction. Its prototype is where <code>px</code> and <code>py</code> are the coordinates at which the event occurred, except if the event is a key press, in which case <code>px</code> contains the key code.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb290-1" title="1"><span class="dt">void</span> ExecuteEvent(<span class="dt">Int_t</span> event, <span class="dt">Int_t</span> px, <span class="dt">Int_t</span> py);</a></code></pre></div>
<p>Where <code>event</code> is the event that occurs and is one of the following (defined in <code>Buttons.h</code>):</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb291-1" title="1">kNoEvent,          kButton1Down,      kButton2Down,</a>
<a class="sourceLine" id="cb291-2" title="2">kButton3Down,      kKeyDown,          kButton1Up,</a>
<a class="sourceLine" id="cb291-3" title="3">kButton2Up,        kButton3Up,        kButton1Motion,</a>
<a class="sourceLine" id="cb291-4" title="4">kButton2Motion,    kButton3Motion,    kKeyPress,</a>
<a class="sourceLine" id="cb291-5" title="5">kButton1Locate,    kButton2Locate,    kButton3Locate,</a>
<a class="sourceLine" id="cb291-6" title="6">kKeyUp,            kButton1Double,    kButton2Double,</a>
<a class="sourceLine" id="cb291-7" title="7">kButton3Double,    kMouseMotion,      kMouseEnter,</a>
<a class="sourceLine" id="cb291-8" title="8">kMouseLeave</a></code></pre></div>
<p>We hope the names are self-explanatory.</p>
<p>Designing an <code>ExecuteEvent</code> method is not very easy, 
except if one wants very basic treatment. We will not go into that and 
let the reader refer to the sources of classes like <strong><code>TLine</code></strong> or <strong><code>TBox</code></strong>. Go and look at their <code>ExecuteEvent</code>
 method! We can nevertheless give some reference to the various actions 
that may be performed. For example, one often wants to change the shape 
of the cursor when passing on top of an object. This is done with the <code>SetCursor</code> method:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb292-1" title="1">gPad-&gt;SetCursor(cursor)</a></code></pre></div>
<p>The argument <code>cursor</code> is the type of cursor. It may be:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb293-1" title="1">kBottomLeft,  kBottomRight,  kTopLeft,</a>
<a class="sourceLine" id="cb293-2" title="2">kTopRight,    kBottomSide,   kLeftSide,</a>
<a class="sourceLine" id="cb293-3" title="3">kTopSide,     kRightSide,    kMove,</a>
<a class="sourceLine" id="cb293-4" title="4">kCross,       kArrowHor,     kArrowVer,</a>
<a class="sourceLine" id="cb293-5" title="5">kHand,        kRotate,       kPointer,</a>
<a class="sourceLine" id="cb293-6" title="6">kArrowRight,  kCaret,        kWatch</a></code></pre></div>
<p>They are defined in <code>TVirtualX.h</code> and again we hope the 
names are self-explanatory. If not, try them by designing a small class.
 It may derive from something already known like <strong><code>TLine</code></strong>.</p>
<p>Note that the <code>ExecuteEvent()</code> functions may in turn; 
invoke such functions for other objects, in case an object is drawn 
using other objects. You can also exploit at best the virtues of 
inheritance. See for example how the class <strong><code>TArrow</code></strong> (derived from <strong><code>TLine</code></strong>) use or redefine the picking functions in its base class.</p>
<p>The last comment is that mouse position is always given in pixel units in all these standard functions. <code>px=0</code> and <code>py=0</code>
 corresponds to the top-left corner of the canvas. Here, we have 
followed the standard convention in windowing systems. Note that user 
coordinates in a canvas (pad) have the origin at the bottom-left corner 
of the canvas (pad). This is all explained in the paragraph “The 
Coordinate Systems of a Pad”.</p>
<h2 id="graphical-containers-canvas-and-pad"><span class="header-section-number">9.3</span> Graphical Containers: Canvas and Pad</h2>
<p></p>
<p>We have talked a lot about canvases, which may be seen as windows. 
More generally, a graphical entity that contains graphical objects is 
called a Pad. A Canvas is a special kind of Pad. From now on, when we 
say something about pads, this also applies to canvases. A pad (class <strong><code>TPad</code></strong>)
 is a graphical container in the sense it contains other graphical 
objects like histograms and arrows. It may contain other pads (sub-pads)
 as well. A Pad is a linked list of primitives of any type (graphs, 
histograms, shapes, tracks, etc.). It is a kind of display list.</p>
<figure>
<img src="ROOTUsersGuide_files/pad_01.png" alt="The pad display list"><figcaption>The pad display list</figcaption>
</figure>
<p>Drawing an object is nothing more than adding its pointer to this list. Look for example at the code of <code>TH1::Draw()</code>. It is merely ten lines of code. The last statement is <code>AppendPad()</code>. This statement calls method of <strong><code>TObject</code></strong>
 that just adds the pointer of the object, here a histogram, to the list
 of objects attached to the current pad. Since this is a <strong><code>TObject</code></strong>’s method, every object may be “drawn”, which means attached to a pad.</p>
<p>When is the painting done then ? The answer is: when needed. Every object that derives from <strong><code>TObject</code></strong> has a <code>Paint()</code>
 method. It may be empty, but for graphical objects, this routine 
contains all the instructions to paint effectively it in the active pad.
 Since a Pad has the list of objects it owns, it will call successively 
the <code>Paint()</code> method of each object, thus re-painting the whole pad on the screen. If the object is a sub-pad, its <code>Paint()</code> method will call the <code>Paint()</code> method of the objects attached, recursively calling <code>Paint()</code> for all the objects.</p>
<figure>
<img src="ROOTUsersGuide_files/pad_02.png" alt="Pad painting"><figcaption>Pad painting</figcaption>
</figure>
<p>In some cases a pad need to be painted during a macro execution. To force the pad painting <code>gPad-&gt;Update()</code> (see next section) should be performed.</p>
<p>The list of primitives stored in the pad is also used to pick objects and to interact with them.</p>
<h3 id="the-global-pad-gpad"><span class="header-section-number">9.3.1</span> The Global Pad: gPad</h3>
<p>When an object is drawn, it is always in the so-called active pad. 
For every day use, it is comfortable to be able to access the active 
pad, whatever it is. For that purpose, there is a global pointer, called
 <strong><em><code>gPad</code></em></strong>. It is always pointing to 
the active pad. If you want to change the fill color of the active pad 
to blue but you do not know its name, do this.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb294-1" title="1">root[] gPad-&gt;SetFillColor(<span class="dv">38</span>)</a></code></pre></div>
<p>To get the list of colors, go to the paragraph “Color and color palettes” or if you have an opened canvas, click on the <code>View</code> menu, selecting the <code>Colors</code> item.</p>
<h4 id="finding-an-object-in-a-pad"><span class="header-section-number">9.3.1.1</span> Finding an Object in a Pad</h4>
<p>Now that we have a pointer to the active pad, <strong><em><code>gPad</code></em></strong> and that we know this pad contains some objects, it is sometimes interesting to access one of those objects. The method <code>GetPrimitive()</code> of <strong><code>TPad</code></strong>, i.e.&nbsp;<code>TPad::GetPrimitive(const char* name)</code> does exactly this. Since most of the objects that a pad contains derive from <strong><code>TObject</code></strong>, they have a name. The following statement will return a pointer to the object <code>myobjectname</code> and put that pointer into the variable <code>obj</code>. As you can see, the type of returned pointer is <code>TObject*</code>.</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb295-1" title="1">root[] obj = gPad-&gt;GetPrimitive(<span class="st">"myobjectname"</span>)</a>
<a class="sourceLine" id="cb295-2" title="2">(<span class="kw">class</span> TObject*)<span class="bn">0x1063cba8</span></a></code></pre></div>
<p>Even if your object is something more complicated, like a histogram <strong><code>TH1F</code></strong>,
 this is normal. A function cannot return more than one type. So the one
 chosen was the lowest common denominator to all possible classes, the 
class from which everything derives, <strong><code>TObject</code></strong>.
 How do we get the right pointer then? Simply do a cast of the function 
output that will transform the output (pointer) into the right type. For
 example if the object is a <strong><code>TPaveLabel</code></strong>:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb296-1" title="1">root[] obj = (TPaveLabel*)(gPad-&gt;GetPrimitive(<span class="st">"myobjectname"</span>))</a>
<a class="sourceLine" id="cb296-2" title="2">(<span class="kw">class</span> TPaveLabel*)<span class="bn">0x1063cba8</span></a></code></pre></div>
<p>This works for all objects deriving from <strong><code>TObject</code></strong>. However, a question remains. An object has a name if it derives from <strong><code>TNamed</code></strong>, not from <strong><code>TObject</code></strong>. For example, an arrow (<strong><code>TArrow</code></strong>)
 doesn’t have a name. In that case, the “name” is the name of the class.
 To know the name of an object, just click with the right button on it. 
The name appears at the top of the context menu. In case of multiple 
unnamed objects, a call to <code>GetPrimitive("className")</code> returns the instance of the class that was first created. To retrieve a later instance you can use <code>GetListOfPrimitives()</code>, which returns a list of all the objects on the pad. From the list you can select the object you need.</p>
<h4 id="hiding-an-object"><span class="header-section-number">9.3.1.2</span> Hiding an Object</h4>
<p>Hiding an object in a pad can be made by removing it from the list of objects owned by that pad. This list is accessible by the <code>GetListOfPrimitives()</code> method of <strong><code>TPad</code></strong>. This method returns a pointer to a <strong><code>TList</code></strong>. Suppose we get the pointer to the object, we want to hide, call it <code>obj</code> (see paragraph above). We get the pointer to the list:</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb297-1" title="1">root[] li = gPad-&gt;GetListOfPrimitives()</a></code></pre></div>
<p>Then remove the object from this list:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb298-1" title="1">root[] li-&gt;Remove(obj)</a></code></pre></div>
<p>The object will disappear from the pad as soon as the pad is updated 
(try to resize it for example). If one wants to make the object 
reappear:</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb299-1" title="1">root[] obj-&gt;Draw()</a></code></pre></div>
<p>Caution, this will not work with composed objects, for example many histograms drawn on the same plot (with the option “<code>same</code>”). There are other ways! Try to use the method described here for simple objects.</p>
<h3 id="the-coordinate-systems-of-a-pad"><span class="header-section-number">9.3.2</span> The Coordinate Systems of a Pad</h3>
<p>There are coordinate systems in a <strong><code>TPad</code></strong>: user coordinates, normalized coordinates (NDC), and pixel coordinates.</p>
<figure>
<img src="ROOTUsersGuide_files/080000A3.png" alt="Pad coordinate systems"><figcaption>Pad coordinate systems</figcaption>
</figure>
<h4 id="the-user-coordinate-system"><span class="header-section-number">9.3.2.1</span> The User Coordinate System</h4>
<p>The most common is the user coordinate system. Most methods of <strong><code>TPad</code></strong>
 use the user coordinates, and all graphic primitives have their 
parameters defined in terms of user coordinates. By default, when an 
empty pad is drawn, the user coordinates are set to a range from 0 to 1 
starting at the lower left corner. At this point they are equivalent of 
the NDC coordinates (see below). If you draw a high level graphical 
object, such as a histogram or a function, the user coordinates are set 
to the coordinates of the histogram. Therefore, when you set a point it 
will be in the histogram coordinates.</p>
<p>For a newly created blank pad, one may use <code>TPad::Range</code> to set the user coordinate system. This function is defined as:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb300-1" title="1"><span class="dt">void</span> Range(<span class="dt">float</span> x1,<span class="dt">float</span> y1,<span class="dt">float</span> x2,<span class="dt">float</span> y2)</a></code></pre></div>
<p>The arguments <code>x1</code>, <code>x2</code> defines the new range in the x direction, and the <code>y1</code>, <code>y2</code> define the new range in the y-direction.</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb301-1" title="1">root[] TCanvas MyCanvas (<span class="st">"MyCanvas"</span>)</a>
<a class="sourceLine" id="cb301-2" title="2">root[] gPad-&gt;Range(-<span class="dv">100</span>,-<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>)</a></code></pre></div>
<p>This will set the active pad to have both coordinates to go from -100
 to 100, with the center of the pad at (0,0). You can visually check the
 coordinates by viewing the status bar in the canvas. To display the 
status bar select Event Status entry in the View canvas menu.</p>
<figure>
<img src="ROOTUsersGuide_files/020000A4.jpg" alt="The status bar"><figcaption>The status bar</figcaption>
</figure>
<h4 id="the-normalized-coordinate-system-ndc"><span class="header-section-number">9.3.2.2</span> The Normalized Coordinate System (NDC)</h4>
<p>Normalized coordinates are independent of the window size and of the 
user system. The coordinates range from 0 to 1 and (0, 0) corresponds to
 the bottom-left corner of the pad. Several internal ROOT functions use 
the NDC system (3D primitives, PostScript, log scale mapping to linear 
scale). You may want to use this system if the user coordinates are not 
known ahead of time.</p>
<h4 id="the-pixel-coordinate-system"><span class="header-section-number">9.3.2.3</span> The Pixel Coordinate System</h4>
<p>The least common is the pixel coordinate system, used by functions such as <code>DistanceToPrimitive()</code> and <code>ExecuteEvent()</code>. Its primary use is for cursor position, which is always given in pixel coordinates. If (<code>px,py</code>) is the cursor position, <code>px=0</code> and <code>py=0</code> corresponds to the top-left corner of the pad, which is the standard convention in windowing systems.</p>
<h4 id="using-ndc-for-a-particular-object"><span class="header-section-number">9.3.2.4</span> Using NDC for a particular Object</h4>
<p>Most of the time, you will be using the user coordinate system. But 
sometimes, you will want to use NDC. For example, if you want to draw 
text always at the same place over a histogram, no matter what the 
histogram coordinates are. There are two ways to do this. You can set 
the NDC for one object or may convert NDC to user coordinates. Most 
graphical objects offer an option to be drawn in NDC. For instance, a 
line (<strong><code>TLine</code></strong>) may be drawn in NDC by using <code>DrawLineNDC()</code>. A latex formula or a text may use <code>TText::SetNDC()</code> to be drawn in NDC coordinates.</p>
<h3 id="converting-between-coordinate-systems"><span class="header-section-number">9.3.3</span> Converting between Coordinate Systems</h3>
<p>There are a few utility functions in <strong><code>TPad</code></strong> to convert from one system of coordinates to another. In the following table, a point is defined by <code>(px,py)</code> in pixel coordinates, <code>(ux,uy)</code> in user coordinates, <code>(ndcx,ndcy)</code> in normalized coordinates, (<code>apx</code>, <code>apy</code>) are in absolute pixel coordinates.</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 43%">
<col style="width: 26%">
</colgroup>
<tbody>
<tr class="odd">
<td>Conversion</td>
<td>TPad’s Methods</td>
<td>Returns</td>
</tr>
<tr class="even">
<td>NDC to Pixel</td>
<td><p><code>UtoPixel(ndcx)</code></p>
<p><code>VtoPixel(ndcy)</code></p></td>
<td><p>Int_t</p>
<p>Int_t</p></td>
</tr>
<tr class="odd">
<td>Pixel to User</td>
<td><p><code>PixeltoX(px)</code></p>
<p><code>PixeltoY(py)</code></p>
<p><code>PixeltoXY(px,py,&amp;ux,&amp;uy)</code></p></td>
<td><p>Double_t</p>
<p>Double_t</p>
<p>Double_t ux,uy</p></td>
</tr>
<tr class="even">
<td>User to Pixel</td>
<td><p><code>XtoPixel(ux)</code></p>
<p><code>YtoPixel(uy)</code></p>
<p><code>XYtoPixel(ux,uy,&amp;px,&amp;py)</code></p></td>
<td><p>Int_t</p>
<p>Int_t</p>
<p>Int_t px,py</p></td>
</tr>
<tr class="odd">
<td>User to absolute pixel</td>
<td><p><code>XtoAbsPixel(ux)</code></p>
<p><code>YtoAbsPixel(uy)</code></p>
<p><code>XYtoAbsPixel(ux,uy,&amp;apx,&amp;apy)</code></p></td>
<td><p>Int_t</p>
<p>Int_t</p>
<p>Int_t apx,apy</p></td>
</tr>
<tr class="even">
<td>Absolute pixel to user</td>
<td><p><code>AbsPixeltoX(apx)</code></p>
<p><code>AbsPixeltoY(apy)</code></p>
<p><code>AbsPixeltoXY(apx,apy,&amp;ux,&amp;uy)</code></p></td>
<td><p>Double_t</p>
<p>Double_t</p>
<p>Double_t ux,uy</p></td>
</tr>
</tbody>
</table>
<p>Note: all the pixel conversion functions along the Y axis consider that <code>py=0</code> is at the top of the pad except <code>PixeltoY()</code> which assume that the position <code>py=0</code> is at the bottom of the pad. To make <code>PixeltoY()</code> converting the same way as the other conversion functions, it should be used the following way (<code>p</code> is a pointer to a <strong><code>TPad</code></strong>):</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb302-1" title="1">p-&gt;PixeltoY(py - p-&gt;GetWh());</a></code></pre></div>
<h3 id="dividing-a-pad-into-sub-pads"><span class="header-section-number">9.3.4</span> Dividing a Pad into Sub-pads</h3>
<p>Dividing a pad into sub pads in order for instance to draw a few 
histograms, may be done in two ways. The first is to build pad objects 
and to draw them into a parent pad, which may be a canvas. The second is
 to automatically divide a pad into horizontal and vertical sub pads.</p>
<h4 id="creating-a-single-sub-pad"><span class="header-section-number">9.3.4.1</span> Creating a Single Sub-pad</h4>
<p>The simplest way to divide a pad is to build sub-pads in it. However,
 this forces the user to explicitly indicate the size and position of 
those sub-pads. Suppose we want to build a sub-pad in the active pad 
(pointed by <strong><em><code>gPad</code></em></strong>). First, we build it, using a <strong><code>TPad</code></strong> constructor:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb303-1" title="1">root[] spad1 = <span class="kw">new</span> TPad(<span class="st">"spad1"</span>,<span class="st">"The first subpad"</span>,<span class="fl">.1</span>,<span class="fl">.1</span>,<span class="fl">.5</span>,<span class="fl">.5</span>)</a></code></pre></div>
<p>One gives the coordinates of the lower left point (0.1, 0.1) and of 
the upper right one (0.5, 0.5). These coordinates are in NDC. This means
 that they are independent of the user coordinates system, in particular
 if you have already drawn for example a histogram in the mother pad. 
The only thing left is to draw the pad:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb304-1" title="1">root[] spad1-&gt;Draw()</a></code></pre></div>
<p>If you want more sub-pads, you have to repeat this procedure as many times as necessary.</p>
<h4 id="dividing-a-canvas-into-sub-pads"><span class="header-section-number">9.3.4.2</span> Dividing a Canvas into Sub-Pads</h4>
<p>The manual way of dividing a pad into sub-pads is sometimes very 
tedious. There is a way to automatically generate horizontal and 
vertical sub-pads inside a given pad.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb305-1" title="1">root[] pad1-&gt;Divide(<span class="dv">3</span>,<span class="dv">2</span>)</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000A5.png" alt="Dividing a pad into 6 sub-pads"><figcaption>Dividing a pad into 6 sub-pads</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/020000A6.jpg" alt="Dividing a pad into 6 sub-pads"><figcaption>Dividing a pad into 6 sub-pads</figcaption>
</figure>
<p>If <code>pad1</code> is a pad then, it will divide the pad into 3 columns of 2 sub-pads. The generated sub-pads get names <code>pad1_i</code> where the index <code>i=1</code> to <code>nxm</code> (in our case <code>pad1_1</code>, <code>pad1_2</code>…<code>pad1_6)</code>. The names <code>pad1_1</code>etc… correspond to new variables in Cling, so you may use them as soon as the executed method was <code>pad-&gt;Divide()</code>.
 However, in a compiled program, one has to access these objects. 
Remember that a pad contains other objects and that these objects may 
themselves be pads. So we can use the <code>GetPrimitive()</code> method:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb306-1" title="1">TPad* pad1_1 = (TPad*)(pad1-&gt;GetPrimitive(<span class="st">"pad1_1"</span>))</a></code></pre></div>
<p>One question remains. In case one does an automatic divide, how one 
can set the default margins between pads? This is done by adding two 
parameters to <code>Divide()</code>, which are the margins in <code>x</code> and <code>y</code>:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb307-1" title="1">root[] pad1-&gt;Divide(<span class="dv">3</span>,<span class="dv">2</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>)</a></code></pre></div>
<p>The margins are here set to 10% of the parent pad width.</p>
<h3 id="updating-the-pad"><span class="header-section-number">9.3.5</span> Updating the Pad</h3>
<p>For performance reasons, a pad is not updated with every change. For 
example, changing the coordinates of the pad does not automatically 
redraw it. Instead, the pad has a “bit-modified” that triggers a redraw.
 This bit is automatically set by:</p>
<ul>
<li><p>Touching the pad with the mouse - for example resizing it with the mouse.</p></li>
<li><p>Finishing the execution of a script.</p></li>
<li><p>Adding a new primitive or modifying some primitives for example the name and title of an object.</p></li>
<li><p>You can also set the “bit-modified” explicitly with the <code>Modified</code> method:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb308-1" title="1"><span class="co">// the pad has changed</span></a>
<a class="sourceLine" id="cb308-2" title="2">root[] pad1-&gt;Modified()</a>
<a class="sourceLine" id="cb308-3" title="3"><span class="co">// recursively update all modified pads:</span></a>
<a class="sourceLine" id="cb308-4" title="4">root[] c1-&gt;Update()</a></code></pre></div>
<p>A subsequent call to <code>TCanvas::Update()</code> scans the list of sub-pads and repaints the pads declared modified.</p></li>
</ul>
<p>In compiled code or in a long macro, you may want to access an object
 created during the paint process. To do so, you can force the painting 
with a <code>TCanvas::Update()</code>. For example, a <strong><code>TGraph</code></strong> creates a histogram (<strong><code>TH1</code></strong>) to paint itself. In this case the internal histogram obtained with <code>TGraph::GetHistogram()</code>
 is created only after the pad is painted. The pad is painted 
automatically after the script is finished executing or if you force the
 painting with <code>TPad::Modified()</code> followed by a <code>TCanvas::Update()</code>. Note that it is not necessary to call <code>TPad::Modified()</code> after a call to <code>Draw()</code>. The “bit-modified” is set automatically by <code>Draw()</code>. A note about the “bit-modified” in sub pads: when you want to update a sub pad in your canvas, you need to call <code>pad-&gt;Modified()</code> rather than <code>canvas-&gt;Modified()</code>, and follow it with a <code>canvas-&gt;Update()</code>. If you use <code>canvas-&gt;Modified()</code>, followed by a call to <code>canvas-&gt;Update()</code>, the sub pad has not been declared modified and it will not be updated. Also note that a call to <code>pad-&gt;Update()</code> where pad is a sub pad of canvas, calls <code>canvas-&gt;Update()</code> and recursively updates all the pads on the canvas.</p>
<h3 id="making-a-pad-transparent"><span class="header-section-number">9.3.6</span> Making a Pad Transparent</h3>
<p>As we will see in the paragraph “Fill Attributes”, a fill style (type of hatching) may be set for a pad.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb309-1" title="1">root[] pad1-&gt;SetFillStyle(istyle)</a></code></pre></div>
<p>This is done with the <code>SetFillStyle</code> method where <code>istyle</code>
 is a style number, defined in “Fill Attributes”. A special set of 
styles allows handling of various levels of transparency. These are 
styles number 4000 to 4100, 4000 being fully transparent and 4100 fully 
opaque. So, suppose you have an existing canvas with several pads. You 
create a new pad (transparent) covering for example the entire canvas. 
Then you draw your primitives in this pad. The same can be achieved with
 the graphics editor. For example:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb310-1" title="1">root[] .x tutorials/hist/h1draw.C</a>
<a class="sourceLine" id="cb310-2" title="2">root[] TPad *newpad=<span class="kw">new</span> TPad(<span class="st">"newpad"</span>,<span class="st">"Transparent pad"</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb310-3" title="3">root[] newpad-&gt;SetFillStyle(<span class="dv">4000</span>);</a>
<a class="sourceLine" id="cb310-4" title="4">root[] newpad-&gt;Draw();</a>
<a class="sourceLine" id="cb310-5" title="5">root[] newpad-&gt;cd();</a>
<a class="sourceLine" id="cb310-6" title="6">root[] <span class="co">// create some primitives, etc</span></a></code></pre></div>
<h3 id="setting-the-log-scale"><span class="header-section-number">9.3.7</span> Setting the Log Scale</h3>
<p>Setting the scale to logarithmic or linear is an attribute of the 
pad, not the axis or the histogram. The scale is an attribute of the pad
 because you may want to draw the same histogram in linear scale in one 
pad and in log scale in another pad. Frequently, we see several 
histograms on top of each other in the same pad. It would be very 
inconvenient to set the scale attribute for each histogram in a pad.</p>
<p>Furthermore, if the logic was set in the histogram class (or each object) the scale setting in each <code>Paint</code> method of all objects should be tested.</p>
<p>If you have a pad with a histogram, a right-click on the pad, outside of the histograms frame will convince you. The <code>SetLogx()</code>, <code>SetLogy()</code> and <code>SetLogz()</code> methods are there. As you see, <strong><code>TPad</code></strong> defines log scale for the two directions <code>x</code> and <code>y</code> plus <code>z</code> if you want to draw a 3D representation of some function or histogram.</p>
<p>The way to set log scale in the x direction for the active pad is:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb311-1" title="1">root[] gPad-&gt;SetLogx(<span class="dv">1</span>)</a></code></pre></div>
<p>To reset log in the z direction:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb312-1" title="1">root[] gPad-&gt;SetLogz(<span class="dv">0</span>)</a></code></pre></div>
<p>If you have a divided pad, you need to set the scale on each of the 
sub-pads. Setting it on the containing pad does not automatically 
propagate to the sub-pads. Here is an example of how to set the log 
scale for the x-axis on a canvas with four sub-pads:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb313-1" title="1">root[] TCanvas MyCanvas(<span class="st">"MyCanvas"</span>,<span class="st">"My Canvas"</span>)</a>
<a class="sourceLine" id="cb313-2" title="2">root[] MyCanvas-&gt;Divide(<span class="dv">2</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb313-3" title="3">root[] MyCanvas-&gt;cd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb313-4" title="4">root[] gPad-&gt;SetLogx()</a>
<a class="sourceLine" id="cb313-5" title="5">root[] MyCanvas-&gt;cd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb313-6" title="6">root[] gPad-&gt;SetLogx()</a>
<a class="sourceLine" id="cb313-7" title="7">root[] MyCanvas-&gt;cd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb313-8" title="8">root[] gPad-&gt;SetLogx()</a></code></pre></div>
<h3 id="waitprimitive-method"><span class="header-section-number">9.3.8</span> WaitPrimitive method</h3>
<p>When the <code>TPad::WaitPrimitive()</code> method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to <code>gSystem-&gt;Sleep(10)</code>
 has been added in the loop to avoid consuming at all the CPU. This new 
option is convenient when executing a macro. By adding statements like:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb314-1" title="1">canvas-&gt;WaitPrimitive();</a></code></pre></div>
<p>You can monitor the progress of a running macro, stop it at 
convenient places with the possibility to interact with the canvas and 
resume the execution with a double click or a key press.</p>
<h3 id="locking-the-pad"><span class="header-section-number">9.3.9</span> Locking the Pad</h3>
<p>You can make the <strong><code>TPad</code></strong> non-editable. 
Then no new objects can be added, and the existing objects and the pad 
can not be changed with the mouse or programmatically. By default the <strong><code>TPad</code></strong> is editable.</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb315-1" title="1">TPad::SetEditable(kFALSE)</a></code></pre></div>
<h2 id="graphical-objects"><span class="header-section-number">9.4</span> Graphical Objects</h2>
<p>In this paragraph, we describe the various simple 2D graphical 
objects defined in ROOT. Usually, one defines these objects with their 
constructor and draws them with their <code>Draw()</code> method. 
Therefore, the examples will be very brief. Most graphical objects have 
line and fill attributes (color, width) that will be described in 
“Graphical objects attributes”. If the user wants more information, the 
class names are given and they may refer to the online developer 
documentation. This is especially true for functions and methods that 
set and get internal values of the objects described here. By default 2D
 graphical objects are created in User Coordinates with (0, 0) in the 
lower left corner.</p>
<h3 id="lines-arrows-and-polylines"><span class="header-section-number">9.4.1</span> Lines, Arrows and Polylines</h3>
<p>The simplest graphical object is a line. It is implemented in the <strong><code>TLine</code></strong> class. The line constructor is:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb316-1" title="1">TLine(<span class="dt">Double_t</span> x1,<span class="dt">Double_t</span> y1,<span class="dt">Double_t</span> x2,<span class="dt">Double_t</span> y2)</a></code></pre></div>
<p>The arguments <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> are the coordinates of the first and second point. It can be used:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb317-1" title="1">root[] l = <span class="kw">new</span> TLine(<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.8</span>,<span class="fl">0.3</span>)</a>
<a class="sourceLine" id="cb317-2" title="2">root[] l-&gt;Draw()</a></code></pre></div>
<p>The arrow constructor is:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb318-1" title="1">TArrow(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1,</a>
<a class="sourceLine" id="cb318-2" title="2">       <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2,</a>
<a class="sourceLine" id="cb318-3" title="3">       <span class="dt">Float_t</span> arrowsize, <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>It defines an arrow between points <code>x1,y1</code> and <code>x2,y2</code>. The arrow size is in percentage of the pad height. The <code>option</code> parameter has the following meanings:</p>
<p><img src="ROOTUsersGuide_files/020000A7.jpg"> “&gt;”</p>
<p><img src="ROOTUsersGuide_files/020000A8.jpg"> “&lt;|”</p>
<p><img src="ROOTUsersGuide_files/020000A9.jpg"> “&lt;”</p>
<p><img src="ROOTUsersGuide_files/020000AA.jpg"> “|&gt;”</p>
<p><img src="ROOTUsersGuide_files/020000AB.jpg"> “&lt;&gt;”</p>
<p><img src="ROOTUsersGuide_files/020000AC.jpg"> “&lt;|&gt;”</p>
<p>Once an arrow is drawn on the screen, one can:</p>
<ul>
<li><p>click on one of the edges and move this edge.</p></li>
<li><p>click on any other arrow part to move the entire arrow.</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/030000AD.png" alt="Different arrow formats"><figcaption>Different arrow formats</figcaption>
</figure>
<p>If <code>FillColor</code> is 0, an open triangle is drawn; else a full triangle is filled with the set fill color. If <code>ar</code> is an arrow object, fill color is set with:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb319-1" title="1">ar.SetFillColor(icolor);</a></code></pre></div>
<p>Where <code>icolor</code> is the color defined in “Color and Color Palettes”.</p>
<p>The default-opening angle between the two sides of the arrow is 60 degrees. It can be changed with the method <code>ar-&gt;SetAngle(angle)</code>, where angle is expressed in degrees.</p>
<p>A poly-line is a set of joint segments. It is defined by a set of N points in a 2D space. Its constructor is:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb320-1" title="1">TPolyLine(<span class="dt">Int_t</span> n,<span class="dt">Double_t</span>* x,<span class="dt">Double_t</span>* y,<span class="dt">Option_t</span>* option)</a></code></pre></div>
<p>Where <code>n</code> is the number of points, and <code>x</code> and <code>y</code> are arrays of <code>n</code> elements with the coordinates of the points. <strong><code>TPolyLine</code></strong> can be used by it self, but is also a base class for other objects, such as curly arcs.</p>
<h3 id="circles-and-ellipses"><span class="header-section-number">9.4.2</span> Circles and Ellipses</h3>
<p>An ellipse can be truncated and rotated. It is defined by its center <code>(x1,y1)</code> and two radii <code>r1</code> and <code>r2</code>. A minimum and maximum angle may be specified <code>(phimin,phimax)</code>. The ellipse may be rotated with an angle <code>theta</code>. All these angles are in degrees. The attributes of the outline line are set via <strong><code>TAttLine</code></strong>, of the fill area - via <strong><code>TAttFill</code></strong> class. They are described in “Graphical Objects Attributes”.</p>
<figure>
<img src="ROOTUsersGuide_files/030000AE.png" alt="Different types of ellipses"><figcaption>Different types of ellipses</figcaption>
</figure>
<p>When an ellipse sector is drawn only, the lines between the center 
and the end points of the sector are drawn by default. By specifying the
 drawn option “<code>only</code>”, these lines can be avoided. Alternatively, the method <code>SetNoEdges()</code> can be called. To remove completely the ellipse outline, specify zero (0) as a line style.</p>
<p>The <strong><code>TEllipse</code></strong> constructor is:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb321-1" title="1">TEllipse(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> r1, <span class="dt">Double_t</span> r2,</a>
<a class="sourceLine" id="cb321-2" title="2">         <span class="dt">Double_t</span> phimin, <span class="dt">Double_t</span> phimax, <span class="dt">Double_t</span> theta)</a></code></pre></div>
<p>An ellipse may be created with:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb322-1" title="1">root[] e = <span class="kw">new</span> TEllipse(<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.8</span>,<span class="fl">0.3</span>)</a>
<a class="sourceLine" id="cb322-2" title="2">root[] e-&gt;Draw()</a></code></pre></div>
<h3 id="rectangles"><span class="header-section-number">9.4.3</span> Rectangles</h3>
<p>The class <strong><code>TBox</code></strong> defines a rectangle. It is a base class for many different higher-level graphical primitives. Its bottom left coordinates <code>x1</code>, <code>y1</code> and its top right coordinates <code>x2</code>, <code>y2</code>, defines a box. The constructor is:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb323-1" title="1">TBox(<span class="dt">Double_t</span> x1,<span class="dt">Double_t</span> y1,<span class="dt">Double_t</span> x2,<span class="dt">Double_t</span> y2)</a></code></pre></div>
<p>It may be used as in:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb324-1" title="1">root[] b = <span class="kw">new</span> TBox(<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.8</span>,<span class="fl">0.3</span>)</a>
<a class="sourceLine" id="cb324-2" title="2">root[] b-&gt;SetFillColor(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb324-3" title="3">root[] b-&gt;Draw()</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/020000AF.jpg" alt="A rectangle with a border"><figcaption>A rectangle with a border</figcaption>
</figure>
<p>A <strong><code>TWbox</code></strong> is a rectangle (<strong><code>TBox</code></strong>)
 with a border size and a border mode. The attributes of the outline 
line and of the fill area are described in “Graphical Objects 
Attributes”</p>
<h3 id="markers"><span class="header-section-number">9.4.4</span> Markers</h3>
<p>A marker is a point with a fancy shape! The possible markers are shown in the next figure.</p>
<figure>
<img src="ROOTUsersGuide_files/030000B0.png" alt="Markers"><figcaption>Markers</figcaption>
</figure>
<p>The marker constructor is:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb325-1" title="1">TMarker(<span class="dt">Double_t</span> x,<span class="dt">Double_t</span> y,<span class="dt">Int_t</span> marker)</a></code></pre></div>
<p>The parameters <code>x</code> and <code>y</code> are the marker coordinates and <code>marker</code> is the marker type, shown in the previous figure. Suppose the pointer <code>ma</code> is a valid marker. The marker size is set via <code>ma-&gt;SetMarkerSize(size)</code>, where <code>size</code>
 is the desired size. Note, that the marker types 1, 6 and 7 (the dots) 
cannot be scaled. They are always drawn with the same number of pixels. <code>SetMarkerSize</code>
 does not apply on them. To have a “scalable dot” a circle shape should 
be used instead, for example, the marker type 20. The default marker 
type is 1, if <code>SetMarkerStyle</code> is not specified. It is the most common one to draw scatter plots.</p>
<figure>
<img src="ROOTUsersGuide_files/030000B1.png" alt="Different marker sizes"><figcaption>Different marker sizes</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/030000B2.png" alt="Different marker sizes"><figcaption>Different marker sizes</figcaption>
</figure>
<p>The user interface for changing the marker color, style and size 
looks like shown in this picture. It takes place in the editor frame 
anytime the selected object inherits the class <strong><code>TAttMarker</code></strong>.</p>
<p>Non-symmetric symbols should be used carefully in plotting. The next 
two graphs show how the misleading a careless use of symbols can be. The
 two plots represent the same data sets but because of a bad symbol 
choice, the two on the top appear further apart from the next example.</p>
<figure>
<img src="ROOTUsersGuide_files/030000B3.png" alt="The use of non-symmetric markers"><figcaption>The use of non-symmetric markers</figcaption>
</figure>
<p>A <strong><code>TPolyMaker</code></strong> is defined by an array on N points in a 2D space. At each point <code>x[i]</code>, <code>y[i]</code> a marker is drawn. The list of marker types is shown in the previous paragraph. The marker attributes are managed by the class <strong><code>TAttMarker</code></strong> and are described in “Graphical Objects Attributes”. The <strong><code>TPolyMarker</code></strong> constructor is:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb326-1" title="1">TPolyMarker(<span class="dt">Int_t</span> n,<span class="dt">Double_t</span> *x,<span class="dt">Double_t</span> *y,<span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>Where <code>x</code> and <code>y</code> are arrays of coordinates for the <code>n</code> points that form the poly-marker.</p>
<h3 id="curly-and-wavy-lines-for-feynman-diagrams"><span class="header-section-number">9.4.5</span> Curly and Wavy Lines for Feynman Diagrams</h3>
<p>This is a peculiarity of particle physics, but we do need sometimes 
to draw Feynman diagrams. Our friends working in banking can skip this 
part. A set of classes implements curly or wavy poly-lines typically 
used to draw Feynman diagrams. Amplitudes and wavelengths may be 
specified in the constructors, via commands or interactively from 
context menus. These classes are <strong><code>TCurlyLine</code></strong> and <strong><code>TCurlyArc</code></strong>. These classes make use of <strong><code>TPolyLine</code></strong> by inheritance; <code>ExecuteEvent</code> methods are highly inspired from the methods used in <strong><code>TPolyLine</code></strong> and <strong><code>TArc</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/030000B4.png" alt="The picture generated by the tutorial macro feynman.C"><figcaption>The picture generated by the tutorial macro feynman.C</figcaption>
</figure>
<p>The <strong><code>TCurlyLine</code></strong> constructor is:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb327-1" title="1">TCurlyLine(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2,</a>
<a class="sourceLine" id="cb327-2" title="2">           <span class="dt">Double_t</span> wavelength, <span class="dt">Double_t</span> amplitude)</a></code></pre></div>
<p>The coordinates <code>(x1</code>, <code>y1)</code> define the starting point, <code>(x2</code>, <code>y2)</code> - the end-point. The <code>wavelength</code> and the <code>amplitude</code> are given in percent of the pad height.</p>
<p>The <strong><code>TCurlyArc</code></strong> constructor is:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb328-1" title="1">TCurlyArc(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> rad,</a>
<a class="sourceLine" id="cb328-2" title="2">          <span class="dt">Double_t</span> phimin, <span class="dt">Double_t</span> phimax,</a>
<a class="sourceLine" id="cb328-3" title="3">          <span class="dt">Double_t</span> wavelength, <span class="dt">Double_t</span> amplitude)</a></code></pre></div>
<p>The curly arc center is <code>(x1</code>, <code>y1)</code> and the radius is <code>rad</code>. The wavelength and the amplitude are given in percent of the line length. The parameters <code>phimin</code> and <code>phimax</code> are the starting and ending angle of the arc (given in degrees). Refer to <code>$ROOTSYS/tutorials/graphics/feynman.C</code> for the script that built the figure above.</p>
<h3 id="text-and-latex-mathematical-expressions"><span class="header-section-number">9.4.6</span> Text and Latex Mathematical Expressions</h3>
<p>Text displayed in a pad may be embedded into boxes, called paves (<strong><code>TPaveLabel</code></strong>),
 or titles of graphs or many other objects but it can live a life of its
 own. All text displayed in ROOT graphics is an object of class <strong><code>TText</code></strong>. For a physicist, it will be most of the time a <strong><code>TLatex</code></strong> expression (which derives from <strong><code>TText</code></strong>). <strong><code>TLatex</code></strong> has been conceived to draw mathematical formulas or equations. Its syntax is very similar to the Latex in mathematical mode.</p>
<h4 id="subscripts-and-superscripts"><span class="header-section-number">9.4.6.1</span> Subscripts and Superscripts</h4>
<p>Subscripts and superscripts are made with the <code>_</code> and <code>^</code>
 commands. These commands can be combined to make complex subscript and 
superscript expressions. You may choose how to display subscripts and 
superscripts using the 2 functions <code>SetIndiceSize(Double_t)</code> and <code>SetLimitIndiceSize(Int_t)</code>. Examples of what can be obtained using subscripts and superscripts:</p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 10%">
<col style="width: 19%">
<col style="width: 12%">
<col style="width: 22%">
<col style="width: 17%">
</colgroup>
<tbody>
<tr class="odd">
<td>The expression</td>
<td>Gives</td>
<td>The expression</td>
<td>Gives</td>
<td>The expression</td>
<td>Gives</td>
</tr>
<tr class="even">
<td><strong><code>x^{2y}</code></strong></td>
<td><span class="math inline">\(x^{2y}\)</span></td>
<td><strong><code>x^{y^{2}}</code></strong></td>
<td><span class="math inline">\(x^{y^{2}}\)</span></td>
<td><strong><code>x_{1}^{y_{1}}</code></strong></td>
<td><span class="math inline">\(x_{1}^{y_{1}}\)</span></td>
</tr>
<tr class="odd">
<td><strong><code>x_{2y}</code></strong></td>
<td><span class="math inline">\(x_{2y}\)</span></td>
<td><strong><code>x^{y_{1}}</code></strong></td>
<td><span class="math inline">\(x^{y_{1}}\)</span></td>
<td><strong><code>x_{1}^{y}</code></strong></td>
<td><span class="math inline">\(x_{1}^{y}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="fractions"><span class="header-section-number">9.4.6.2</span> Fractions</h4>
<p>Fractions denoted by the / symbol are made in the obvious way. The <code>#frac</code>
 command is used for large fractions in displayed formula; it has two 
arguments: the numerator and the denominator. For example, the equation x
 = y + z 2 y 2 + 1 is obtained by following expression <code>x=#frac{y+z/2}{y^{2}+1}</code>.</p>
<h4 id="roots"><span class="header-section-number">9.4.6.3</span> Roots</h4>
<p>The <code>#sqrt</code> command produces the square ROOT of its argument; it has an optional first argument for other roots.</p>
<p>Example: <code>#sqrt{10}  #sqrt[3]{10}</code> <img src="ROOTUsersGuide_files/030000BC.png"></p>
<h4 id="delimiters"><span class="header-section-number">9.4.6.4</span> Delimiters</h4>
<p>You can produce three kinds of proportional delimiters.</p>
<p><code>#[]{....}</code> or “à la” Latex</p>
<p><code>#left[.....#right]</code>big square brackets</p>
<p><code>#{}{....} or #left{.....#right}</code>big curly brackets</p>
<p><code>#||{....} or #left|.....#right|</code>big absolute value symbol</p>
<p><code>#(){....} or #left(.....#right)</code>big parenthesis</p>
<h4 id="changing-style-in-math-mode"><span class="header-section-number">9.4.6.5</span> Changing Style in Math Mode</h4>
<p>You can change the font and the text color at any moment using:</p>
<p><code>#font[font-number]{...}</code> and <code>#color[color-number]{...}</code></p>
<h4 id="line-splitting"><span class="header-section-number">9.4.6.6</span> Line Splitting</h4>
<p>A <strong><code>TLatex</code></strong> string may be split in two with the following command: <code>#splitline{top}{bottom}</code>. <strong><code>TAxis</code></strong> and <strong><code>TGaxis</code></strong>
 objects can take advantage of this feature. For example, the date and 
time could be shown in the time axis over two lines with: <code>#splitline{21 April 2003}{14:23:56}</code></p>
<h3 id="greek-letters"><span class="header-section-number">9.4.7</span> Greek Letters</h3>
<p>The command to produce a lowercase Greek letter is obtained by adding <code>#</code> to the name of the letter. For an uppercase Greek letter, just capitalize the first letter of the command name.</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb329-1" title="1"><span class="pp">#</span><span class="er">alpha     #beta    #chi      #delta     #varepsilon  #phi</span></a>
<a class="sourceLine" id="cb329-2" title="2"><span class="pp">#</span><span class="er">gamma     #eta     #iota     #varphi    #kappa       #lambda</span></a>
<a class="sourceLine" id="cb329-3" title="3"><span class="pp">#</span><span class="er">mu        #nu      #omicron  #pi        #theta       #rho</span></a>
<a class="sourceLine" id="cb329-4" title="4"><span class="pp">#</span><span class="er">sigma     #tau     #upsilon  #varomega  #omega       #xi</span></a>
<a class="sourceLine" id="cb329-5" title="5"><span class="pp">#</span><span class="er">psi       #zeta    #Alpha    #Beta      #Chi         #Delta</span></a>
<a class="sourceLine" id="cb329-6" title="6"><span class="pp">#</span><span class="er">Epsilon   #Phi     #Gamma    #Eta       #Iota        #Kappa</span></a>
<a class="sourceLine" id="cb329-7" title="7"><span class="pp">#</span><span class="er">vartheta  #Lambda  #Mu       #Nu        #Omicron     #Pi</span></a>
<a class="sourceLine" id="cb329-8" title="8"><span class="pp">#</span><span class="er">Theta     #Rho     #Sigma    #Tau       #Upsilon     #Omega</span></a>
<a class="sourceLine" id="cb329-9" title="9"><span class="pp">#</span><span class="er">varsigma  #Xi      #Psi      #epsilon   #varUpsilon  #Zeta</span></a></code></pre></div>
<p><img src="ROOTUsersGuide_files/030000BD.png"></p>
<h3 id="mathematical-symbols"><span class="header-section-number">9.4.8</span> Mathematical Symbols</h3>
<p><img src="ROOTUsersGuide_files/030000BE.png"></p>
<p><strong><code>TLatex</code></strong> can make mathematical and other symbols. A few of them, such as <code>+</code> and <code>&gt;</code>,
 are produced by typing the corresponding keyboard character. Others are
 obtained with the commands as shown in the table above.</p>
<h4 id="accents-arrows-and-bars"><span class="header-section-number">9.4.8.1</span> Accents, Arrows and Bars</h4>
<p>Symbols in a formula are sometimes placed one above another. <strong><code>TLatex</code></strong> provides special commands for that.</p>
<p><code>#hat{a} =</code>hat</p>
<p><code>#check  =</code>inverted hat</p>
<p><code>#acute  =</code>acute</p>
<p><code>#grave  =</code>accent grave</p>
<p><code>#dot    =</code>derivative</p>
<p><code>#ddot   =</code>double derivative</p>
<p><code>#tilde  =</code>tilde</p>
<p><code>#slash  =</code>special sign. Draw a slash on top of the text between brackets for example</p>
<p><code>#slash{E}_{T}</code>generates “Missing ET”</p>
<p>a _ is obtained with <code>#bar{a}</code></p>
<p>a -&gt; is obtained with <code>#vec{a}</code></p>
<h4 id="example-1"><span class="header-section-number">9.4.8.2</span> Example 1</h4>
<p>The script <code>$ROOTSYS/tutorials/graphics/latex.C:</code></p>
<div class="sourceCode" id="cb330"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb330-1" title="1">{</a>
<a class="sourceLine" id="cb330-2" title="2">  TCanvas c1(<span class="st">"c1"</span>,<span class="st">"Latex"</span>,<span class="dv">600</span>,<span class="dv">700</span>);</a>
<a class="sourceLine" id="cb330-3" title="3">  TLatex l;</a>
<a class="sourceLine" id="cb330-4" title="4">  l.SetTextAlign(<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb330-5" title="5">  l.SetTextSize(<span class="fl">0.04</span>);</a>
<a class="sourceLine" id="cb330-6" title="6"></a>
<a class="sourceLine" id="cb330-7" title="7">  l.DrawLatex(<span class="fl">0.1</span>,<span class="fl">0.8</span>,<span class="st">"1) C(x) = d #sqrt{#frac{2}{#lambdaD}}</span></a>
<a class="sourceLine" id="cb330-8" title="8">  <span class="pp">#</span><span class="er">int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt");</span></a>
<a class="sourceLine" id="cb330-9" title="9">  l.DrawLatex(<span class="fl">0.1</span>,<span class="fl">0.6</span>,<span class="st">"2) C(x) = d #sqrt{#frac{2}{#lambdaD}}</span></a>
<a class="sourceLine" id="cb330-10" title="10">  <span class="pp">#</span><span class="er">int^{x}cos(#frac{#pi}{2}t^{2})dt");</span></a>
<a class="sourceLine" id="cb330-11" title="11">  l.DrawLatex(<span class="fl">0.1</span>,<span class="fl">0.4</span>,<span class="st">"3) R = |A|^{2} =</span></a>
<a class="sourceLine" id="cb330-12" title="12">  <span class="pp">#</span><span class="er">frac{1}{2}(#[]{#frac{1}{2}+C(V)}^{2}+</span></a>
<a class="sourceLine" id="cb330-13" title="13">  <span class="pp">#</span><span class="er">[]{#frac{1}{2}+S(V)}^{2})");</span></a>
<a class="sourceLine" id="cb330-14" title="14">  l.DrawLatex(<span class="fl">0.1</span>,<span class="fl">0.2</span>,<span class="st">"4) F(t) = #sum_{i=</span></a>
<a class="sourceLine" id="cb330-15" title="15">  -<span class="er">#infty}^{#infty}A(i)cos#[]{#frac{i}{t+i}}");</span></a>
<a class="sourceLine" id="cb330-16" title="16">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/020000C1.jpg" alt="The picture generated by the tutorial macro latex.C"><figcaption>The picture generated by the tutorial macro latex.C</figcaption>
</figure>
<h4 id="example-2"><span class="header-section-number">9.4.8.3</span> Example 2</h4>
<p>The script <code>$ROOTSYS/tutorials/graphics/latex2.C:</code></p>
<div class="sourceCode" id="cb331"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb331-1" title="1">{</a>
<a class="sourceLine" id="cb331-2" title="2">  TCanvas c1(<span class="st">"c1"</span>,<span class="st">"Latex"</span>,<span class="dv">600</span>,<span class="dv">700</span>);</a>
<a class="sourceLine" id="cb331-3" title="3">  TLatex l;</a>
<a class="sourceLine" id="cb331-4" title="4">  l.SetTextAlign(<span class="dv">23</span>);</a>
<a class="sourceLine" id="cb331-5" title="5">  l.SetTextSize(<span class="fl">0.1</span>);</a>
<a class="sourceLine" id="cb331-6" title="6">  l.DrawLatex(<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="st">"e^{+}e^{-}#rightarrowZ^{0}</span></a>
<a class="sourceLine" id="cb331-7" title="7">  <span class="pp">#</span><span class="er">rightarrowI#bar{I}, q#bar{q}");</span></a>
<a class="sourceLine" id="cb331-8" title="8">  l.DrawLatex(<span class="fl">0.5</span>,<span class="fl">0.75</span>,<span class="st">"|#vec{a}#bullet#vec{b}|=</span></a>
<a class="sourceLine" id="cb331-9" title="9">  <span class="pp">#</span><span class="er">Sigmaa^{i}_{jk}+b^{bj}_{i}");</span></a>
<a class="sourceLine" id="cb331-10" title="10">  l.DrawLatex(<span class="fl">0.5</span>,<span class="fl">0.5</span>,<span class="st">"i(#partial_{#mu}#bar{#psi}#gamma^{#mu}</span></a>
<a class="sourceLine" id="cb331-11" title="11">  +m<span class="er">#bar{#psi}=0</span></a>
<a class="sourceLine" id="cb331-12" title="12">  <span class="pp">#</span><span class="er">Leftrightarrow(#Box+m^{2})#psi=0");</span></a>
<a class="sourceLine" id="cb331-13" title="13">  l.DrawLatex(<span class="fl">0.5</span>,<span class="fl">0.3</span>,<span class="st">"L_{em}=eJ^{#mu}_{em}A_{#mu} ,</span></a>
<a class="sourceLine" id="cb331-14" title="14">  J^{<span class="er">#mu}_{em}=#bar{I}#gamma_{#mu}I</span></a>
<a class="sourceLine" id="cb331-15" title="15">  M^{j}_{i}=<span class="er">#SigmaA_{#alpha}#tau^{#alphaj}_{i}");</span></a>
<a class="sourceLine" id="cb331-16" title="16">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/020000C2.jpg" alt="The picture generated by the tutorial macro latex2.C"><figcaption>The picture generated by the tutorial macro latex2.C</figcaption>
</figure>
<h4 id="example-3"><span class="header-section-number">9.4.8.4</span> Example 3</h4>
<p>The script <code>$ROOTSYS/tutorials/graphics/latex3.C</code>:</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb332-1" title="1">{</a>
<a class="sourceLine" id="cb332-2" title="2">  TCanvas c1(<span class="st">"c1"</span>);</a>
<a class="sourceLine" id="cb332-3" title="3">  TPaveText pt(<span class="fl">.1</span>,<span class="fl">.5</span>,<span class="fl">.9</span>,<span class="fl">.9</span>);</a>
<a class="sourceLine" id="cb332-4" title="4">  pt.AddText(<span class="st">"#frac{2s}{#pi#alpha^{2}}</span></a>
<a class="sourceLine" id="cb332-5" title="5">  <span class="pp">#</span><span class="er">frac{d#sigma}{dcos#theta} (e^{+}e^{-}</span></a>
<a class="sourceLine" id="cb332-6" title="6">  <span class="pp">#</span><span class="er">rightarrow f#bar{f} ) = ");</span></a>
<a class="sourceLine" id="cb332-7" title="7">  pt.AddText(<span class="st">"#left| #frac{1}{1 - #Delta#alpha} #right|^{2}</span></a>
<a class="sourceLine" id="cb332-8" title="8">  (<span class="dv">1</span>+cos^{<span class="dv">2</span>}<span class="er">#theta");</span></a>
<a class="sourceLine" id="cb332-9" title="9">  pt.AddText(<span class="st">"+ 4 Re #left{ #frac{2}{1 - #Delta#alpha} #chi(s)</span></a>
<a class="sourceLine" id="cb332-10" title="10">  <span class="pp">#</span><span class="er">[]{#hat{g}_{#nu}^{e}#hat{g}_{#nu}^{f}</span></a>
<a class="sourceLine" id="cb332-11" title="11">  (<span class="dv">1</span> + cos^{<span class="dv">2</span>}<span class="er">#theta) + 2 #hat{g}_{a}^{e}</span></a>
<a class="sourceLine" id="cb332-12" title="12">  <span class="pp">#</span><span class="er">hat{g}_{a}^{f} cos#theta) } #right}");</span></a>
<a class="sourceLine" id="cb332-13" title="13">  pt.SetLabel(<span class="st">"Born equation"</span>);</a>
<a class="sourceLine" id="cb332-14" title="14">  pt.Draw();</a>
<a class="sourceLine" id="cb332-15" title="15">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/020000C3.jpg" alt="The picture generated by the tutorial macro latex3.C"><figcaption>The picture generated by the tutorial macro latex3.C</figcaption>
</figure>
<h3 id="text-in-a-pad"><span class="header-section-number">9.4.9</span> Text in a Pad</h3>
<p>Text displayed in a pad may be embedded into boxes, called paves, or 
may be drawn alone. In any case, it is recommended to use a Latex 
expression, which is covered in the previous paragraph. Using <strong><code>TLatex</code></strong>
 is valid whether the text is embedded or not. In fact, you will use 
Latex expressions without knowing it since it is the standard for all 
the embedded text. A pave is just a box with a border size and a shadow 
option. The options common to all types of paves and used when building 
those objects are the following:</p>
<p><code>option = "T"</code> top frame</p>
<p><code>option = "B"</code> bottom frame</p>
<p><code>option = "R"</code> right frame</p>
<p><code>option = "L"</code> left frame</p>
<p><code>option = "NDC" x1,y1,x2,y2</code> are given in NDC</p>
<p><code>option = "ARC"</code> corners are rounded</p>
<p>We will see the practical use of these options in the description of the more functional objects like <code>TPaveLabels</code>. There are several categories of paves containing text: <strong><code>TPaveLabel</code></strong>, <strong><code>TPaveText</code></strong> and <strong><code>TPavesText</code></strong>. <code>TPaveLabels</code> are panels containing one line of text. They are used for labeling.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb333-1" title="1">TPaveLabel(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2,</a>
<a class="sourceLine" id="cb333-2" title="2">           <span class="at">const</span> <span class="dt">char</span> *label, <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>Where (<code>x1</code>, <code>y1</code>) are the coordinates of the bottom left corner, <code>(x2,y2)</code> - coordinates of the upper right corner. “<code>label</code>” is the text to be displayed and “<code>option</code>” is the drawing option, described above. By default, the border size is 5 and the option is “<code>br</code>”. If one wants to set the border size to some other value, one may use the method <code>SetBorderSize()</code>.
 For example, suppose we have a histogram, which limits are (-100,100) 
in the x direction and (0, 1000) in the y direction. The following lines
 will draw a label in the center of the histogram, with no border. If 
one wants the label position to be independent of the histogram 
coordinates, or user coordinates, one can use the option “<code>NDC</code>”. See “The Coordinate Systems of a Pad”.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb334-1" title="1">root[] pl = <span class="kw">new</span> TPaveLabel(-<span class="dv">50</span>,<span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">200</span>,<span class="st">"Some text"</span>)</a>
<a class="sourceLine" id="cb334-2" title="2">root[] pl-&gt;SetBorderSize(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb334-3" title="3">root[] pl-&gt;Draw()</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060000C4.png" alt="PaveLabels drawn with different options"><figcaption><code>PaveLabels</code> drawn with different options</figcaption>
</figure>
<p>A <strong><code>TPaveLabel</code></strong> can contain only one line of text. A <strong><code>TPaveText</code></strong> may contain several lines. This is the only difference. This picture illustrates and explains some of the points of <strong><code>TPaveText</code></strong>. Once a <strong><code>TPaveText</code></strong> is drawn, a line can be added or removed by brining up the context menu with the mouse.</p>
<figure>
<img src="ROOTUsersGuide_files/030000C5.png" alt="PaveText examples"><figcaption>PaveText examples</figcaption>
</figure>
<p>A <strong><code>TPavesText</code></strong> is a stack of text panels (see <strong><code>TPaveText</code></strong>).
 One can set the number of stacked panels at building time. It has the 
following constructor: By default, the number of stacked panels is 5, <code>option=</code>“<code>br</code>”.</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb335-1" title="1">TPavesText(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2,</a>
<a class="sourceLine" id="cb335-2" title="2"><span class="dt">Int_t</span> npaves, <span class="dt">Option_t</span>* option)</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000C6.png" alt="A PaveText example"><figcaption>A PaveText example</figcaption>
</figure>
<h3 id="the-tex-processor-tmathtext"><span class="header-section-number">9.4.10</span> The TeX Processor TMathText</h3>
<p>TMathText’s purpose is to write mathematical equations, exactly as TeX would do it. The syntax is the same as the TeX’s one.</p>
<p>The script <code>$ROOTSYS/tutorials/graphics/tmathtex.C</code>:</p>
<p>gives the following output:</p>
<figure>
<img src="ROOTUsersGuide_files/mathtext.png" alt="A TMathText example"><figcaption>A TMathText example</figcaption>
</figure>
<p><code>TMathText</code> uses plain TeX syntax and uses “\” as control instead of “#”. If a piece of text containing “\” is given to <code>TLatex</code> then <code>TMathText</code> is automatically invoked. Therefore, as histograms’ titles, axis titles, labels etc … are drawn using <code>TLatex</code>, the <code>TMathText</code> syntax can be used for them also.</p>
<h2 id="axis"><span class="header-section-number">9.5</span> Axis</h2>
<p>The axis objects are automatically built by various high level 
objects such as histograms or graphs. Once build, one may access them 
and change their characteristics. It is also possible, for some 
particular purposes to build axis on their own. This may be useful for 
example in the case one wants to draw two axis for the same plot, one on
 the left and one on the right.</p>
<p>For historical reasons, there are two classes representing axis. <strong><code>TAxis</code></strong> * <code>axis</code> is the axis object, which will be returned when calling the <code>TH1::GetAxis()</code> method.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb336-1" title="1">TAxis *axis = histo-&gt;GetXaxis()</a></code></pre></div>
<p>Of course, you may do the same for <code>Y</code> and <code>Z</code>-axis. The graphical representation of an axis is done with the <strong><code>TGaxis</code></strong> class. The histogram classes and <strong><code>TGraph</code></strong> generate instances of this class. This is internal and the user should not have to see it.</p>
<h3 id="axis-title"><span class="header-section-number">9.5.1</span> Axis Title</h3>
<p>The axis title is set, as with all named objects, by</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb337-1" title="1">axis-&gt;SetTitle(<span class="st">"Whatever title you want"</span>);</a></code></pre></div>
<p>When the axis is embedded into a histogram or a graph, one has to first extract the axis object:</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb338-1" title="1">h-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"Whatever title you want"</span>)</a></code></pre></div>
<h3 id="axis-options-and-characteristics"><span class="header-section-number">9.5.2</span> Axis Options and Characteristics</h3>
<p>The axis options are most simply set with the styles. The available 
style options controlling specific axis options are the following:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb339-1" title="1">TAxis *axis = histo-&gt;GetXaxis();</a>
<a class="sourceLine" id="cb339-2" title="2">axis-&gt;SetAxisColor(<span class="dt">Color_t</span> color = <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb339-3" title="3">axis-&gt;SetLabelColor(<span class="dt">Color_t</span> color = <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb339-4" title="4">axis-&gt;SetLabelFont(<span class="dt">Style_t</span> font = <span class="dv">62</span>);</a>
<a class="sourceLine" id="cb339-5" title="5">axis-&gt;SetLabelOffset(<span class="dt">Float_t</span> offset = <span class="fl">0.005</span>);</a>
<a class="sourceLine" id="cb339-6" title="6">axis-&gt;SetLabelSize(<span class="dt">Float_t</span> size = <span class="fl">0.04</span>);</a>
<a class="sourceLine" id="cb339-7" title="7">axis-&gt;SetNdivisions(<span class="dt">Int_t</span> n = <span class="dv">510</span>, <span class="dt">Bool_t</span> optim = kTRUE);</a>
<a class="sourceLine" id="cb339-8" title="8">axis-&gt;SetNoExponent(<span class="dt">Bool_t</span> noExponent = kTRUE);</a>
<a class="sourceLine" id="cb339-9" title="9">axis-&gt;SetTickLength(<span class="dt">Float_t</span> length = <span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb339-10" title="10">axis-&gt;SetTitleOffset(<span class="dt">Float_t</span> offset = <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb339-11" title="11">axis-&gt;SetTitleSize(<span class="dt">Float_t</span> size = <span class="fl">0.02</span>);</a></code></pre></div>
<p>The getters corresponding to the described setters are also 
available. The general options, not specific to axis, as for instance <code>SetTitleTextColor()</code> are valid and do have an effect on axis characteristics.</p>
<h3 id="setting-the-number-of-divisions"><span class="header-section-number">9.5.3</span> Setting the Number of Divisions</h3>
<p>Use <code>TAxis::SetNdivisions(ndiv,optim)</code> to set the number of divisions for an axis. The <code>ndiv</code> and <code>optim</code> are as follows:</p>
<ul>
<li><p><code>ndiv = N1 + 100*N2 + 10000*N3</code></p></li>
<li><p><code>N1 =</code> number of first divisions.</p></li>
<li><p><code>N2 =</code> number of secondary divisions.</p></li>
<li><p><code>N3 =</code> number of tertiary divisions.</p></li>
<li><p><code>optim = kTRUE</code> (default), the divisions’ number will be optimized around the specified value.</p></li>
<li><p><code>optim = kFALSE,</code> or n &lt; 0, the axis will be forced to use exactly n divisions.</p></li>
</ul>
<p>For example:</p>
<p><code>ndiv = 0</code>: no tick marks.</p>
<p><code>ndiv = 2</code>: 2 divisions, one tick mark in the middle of the axis.</p>
<p><code>ndiv = 510</code>: 10 primary divisions, 5 secondary divisions</p>
<p><code>ndiv = -10</code>: exactly 10 primary divisions</p>
<h3 id="zooming-the-axis"><span class="header-section-number">9.5.4</span> Zooming the Axis</h3>
<p>You can use <code>TAxis::SetRange</code> or <code>TAxis::SetRangeUser</code> to zoom the axis.</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb340-1" title="1">TAxis::SetRange(<span class="dt">Int_t</span> binfirst,<span class="dt">Int_t</span> binlast)</a></code></pre></div>
<p>The <code>SetRange</code> method parameters are bin numbers. They are
 not axis. For example if a histogram plots the values from 0 to 500 and
 has 100 bins, <code>SetRange(0,10)</code> will cover the values 0 to 50. The parameters for <code>SetRangeUser</code>
 are user coordinates. If the start or end is in the middle of a bin the
 resulting range is approximation. It finds the low edge bin for the 
start and the high edge bin for the high.</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb341-1" title="1">TAxis::SetRangeUser(<span class="dt">Axis_t</span> ufirst,<span class="dt">Axis_t</span> ulast)</a></code></pre></div>
<p>Both methods, <code>SetRange</code> and <code>SetRangeUser</code>, 
are in the context menu of any axis and can be used interactively. In 
addition, you can zoom an axis interactively: click on the axis on the 
start, drag the cursor to the end, and release the mouse button.</p>
<h3 id="drawing-axis-independently-of-graphs-or-histograms"><span class="header-section-number">9.5.5</span> Drawing Axis Independently of Graphs or Histograms</h3>
<p>An axis may be drawn independently of a histogram or a graph. This 
may be useful to draw for example a supplementary axis for a graph. In 
this case, one has to use the <strong><code>TGaxis</code></strong> class, the graphical representation of an axis. One may use the standard constructor for this kind of objects:</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb342-1" title="1">TGaxis(<span class="dt">Double_t</span> xmin, <span class="dt">Double_t</span> ymin, <span class="dt">Double_t</span> xmax, <span class="dt">Double_t</span> ymax,</a>
<a class="sourceLine" id="cb342-2" title="2">       <span class="dt">Double_t</span> wmin, <span class="dt">Double_t</span> wmax, <span class="dt">Int_t</span> ndiv = <span class="dv">510</span>,</a>
<a class="sourceLine" id="cb342-3" title="3">       <span class="dt">Option_t</span>* chopt,<span class="dt">Double_t</span> gridlength = <span class="dv">0</span>)</a></code></pre></div>
<p>The arguments <code>xmin, ymin</code> are the coordinates of the axis’ start in the user coordinates system, <code>and xmax, ymax</code> are the end coordinates. The arguments <code>wmin</code> and <code>wmax</code> are the minimum (at the start) and maximum (at the end) values to be represented on the axis; <code>ndiv</code> is the number of divisions. The options, given by the “<code>chopt</code>” string are the following:</p>
<ul>
<li><p><code>chopt = 'G'</code>: logarithmic scale, default is linear.</p></li>
<li><p><code>chopt = 'B'</code>: Blank axis (it is useful to superpose the axis).</p></li>
</ul>
<p>Instead of the <code>wmin,wmax</code> arguments of the normal constructor, i.e.&nbsp;the limits of the axis, the name of a <strong><code>TF1</code></strong> function can be specified. This function will be used to map the user coordinates to the axis values and ticks.</p>
<p>The constructor is the following:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb343-1" title="1">TGaxis(<span class="dt">Double_t</span> xmin, <span class="dt">Double_t</span> ymin, <span class="dt">Double_t</span> xmax, <span class="dt">Double_t</span> ymax,</a>
<a class="sourceLine" id="cb343-2" title="2">       <span class="at">const</span> <span class="dt">char</span>* funcname, <span class="dt">Int_t</span> ndiv=<span class="dv">510</span>,</a>
<a class="sourceLine" id="cb343-3" title="3">       <span class="dt">Option_t</span>* chopt, <span class="dt">Double_t</span> gridlength=<span class="dv">0</span>)</a></code></pre></div>
<p>In such a way, it is possible to obtain exponential evolution of the 
tick marks position, or even decreasing. In fact, anything you like.</p>
<h3 id="orientation-of-tick-marks-on-axis"><span class="header-section-number">9.5.6</span> Orientation of Tick Marks on Axis</h3>
<p>Tick marks are normally drawn on the positive side of the axis, however, if <code>xmin = xmax</code>, then negative.</p>
<ul>
<li><p><code>chopt = '+':</code> tick marks are drawn on Positive side. (Default)</p></li>
<li><p><code>chopt = '-':</code> tick marks are drawn on the negative side.</p></li>
<li><p><code>chopt = '+-':</code> tick marks are drawn on both sides of the axis.</p></li>
<li><p><code>chopt = ‘U':</code> unlabeled axis, default is labeled.</p></li>
</ul>
<h3 id="labels"><span class="header-section-number">9.5.7</span> Labels</h3>
<h4 id="position"><span class="header-section-number">9.5.7.1</span> Position</h4>
<p>Labels are normally drawn on side opposite to tick marks. However, <code>chopt = '='</code>: on Equal side. The function <code>TAxis::CenterLabels()</code> sets the bit <code>kCenterLabels</code> and it is visible from <strong><code>TAxis</code></strong>
 context menu. It centers the bin labels and it makes sense only when 
the number of bins is equal to the number of tick marks. The class 
responsible for drawing the axis <strong><code>TGaxis</code></strong> inherits this property.</p>
<h4 id="orientation"><span class="header-section-number">9.5.7.2</span> Orientation</h4>
<p>Labels are normally drawn parallel to the axis. However, if <code>xmin = xmax</code>, then they are drawn orthogonal, and if <code>ymin=ymax</code> they are drawn parallel.</p>
<h4 id="labels-for-exponents"><span class="header-section-number">9.5.7.3</span> Labels for Exponents</h4>
<p>By default, an exponent of the form 10^N is used when the label 
values are either all very small or very large. One can disable the 
exponent by calling:</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb344-1" title="1">TAxis::SetNoExponent(kTRUE)</a></code></pre></div>
<p>Note that this option is implicitly selected if the number of digits to draw a label is less than the <code>fgMaxDigits</code> global member. If the property <code>SetNoExponent</code> was set in <strong><code>TAxis</code></strong> (via <code>TAxis::SetNoExponent)</code>, the <strong><code>TGaxis</code></strong> will inherit this property. <strong><code>TGaxis</code></strong> is the class responsible for drawing the axis. The method <code>SetNoExponent</code> is also available from the axis context menu.</p>
<figure>
<img src="ROOTUsersGuide_files/030000C7.png" alt="Y-axis with and without exponent labels"><figcaption>Y-axis with and without exponent labels</figcaption>
</figure>
<h4 id="number-of-digits-in-labels"><span class="header-section-number">9.5.7.4</span> Number of Digits in Labels</h4>
<p><code>TGaxis::fgMaxDigits</code> is the maximum number of digits 
permitted for the axis labels above which the notation with 10^N is 
used. It must be greater than 0. By default <code>fgMaxDigits</code> is 5 and to change it use the <code>TGaxis::SetMaxDigits</code> method. For example to set <code>fgMaxDigits</code> to accept 6 digits and accept numbers like 900000 on an axis call:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb345-1" title="1">TGaxis::SetMaxDigits(<span class="dv">6</span>)</a></code></pre></div>
<h4 id="tick-mark-positions"><span class="header-section-number">9.5.7.5</span> Tick Mark Positions</h4>
<p>Labels are centered on tick marks. However, if <code>xmin = xmax</code>, then they are right adjusted.</p>
<ul>
<li><p><code>chopt = 'R'</code>: labels are right adjusted on tick mark (default is centered)</p></li>
<li><p><code>chopt = 'L'</code>: labels are left adjusted on tick mark.</p></li>
<li><p><code>chopt = 'C'</code>: labels are centered on tick mark.</p></li>
<li><p><code>chopt = 'M'</code>: In the Middle of the divisions.</p></li>
</ul>
<h4 id="label-formatting"><span class="header-section-number">9.5.7.6</span> Label Formatting</h4>
<p>Blank characters are stripped, and then the label is correctly 
aligned. The dot, if last character of the string, is also stripped. In 
the following, we have some parameters, like tick marks length and 
characters height (in percentage of the length of the axis, in user 
coordinates). The default values are as follows:</p>
<ul>
<li><p>Primary tick marks: 3.0 %</p></li>
<li><p>Secondary tick marks: 1.5 %</p></li>
<li><p>Third order tick marks: .75 %</p></li>
<li><p>Characters height for labels: 4%</p></li>
<li><p>Labels offset: 1.0 %</p></li>
</ul>
<h4 id="stripping-decimals"><span class="header-section-number">9.5.7.7</span> Stripping Decimals</h4>
<p>Use the <code>TStyle::SetStripDecimals</code> to strip decimals when drawing axis labels. By default, the option is set to true, and <code>TGaxis::PaintAxis</code> removes trailing zeros after the dot in the axis labels, e.g.&nbsp;{0, 0.5, 1, 1.5, 2, 2.5, etc.}</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb346-1" title="1">TStyle::SetStripDecimals (<span class="dt">Bool_t</span> strip=kTRUE)</a></code></pre></div>
<p>If this function is called with <code>strip=kFALSE</code>, <code>TGaxis::PaintAxis()</code> will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}</p>
<h4 id="optional-grid"><span class="header-section-number">9.5.7.8</span> Optional Grid</h4>
<p><code>chopt = 'W'</code>: cross-Wire</p>
<h4 id="axis-binning-optimization"><span class="header-section-number">9.5.7.9</span> Axis Binning Optimization</h4>
<p>By default, the axis binning is optimized.</p>
<ul>
<li><p><code>chopt = 'N'</code>: No binning optimization</p></li>
<li><p><code>chopt = 'I'</code>: Integer labeling</p></li>
</ul>
<h3 id="axis-with-time-units"><span class="header-section-number">9.5.8</span> Axis with Time Units</h3>
<p>Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the <code>SetTimeDisplay</code> attribute on a given axis. If <code>h</code> is a histogram, it is done the following way:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb347-1" title="1">h-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);    <span class="co">// X axis is a time axis</span></a></code></pre></div>
<p>Two parameters can be adjusted in order to define time axis: the time format and the time offset.</p>
<h4 id="time-format"><span class="header-section-number">9.5.8.1</span> Time Format</h4>
<p>It defines the format of the labels along the time axis. It can be changed using the <strong><code>TAxis</code></strong> method <code>SetTimeFormat</code>. The time format is the one used by the C function <code>strftime()</code>. It is a string containing the following formatting characters:</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<tbody>
<tr class="odd">
<td>For the date:</td>
<td><p>%a abbreviated weekday name</p>
<p>%b abbreviated month name</p>
<p>%d day of the month (01-31)</p>
<p>%m month (01-12)</p>
<p>%y year without century</p>
<p>%Y year with century</p></td>
</tr>
<tr class="even">
<td>For the time:</td>
<td><p>%H hour (24-hour clock)</p>
<p>%I hour (12-hour clock)</p>
<p>%p local equivalent of AM or PM</p>
<p>%M minute (00-59)</p>
<p>%S seconds (00-61)</p>
<p>%% %</p></td>
</tr>
</tbody>
</table>
<p>The other characters are output as is. For example to have a format like <code>dd/mm/yyyy</code> one should do:</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb348-1" title="1">h-&gt;GetXaxis()-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%Y"</span>);</a></code></pre></div>
<p>If the time format is not defined, a default one will be computed automatically.</p>
<h4 id="time-offset"><span class="header-section-number">9.5.8.2</span> Time Offset</h4>
<p>This is a time in seconds in the UNIX standard UTC format (the 
universal time, not the local one), defining the starting date of a 
histogram axis. This date should be greater than 01/01/95 and is given 
in seconds. There are three ways to define the time offset:</p>
<p>1- By setting the global default time offset:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb349-1" title="1">TDatime da(<span class="dv">2003</span>,<span class="bn">02</span>,<span class="dv">28</span>,<span class="dv">12</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb349-2" title="2">gStyle-&gt;SetTimeOffset(da.Convert());</a></code></pre></div>
<p>If no time offset is defined for a particular axis, the default time 
offset will be used. In the example above, notice the usage of <strong><code>TDatime</code></strong> to translate an explicit date into the time in seconds required by <code>SetTimeFormat</code>.</p>
<p>2- By setting a time offset to a particular axis:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb350-1" title="1">TDatime dh(<span class="dv">2001</span>,<span class="er">09</span>,<span class="dv">23</span>,<span class="dv">15</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb350-2" title="2">h-&gt;GetXaxis()-&gt;SetTimeOffset(dh.Convert());</a></code></pre></div>
<p>3- Together with the time format using <code>SetTimeFormat</code>. The time offset can be specified using the control character %F after the normal time format. <code>%F</code> is followed by the date in the format: <code>yyyy-mm-dd hh:mm:ss</code>.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb351-1" title="1">h-&gt;GetXaxis()-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%y</span><span class="sc">%F</span><span class="st">2000-02-28 13:00:01"</span>);</a></code></pre></div>
<p>Notice that this date format is the same used by the <strong><code>TDatime</code></strong> function <code>AsSQLString</code>. If needed, this function can be used to translate a time in seconds into a character string which can be appended after <code>%F</code>. If the time format is not specified (before <code>%F</code>) the automatic one will be used. The following example illustrates the various possibilities.</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb352-1" title="1">{</a>
<a class="sourceLine" id="cb352-2" title="2">  gStyle-&gt;SetTitleH(<span class="fl">0.08</span>);</a>
<a class="sourceLine" id="cb352-3" title="3">  TDatime da(<span class="dv">2003</span>,<span class="bn">02</span>,<span class="dv">28</span>,<span class="dv">12</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb352-4" title="4">  gStyle-&gt;SetTimeOffset(da.Convert());</a>
<a class="sourceLine" id="cb352-5" title="5">  ct = <span class="kw">new</span> TCanvas(<span class="st">"ct"</span>,<span class="st">"Time on axis"</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">600</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb352-6" title="6">  ct-&gt;Divide(<span class="dv">1</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb352-7" title="7">  ht1 = <span class="kw">new</span> TH1F(<span class="st">"ht1"</span>,<span class="st">"ht1"</span>,<span class="dv">30000</span>,<span class="fl">0.</span>,<span class="fl">200000.</span>);</a>
<a class="sourceLine" id="cb352-8" title="8">  ht2 = <span class="kw">new</span> TH1F(<span class="st">"ht2"</span>,<span class="st">"ht2"</span>,<span class="dv">30000</span>,<span class="fl">0.</span>,<span class="fl">200000.</span>);</a>
<a class="sourceLine" id="cb352-9" title="9">  ht3 = <span class="kw">new</span> TH1F(<span class="st">"ht3"</span>,<span class="st">"ht3"</span>,<span class="dv">30000</span>,<span class="fl">0.</span>,<span class="fl">200000.</span>);</a>
<a class="sourceLine" id="cb352-10" title="10">  <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">1</span>;i&lt;<span class="dv">30000</span>;i++) {</a>
<a class="sourceLine" id="cb352-11" title="11">    <span class="dt">Float_t</span> noise = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">120</span>);</a>
<a class="sourceLine" id="cb352-12" title="12">    ht1-&gt;SetBinContent(i,noise);</a>
<a class="sourceLine" id="cb352-13" title="13">    ht2-&gt;SetBinContent(i,noise*noise);</a>
<a class="sourceLine" id="cb352-14" title="14">    ht3-&gt;SetBinContent(i,noise*noise*noise);</a>
<a class="sourceLine" id="cb352-15" title="15">  }</a>
<a class="sourceLine" id="cb352-16" title="16">  ct-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb352-17" title="17">  ht1-&gt;GetXaxis()-&gt;SetLabelSize(<span class="fl">0.06</span>);</a>
<a class="sourceLine" id="cb352-18" title="18">  ht1-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb352-19" title="19">  ht1-&gt;GetXaxis()-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%y</span><span class="sc">%F</span><span class="st">2000-02-2813:00:01"</span>);</a>
<a class="sourceLine" id="cb352-20" title="20">  ht1-&gt;Draw();</a>
<a class="sourceLine" id="cb352-21" title="21">  ct-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb352-22" title="22">  ht2-&gt;GetXaxis()-&gt;SetLabelSize(<span class="fl">0.06</span>);</a>
<a class="sourceLine" id="cb352-23" title="23">  ht2-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb352-24" title="24">  ht2-&gt;GetXaxis()-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%y"</span>);</a>
<a class="sourceLine" id="cb352-25" title="25">  ht2-&gt;Draw();</a>
<a class="sourceLine" id="cb352-26" title="26">  ct-&gt;cd(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb352-27" title="27">  ht3-&gt;GetXaxis()-&gt;SetLabelSize(<span class="fl">0.06</span>);</a>
<a class="sourceLine" id="cb352-28" title="28">  TDatime dh(<span class="dv">2001</span>,<span class="er">09</span>,<span class="dv">23</span>,<span class="dv">15</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb352-29" title="29">  ht3-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb352-30" title="30">  ht3-&gt;GetXaxis()-&gt;SetTimeOffset(dh.Convert());</a>
<a class="sourceLine" id="cb352-31" title="31">  ht3-&gt;Draw();</a>
<a class="sourceLine" id="cb352-32" title="32">}</a></code></pre></div>
<p>The output is shown in the figure below. If a time axis has no 
specified time offset, the global time offset will be stored in the axis
 data structure. The histogram limits are in seconds. If <code>wmin</code> and <code>wmax</code> are the histogram limits, the time axis will spread around the time offset value from <code>TimeOffset+wmin</code> to <code>TimeOffset+wmax</code>.
 Until now all examples had a lowest value equal to 0. The following 
example demonstrates how to define the histogram limits relatively to 
the time offset value.</p>
<figure>
<img src="ROOTUsersGuide_files/030000C8.png" alt="Time axis examples"><figcaption>Time axis examples</figcaption>
</figure>
<div class="sourceCode" id="cb353"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb353-1" title="1">{</a>
<a class="sourceLine" id="cb353-2" title="2">  <span class="co">// Define the time offset as 2003, January 1st</span></a>
<a class="sourceLine" id="cb353-3" title="3">  TDatime T0(<span class="dv">2003</span>,<span class="bn">01</span>,<span class="bn">01</span>,<span class="bn">00</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb353-4" title="4">  <span class="dt">int</span> X0 = T0.Convert();</a>
<a class="sourceLine" id="cb353-5" title="5">  gStyle-&gt;SetTimeOffset(X0);</a>
<a class="sourceLine" id="cb353-6" title="6"></a>
<a class="sourceLine" id="cb353-7" title="7">  <span class="co">// Define the lowest histogram limit as 2002,September 23rd</span></a>
<a class="sourceLine" id="cb353-8" title="8">   TDatime T1(<span class="dv">2002</span>,<span class="er">09</span>,<span class="dv">23</span>,<span class="bn">00</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb353-9" title="9">   <span class="dt">int</span> X1 = T1.Convert()-X0;</a>
<a class="sourceLine" id="cb353-10" title="10"></a>
<a class="sourceLine" id="cb353-11" title="11">  <span class="co">// Define the highest histogram limit as 2003, March 7th</span></a>
<a class="sourceLine" id="cb353-12" title="12">  TDatime T2(<span class="dv">2003</span>,<span class="bn">03</span>,<span class="bn">07</span>,<span class="bn">00</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb353-13" title="13">  <span class="dt">int</span> X2 = T2.Convert(<span class="dv">1</span>)-X0;</a>
<a class="sourceLine" id="cb353-14" title="14"></a>
<a class="sourceLine" id="cb353-15" title="15">  TH1F * h1 = <span class="kw">new</span> TH1F(<span class="st">"h1"</span>,<span class="st">"test"</span>,<span class="dv">100</span>,X1,X2);</a>
<a class="sourceLine" id="cb353-16" title="16"></a>
<a class="sourceLine" id="cb353-17" title="17">  TRandom r;</a>
<a class="sourceLine" id="cb353-18" title="18">  <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;<span class="dv">30000</span>;i++) {</a>
<a class="sourceLine" id="cb353-19" title="19">    <span class="dt">Double_t</span> noise = r.Gaus(<span class="fl">0.5</span>*(X1+X2),<span class="fl">0.1</span>*(X2-X1));</a>
<a class="sourceLine" id="cb353-20" title="20">    h1-&gt;Fill(noise);</a>
<a class="sourceLine" id="cb353-21" title="21">  }</a>
<a class="sourceLine" id="cb353-22" title="22"></a>
<a class="sourceLine" id="cb353-23" title="23">  h1-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb353-24" title="24">  h1-&gt;GetXaxis()-&gt;SetLabelSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb353-25" title="25">  h1-&gt;GetXaxis()-&gt;SetTimeFormat(<span class="st">"%Y/%m/</span><span class="sc">%d</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb353-26" title="26">  h1-&gt;Draw();</a>
<a class="sourceLine" id="cb353-27" title="27">}</a></code></pre></div>
<p>The output is shown in the next figure. Usually time axes are created
 automatically via histograms, but one may also want to draw a time axis
 outside a “histogram context”. Therefore, it is useful to understand 
how <strong><code>TGaxis</code></strong> works for such axis. The time 
offset can be defined using one of the three methods described before. 
The time axis will spread around the time offset value. Actually, it 
will go from <code>TimeOffset+wmin</code> to <code>TimeOffset+wmax</code> where <code>wmin</code> and <code>wmax</code>
 are the minimum and maximum values (in seconds) of the axis. Let us 
take again an example. Having defined “2003, February 28 at 12h”, we 
would like to see the axis a day before and a day after.</p>
<figure>
<img src="ROOTUsersGuide_files/030000C9.png" alt="A histogram with time axis X"><figcaption>A histogram with time axis X</figcaption>
</figure>
<p>A <strong><code>TGaxis</code></strong> can be created the following way (a day has 86400 seconds):</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb354-1" title="1">TGaxis *axis = <span class="kw">new</span> TGaxis(x1,y1,x2,y2,-<span class="dv">100000</span>,<span class="dv">150000</span>,<span class="dv">2405</span>,<span class="st">"t"</span>);</a></code></pre></div>
<p>the “<code>t</code>” option (in lower case) means it is a “time axis”. The axis goes form 100000 seconds before <code>TimeOffset</code> and 150000 seconds after. So the complete macro is:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb355-1" title="1">{</a>
<a class="sourceLine" id="cb355-2" title="2">  c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"Examples of TGaxis"</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb355-3" title="3">  c1-&gt;Range(-<span class="dv">10</span>,-<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb355-4" title="4">  TGaxis *axis = <span class="kw">new</span> TGaxis(-<span class="dv">8</span>,-<span class="fl">0.6</span>,<span class="dv">8</span>,-<span class="fl">0.6</span>,-<span class="dv">100000</span>,<span class="dv">150000</span>,<span class="dv">2405</span>,<span class="st">"t"</span>);</a>
<a class="sourceLine" id="cb355-5" title="5">  axis-&gt;SetLabelSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb355-6" title="6"></a>
<a class="sourceLine" id="cb355-7" title="7">  TDatime da(<span class="dv">2003</span>,<span class="bn">02</span>,<span class="dv">28</span>,<span class="dv">12</span>,<span class="bn">00</span>,<span class="bn">00</span>);</a>
<a class="sourceLine" id="cb355-8" title="8">  axis-&gt;SetTimeOffset(da.Convert());</a>
<a class="sourceLine" id="cb355-9" title="9">  axis-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%Y"</span>);</a>
<a class="sourceLine" id="cb355-10" title="10">  axis-&gt;Draw();</a>
<a class="sourceLine" id="cb355-11" title="11">}</a></code></pre></div>
<p>The time format is specified with:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb356-1" title="1">axis-&gt;SetTimeFormat(<span class="st">"</span><span class="sc">%d</span><span class="st">/%m/%Y"</span>);</a></code></pre></div>
<p>The macro gives the following output:</p>
<p><img src="ROOTUsersGuide_files/030000CA.png"></p>
<p>Thanks to the <strong><code>TLatex</code></strong> directive <code>#splitline</code> it is possible to write the time labels on two lines. In the previous example changing the <code>SetTimeFormat</code> line by:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb357-1" title="1">axis-&gt;SetLabelOffset(<span class="fl">0.02</span>);</a>
<a class="sourceLine" id="cb357-2" title="2">axis-&gt;SetTimeFormat(<span class="st">"#splitline{%Y}{</span><span class="sc">%d</span><span class="st">/%m}"</span>);</a></code></pre></div>
<p>will produce the following axis:</p>
<p><img src="ROOTUsersGuide_files/030000CB.png"></p>
<h3 id="axis-examples"><span class="header-section-number">9.5.9</span> Axis Examples</h3>
<p>To illustrate what was said, we provide two scripts. The first one creates the picture shown in the next figure.</p>
<figure>
<img src="ROOTUsersGuide_files/030000CC.png" alt="The first axis example"><figcaption>The first axis example</figcaption>
</figure>
<p>The first script is:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb358-1" title="1">{</a>
<a class="sourceLine" id="cb358-2" title="2">  c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"Examples of Gaxis"</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb358-3" title="3">  c1-&gt;Range(-<span class="dv">10</span>,-<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb358-4" title="4"></a>
<a class="sourceLine" id="cb358-5" title="5">  TGaxis *axis1 = <span class="kw">new</span> TGaxis(-<span class="fl">4.5</span>,-<span class="fl">0.2</span>,<span class="fl">5.5</span>,-<span class="fl">0.2</span>,-<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">510</span>,<span class="st">""</span>);</a>
<a class="sourceLine" id="cb358-6" title="6">  axis1-&gt;SetName(<span class="st">"axis1"</span>);</a>
<a class="sourceLine" id="cb358-7" title="7">  axis1-&gt;Draw();</a>
<a class="sourceLine" id="cb358-8" title="8">  TGaxis *axis2 = <span class="kw">new</span> TGaxis(<span class="fl">4.5</span>,<span class="fl">0.2</span>,<span class="fl">5.5</span>,<span class="fl">0.2</span>,<span class="fl">0.001</span>,<span class="dv">10000</span>,<span class="dv">510</span>,<span class="st">"G"</span>);</a>
<a class="sourceLine" id="cb358-9" title="9">  axis2-&gt;SetName(<span class="st">"axis2"</span>);</a>
<a class="sourceLine" id="cb358-10" title="10">  axis2-&gt;Draw();</a>
<a class="sourceLine" id="cb358-11" title="11"></a>
<a class="sourceLine" id="cb358-12" title="12">  TGaxis *axis3 = <span class="kw">new</span> TGaxis(-<span class="dv">9</span>,-<span class="fl">0.8</span>,-<span class="dv">9</span>,<span class="fl">0.8</span>,-<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">50510</span>,<span class="st">""</span>);</a>
<a class="sourceLine" id="cb358-13" title="13">  axis3-&gt;SetName(<span class="st">"axis3"</span>);</a>
<a class="sourceLine" id="cb358-14" title="14">  axis3-&gt;Draw();</a>
<a class="sourceLine" id="cb358-15" title="15">  TGaxis *axis4 = <span class="kw">new</span> TGaxis(-<span class="dv">7</span>,-<span class="fl">0.8</span>,<span class="dv">7</span>,<span class="fl">0.8</span>,<span class="dv">1</span>,<span class="dv">10000</span>,<span class="dv">50510</span>,<span class="st">"G"</span>);</a>
<a class="sourceLine" id="cb358-16" title="16">  axis4-&gt;SetName(<span class="st">"axis4"</span>);</a>
<a class="sourceLine" id="cb358-17" title="17">  axis4-&gt;Draw();</a>
<a class="sourceLine" id="cb358-18" title="18"></a>
<a class="sourceLine" id="cb358-19" title="19">  TGaxis *axis5 = <span class="kw">new</span> TGaxis(-<span class="fl">4.5</span>,-<span class="dv">6</span>,<span class="fl">5.5</span>,-<span class="dv">6</span>,<span class="fl">1.2</span>,<span class="fl">1.32</span>,<span class="dv">80506</span>,<span class="st">"-+"</span>);</a>
<a class="sourceLine" id="cb358-20" title="20">  axis5-&gt;SetName(<span class="st">"axis5"</span>);</a>
<a class="sourceLine" id="cb358-21" title="21">  axis5-&gt;SetLabelSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb358-22" title="22">  axis5-&gt;SetTextFont(<span class="dv">72</span>);</a>
<a class="sourceLine" id="cb358-23" title="23">  axis5-&gt;SetLabelOffset(<span class="fl">0.025</span>);</a>
<a class="sourceLine" id="cb358-24" title="24">  axis5-&gt;Draw();</a>
<a class="sourceLine" id="cb358-25" title="25"></a>
<a class="sourceLine" id="cb358-26" title="26">  TGaxis *axis6 = <span class="kw">new</span> TGaxis(-<span class="fl">4.5</span>,<span class="fl">0.6</span>,<span class="fl">5.5</span>,<span class="fl">0.6</span>,<span class="dv">100</span>,<span class="dv">900</span>,<span class="dv">50510</span>,<span class="st">"-"</span>);</a>
<a class="sourceLine" id="cb358-27" title="27">  axis6-&gt;SetName(<span class="st">"axis6"</span>);</a>
<a class="sourceLine" id="cb358-28" title="28">  axis6-&gt;Draw();</a>
<a class="sourceLine" id="cb358-29" title="29">  TGaxis *axis7 = <span class="kw">new</span> TGaxis(<span class="dv">8</span>,-<span class="fl">0.8</span>,<span class="dv">8</span>,<span class="fl">0.8</span>,<span class="dv">0</span>,<span class="dv">9000</span>,<span class="dv">50510</span>,<span class="st">"+L"</span>);</a>
<a class="sourceLine" id="cb358-30" title="30">  axis7-&gt;SetName(<span class="st">"axis7"</span>);</a>
<a class="sourceLine" id="cb358-31" title="31">  axis7-&gt;SetLabelOffset(<span class="fl">0.01</span>);</a>
<a class="sourceLine" id="cb358-32" title="32">  axis7-&gt;Draw();</a>
<a class="sourceLine" id="cb358-33" title="33"></a>
<a class="sourceLine" id="cb358-34" title="34">  <span class="co">// one can make axis top-&gt;bottom. However because of a problem,</span></a>
<a class="sourceLine" id="cb358-35" title="35">  <span class="co">// the two x values should not be equal</span></a>
<a class="sourceLine" id="cb358-36" title="36">  TGaxis *axis8 = <span class="kw">new</span> TGaxis(<span class="fl">6.5</span>,<span class="fl">0.8</span>,<span class="fl">6.499</span>,-<span class="fl">0.8</span>,<span class="dv">0</span>,<span class="dv">90</span>,<span class="dv">50510</span>,<span class="st">"-"</span>);</a>
<a class="sourceLine" id="cb358-37" title="37">  axis8-&gt;SetName(<span class="st">"axis8"</span>);</a>
<a class="sourceLine" id="cb358-38" title="38">  axis8-&gt;Draw();</a>
<a class="sourceLine" id="cb358-39" title="39">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000CD.png" alt="The second axis example"><figcaption>The second axis example</figcaption>
</figure>
<p>The second example shows the use of the second form of the constructor, with axis ticks position determined by a function <strong><code>TF1</code></strong>:</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb359-1" title="1"><span class="dt">void</span> gaxis3a()</a>
<a class="sourceLine" id="cb359-2" title="2">{</a>
<a class="sourceLine" id="cb359-3" title="3">  gStyle-&gt;SetOptStat(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb359-4" title="4"></a>
<a class="sourceLine" id="cb359-5" title="5">  TH2F *h2 = <span class="kw">new</span> TH2F(<span class="st">"h"</span>,<span class="st">"Axes"</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb359-6" title="6">  h2-&gt;Draw();</a>
<a class="sourceLine" id="cb359-7" title="7">  TF1 *f1=<span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"-x"</span>,-<span class="dv">10</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb359-8" title="8">  TGaxis *A1 = <span class="kw">new</span> TGaxis(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">10</span>,<span class="dv">2</span>,<span class="st">"f1"</span>,<span class="dv">510</span>,<span class="st">"-"</span>);</a>
<a class="sourceLine" id="cb359-9" title="9">  A1-&gt;SetTitle(<span class="st">"axis with decreasing values"</span>);</a>
<a class="sourceLine" id="cb359-10" title="10">  A1-&gt;Draw();</a>
<a class="sourceLine" id="cb359-11" title="11"></a>
<a class="sourceLine" id="cb359-12" title="12">  TF1 *f2=<span class="kw">new</span> TF1(<span class="st">"f2"</span>,<span class="st">"exp(x)"</span>,<span class="dv">0</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb359-13" title="13">  TGaxis *A2 = <span class="kw">new</span> TGaxis(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">1</span>,<span class="st">"f2"</span>);</a>
<a class="sourceLine" id="cb359-14" title="14">  A2-&gt;SetTitle(<span class="st">"exponential axis"</span>);</a>
<a class="sourceLine" id="cb359-15" title="15">  A2-&gt;SetLabelSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb359-16" title="16">  A2-&gt;SetTitleSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb359-17" title="17">  A2-&gt;SetTitleOffset(<span class="fl">1.2</span>);</a>
<a class="sourceLine" id="cb359-18" title="18">  A2-&gt;Draw();</a>
<a class="sourceLine" id="cb359-19" title="19"></a>
<a class="sourceLine" id="cb359-20" title="20">  TF1 *f3=<span class="kw">new</span> TF1(<span class="st">"f3"</span>,<span class="st">"log10(x)"</span>,<span class="dv">0</span>,<span class="dv">800</span>);</a>
<a class="sourceLine" id="cb359-21" title="21">  TGaxis *A3 = <span class="kw">new</span> TGaxis(<span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="st">"f3"</span>,<span class="dv">505</span>);</a>
<a class="sourceLine" id="cb359-22" title="22">  A3-&gt;SetTitle(<span class="st">"logarithmic axis"</span>);</a>
<a class="sourceLine" id="cb359-23" title="23">  A3-&gt;SetLabelSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb359-24" title="24">  A3-&gt;SetTitleSize(<span class="fl">0.03</span>);</a>
<a class="sourceLine" id="cb359-25" title="25">  A3-&gt;SetTitleOffset(<span class="fl">1.2</span>);</a>
<a class="sourceLine" id="cb359-26" title="26">  A3-&gt;Draw();</a>
<a class="sourceLine" id="cb359-27" title="27">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000CE.png" alt="An axis example with time display"><figcaption>An axis example with time display</figcaption>
</figure>
<div class="sourceCode" id="cb360"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb360-1" title="1"><span class="co">// strip chart example</span></a>
<a class="sourceLine" id="cb360-2" title="2"><span class="dt">void</span> seism() {</a>
<a class="sourceLine" id="cb360-3" title="3"></a>
<a class="sourceLine" id="cb360-4" title="4">  TStopwatch sw; sw.Start();</a>
<a class="sourceLine" id="cb360-5" title="5">  <span class="co">//set time offset</span></a>
<a class="sourceLine" id="cb360-6" title="6">  TDatime dtime;</a>
<a class="sourceLine" id="cb360-7" title="7">  gStyle-&gt;SetTimeOffset(dtime.Convert());</a>
<a class="sourceLine" id="cb360-8" title="8">  TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"Time on axis"</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">1000</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb360-9" title="9">  c1-&gt;SetFillColor(<span class="dv">42</span>);</a>
<a class="sourceLine" id="cb360-10" title="10">  c1-&gt;SetFrameFillColor(<span class="dv">33</span>);</a>
<a class="sourceLine" id="cb360-11" title="11">  c1-&gt;SetGrid();</a>
<a class="sourceLine" id="cb360-12" title="12"></a>
<a class="sourceLine" id="cb360-13" title="13">  <span class="dt">Float_t</span> bintime = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb360-14" title="14">  <span class="co">// one bin = 1 second. change it to set the time scale</span></a>
<a class="sourceLine" id="cb360-15" title="15">  TH1F *ht = <span class="kw">new</span> TH1F(<span class="st">"ht"</span>,<span class="st">"The ROOT seism"</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>*bintime);</a>
<a class="sourceLine" id="cb360-16" title="16">  <span class="dt">Float_t</span> signal = <span class="dv">1000</span>;</a>
<a class="sourceLine" id="cb360-17" title="17">  ht-&gt;SetMaximum(signal);</a>
<a class="sourceLine" id="cb360-18" title="18">  ht-&gt;SetMinimum(-signal);</a>
<a class="sourceLine" id="cb360-19" title="19">  ht-&gt;SetStats(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb360-20" title="20">  ht-&gt;SetLineColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb360-21" title="21">  ht-&gt;GetXaxis()-&gt;SetTimeDisplay(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb360-22" title="22">  ht-&gt;GetYaxis()-&gt;SetNdivisions(<span class="dv">520</span>);</a>
<a class="sourceLine" id="cb360-23" title="23">  ht-&gt;Draw();</a>
<a class="sourceLine" id="cb360-24" title="24"></a>
<a class="sourceLine" id="cb360-25" title="25">  <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">1</span>;i&lt;<span class="dv">2300</span>;i++) {</a>
<a class="sourceLine" id="cb360-26" title="26">    <span class="co">// Build a signal : noisy damped sine</span></a>
<a class="sourceLine" id="cb360-27" title="27">    <span class="dt">Float_t</span> noise  = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">120</span>);</a>
<a class="sourceLine" id="cb360-28" title="28">    <span class="cf">if</span> (i &gt; <span class="dv">700</span>)</a>
<a class="sourceLine" id="cb360-29" title="29">      noise += signal*sin((i-<span class="fl">700.</span>)*<span class="fl">6.28</span>/<span class="dv">30</span>)*exp((<span class="fl">700.</span>-i)/<span class="fl">300.</span>);</a>
<a class="sourceLine" id="cb360-30" title="30">    ht-&gt;SetBinContent(i,noise);</a>
<a class="sourceLine" id="cb360-31" title="31">    c1-&gt;Modified();</a>
<a class="sourceLine" id="cb360-32" title="32">    c1-&gt;Update();</a>
<a class="sourceLine" id="cb360-33" title="33">    gSystem-&gt;ProcessEvents();</a>
<a class="sourceLine" id="cb360-34" title="34">    <span class="co">//canvas can be edited during the loop</span></a>
<a class="sourceLine" id="cb360-35" title="35">   }</a>
<a class="sourceLine" id="cb360-36" title="36">   printf(<span class="st">"Real Time = %8.3fs,Cpu Time = %8.3fsn"</span>,sw.RealTime(),</a>
<a class="sourceLine" id="cb360-37" title="37">          sw.CpuTime());</a>
<a class="sourceLine" id="cb360-38" title="38">}</a></code></pre></div>
<h2 id="graphical-objects-attributes"><span class="header-section-number">9.6</span> Graphical Objects Attributes</h2>
<h3 id="text-attributes"><span class="header-section-number">9.6.1</span> Text Attributes</h3>
<p>When a class contains text or derives from a text class, it needs to 
be able to set text attributes like font type, size, and color. To do 
so, the class inherits from the <strong><code>TAttText</code></strong> class (a secondary inheritance), which defines text attributes. <strong><code>TLatex</code></strong> and <strong><code>TText</code></strong> inherit from <strong><code>TAttText</code></strong>.</p>
<h4 id="setting-text-alignment"><span class="header-section-number">9.6.1.1</span> Setting Text Alignment</h4>
<p>Text alignment may be set by a method call. What is said here applies to all objects deriving from <strong><code>TAttText</code></strong>, and there are many. We will take an example that may be transposed to other types. Suppose “<code>la</code>” is a <strong><code>TLatex</code></strong> object. The alignment is set with:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb361-1" title="1">root[] la-&gt;SetTextAlign(align)</a></code></pre></div>
<p>The parameter <code>align</code> is a <code>short</code> describing the alignment:</p>
<p><code>align  = 10*HorizontalAlign + VerticalAlign</code></p>
<p>For horizontal alignment, the following convention applies:</p>
<ul>
<li><p>1 = left</p></li>
<li><p>2 = centered</p></li>
<li><p>3 = right</p></li>
</ul>
<p>For vertical alignment, the following convention applies:</p>
<ul>
<li><p>1 = bottom</p></li>
<li><p>2 = centered</p></li>
<li><p>3 = top</p></li>
</ul>
<p>For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.</p>
<h4 id="setting-text-angle"><span class="header-section-number">9.6.1.2</span> Setting Text Angle</h4>
<p>Use <code>TAttText::SetTextAngle</code> to set the text angle. The <code>angle</code> is the degrees of the horizontal.</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb362-1" title="1">root[] la-&gt;SetTextAngle(angle)</a></code></pre></div>
<h4 id="setting-text-color"><span class="header-section-number">9.6.1.3</span> Setting Text Color</h4>
<p>Use <code>TAttText::SetTextColor</code> to set the text color. The <code>color</code> is the color index. The colors are described in “Color and Color Palettes”.</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb363-1" title="1">root[] la-&gt;SetTextColor(color)</a></code></pre></div>
<h4 id="setting-text-font"><span class="header-section-number">9.6.1.4</span> Setting Text Font</h4>
<p>Use <code>TAttText::SetTextFont</code> to set the font. The parameter font is the font code, combining the font and precision: <code>font = 10 * fontID + precision</code></p>
<div class="sourceCode" id="cb364"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb364-1" title="1">root[] la-&gt;SetTextFont(font)</a></code></pre></div>
<p>The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:</p>
<ul>
<li><p>Precision = 0 fast hardware fonts (steps in the size)</p></li>
<li><p>Precision = 1 scalable and rotate-able hardware fonts (see below)</p></li>
<li><p>Precision = 2 scalable and rotate-able hardware fonts</p></li>
</ul>
<p>When precision 0 is used, only the original non-scaled system fonts 
are used. The fonts have a minimum (4) and maximum (37) size in pixels. 
These fonts are fast and are of good quality. Their size varies with 
large steps and they cannot be rotated. Precision 1 and 2 fonts have a 
different behavior depending if True Type Fonts (TTF) are used or not. 
If TTF are used, you always get very good quality scalable and 
rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a
 different behavior for PostScript in case of <strong><code>TLatex</code></strong> objects:</p>
<ul>
<li><p>With precision 1, the PostScript text uses the old convention (see <strong><code>TPostScript</code></strong>) for some special characters to draw sub and superscripts or Greek text.</p></li>
<li><p>With precision 2, the “PostScript” special characters are drawn 
as such. To draw sub and superscripts it is highly recommended to use <strong><code>TLatex</code></strong> objects instead.</p></li>
</ul>
<p>For example: <code>font = 62</code> is the font with ID <code>6</code> and precision <code>2</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/030000CF.png" alt="Font’s examples"><figcaption>Font’s examples</figcaption>
</figure>
<p>The available fonts are:</p>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 31%">
<col style="width: 27%">
<col style="width: 11%">
<col style="width: 15%">
</colgroup>
<tbody>
<tr class="odd">
<td>Font ID</td>
<td>X11</td>
<td>True Type name</td>
<td>Is italic</td>
<td>“boldness”</td>
</tr>
<tr class="even">
<td>1</td>
<td>times-medium-i-normal</td>
<td>“Times New Roman”</td>
<td>Yes</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2</td>
<td>times-bold-r-normal</td>
<td>“Times New Roman”</td>
<td>No</td>
<td>7</td>
</tr>
<tr class="even">
<td>3</td>
<td>times-bold-i-normal</td>
<td>“Times New Roman”</td>
<td>Yes</td>
<td>7</td>
</tr>
<tr class="odd">
<td>4</td>
<td>helvetica-medium-r-norma l</td>
<td>“Arial”</td>
<td>No</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>helvetica-medium-o-norma l</td>
<td>“Arial”</td>
<td>Yes</td>
<td>4</td>
</tr>
<tr class="odd">
<td>6</td>
<td>helvetica-bold-r-normal</td>
<td>“Arial”</td>
<td>No</td>
<td>7</td>
</tr>
<tr class="even">
<td>7</td>
<td>helvetica-bold-o-normal</td>
<td>“Arial”</td>
<td>Yes</td>
<td>7</td>
</tr>
<tr class="odd">
<td>8</td>
<td>courier-medium-r-normal</td>
<td>“Courier New”</td>
<td>No</td>
<td>4</td>
</tr>
<tr class="even">
<td>9</td>
<td>courier-medium-o-normal</td>
<td>“Courier New”</td>
<td>Yes</td>
<td>4</td>
</tr>
<tr class="odd">
<td>10</td>
<td>courier-bold-r-normal</td>
<td>“Courier New”</td>
<td>No</td>
<td>7</td>
</tr>
<tr class="even">
<td>11</td>
<td>courier-bold-o-normal</td>
<td>“Courier New”</td>
<td>Yes</td>
<td>7</td>
</tr>
<tr class="odd">
<td>12</td>
<td>symbol-medium-r-normal</td>
<td>“Symbol”</td>
<td>No</td>
<td>6</td>
</tr>
<tr class="even">
<td>13</td>
<td>times-medium-r-normal</td>
<td>“Times New Roman”</td>
<td>No</td>
<td>4</td>
</tr>
<tr class="odd">
<td>14</td>
<td></td>
<td>“Wingdings”</td>
<td>No</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>This script makes the image of the different fonts:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb365-1" title="1">{</a>
<a class="sourceLine" id="cb365-2" title="2">  textc = <span class="kw">new</span> TCanvas(<span class="st">"textc"</span>,<span class="st">"Example of text"</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb365-3" title="3">  <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;<span class="dv">15</span>;i++) {</a>
<a class="sourceLine" id="cb365-4" title="4">    cid = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">8</span>];</a>
<a class="sourceLine" id="cb365-5" title="5">    sprintf(cid,<span class="st">"ID </span><span class="sc">%d</span><span class="st"> :"</span>,i);</a>
<a class="sourceLine" id="cb365-6" title="6">    cid[<span class="dv">7</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb365-7" title="7">    lid = <span class="kw">new</span> TLatex(<span class="fl">0.1</span>,<span class="dv">1</span>-(<span class="dt">double</span>)i/<span class="dv">15</span>,cid);</a>
<a class="sourceLine" id="cb365-8" title="8">    lid-&gt;SetTextFont(<span class="dv">62</span>);</a>
<a class="sourceLine" id="cb365-9" title="9">    lid-&gt;Draw();</a>
<a class="sourceLine" id="cb365-10" title="10">    l = <span class="kw">new</span> TLatex(<span class="fl">.2</span>,<span class="dv">1</span>-(<span class="dt">double</span>)i/<span class="dv">15</span>,</a>
<a class="sourceLine" id="cb365-11" title="11">                   <span class="st">"The quick brown fox is not here anymore"</span>)</a>
<a class="sourceLine" id="cb365-12" title="12">    l-&gt;SetTextFont(i*<span class="dv">10</span>+<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb365-13" title="13">    l-&gt;Draw();</a>
<a class="sourceLine" id="cb365-14" title="14">  }</a>
<a class="sourceLine" id="cb365-15" title="15">}</a></code></pre></div>
<h4 id="how-to-use-true-type-fonts"><span class="header-section-number">9.6.1.5</span> How to use True Type Fonts</h4>
<p>You can activate the True Type Fonts by adding the following line in your <code>.rootrc</code> file.</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb366-1" title="1">Unix.*.Root.UseTTFonts:     <span class="kw">true</span></a></code></pre></div>
<p>You can check that you indeed use the <code>TTF</code> in your Root session. When the <code>TTF</code>
 is active, you get the following message at the start of a session: 
“Free Type Engine v1.x used to render TrueType fonts.” You can also 
check with the command:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb367-1" title="1">gEnv-&gt;Print()</a></code></pre></div>
<h4 id="setting-text-size"><span class="header-section-number">9.6.1.6</span> Setting Text Size</h4>
<p>Use <code>TAttText::SetTextSize</code> to set the text size.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb368-1" title="1">root[] la-&gt;SetTextSize(size)</a></code></pre></div>
<p>The <code>size</code> is the text size expressed in percentage of the current pad size.</p>
<p>The text size in pixels will be:</p>
<ul>
<li><p>If current pad is horizontal, the size in pixels = <code>textsize * canvas_height</code></p></li>
<li><p>If current pad is vertical, the size in pixels = <code>textsize * canvas_width</code></p></li>
</ul>
<p><img src="ROOTUsersGuide_files/030000D0.png"> The user interface for 
changing the text color, size, font and alignment looks like shown in 
this picture. It takes place in the editor frame anytime the selected 
object inherits the class <strong><code>TAttText</code></strong>.</p>
<h3 id="line-attributes"><span class="header-section-number">9.6.2</span> Line Attributes</h3>
<p>All classes manipulating lines have to deal with line attributes: 
color, style and width. This is done by using secondary inheritance of 
the class <strong><code>TAttLine</code></strong>. The line color may be set by a method call. What is said here applies to all objects deriving from <strong><code>TAttLine</code></strong>, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “<code>li</code>” is a <strong><code>TLine</code></strong> object. The line color is set with:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb369-1" title="1">root[] li-&gt;SetLineColor(color)</a></code></pre></div>
<p>The argument <code>color</code> is a color number. The colors are described in “Color and Color Palettes”</p>
<p>The line style may be set by a method call. What is said here applies to all objects deriving from <strong><code>TAttLine</code></strong>, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “<code>li</code>” is a <strong><code>TLine</code></strong> object. The line style is set with:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb370-1" title="1">root[] li-&gt;SetLineStyle(style)</a></code></pre></div>
<p>The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.</p>
<p>The line width may be set by a method call. What is said here applies to all objects deriving from <strong><code>TAttLine</code></strong>, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “<code>li</code>” is a <strong><code>TLine</code></strong> object. The line width is set with:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb371-1" title="1">root[] li-&gt;SetLineWidth(width)</a></code></pre></div>
<p>The <code>width</code> is the width expressed in pixel units.</p>
<p><img src="ROOTUsersGuide_files/030000D1.png"> The user interface for 
changing the line color, line width and style looks like shown in this 
picture. It takes place in the editor frame anytime the selected object 
inherits the class <strong><code>TAttLine</code></strong>.</p>
<h3 id="fill-attributes"><span class="header-section-number">9.6.3</span> Fill Attributes</h3>
<p>Almost all graphics classes have a fill area somewhere. These classes
 have to deal with fill attributes. This is done by using secondary 
inheritance of the class <strong><code>TAttFill</code></strong>. Fill color may be set by a method call. What is said here applies to all objects deriving from <strong><code>TAttFill</code></strong>, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “<code>h</code>” is a <strong><code>TH1F</code></strong> (1 dim histogram) object. The histogram fill color is set with:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb372-1" title="1">root[] h-&gt;SetFillColor(color)</a></code></pre></div>
<p>The color is a color number. The colors are described in “Color and color palettes”</p>
<p>Fill style may be set by a method call. What is said here applies to all objects deriving from <code>TAttFill</code>, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “<code>h</code>” is a <strong>TH1F</strong> (1 dim histogram) object. The histogram fill style is set with:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb373-1" title="1">root[] h-&gt;SetFillStyle(style)</a></code></pre></div>
<p>The convention for style is: 0:hollow, 1001:solid, 2001:hatch style, 
3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully 
transparent, 4100: fully opaque.</p>
<p>Fill styles &gt;3100 and &lt;3999 are hatches. They are defined according to the <code>FillStyle=3ijk</code> value as follows:</p>
<ul>
<li><p><code>i(1-9)</code> specifies the space between each hatch <code>(1=minimum space</code>, <code>9=maximum)</code>. The final spacing is set by <code>SetHatchesSpacing()</code> method and it is<code>*GetHatchesSpacing()</code>.</p></li>
<li><p><code>j(0-9)</code> specifies the angle between 0 and 90 degres as follows: <code>0=0</code>, <code>1=10</code>, <code>2=20</code>, <code>3=30</code>, <code>4=45</code>, <code>5=not drawn</code>, <code>6=60</code>, <code>7=70</code>, <code>8=80</code> and <code>9=90</code>.</p></li>
<li><p><code>k(0-9)</code> specifies the angle between 0 and 90 degres as follows: <code>0=180</code>, <code>1=170</code>, <code>2=160</code>, <code>3=150</code>, <code>4=135</code>, <code>5=not drawn</code>, <code>6=120</code>, <code>7=110</code>, <code>8=100</code> and <code>9=90</code>.</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/030000D2.png" alt="The various patterns"><figcaption>The various patterns</figcaption>
</figure>
<h3 id="color-and-color-palettes"><span class="header-section-number">9.6.4</span> Color and Color Palettes</h3>
<p>At initialization time, a table of basic colors is generated when the
 first Canvas constructor is called. This table is a linked list, which 
can be accessed from the <strong><em><code>gROOT</code></em></strong> object (see <code>TROOT::GetListOfColors()</code>). Each color has an index and when a basic color is defined, two “companion” colors are defined:</p>
<ul>
<li><p>the dark version (color index + 100)</p></li>
<li><p>the bright version (color index + 150)</p></li>
</ul>
<p>The dark and bright colors are used to give 3-D effects when drawing various boxes (see <strong><code>TWbox</code></strong>, <strong><code>TPave</code></strong>, <strong><code>TPaveText</code></strong>, <strong><code>TPaveLabel</code></strong>, etc). If you have a black and white copy of the manual, here are the basic colors and their indices.</p>
<figure>
<img src="ROOTUsersGuide_files/030000D3.png" alt="The basic ROOT colors"><figcaption>The basic ROOT colors</figcaption>
</figure>
<p><img src="ROOTUsersGuide_files/image212.jpg"></p>
<p>The list of currently supported basic colors (here dark and bright 
colors are not shown) are shown. The color numbers specified in the 
basic palette, and the picture above, can be viewed by selecting the 
menu entry Colors in the View canvas menu. The user may define other 
colors. To do this, one has to build a new <strong><code>TColor</code></strong>:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb374-1" title="1">TColor(<span class="dt">Int_t</span> color,<span class="dt">Float_t</span> r,<span class="dt">Float_t</span> g,<span class="dt">Float_t</span> b,<span class="at">const</span> <span class="dt">char</span>* name)</a></code></pre></div>
<p>One has to give the color number and the three Red, Green, Blue 
values, each being defined from 0 (min) to 1(max). An optional name may 
be given. When built, this color is automatically added to the existing 
list of colors. If the color number already exists, one has to extract 
it from the list and redefine the RGB values. This may be done for 
example with:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb375-1" title="1">root[] color=(TColor*)(gROOT-&gt;GetListOfColors()-&gt;At(index_color))</a>
<a class="sourceLine" id="cb375-2" title="2">root[] color-&gt;SetRGB(r,g,b)</a></code></pre></div>
<p>Where <code>r</code>, <code>g</code> and <code>b</code> go from 0 to 1 and <code>index_color</code> is the color number you wish to change.</p>
<p><img src="ROOTUsersGuide_files/030000D4.png"> The user interface for 
changing the fill color and style looks like shown in this picture. It 
takes place in the editor frame anytime the selected object inherits the
 class <strong><code>TAttFill</code></strong>.</p>
<h4 id="color-palette-for-histograms"><span class="header-section-number">9.6.4.1</span> Color Palette (for Histograms)</h4>
<p>Defining one color at a time may be tedious. The histogram classes (see Draw Options) use the color palette. For example, <code>TH1::Draw("col")</code> draws a 2-D histogram with cells represented by a box filled with a color <code>CI</code> function of the cell content. If the cell content is <code>N</code>, the color <code>CI</code> used will be the color number in <code>colors[N]</code>. If the maximum cell content is <code>&gt;ncolors</code>, all cell contents are scaled to <code>ncolors</code>.
 The current color palette does not have a class or global object of its
 own. It is defined in the current style as an array of color numbers. 
The current palette can be changed with:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb376-1" title="1">TStyle::SetPalette(<span class="dt">Int_t</span> ncolors,<span class="dt">Int_t</span>*color_indexes).</a></code></pre></div>
<p>By default, or if <code>ncolors &lt;= 0</code>, a default palette 
(see above) of 50 colors is defined. The colors defined in this palette 
are good for coloring pads, labels, and other graphic objects. If <code>ncolors &gt; 0</code> and <code>colors = 0</code>, the default palette is used with a maximum of <code>ncolors</code>. If <code>ncolors == 1 &amp;&amp; colors == 0</code>, then a pretty palette with a spectrum <code>Violet-&gt;Red</code>
 is created. It is recommended to use this pretty palette when drawing 
lego(s), surfaces or contours. For example, to set the current palette 
to the “<code>pretty</code>” one, do:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb377-1" title="1">root[] gStyle-&gt;SetPalette(<span class="dv">1</span>)</a></code></pre></div>
<p>A more complete example is shown below. It illustrates the definition
 of a custom palette. You can adapt it to suit your needs. In case you 
use it for contour coloring, with the current color/contour algorithm, 
always define two more colors than the number of contours.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb378-1" title="1"><span class="dt">void</span> palette() {</a>
<a class="sourceLine" id="cb378-2" title="2">  <span class="co">// Example of creating new colors (purples)</span></a>
<a class="sourceLine" id="cb378-3" title="3">  <span class="at">const</span> <span class="dt">Int_t</span> colNum = <span class="dv">10</span>;    <span class="co">// and defining of a new palette</span></a>
<a class="sourceLine" id="cb378-4" title="4">  <span class="dt">Int_t</span> palette[colNum];</a>
<a class="sourceLine" id="cb378-5" title="5">  <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;colNum; i++) {</a>
<a class="sourceLine" id="cb378-6" title="6">    <span class="co">// get the color and if it does not exist create it</span></a>
<a class="sourceLine" id="cb378-7" title="7">    <span class="cf">if</span> (! gROOT-&gt;GetColor(<span class="dv">230</span>+i) ){</a>
<a class="sourceLine" id="cb378-8" title="8">      TColor *color =</a>
<a class="sourceLine" id="cb378-9" title="9">         <span class="kw">new</span> TColor(<span class="dv">230</span>+i,<span class="dv">1</span>-(i/((colNum)*<span class="fl">1.0</span>)),<span class="fl">0.3</span>,<span class="fl">0.5</span>,<span class="st">""</span>);</a>
<a class="sourceLine" id="cb378-10" title="10">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb378-11" title="11">      TColor *color = gROOT-&gt;GetColor(<span class="dv">230</span>+i);</a>
<a class="sourceLine" id="cb378-12" title="12">      color-&gt;SetRGB(<span class="dv">1</span>-(i/((colNum)*<span class="fl">1.0</span>)),<span class="fl">0.3</span>,<span class="fl">0.5</span>);</a>
<a class="sourceLine" id="cb378-13" title="13">    }</a>
<a class="sourceLine" id="cb378-14" title="14">    palette[i] = <span class="dv">230</span>+i;</a>
<a class="sourceLine" id="cb378-15" title="15">  }</a>
<a class="sourceLine" id="cb378-16" title="16">  gStyle-&gt;SetPalette(colNum,palette);</a>
<a class="sourceLine" id="cb378-17" title="17">  TF2 *f2 = <span class="kw">new</span> TF2(<span class="st">"f2"</span>,<span class="st">"exp(-(x^2)-(y^2))"</span>,-<span class="dv">3</span>,<span class="dv">3</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb378-18" title="18">  <span class="co">// two contours less than the number of colors in palette</span></a>
<a class="sourceLine" id="cb378-19" title="19">  f2-&gt;SetContour(colNum-<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb378-20" title="20">  f2-&gt;Draw(<span class="st">"cont"</span>);</a>
<a class="sourceLine" id="cb378-21" title="21">}</a></code></pre></div>
<p>Since ROOT 6.26, you can also define a palette based on an ASCII text file, using <code>TColor::CreateColorTableFromFile("filename.txt")</code> or <code>gStyle-&gt;SetPalette("filename.txt")</code>.
 The input file contains one color per line in “r g b” float format. 
This function is useful to profit from a full set of colour-vision 
deficiency friendly and perceptually uniform colour maps that are 
available to <a href="https://doi.org/10.5281/zenodo.4491293">download</a></p>
<h2 id="the-graphics-editor"><span class="header-section-number">9.7</span> The Graphics Editor</h2>
<p>A new graphics editor took place in ROOT v4.0. The editor can be 
activated by selecting the Editor menu entry in the canvas View menu or 
one of the context menu entries for setting line, fill, marker or text 
attributes. The following object editors are available for the current 
ROOT version.</p>
<h3 id="taxiseditor"><span class="header-section-number">9.7.1</span> TAxisEditor</h3>
<p><img src="ROOTUsersGuide_files/030000D5.png"></p>
<p>This user interface gives the possibility for changing the following axis attributes:</p>
<ul>
<li><p>color of the selected axis, the axis’ title and labels;</p></li>
<li><p>the length of thick parameters and the possibility to set them on both axis sides (if <code>+-</code> is selected);</p></li>
<li><p>to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;</p></li>
<li><p>primary, secondary and tertiary axis divisions can be set via the three number fields;</p></li>
<li><p>the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;</p></li>
<li><p>the color, size, and offset of axis labels can be set similarly. 
In addition, there is a check box for no exponent choice, and another 
one for setting the same decimal part for all labels.</p></li>
</ul>
<h3 id="tpadeditor"><span class="header-section-number">9.7.2</span> TPadEditor</h3>
<p><img src="ROOTUsersGuide_files/030000D6.png"></p>
<ul>
<li><p>It provides the following user interface:</p></li>
<li><p>Fixed aspect ratio - can be set for pad resizing.</p></li>
<li><p>Edit - sets pad or canvas as editable.</p></li>
<li><p>Cross-hair - sets a cross hair on the pad.</p></li>
<li><p>TickX - set ticks along the X axis.</p></li>
<li><p>TickY - set ticks along the Y axis.</p></li>
<li><p>GridX - set a grid along the X axis.</p></li>
<li><p>GridY - set a grid along the Y axis.</p></li>
<li><p>The pad or canvas border size can be set if a sunken or a raised border mode is</p></li>
<li><p>selected; no border mode can be set too.</p></li>
</ul>
<h2 id="copy-and-paste"><span class="header-section-number">9.8</span> Copy and Paste</h2>
<p>You can make a copy of a canvas using <code>TCanvas::DrawClonePad</code>. This method is unique to <strong><code>TCanvas</code></strong>. It clones the entire canvas to the active pad. There is a more general method <code>TObject::DrawClone</code>, which all objects descendent of <strong><code>TObject</code></strong>, specifically all graphic objects inherit. Below are two examples, one to show the use of <code>DrawClonePad</code> and the other to show the use of <code>DrawClone</code>.</p>
<h3 id="using-the-gui-1"><span class="header-section-number">9.8.1</span> Using the GUI</h3>
<p>In this example we will copy an entire canvas to a new one with <code>DrawClonePad</code>. Run the script <code>draw2dopt.C</code>.</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb379-1" title="1">root[] .x tutorials/hist/draw2dopt.C</a></code></pre></div>
<p>This creates a canvas with 2D histograms. To make a copy of the canvas follow the steps:</p>
<ul>
<li><p>Right-click on it to bring up the context menu</p></li>
<li><p>Select <code>DrawClonePad</code></p></li>
</ul>
<p>This copies the entire canvas and all its sub-pads to a new canvas. 
The copied canvas is a deep clone, and all the objects on it are copies 
and independent of the original objects. For instance, change the fill 
on one of the original histograms, and the cloned histogram retains its 
attributes. <code>DrawClonePad</code> will copy the canvas to the active pad; the target does not have to be a canvas. It can also be a pad on a canvas.</p>
<figure>
<img src="ROOTUsersGuide_files/030000D7.png" alt="Different draw options"><figcaption>Different draw options</figcaption>
</figure>
<p>If you want to copy and paste a graphic object from one canvas or pad to another canvas or pad, you can do so with <code>DrawClone</code> method inherited from <strong><code>TObject</code></strong>. All graphics objects inherit the <code>TObject::DrawClone</code> method. In this example, we create a new canvas with one histogram from each of the canvases from the script <code>draw2dopt.C</code>.</p>
<ul>
<li><p>Start a new ROOT session and execute the script <code>draw2dopt.C</code></p></li>
<li><p>Select a canvas displayed by the script, and create a new canvas <code>c1</code> from the File menu.</p></li>
<li><p>Make sure that the target canvas (<code>c1</code>) is the active one by middle clicking on it. If you do this step right after step 2, c1 will be active.</p></li>
<li><p>Select the pad with the first histogram you want to copy and paste.</p></li>
<li><p>Right click on it to show the context menu, and select <code>DrawClone</code>.</p></li>
<li><p>Leave the option blank and hit OK.</p></li>
</ul>
<p>Repeat these steps for one histogram on each of the canvases created 
by the script, until you have one pad from each type. If you wanted to 
put the same annotation on each of the sub pads in the new canvas, you 
could use <code>DrawClone</code> to do so. Here we added the date to each pad. The steps to this are:</p>
<ul>
<li><p>Create the label in on of the pads with the graphics editor.</p></li>
<li><p>Middle-click on the target pad to make it the active pad</p></li>
<li><p>Use <code>DrawClone</code> method of the label to draw it in each of the other panels.</p></li>
</ul>
<p>The option in the <code>DrawClone</code> method argument is the Draw option for a histogram or graph. A call to <code>TH1::DrawClone</code> can clone the histogram with a different draw option.</p>
<h3 id="programmatically"><span class="header-section-number">9.8.2</span> Programmatically</h3>
<p>To copy and paste the four pads from the command line or in a script you would execute the following statements:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb380-1" title="1">root[] .x tutorials/hist/draw2dopt.C</a>
<a class="sourceLine" id="cb380-2" title="2">root[] <span class="kw">auto</span> p1 = surfopt-&gt;GetPad(<span class="dv">1</span>);  <span class="co">// get the first pad</span></a>
<a class="sourceLine" id="cb380-3" title="3">root[] <span class="kw">auto</span> p2 = lego-&gt;GetPad(<span class="dv">2</span>);     <span class="co">// get the second pad</span></a>
<a class="sourceLine" id="cb380-4" title="4">root[] <span class="kw">auto</span> p3 = contours-&gt;GetPad(<span class="dv">3</span>); <span class="co">// get the third pad</span></a>
<a class="sourceLine" id="cb380-5" title="5">root[] <span class="kw">auto</span> p4 = c2h-&gt;GetPad(<span class="dv">4</span>);      <span class="co">// get the forth pad</span></a>
<a class="sourceLine" id="cb380-6" title="6">root[] TCanvas c1(<span class="st">"c1"</span>,<span class="st">"Copy Paste"</span>,<span class="dv">200</span>,<span class="dv">200</span>,<span class="dv">800</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb380-7" title="7">root[] p1-&gt;DrawClone();</a>
<a class="sourceLine" id="cb380-8" title="8">root[] p2-&gt;DrawClone();</a>
<a class="sourceLine" id="cb380-9" title="9">root[] p3-&gt;DrawClone();</a>
<a class="sourceLine" id="cb380-10" title="10">root[] p4-&gt;DrawClone();</a></code></pre></div>
<p>Note that the pad is copied to the new canvas in the same location as
 in the old canvas. For example if you were to copy the third pad of <code>surfopt</code> canvas to the top left corner of the target canvas you would have to reset the coordinates of the cloned pad.</p>
<h2 id="legends"><span class="header-section-number">9.9</span> Legends</h2>
<p>Legends for a graph are obtained with a <strong><code>TLegend</code></strong>
 object. This object points to markers, lines, boxes, histograms, graphs
 and represent their marker, line, fill attributes. Any object that has a
 marker or line or fill attribute may have an associated legend. A <strong><code>TLegend</code></strong> is a panel with several entries (class <strong><code>TLegendEntry</code></strong>) and is created by the constructor</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb381-1" title="1">TLegend(<span class="dt">Double_t</span> x1, <span class="dt">Double_t</span> y1, <span class="dt">Double_t</span> x2, <span class="dt">Double_t</span> y2,</a>
<a class="sourceLine" id="cb381-2" title="2">        <span class="at">const</span> <span class="dt">char</span> *header, <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>The legend is defined with default coordinates, border size and option. The legend coordinates (NDC) in the current pad are <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>. The default text attributes for the legend are:</p>
<ul>
<li><p>Alignment = 12 left adjusted and vertically centered</p></li>
<li><p>Angle = 0 (degrees)</p></li>
<li><p>Color = 1 (black)</p></li>
<li><p>Size = calculate when number of entries is known</p></li>
<li><p>Font = helvetica-medium-r-normal scalable font = 42, and bold = 62 for title</p></li>
</ul>
<p>The title is a regular entry and supports <strong><code>TLatex</code></strong>. The default is no title (<code>header = 0</code>). The options are the same as for <strong><code>TPave</code></strong>; by default, they are “<code>brand</code>”. Once the legend box is created, one has to add the text with the <code>AddEntry()</code> method:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb382-1" title="1">TLegendEntry* TLegend::AddEntry(TObject *obj,</a>
<a class="sourceLine" id="cb382-2" title="2">                                <span class="at">const</span> <span class="dt">char</span> *label,</a>
<a class="sourceLine" id="cb382-3" title="3">                                <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>The parameters are:</p>
<ul>
<li><p><code>*obj</code>is a pointer to an object having marker, line, or fill attributes (a histogram, or a graph)</p></li>
<li><p><code>label</code> is the label to be associated to the object</p></li>
<li><p><code>option</code>:</p></li>
<li><p>“L” draw line associated with line attributes of <code>obj</code>, if <code>obj</code> inherits from <strong><code>TAttLine</code></strong>.</p></li>
<li><p>“P” draw poly-marker associated with marker attributes of <code>obj</code>, if <code>obj</code> inherits <strong><code>TAttMarker</code></strong>.</p></li>
<li><p>“F” draw a box with fill associated with fill attributes of <code>obj</code>, if <code>obj</code> inherits <strong><code>TAttFill</code></strong>.</p></li>
</ul>
<p>One may also use the other form of the method <code>AddEntry</code>:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb383-1" title="1">TLegendEntry* TLegend::AddEntry(<span class="at">const</span> <span class="dt">char</span> *name,</a>
<a class="sourceLine" id="cb383-2" title="2">                                <span class="at">const</span> <span class="dt">char</span> *label,</a>
<a class="sourceLine" id="cb383-3" title="3">                                <span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>Here <code>name</code> is the name of the object in the pad. Other parameters are as in the previous case. Next example shows how to create a legend:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb384-1" title="1">leg = <span class="kw">new</span> TLegend(<span class="fl">0.4</span>,<span class="fl">0.6</span>,<span class="fl">0.89</span>,<span class="fl">0.89</span>);</a>
<a class="sourceLine" id="cb384-2" title="2">leg-&gt;AddEntry(fun1,<span class="st">"One Theory"</span>,<span class="st">"l"</span>);</a>
<a class="sourceLine" id="cb384-3" title="3">leg-&gt;AddEntry(fun3,<span class="st">"Another Theory"</span>,<span class="st">"f"</span>);</a>
<a class="sourceLine" id="cb384-4" title="4">leg-&gt;AddEntry(gr,<span class="st">"The Data"</span>,<span class="st">"p"</span>);</a>
<a class="sourceLine" id="cb384-5" title="5">leg-&gt;Draw();</a>
<a class="sourceLine" id="cb384-6" title="6"><span class="co">// oops we forgot the blue line... add it after</span></a>
<a class="sourceLine" id="cb384-7" title="7">leg-&gt;AddEntry(fun2,</a>
<a class="sourceLine" id="cb384-8" title="8">              <span class="st">"#sqrt{2#pi} P_{T} (#gamma) latex  formula"</span>,<span class="st">"f"</span>);</a>
<a class="sourceLine" id="cb384-9" title="9"><span class="co">// and add a header (or "title") for the legend</span></a>
<a class="sourceLine" id="cb384-10" title="10">leg-&gt;SetHeader(<span class="st">"The Legend Title"</span>);</a>
<a class="sourceLine" id="cb384-11" title="11">leg-&gt;Draw();</a></code></pre></div>
<p>Here <code>fun1</code>, <code>fun2</code>, <code>fun3</code> and <code>gr</code> are pre-existing functions and graphs. You can edit the <strong><code>TLegend</code></strong> by right clicking on it.</p>
<figure>
<img src="ROOTUsersGuide_files/030000D8.png" alt="A legend example"><figcaption>A legend example</figcaption>
</figure>
<h2 id="the-postscript-interface"><span class="header-section-number">9.10</span> The PostScript Interface</h2>
<p>To generate a PostScript (or encapsulated PostScript) file for a single image in a canvas, you can:</p>
<ul>
<li><p>Select to print the canvas in the PostScript file format from the
 File menu / Save or Save As menu entries. By default, a PostScript file
 is generated, if you do not specify the file format.</p></li>
<li><p>Click in the canvas area, near the edges, with the right mouse 
button and select the Print context menu entry. This will generate a 
file of canvas pointed to by c1. You can select the name of the 
PostScript file. If the file name is <code>xxx.ps</code>, you will generate a PostScript file named <code>xxx.ps</code>. If the file name is <code>xxx.eps</code>, you generate an encapsulated Postscript file instead. In your program (or script), you can type:</p></li>
</ul>
<div class="sourceCode" id="cb385"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb385-1" title="1">c1-&gt;Print(<span class="st">"xxx.ps"</span>) <span class="co">// or</span></a>
<a class="sourceLine" id="cb385-2" title="2">c1-&gt;Print(<span class="st">"xxx.eps"</span>)</a></code></pre></div>
<p>Next example prints the picture in the pad pointed by <code>pad1</code>.</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb386-1" title="1">pad1-&gt;Print(<span class="st">"xxx.ps"</span>)</a></code></pre></div>
<p>The <code>TPad::Print</code> method has a second parameter called option. Its value can be:</p>
<ul>
<li><p><code>0</code> which is the default and is the same as “<code>ps</code>”</p></li>
<li><p>“<code>ps</code>” a Postscript file is produced</p></li>
<li><p>“<code>Portrait</code>” a Postscript file is produced with Portrait orientation</p></li>
<li><p>“<code>Landscape</code>” a Postscript file is produced with Landscape orientation</p></li>
<li><p>“<code>eps</code>”an Encapsulated Postscript file</p></li>
<li><p>“<code>Preview</code>”an Encapsulated Postscript file with preview is produced</p></li>
<li><p>“<code>gif</code>” a Graphics Interchange Format file</p></li>
<li><p>“<code>cxx</code>” a C++ macro file is generated</p></li>
<li><p>“<code>pdf</code>”a Portable Document Format file</p></li>
<li><p>“<code>xml</code>” a eXtensible Mark-up Language file</p></li>
<li><p>“<code>jpg</code>”a Joint Photographic Experts Group file</p></li>
<li><p>“<code>png</code>” a Portable Network Graphics Format (PNG file)</p></li>
<li><p>“<code>xpm</code>” a X11 Pixel Map Format</p></li>
<li><p>“<code>svg</code>” a Scalable Vector Graphics file</p></li>
<li><p>“<code>tiff</code>” a Tagged-Image File Format</p></li>
<li><p>“<code>root</code>”a ROOT binary file is produced</p></li>
</ul>
<p>You do not need to specify this second parameter; you can indicate by
 the filename extension what format you want to save a canvas in (i.e. <code>canvas.ps</code>, <code>canvas.gif</code>, <code>canvas.C</code>, etc).</p>
<p>The size of the PostScript picture, by default, is computed to keep 
the aspect ratio of the picture on the screen, where the size along <code>x</code> is always 20 cm. You can set the size of the PostScript picture before generating the picture with a command such as:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb387-1" title="1">TPostScript myps(<span class="st">"myfile.ps"</span>,<span class="dv">111</span>)</a>
<a class="sourceLine" id="cb387-2" title="2">myps.Range(xsize,ysize);</a>
<a class="sourceLine" id="cb387-3" title="3">object-&gt;Draw();</a>
<a class="sourceLine" id="cb387-4" title="4">myps.Close();</a></code></pre></div>
<p>The first parameter in the <strong><code>TPostScript</code></strong> constructor is the name of the file; the second one is the format option:</p>
<ul>
<li><p>111 - <code>ps portrait</code></p></li>
<li><p>112 - <code>ps landscape</code></p></li>
<li><p>113 - <code>eps</code></p></li>
</ul>
<p>You can set the default paper size with:</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb388-1" title="1">gStyle-&gt;SetPaperSize(xsize,ysize);</a></code></pre></div>
<p>You can resume writing again in this file with <code>myps.Open()</code>. Note that you may have several Post Script files opened simultaneously. Use <code>TPostScript::Text(x,y,"string")</code> to add text to a postscript file. This method writes the string in quotes into a PostScript file at position <code>x, y</code> in world coordinates.</p>
<h3 id="special-characters"><span class="header-section-number">9.10.1</span> Special Characters</h3>
<p>The following characters have a special action on the PostScript file:</p>
<ul>
<li><p><code>`</code> - go to Greek</p></li>
<li><p><code>'</code> - go to special</p></li>
<li><p><code>~</code> - go to Zapf Dingbats</p></li>
<li><p><code>?</code> - go to subscript</p></li>
<li><p><code>^</code> - go to superscript</p></li>
<li><p><code>!</code> - go to normal level of script</p></li>
<li><p><code>&amp;</code> - backspace one character</p></li>
<li><p><code>#</code> - end of Greek or end of ZapfDingbats</p></li>
</ul>
<p>These special characters are printed as such on the screen. To 
generate one of these characters on the PostScript file, you must escape
 it with the escape character “@”. The use of these special characters 
is illustrated in several scripts referenced by the <strong><code>TPostScript</code></strong> constructor.</p>
<h3 id="writing-several-canvases-to-the-same-postscript-file"><span class="header-section-number">9.10.2</span> Writing Several Canvases to the Same PostScript File</h3>
<p>The following sequence writes the canvas to “<code>c1.ps</code>” and closes the postscript file:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb389-1" title="1">TCanvas c1(<span class="st">"c1"</span>);</a>
<a class="sourceLine" id="cb389-2" title="2">h1.Draw();</a>
<a class="sourceLine" id="cb389-3" title="3">c1.Print(<span class="st">"c1.ps"</span>);</a></code></pre></div>
<p>If the Postscript file name finishes with “<code>(</code>”, the file remains opened (it is not closed). If the Postscript file name finishes with “<code>)</code>” and the file has been opened with “<code>(</code>”, the file is closed.</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb390-1" title="1">{</a>
<a class="sourceLine" id="cb390-2" title="2">   TCanvas c1(<span class="st">"c1"</span>);</a>
<a class="sourceLine" id="cb390-3" title="3">   h1.Draw();</a>
<a class="sourceLine" id="cb390-4" title="4">   c1.Print(<span class="st">"c1.ps("</span>); <span class="co">// write canvas and keep the ps file open</span></a>
<a class="sourceLine" id="cb390-5" title="5">   h2.Draw();</a>
<a class="sourceLine" id="cb390-6" title="6">   c1.Print(<span class="st">"c1.ps"</span>);  <span class="co">// canvas is added to "c1.ps"</span></a>
<a class="sourceLine" id="cb390-7" title="7">   h3.Draw();</a>
<a class="sourceLine" id="cb390-8" title="8">   c1.Print(<span class="st">"c1.ps)"</span>); <span class="co">// canvas is added to "c1.ps"</span></a>
<a class="sourceLine" id="cb390-9" title="9">                       <span class="co">// and ps file is closed</span></a>
<a class="sourceLine" id="cb390-10" title="10">}</a></code></pre></div>
<p>The <code>TCanvas::Print("file.ps(")</code> mechanism is very useful,
 but it can be a little inconvenient to have the action of 
opening/closing a file being atomic with printing a page. Particularly 
if pages are being generated in some loop, one needs to detect the 
special cases of first and last page. The “<code>[</code>” and “<code>]</code>” can be used instead of “<code>(</code>” and “<code>)</code>” as shown in the next example.</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb391-1" title="1">c1.Print(<span class="st">"file.ps["</span>);      <span class="co">// no actual print; just open file.ps</span></a>
<a class="sourceLine" id="cb391-2" title="2"><span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; ++i) {</a>
<a class="sourceLine" id="cb391-3" title="3">   <span class="co">// fill canvas for context i</span></a>
<a class="sourceLine" id="cb391-4" title="4">   ...</a>
<a class="sourceLine" id="cb391-5" title="5">   c1.Print(<span class="st">"file.ps"</span>);   <span class="co">// actually print canvas to file.ps</span></a>
<a class="sourceLine" id="cb391-6" title="6">}  <span class="co">// end loop</span></a>
<a class="sourceLine" id="cb391-7" title="7">c1.Print(<span class="st">"file.ps]"</span>);     <span class="co">// no actual print; just close file.ps</span></a></code></pre></div>
<p>The following script illustrates how to open a postscript file and 
draw several pictures. The generation of a new postscript page is 
automatic when <strong><code>TCanvas::Clear</code> is called by <code>object-&gt;Draw()</code>.</strong></p>
<div class="sourceCode" id="cb392"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb392-1" title="1">{</a>
<a class="sourceLine" id="cb392-2" title="2">   TFile f(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb392-3" title="3">   TCanvas c1(<span class="st">"c1"</span>,<span class="st">"canvas"</span>,<span class="dv">800</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb392-4" title="4"></a>
<a class="sourceLine" id="cb392-5" title="5">   <span class="co">//select PostScript  output type</span></a>
<a class="sourceLine" id="cb392-6" title="6">   <span class="dt">Int_t</span> type = <span class="dv">111</span>;         <span class="co">//portrait  ps</span></a>
<a class="sourceLine" id="cb392-7" title="7">   <span class="co">// Int_t type = 112;      //landscape ps</span></a>
<a class="sourceLine" id="cb392-8" title="8">   <span class="co">// Int_t type = 113;      //eps</span></a>
<a class="sourceLine" id="cb392-9" title="9"></a>
<a class="sourceLine" id="cb392-10" title="10">   <span class="co">//create a PostScript  file and set the paper size</span></a>
<a class="sourceLine" id="cb392-11" title="11">   TPostScript ps(<span class="st">"test.ps"</span>,type);</a>
<a class="sourceLine" id="cb392-12" title="12">   ps.Range(<span class="dv">16</span>,<span class="dv">24</span>);          <span class="co">//set x,y of printed page</span></a>
<a class="sourceLine" id="cb392-13" title="13"></a>
<a class="sourceLine" id="cb392-14" title="14">   <span class="co">//draw 3 histograms from file hsimple.root on separate pages</span></a>
<a class="sourceLine" id="cb392-15" title="15">   hpx-&gt;Draw();</a>
<a class="sourceLine" id="cb392-16" title="16">   c1.Update();              <span class="co">//force drawing in a script</span></a>
<a class="sourceLine" id="cb392-17" title="17">   hprof-&gt;Draw();</a>
<a class="sourceLine" id="cb392-18" title="18">   c1.Update();</a>
<a class="sourceLine" id="cb392-19" title="19">   hpx-&gt;Draw(<span class="st">"lego1"</span>);</a>
<a class="sourceLine" id="cb392-20" title="20">   c1.Update();</a>
<a class="sourceLine" id="cb392-21" title="21">   ps.Close();</a>
<a class="sourceLine" id="cb392-22" title="22">}</a></code></pre></div>
<p>The next example does the same:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb393-1" title="1">{</a>
<a class="sourceLine" id="cb393-2" title="2">   TFile f(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb393-3" title="3">   TCanvas c1(<span class="st">"c1"</span>,<span class="st">"canvas"</span>,<span class="dv">800</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb393-4" title="4"></a>
<a class="sourceLine" id="cb393-5" title="5">   <span class="co">//set x,y of printed page</span></a>
<a class="sourceLine" id="cb393-6" title="6">   gStyle-&gt;SetPaperSize(<span class="dv">16</span>,<span class="dv">24</span>);</a>
<a class="sourceLine" id="cb393-7" title="7"></a>
<a class="sourceLine" id="cb393-8" title="8">   <span class="co">//draw 3 histograms from file hsimple.root on separate pages</span></a>
<a class="sourceLine" id="cb393-9" title="9">   hpx-&gt;Draw();</a>
<a class="sourceLine" id="cb393-10" title="10">   c1-&gt;Print(<span class="st">"test1.ps("</span>, <span class="st">"Portrait"</span>);</a>
<a class="sourceLine" id="cb393-11" title="11">   hprof-&gt;Draw();</a>
<a class="sourceLine" id="cb393-12" title="12">   c1-&gt;Print(<span class="st">"test1.ps"</span>);</a>
<a class="sourceLine" id="cb393-13" title="13">   hpx-&gt;Draw(<span class="st">"lego1"</span>);</a>
<a class="sourceLine" id="cb393-14" title="14">   c1-&gt;Print(<span class="st">"test1.ps)"</span>);</a>
<a class="sourceLine" id="cb393-15" title="15">}</a></code></pre></div>
<p>This following example shows two pages. The canvas is divided. <code>TPostScript::NewPage</code> must be called before starting a new picture. <code>object-&gt;Draw</code> does not clear the canvas in this case because we clear only the pads and not the main canvas. Note that <code>c1-&gt;Update</code> must be called at the end of the first picture.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb394-1" title="1">{</a>
<a class="sourceLine" id="cb394-2" title="2">   TFile *f1 = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb394-3" title="3">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>);</a>
<a class="sourceLine" id="cb394-4" title="4">   TPostScript *ps = <span class="kw">new</span> TPostScript(<span class="st">"file.ps"</span>,<span class="dv">112</span>);</a>
<a class="sourceLine" id="cb394-5" title="5"></a>
<a class="sourceLine" id="cb394-6" title="6">   <span class="co">// picture 1</span></a>
<a class="sourceLine" id="cb394-7" title="7">   c1-&gt;Divide(<span class="dv">2</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb394-8" title="8">   ps-&gt;NewPage();</a>
<a class="sourceLine" id="cb394-9" title="9">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb394-10" title="10">   hpx-&gt;Draw();</a>
<a class="sourceLine" id="cb394-11" title="11">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb394-12" title="12">   hprof-&gt;Draw();</a>
<a class="sourceLine" id="cb394-13" title="13"></a>
<a class="sourceLine" id="cb394-14" title="14">   <span class="co">// picture 2</span></a>
<a class="sourceLine" id="cb394-15" title="15">   c1-&gt;Update();</a>
<a class="sourceLine" id="cb394-16" title="16">   ps-&gt;NewPage();</a>
<a class="sourceLine" id="cb394-17" title="17">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb394-18" title="18">   hpxpy-&gt;Draw();</a>
<a class="sourceLine" id="cb394-19" title="19">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb394-20" title="20">   ntuple-&gt;Draw(<span class="st">"px"</span>);</a>
<a class="sourceLine" id="cb394-21" title="21">   c1-&gt;Update();</a>
<a class="sourceLine" id="cb394-22" title="22">   ps-&gt;Close();</a>
<a class="sourceLine" id="cb394-23" title="23"></a>
<a class="sourceLine" id="cb394-24" title="24">   <span class="co">// invoke PostScript  viewer</span></a>
<a class="sourceLine" id="cb394-25" title="25">   gSystem-&gt;Exec(<span class="st">"gs file.ps"</span>);</a>
<a class="sourceLine" id="cb394-26" title="26">}</a></code></pre></div>
<p>The next one does the same:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb395-1" title="1">{</a>
<a class="sourceLine" id="cb395-2" title="2">   TFile *f1 = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb395-3" title="3">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>);</a>
<a class="sourceLine" id="cb395-4" title="4">   c1-&gt;Divide(<span class="dv">2</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb395-5" title="5"></a>
<a class="sourceLine" id="cb395-6" title="6">   <span class="co">// picture 1</span></a>
<a class="sourceLine" id="cb395-7" title="7">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb395-8" title="8">   hpx-&gt;Draw();</a>
<a class="sourceLine" id="cb395-9" title="9">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb395-10" title="10">   hprof-&gt;Draw();</a>
<a class="sourceLine" id="cb395-11" title="11">   c1-&gt;Print(<span class="st">"test2.ps("</span>, <span class="st">"Landscape"</span>);</a>
<a class="sourceLine" id="cb395-12" title="12"></a>
<a class="sourceLine" id="cb395-13" title="13">   <span class="co">// picture 2</span></a>
<a class="sourceLine" id="cb395-14" title="14">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb395-15" title="15">   hpxpy-&gt;Draw();</a>
<a class="sourceLine" id="cb395-16" title="16">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb395-17" title="17">   ntuple-&gt;Draw(<span class="st">"px"</span>);</a>
<a class="sourceLine" id="cb395-18" title="18">   c1-&gt;Print(<span class="st">"test2.ps)"</span>);</a>
<a class="sourceLine" id="cb395-19" title="19">   gSystem-&gt;Exec(<span class="st">"gs file.ps"</span>);  <span class="co">// invoke PostScript  viewer</span></a>
<a class="sourceLine" id="cb395-20" title="20">}</a></code></pre></div>
<h3 id="the-color-models"><span class="header-section-number">9.10.3</span> The Color Models</h3>
<p><code>TPostScript</code> (and <code>TPDF</code>) support two color 
models: RGB and CMYK. CMY and CMYK models are subtractive color models 
unlike RGB which is an additive. They are mainly used for printing 
purposes. CMY means Cyan Magenta Yellow to convert RGB to CMY it is 
enough to do: <code>C=1-R</code>, <code>M=1-G</code> and <code>Y=1-B</code>. CMYK has one more component K (black). The conversion from RGB to CMYK is:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb396-1" title="1"> <span class="dt">Double_t</span> Black   = TMath::Min(TMath::Min(<span class="dv">1</span>-Red,<span class="dv">1</span>-Green),<span class="dv">1</span>-Blue);</a>
<a class="sourceLine" id="cb396-2" title="2"> <span class="dt">Double_t</span> Cyan    = (<span class="dv">1</span>-Red-Black)/(<span class="dv">1</span>-Black);</a>
<a class="sourceLine" id="cb396-3" title="3"> <span class="dt">Double_t</span> Magenta = (<span class="dv">1</span>-Green-Black)/(<span class="dv">1</span>-Black);</a>
<a class="sourceLine" id="cb396-4" title="4"> <span class="dt">Double_t</span> Yellow  = (<span class="dv">1</span>-Blue-Black)/(<span class="dv">1</span>-Black);</a></code></pre></div>
<p><code>CMYK</code> add the black component which allows to have a better quality for black printing. <code>TPostScript</code> (and <code>TPDF</code>) support the <code>CMYK</code> model. To change the color model use:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb397-1" title="1"> gStyle-&gt;SetColorModelPS(c);</a></code></pre></div>
<ul>
<li><code>c = 0</code> means TPostScript will use RGB color model (default)</li>
<li><code>c = 1</code> means TPostScript will use CMYK color model</li>
</ul>
<h2 id="the-pdf-interface"><span class="header-section-number">9.11</span> The PDF Interface</h2>
<p>Like PostScript, PDF is a vector graphics output format allowing a 
very high graphics output quality. The functionalities provided by this 
class are very similar to those provided by <code>TPostScript</code>.</p>
<p>Compare to PostScript output, the PDF files are usually smaller because some parts of them can be compressed.</p>
<p>PDF also allows to define table of contents. This facility can be used in ROOT. The following example shows how to proceed:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb398-1" title="1">{</a>
<a class="sourceLine" id="cb398-2" title="2">   TCanvas* canvas = <span class="kw">new</span> TCanvas(<span class="st">"canvas"</span>);</a>
<a class="sourceLine" id="cb398-3" title="3">   TH1F* histo = <span class="kw">new</span> TH1F(<span class="st">"histo"</span>,<span class="st">"test 1"</span>,<span class="dv">10</span>,<span class="fl">0.</span>,<span class="fl">10.</span>);</a>
<a class="sourceLine" id="cb398-4" title="4">   histo-&gt;SetFillColor(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb398-5" title="5">   histo-&gt;Fill(<span class="fl">2.</span>);</a>
<a class="sourceLine" id="cb398-6" title="6">   histo-&gt;Draw();</a>
<a class="sourceLine" id="cb398-7" title="7">   canvas-&gt;Print(<span class="st">"plots.pdf("</span>,<span class="st">"Title:One bin filled"</span>);</a>
<a class="sourceLine" id="cb398-8" title="8">   histo-&gt;Fill(<span class="fl">4.</span>);</a>
<a class="sourceLine" id="cb398-9" title="9">   histo-&gt;Draw();</a>
<a class="sourceLine" id="cb398-10" title="10">   canvas-&gt;Print(<span class="st">"plots.pdf"</span>,<span class="st">"Title:Two bins filled"</span>);</a>
<a class="sourceLine" id="cb398-11" title="11">   histo-&gt;Fill(<span class="fl">6.</span>);</a>
<a class="sourceLine" id="cb398-12" title="12">   histo-&gt;Draw();</a>
<a class="sourceLine" id="cb398-13" title="13">   canvas-&gt;Print(<span class="st">"plots.pdf"</span>,<span class="st">"Title:Three bins filled"</span>);</a>
<a class="sourceLine" id="cb398-14" title="14">   histo-&gt;Fill(<span class="fl">8.</span>);</a>
<a class="sourceLine" id="cb398-15" title="15">   histo-&gt;Draw();</a>
<a class="sourceLine" id="cb398-16" title="16">   canvas-&gt;Print(<span class="st">"plots.pdf"</span>,<span class="st">"Title:Four bins filled"</span>);</a>
<a class="sourceLine" id="cb398-17" title="17">   histo-&gt;Fill(<span class="fl">8.</span>);</a>
<a class="sourceLine" id="cb398-18" title="18">   histo-&gt;Draw();</a>
<a class="sourceLine" id="cb398-19" title="19">   canvas-&gt;Print(<span class="st">"plots.pdf)"</span>,<span class="st">"Title:The fourth bin content is 2"</span>);</a>
<a class="sourceLine" id="cb398-20" title="20">}</a></code></pre></div>
<p>Each character string following the keyword “Title:” makes a new entry in the table of contents.</p>
<h2 id="create-or-modify-a-style"><span class="header-section-number">9.12</span> Create or Modify a Style</h2>
<p>All objects that can be drawn in a pad inherit from one or more attribute classes like <strong><code>TAttLine</code></strong>, <strong><code>TAttFill</code></strong>, <strong><code>TAttText</code></strong>, <strong><code>TAttMarker</code></strong>.
 When objects are created, their default attributes are taken from the 
current style. The current style is an object of the class <strong><code>TStyle</code></strong> and can be referenced via the global variable <strong><em><code>gStyle</code></em></strong> (in <code>TStyle.h</code>). See the class <strong><code>TStyle</code></strong> for a complete list of the attributes that can be set in one style.</p>
<p>ROOT provides several styles called:</p>
<ul>
<li><p>“<code>Default</code>” - the default style</p></li>
<li><p>“<code>Plain</code>” - the simple style (black and white)</p></li>
<li><p>“<code>Bold</code>” - bolder lines</p></li>
<li><p>“<code>Video</code>” - suitable for html output or screen viewing</p></li>
</ul>
<p>The “<code>Default</code>” style is created by:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb399-1" title="1">TStyle *<span class="cf">default</span> = <span class="kw">new</span> TStyle(<span class="st">"Default"</span>,<span class="st">"Default Style"</span>);</a></code></pre></div>
<p>The “<code>Plain</code>” style can be used if you want to get a 
“conventional” PostScript output or if you are working on a monochrome 
display. The following example shows how to create it.</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb400-1" title="1">TStyle *plain  = <span class="kw">new</span> TStyle(<span class="st">"Plain"</span>,</a>
<a class="sourceLine" id="cb400-2" title="2">                            <span class="st">"Plain Style(no colors/fill areas)"</span>);</a>
<a class="sourceLine" id="cb400-3" title="3">plain-&gt;SetCanvasBorderMode(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb400-4" title="4">plain-&gt;SetPadBorderMode(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb400-5" title="5">plain-&gt;SetPadColor(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb400-6" title="6">plain-&gt;SetCanvasColor(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb400-7" title="7">plain-&gt;SetTitleColor(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb400-8" title="8">plain-&gt;SetStatColor(<span class="dv">0</span>);</a></code></pre></div>
<p>You can set the current style by:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb401-1" title="1">gROOT-&gt;SetStyle(style_name);</a></code></pre></div>
<p>You can get a pointer to an existing style by:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb402-1" title="1">TStyle *style = gROOT-&gt;GetStyle(style_name);</a></code></pre></div>
<p>You can create additional styles by:</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb403-1" title="1">TStyle *st1 = <span class="kw">new</span> TStyle(<span class="st">"st1"</span>,<span class="st">"my style"</span>);</a>
<a class="sourceLine" id="cb403-2" title="2">st1-&gt;Set...</a>
<a class="sourceLine" id="cb403-3" title="3">st1-&gt;cd();  <span class="co">// this becomes now the current style gStyle</span></a></code></pre></div>
<p>In your <code>rootlogon.C</code> file, you can redefine the default parameters via statements like:</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb404-1" title="1">gStyle-&gt;SetStatX(<span class="fl">0.7</span>);</a>
<a class="sourceLine" id="cb404-2" title="2">gStyle-&gt;SetStatW(<span class="fl">0.2</span>);</a>
<a class="sourceLine" id="cb404-3" title="3">gStyle-&gt;SetLabelOffset(<span class="fl">1.2</span>);</a>
<a class="sourceLine" id="cb404-4" title="4">gStyle-&gt;SetLabelFont(<span class="dv">72</span>);</a></code></pre></div>
<p>Note that when an object is created, its attributes are taken from 
the current style. For example, you may have created a histogram in a 
previous session and saved it in a file. Meanwhile, if you have changed 
the style, the histogram will be drawn with the old attributes. You can 
force the current style attributes to be set when you read an object 
from a file by calling <code>ForceStyle</code> before reading the objects from the file.</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb405-1" title="1">gROOT-&gt;ForceStyle();</a></code></pre></div>
<p>When you call <code>gROOT-&gt;ForceStyle()</code> and read an object from a ROOT file, the object’s method <code>UseCurrentStyle</code> is called. The attributes saved with the object are replaced by the current style attributes. You call also call <code>myObject-&gt;UseCurrentStyle()</code>
 directly. For example if you have a canvas or pad with your histogram 
or any other object, you can force these objects to get the attributes 
of the current style by:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb406-1" title="1">canvas-&gt;UseCurrentStyle();</a></code></pre></div>
<p>The description of the style functions should be clear from the name of the <strong><code>TStyle</code></strong> setters or getters. Some functions have an extended description, in particular:</p>
<ul>
<li><p><code>TStyle::SetLabelFont</code></p></li>
<li><p><code>TStyle::SetLineStyleString</code>: set the format of dashed lines.</p></li>
<li><p><code>TStyle::SetOptStat</code></p></li>
<li><p><code>TStyle::SetPalette</code> to change the colors palette</p></li>
<li><p><code>TStyle::SetTitleOffset</code></p></li>
<li><p><code>TStyle::SetOptDate(Int_t optdate)</code> to support several date formats. If <code>optdate</code> is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: <code>optdate = 10*format</code>+<code>mode</code></p></li>
<li><p><code>mode = 1</code> the date is printed in the bottom/left corner</p></li>
<li><p><code>mode = 2</code> date is printed in the bottom/right corner</p></li>
<li><p><code>mode = 3</code> date is printed in the top/right corner</p></li>
<li><p><code>format = 0</code> (default) date format is like: “Wed Sep 25 17:10:35 2002”</p></li>
<li><p><code>format = 1</code> date format is: “2002-09-25”</p></li>
<li><p><code>format = 2</code> date format is: “2002-09-25 17:10:35”</p></li>
</ul>
<h2 id="d-viewers"><span class="header-section-number">9.13</span> 3D Viewers</h2>
<p>ROOT provides several viewers capable of displaying 3D content:</p>
<ul>
<li><p>the Pad - simple line drawing using <strong><code>TPad</code></strong> and associated projection class <strong><code>TView</code></strong>;</p></li>
<li><p>GL Viewer - high quality and performance viewer(See “The GL Viewer”);</p></li>
<li><p>X3D viewer - simple legacy viewer (See “The X3D Viewer”);</p></li>
<li><p>GL-in-pad - combination of basic GL viewer in <strong><code>TPad</code></strong>, with no hardware acceleration.</p></li>
</ul>
<p>The X3D and GL viewers are created as external windows, associated 
with a pad, and displaying the same content as it. Only these external 
viewers are detailed here - for Pad (<strong><code>TPad</code></strong>, <strong><code>TView</code></strong> classes) you should refer to “Graphical Containers: Canvas and Pad” and the class definitions.</p>
<p>All viewers use a common architecture to publish 3D objects to the 
viewer - described in “Common 3D Viewer Architecture” below. In most 
cases, you will <strong>not</strong> need to use this, working instead 
with a package, such as the “The Geometry Package”, which provides 
comprehensive, high level functionality to create and place objects into
 complex 3D scenes, and uses the viewer architecture internally to show 
the result in your chosen viewer.</p>
<h3 id="invoking-a-3d-viewer"><span class="header-section-number">9.13.1</span> Invoking a 3D viewer</h3>
<p>A 3D viewer can be created in a script by passing the appropriate option to <code>Draw()</code>when attaching the drawn object(s) to a pad. For a fuller explanation of pads, attaching objects with <code>Draw()</code> etc. refer to “Graphical Containers: Canvas and Pad”.</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb407-1" title="1">root[] myShapes-&gt;Draw(<span class="st">"ogl"</span>);</a></code></pre></div>
<p>Valid option strings are:</p>
<ul>
<li><p>“<code>ogl</code>” : external GL viewer</p></li>
<li><p>“<code>x3d</code>”: external X3D viewer</p></li>
<li><p>“<code>pad</code>”: pad viewer</p></li>
</ul>
<p>If no option is passed to <code>Draw()</code> then the “<code>pad</code>”
 is used by default. If you already have content in a pad, which you 
would like to display in one of the external viewers you can select from
 the canvas View menu / View With, and pick the viewer type.</p>
<figure>
<img src="ROOTUsersGuide_files/030000D9.png" alt="Invoking external 3D viewers from canvas menus"><figcaption>Invoking external 3D viewers from canvas menus</figcaption>
</figure>
<p>Note: A current limitation means that when an external viewer is 
created the pad is no longer redrawn. When the external viewer is 
closed, clicking in the pad will refresh.</p>
<h3 id="the-gl-viewer"><span class="header-section-number">9.13.2</span> The GL Viewer</h3>
<p>The GL Viewer uses &lt;OpenGL®&gt; (or compliant libraries such as <mesa3d>)
 to generate high quality, high-performance 3D renderings, with 
sophisticated lighting, materials and rendering styles for 3D scenes. 
Many users will be able to take advantage of hardware acceleration of 
the underlying OpenGL commands by their computer’s video card, resulting
 is considerable performance gains - up to interactive manipulation of 
1000’s of complex shapes in real-time.</mesa3d></p>
<p>The GL Viewer is supported on all official ROOT platforms (assuming 
you have suitable &lt;OpenGL®&gt; libraries), and is the main 3D viewer,
 which development effort is concentrated upon. As OpenGL® is a 
trademark we refer to our viewer built on this technology as the ‘GL 
Viewer’. The code for it can be found under <code>$ROOTSYS/gl</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/020000DA.jpg" alt="The GL 3D Viewer"><figcaption>The GL 3D Viewer</figcaption>
</figure>
<p>You can manipulate the viewer via the GUI or via the base <strong><code>TGLViewer</code></strong> object behind the interface. These are detailed below - see also <code>$ROOTSYS/tutorials/gl/glViewerExercise.C</code>.</p>
<h4 id="projections-modes-cameras"><span class="header-section-number">9.13.2.1</span> Projections Modes (Cameras)</h4>
<p>The GL Viewer supports two basic types of camera, which affect how the 3D world is projected onto the 2D render area:</p>
<ul>
<li><p>Perspective: Objects are drawn with characteristic 
‘foreshortening’ effect, where distant objects appear smaller than near 
ones. This is useful for obtaining a ‘real world’ views. The degree of 
foreshortening is affected by the current camera field of view (focal 
length of its ‘lens’) - see “Adjusting Cameras”.</p></li>
<li><p>Orthographic: Distance from camera does not affect object size. 
These projections are useful for measurement or checking alignments, as 
the sizes and angles between objects are preserved.</p></li>
</ul>
<p>You can select the active camera from the viewer’s Camera menu on the top menu bar. There are three perspective camera choices:</p>
<ul>
<li><p>Perspective (Floor XOZ) Default</p></li>
<li><p>Perspective (Floor YOZ)</p></li>
<li><p>Perspective (Floor XOY)</p></li>
</ul>
<p>In each case the perspective camera is constrained to keep the chosen
 floor plane, defined by a pair of world axes, appearing level at all 
times - i.e.&nbsp;there is no banking of the ‘horizon’ that you 
experience when a plane rolls. There are also three orthographic camera 
choices:</p>
<ul>
<li><p>Orthographic (XOY)</p></li>
<li><p>Orthographic (XOZ)</p></li>
<li><p>Orthographic (ZOY)</p></li>
</ul>
<p>Orthographic projections are generally constrained to look down one 
of the global axes of the world, with the other two axes lying 
horizontal/vertical on the viewer window. Therefore, XOY has the X-axis 
horizontal, the Y-axis vertical. You can always confirm the orientation 
and constraints of the camera in the world by enabling axis drawing in 
the “Guides” tab - see sections “Guides” and “Clipping” below. For 
orthographic camera a ruler-depicting current scene units is also 
available.</p>
<p>You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb408-1" title="1">TGLViewer * v = (TGLViewer *)gPad-&gt;GetViewer3D();</a></code></pre></div>
<p>calling the method <code>TGLViewer::SetCurrentCamera</code> with one of the <strong><code>TGLViewer::ECameraType</code> types:</strong></p>
<div class="sourceCode" id="cb409"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb409-1" title="1">v-&gt;SetCurrentCamera(TGLViewer::kCameraPerspXOZ);</a></code></pre></div>
<p>See also <code>$ROOTSYS/tutorials/gl/glViewerExercise.C</code>.</p>
<h4 id="adjusting-cameras"><span class="header-section-number">9.13.2.2</span> Adjusting Cameras</h4>
<p>The interactions with the camera are summarized above. In each case 
the interaction is listed, along with description and user actions 
required to achieve it. For all cameras you can reset the original 
default view, framing the entire scene, by double clicking any mouse 
button.</p>
<figure>
<img src="ROOTUsersGuide_files/020000DB.jpg" alt="GL Viewer camera interactions"><figcaption>GL Viewer camera interactions</figcaption>
</figure>
<p>For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:</p>
<ul>
<li><p>Shiftx 10</p></li>
<li><p>Ctrlx 0.1</p></li>
<li><p>Shift + Ctrlx 0.01</p></li>
</ul>
<p>The modifiers must be applied after the zoom action has started (right mouse button is down).</p>
<p>Note for orthographic cameras:</p>
<ul>
<li><p>There is no field of view of view/focal length - dollying and zooming producing an identical scaling action.</p></li>
<li><p>There is a fixed eye direction - so the ‘Orbit’ action is disabled.</p></li>
</ul>
<p>Note for perspective cameras:</p>
<ul>
<li><p>Dollying (moving the camera backwards/forwards) and zooming are often confused, and may appear very similar.</p></li>
<li><p>When you dolly the camera the lens focal length does not change, 
hence the distortions associated with the projections are unaffected. 
However the movement can result in objects coming ‘through the front’ of
 the camera and disappearing.</p></li>
<li><p>When you zoom, the camera does not move - hence clipping of near 
objects is unaffected. However with extremely small zooms (FOV 
large/focal length short) noticeable distortions, causing straight lines
 to become curved, can be seen with objects near the camera - the 
‘fisheye’ lens effect.</p></li>
<li><p>Generally dollying is more ‘natural’, but you may need to use 
both to achieve the desired perspective and eye position - particularly 
when you are working inside or very close to 3D objects.</p></li>
</ul>
<p>Configure the camera by calling the methods <code>SetPerspectiveCamera(</code>) or <code>SetOrthographicCamera()</code> of <strong><code>TGLViewer</code></strong>:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb410-1" title="1">TGLViewer * v = (TGLViewer *)gPad-&gt;GetViewer3D();</a>
<a class="sourceLine" id="cb410-2" title="2">v-&gt;SetOrthoCamera(TGLViewer::kCameraOrthoXOY,</a>
<a class="sourceLine" id="cb410-3" title="3">                  left,right,top,bottom);</a>
<a class="sourceLine" id="cb410-4" title="4">...</a>
<a class="sourceLine" id="cb410-5" title="5">v-&gt;SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);</a></code></pre></div>
<p>Note - you can configure any of the six cameras in the viewer at any 
time, but you will not see the result until the camera is made current.</p>
<h4 id="draw-styles"><span class="header-section-number">9.13.2.3</span> Draw Styles</h4>
<p>The GL Viewer supports three different rendering modes, which are 
applied to all the objects in your scene, but not Clip Shapes and Guides
 (See “Clipping” and “Manipulators”). These are shown below, along with 
the key used to activate the style.</p>
<figure>
<img src="ROOTUsersGuide_files/020000DC.jpg" alt="GL Viewer draw styles"><figcaption>GL Viewer draw styles</figcaption>
</figure>
<p><strong>Filled Polygons</strong> <strong>Wireframe</strong> <strong>Outline</strong>
 Enable with ‘r’ key Enable with ‘w’ key Enable with ‘t’ key Solid 
polygons, with hidden surface Object edges in color, with Combination of
 Filled Polygons removal, color surface materials, no surface 
filling/hiding. and Outline styles. Solid opacity, specular reflection 
etc. shapes with edges. Black background. Black background. White 
background.</p>
<p>Call method <code>TGLViewer::SetStyle</code> with one of <strong><code>TGLRnrCtx::EDrawStyle</code>flags <code>kFill</code>, <code>kOutline</code>, <code>kWireFrame</code>:</strong></p>
<div class="sourceCode" id="cb411"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb411-1" title="1">v-&gt;SetStyle(TGLRnrCtx::kFill);</a></code></pre></div>
<h4 id="lighting-style"><span class="header-section-number">9.13.2.4</span> Lighting / Style</h4>
<p>The GL viewer creates five diffuse lights (left, right, top, bottom, 
and front) arranged around the 3D scene. These lights are carried with 
the camera - that is they are always in same position relative to your 
eye - the left light always shines from the left.</p>
<p>Light controls are located: Viewer Controls Pane ‘Style’.</p>
<p>Each light has a checkbox to enable/disable it. Set lights on/off with <strong><code>TGLLightSet::SetLight</code> e.g.</strong></p>
<div class="sourceCode" id="cb412"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb412-1" title="1">v-&gt;GetLightSet()-&gt;SetLight(TGLLightSet::kLightBottom, kFALSE);</a></code></pre></div>
<h4 id="clipping"><span class="header-section-number">9.13.2.5</span> Clipping</h4>
<p>The GL viewer supports interactive clipping, enabling you to remove 
sections of your 3D scene and the shapes, revealing internal details.</p>
<figure>
<img src="ROOTUsersGuide_files/020000DD.jpg" alt="GL Viewer interactive box clipping"><figcaption>GL Viewer interactive box clipping</figcaption>
</figure>
<p>The controls for clipping can be found under: Viewer Controls Pane ‘Clipping’ tab.</p>
<p>Two clipping ‘shapes’ are currently supported:</p>
<ul>
<li><p>Single plane</p></li>
<li><p>Box</p></li>
</ul>
<p>Pick the type from the radio buttons - only one (or none) may be active at one time.</p>
<p>The clip object can be adjusted by:</p>
<ul>
<li><p>Adjusting the values in the properties panel GUI</p></li>
<li><p>Directly manipulating the clip object in the viewer</p></li>
</ul>
<p>To show and/or directly manipulate the object check the ‘Show / Edit 
in Viewer’ checkbox. The clip object is drawn in semi-transparent light 
brown. The current manipulator is attached to it, allowing you direct 
control over its position, scale and rotation. See “Manipulators” 
section below for details on using viewer manipulators.</p>
<p>The clip plane is described by the standard plane equation: <strong><code>ax+by+cz+d=0</code></strong>, where the factors <strong><code>a</code></strong>, <strong><code>b</code></strong>, <strong><code>c</code></strong>, <strong><code>d</code></strong> are entered into the edit boxes, and applied using the ‘Apply’ button.</p>
<p>The clip box is described by its center position, entered in the 
‘Center X’, ‘Center Y’ and ‘Center Z’ edit boxes, and its lengths 
(extents) entered in the ‘Length X’, ‘Length Y’ and ‘Length Z’ edit 
boxes.</p>
<p>This clipping is achieved using OpenGL clip plane support; as such, there are certain limitations:</p>
<ul>
<li><p>Solid shapes are not capped - they appear hollow.</p></li>
<li><p>Only shapes, which can be described with combination of planes, 
can be rendered in this fashion - e.g.&nbsp;a clipping tube is not 
possible.</p></li>
<li><p>Each additional clipping plane requires an additional render pass
 - so the more active planes the more time the render will take.</p></li>
</ul>
<p>Set the current clip object with <strong><code>TGLClipSet::SetClipType</code></strong></p>
<div class="sourceCode" id="cb413"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb413-1" title="1">v-&gt;GetClipSet()-&gt;SetClipType(TGLClipSet::kClipPlane);</a></code></pre></div>
<p>Configure the clip object with <strong><code>TGLClipSet::SetClipState</code></strong></p>
<div class="sourceCode" id="cb414"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb414-1" title="1"><span class="dt">Double_t</span> planeEq[<span class="dv">4</span>] = {<span class="fl">0.5</span>,<span class="fl">1.0</span>,-<span class="fl">1.0</span>, <span class="fl">2.0</span>};</a>
<a class="sourceLine" id="cb414-2" title="2">v-&gt;GetClipSet()-&gt;SetClipState(TGLClipSet::kClipPlane, planeEq);</a></code></pre></div>
<p>As with cameras, any clip can be configured at any time, but you must set the clip current to see the effect.</p>
<h4 id="manipulators"><span class="header-section-number">9.13.2.6</span> Manipulators</h4>
<p><em>Manipulators</em> are GUI ‘widgets’ or controls attached to a 3D 
object in the viewer, allowing a direct manipulation of the object’s 
geometry. There are three manipulators for the three basic geometries 
transformations. In each case, the <em>manipulator</em> consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z).</p>
<figure>
<img src="ROOTUsersGuide_files/030000DE.png" alt="GL Viewer object manipulators"><figcaption>GL Viewer object manipulators</figcaption>
</figure>
<p>Activate the <em>manipulator</em> by moving the mouse over one of 
these components (which turns yellow to indicate active state). Click 
with left mouse and drag this active component to perform the 
manipulation. Toggle between the <em>manipulator</em> types using the 
‘x’, ‘c’, ‘v’ keys while the mouse cursor is above the manipulator. 
Note: Manipulators cannot be controlled via the API at present.</p>
<h4 id="guides"><span class="header-section-number">9.13.2.7</span> Guides</h4>
<p>Guides are visual aids drawn into the viewer world. Controls for these are under the “Guides” tab:</p>
<p>Viewer Controls Pane Guides Tab</p>
<p>Axes show the world (global) frame <em>coordinate</em>directions: X (red), Y (green) and Z (blue). The negative portion of the <em>axis</em> line is shown in dark color, the positive in bright. The <em>axis</em> name and minimum / maximum values are labeled in the same color. There are three options for <em>axes</em> drawing - selected by radio buttons:</p>
<ul>
<li><p>None - not drawn (default).</p></li>
<li><p>Edge - draw axes on the (minimum) edge of the scene extents box.</p></li>
<li><p>Origin - drawn axes through the origin.</p></li>
</ul>
<p>For <em>edge axes</em>, the zero value for each axis is marked on the axis line with a colored sphere. For <em>origin axes,</em> a single white sphere is shown at the origin.</p>
<p><em>Edge axes</em> are depth clipped - i.e.&nbsp;are obscured by 3D objects in front of them. <em>Origin axes</em> (which generally pass through the middle of the 3D scene) are not depth clipped - so always visible.</p>
<p>A single orange sphere of fixed view port (window) size can be shown 
at any arbitrary position. Enable / disable the drawing with ‘<em>Show’</em> checkbox. Enter X/Y/Z position in the edit boxes to set position. Initial position is at the center of the scene.</p>
<p>Set the guides using <code>TGLViewer::SetGuideState</code> e.g.&nbsp;to enable edge axes, and enable a reference marker at world position 50, 60, 100:</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb415-1" title="1"><span class="dt">Double_t</span> refPos[<span class="dv">3</span>] = {<span class="fl">50.0</span>,<span class="fl">60.0</span>,<span class="fl">100.0</span>};</a>
<a class="sourceLine" id="cb415-2" title="2">v-&gt;SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);</a></code></pre></div>
<h4 id="selecting-scene-shapes"><span class="header-section-number">9.13.2.8</span> Selecting Scene Shapes</h4>
<p>You can select a single shape from your scene by pressing ‘Shift’ 
key, pointing and left clicking anywhere on the shape in the viewer. 
Selection is currently shown by drawing the shape-bounding box (not 
depth clipped) in white (polygon or wire frame render styles) or red 
(outline render style). Manipulators supported by the shape are drawn in
 red, green and blue while the non-supported ones are drawn in grey. To 
deselect a shape, either select another, or shift/click anywhere on the 
background (empty space) in the viewer. You cannot select Manipulators 
or Guides (Axes / Reference Marker).</p>
<h4 id="editing-shapes"><span class="header-section-number">9.13.2.9</span> Editing Shapes</h4>
<p>When a shape is selected, the viewer’s control pane shows the user 
interface that allows you to review and adjust the color and geometry 
properties of the shape.</p>
<p>Note: At present modifications to the shapes are local to the viewer -
 they are not propagated back to external objects/client that published 
to the viewer. The changes are preserved only until the viewer is 
closed. In some cases, this will never be feasible as there is not a 
one-to-one correspondence between a shape in the viewer and a single 
external object in which the modification could be stored.</p>
<h4 id="colors-style"><span class="header-section-number">9.13.2.10</span> Colors / Style</h4>
<p>Viewer Controls Pane ‘Style’ tab.</p>
<p>A full description of OpenGL materials, colors and lighting is beyond
 the scope of this document. You should refer to the OpenGL programming 
manual (Red Book) for a full discussion. In most cases adjustment of the
 Diffuse color material + Opacity/Shine properties is sufficient to 
achieve desired results.</p>
<p>A shape has four-color materials (components):</p>
<ul>
<li><p>Diffuse</p></li>
<li><p>Ambient</p></li>
<li><p>Specular</p></li>
<li><p>Emissive</p></li>
</ul>
<p>For each of these you can select the component via the radio buttons.
 Each component can have the red, green and blue values for the 
component adjusted via the sliders. You can apply this adjustment to the
 shape itself, or to all shapes sharing a common ‘family’. Shapes of the
 same family have external objects with the same <strong><code>TObject</code></strong> name string. You can also adjust the ‘Opacity’ and ‘Shine’ for the shapes materials via the sliders.</p>
<h4 id="geometry"><span class="header-section-number">9.13.2.11</span> Geometry</h4>
<p>Viewer Controls Pane ‘Geometry’ tab.</p>
<p>Review and modify the shapes X/Y/Z center and scaling factors via the
 edit boxes. Selection and editing of shapes is not available via the 
API at present.</p>
<h4 id="outputting-viewer-contents"><span class="header-section-number">9.13.2.12</span> Outputting Viewer Contents</h4>
<p>The current viewer rendering can be output to an external <code>EPS</code> or <code>PDF</code>, using the options under the ‘File’ menu on the top menu bar. The file is named ‘<code>viewer.eps</code>’ or ‘<code>viewer.pdf</code>’ and written to the current ROOT directory.</p>
<h3 id="the-x3d-viewer"><span class="header-section-number">9.13.3</span> The X3D Viewer</h3>
<p>The X3D viewer is a fairly simple and limited viewer, capable of 
showing basic lines and polygons. It lacks the quality, performance and 
more advanced features of the GL Viewer, and additionally is not 
supported on Windows. It is not actively developed and you are 
encouraged to use the GL Viewer out of preference. The below table 
presents the main interactions - these are repeated in the Help dialog 
of the viewer.</p>
<p>Action KeyActionKey</p>
<p>Wireframe Mode wRotate about xx a</p>
<p>Hidden Line Mode eRotate about yy b</p>
<p>Hidden Surface Mode rRotate about zz c</p>
<p>Move object down uAuto-rotate about x1 2 3</p>
<p>Move object up iAuto-rotate about y4 5 6</p>
<p>Move object left lAuto-rotate about z7 8 9</p>
<p>Move object right hToggle controls styleo</p>
<p>Move object forward jToggle stereo displays</p>
<p>Move object backward kToggle blue stereo viewd</p>
<p>Adjust focus (stereo mode) [ ] { }Toggle double bufferf</p>
<p>Rotate object Left mouse button down + move.</p>
<h3 id="common-3d-viewer-architecture"><span class="header-section-number">9.13.4</span> Common 3D Viewer Architecture</h3>
<p>The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:</p>
<ul>
<li><p>Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.</p></li>
<li><p>Producer code free of explicit drawing commands &amp; viewer specific branching.</p></li>
<li><p>Support differing viewers and clients capabilities, e.g.</p></li>
<li><p>Mix of native (in viewer) shapes and generic client side tessellation.</p></li>
<li><p>Local/global frame object description</p></li>
<li><p>Bounding boxes</p></li>
<li><p>Placing copies sharing common geometry (logical/physical shapes).</p></li>
</ul>
<p>The architecture consists of:</p>
<ul>
<li><p><strong><code>TVirtualViewer3D</code></strong> interface: An abstract handle to the viewer, allowing client to add objects, test preferences etc.</p></li>
<li><p><strong><code>TBuffer3D</code></strong> class hierarchy: Used to describe 3D objects (“shapes”) - filled /added by negotiation with viewer via <strong><code>TVirtualViewer3D</code></strong>.</p></li>
</ul>
<p>A typical interaction between viewer and client using these, taken from <strong><code>TGeoPainter</code></strong> is:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb416-1" title="1">TVirtualViewer3D * viewer = gPad-&gt;GetViewer3D();</a>
<a class="sourceLine" id="cb416-2" title="2"><span class="co">// Does viewer prefer local frame positions?</span></a>
<a class="sourceLine" id="cb416-3" title="3"><span class="dt">Bool_t</span> localFrame = viewer-&gt;PreferLocalFrame();</a>
<a class="sourceLine" id="cb416-4" title="4"><span class="co">// Perform first fetch of buffer from the shape and try adding it to the viewer</span></a>
<a class="sourceLine" id="cb416-5" title="5"><span class="at">const</span> TBuffer3D &amp;buffer = shape.GetBuffer3D(TBuffer3D::kCore |</a>
<a class="sourceLine" id="cb416-6" title="6">TBuffer3D::kBoundingBox |</a>
<a class="sourceLine" id="cb416-7" title="7">TBuffer3D::kShapeSpecific,</a>
<a class="sourceLine" id="cb416-8" title="8">localFrame);</a>
<a class="sourceLine" id="cb416-9" title="9"><span class="dt">Int_t</span> reqSections = viewer-&gt;AddObject(buffer, &amp;addDaughters);</a>
<a class="sourceLine" id="cb416-10" title="10"></a>
<a class="sourceLine" id="cb416-11" title="11"><span class="co">// If the viewer requires additional sections fetch from the shape</span></a>
<a class="sourceLine" id="cb416-12" title="12"><span class="co">// (if possible) and add again</span></a>
<a class="sourceLine" id="cb416-13" title="13"><span class="cf">if</span> (reqSections != TBuffer3D::kNone)</a>
<a class="sourceLine" id="cb416-14" title="14">shape.GetBuffer3D(reqSections, localFrame);</a></code></pre></div>
<p>Together these allow clients to publish objects to any one of the 3D 
viewers free of viewer specific drawing code. They allow our simple x3d 
viewer, and considerably more sophisticated OpenGL one to both work with
 both geometry libraries (<code>g3d</code> and <code>geom</code>) efficiently.</p>
<p>In addition to external viewers, created in separate windows, this architecture is also used by internal <strong><code>TPad</code></strong> drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:</p>
<p>1- Create / obtain viewer handle.</p>
<p>2- Begin scene on viewer.</p>
<p>3- Fill mandatory parts of TBuffer3D describing object.</p>
<p>4- Add to viewer.</p>
<p>5- Fill optional parts of TBuffer3D as requested by viewer.</p>
<p>[ …. repeat 3/4/5 as required for other/child objects]</p>
<p>6- End scene on viewer.</p>
<p>You should attach the top-level node of your external geometry (or the manager) to a <strong><code>TPad</code></strong> object using <strong><code>TObject::Draw()</code>, and perform the publishing to the viewer in your object’s <code>TObject::Paint()</code> overloaded method. See “Scene Rebuilds”, and example scripts, for more details.</strong></p>
<h4 id="creating-obtaining-viewer-handle"><span class="header-section-number">9.13.4.1</span> Creating / Obtaining Viewer Handle</h4>
<p>External viewers are bound to a <strong><code>TPad</code></strong> object (this may be removed as a requirement in the future). You can create or obtain the current viewer handle via the method:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb417-1" title="1">TVirtualViewer3D * v = gPad-&gt;GetViewer3D(<span class="st">"type"</span>);</a></code></pre></div>
<p>Here the “type” string defines the viewer type - currently one of:</p>
<ul>
<li><p>“<code>ogl</code>” : External GL viewer</p></li>
<li><p>“<code>x3d</code>”: External X3D viewer</p></li>
<li><p>“<code>pad</code>”: Pad viewer</p></li>
</ul>
<p>If no type is passed (null string), and there is no current viewer, then the type is defaulted to “<code>pad</code>”.
 If no type is passed and there is a current viewer, then this is 
returned - hence once a viewer is created it can be obtained elsewhere 
by:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb418-1" title="1">TVirtualViewer3D * v = gPad-&gt;GetViewer3D();</a></code></pre></div>
<h4 id="opening-closing-scenes"><span class="header-section-number">9.13.4.2</span> Opening / Closing Scenes</h4>
<p>Objects must be added to viewer between <code>BeginScene()</code> and <code>EndScene()</code> calls e.g.</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb419-1" title="1">viewer-&gt;BeginScene();</a>
<a class="sourceLine" id="cb419-2" title="2"><span class="co">// Add objects</span></a>
<a class="sourceLine" id="cb419-3" title="3">viewer -&gt;EndScene();</a></code></pre></div>
<p>These calls enable the viewer to suspend redraws, and perform 
internal caching/setup. If the object you attach to the pad derives from
 <strong><code>TAtt3D</code></strong>, then the pad will take responsibility for calling <code>BeginScene()</code> and <code>EndScene()</code> for you. You can always test if the scene is already open for object addition with:</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb420-1" title="1">viewer-&gt;BuildingScene();</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000DF.png" alt="Overview of 3D viewer architecture"><figcaption>Overview of 3D viewer architecture</figcaption>
</figure>
<p>Note: the x3d viewer does not support rebuilding of scenes - objects 
added after the first Open/Close Scene pair will be ignored.</p>
<h4 id="describing-objects---filling-tbuffer3d"><span class="header-section-number">9.13.4.3</span> Describing Objects - Filling TBuffer3D</h4>
<p>The viewers behind the <strong><code>TVirtualViewer3D</code></strong> interface differ greatly in their capabilities e.g.</p>
<ul>
<li><p>Some support native shape (e.g.&nbsp;spheres/tubes in OpenGL) and
 can draw these based on an abstract description. Others always require a
 tessellation description based on <strong><code>TBuffer3D</code></strong>’s <code>kRaw</code> / <code>kRawSizes</code> points/lines/segments sections.</p></li>
<li><p>Some need the 3D object positions in the master (world) frame, 
others can cope with local frames and a translation matrix to place the 
object.</p></li>
<li><p>Some require bounding boxes for objects - others do not.</p></li>
</ul>
<p>Similarly some viewer clients are only capable of providing positions
 in master frame, cannot provide bounding boxes etc. Additionally we do 
not want to incur the cost of expensive tessellation operations if the 
viewer does not require them. To cope with these variations the <strong><code>TBuffer3D</code></strong> objects are filled by negotiation with the viewer.</p>
<figure>
<img src="ROOTUsersGuide_files/030000E0.png" alt="TBuffer3D class hierarchy"><figcaption>TBuffer3D class hierarchy</figcaption>
</figure>
<p><strong><code>TBuffer3D</code></strong> classes are conceptually divided into enumerated sections: <code>kCore</code>, <code>kBoundingBox</code>, <code>kRaw</code> - see the class diagram and the file <code>TBuffer3D.h</code> for more details. The <strong><code>TBuffer3D</code></strong> methods <code>SectionsValid()</code>, <code>SetSectionsValid()</code>, <code>ClearSectionsValid()</code> are used to test, set, clear these section validity flags e.g.</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb421-1" title="1">buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);</a>
<a class="sourceLine" id="cb421-2" title="2">...</a>
<a class="sourceLine" id="cb421-3" title="3"><span class="cf">if</span> (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {</a>
<a class="sourceLine" id="cb421-4" title="4">   ...</a>
<a class="sourceLine" id="cb421-5" title="5">}</a></code></pre></div>
<p>The sections found in the base <strong><code>TBuffer3D</code></strong> (<code>kCore/kBoundingBox/kRawSizes/kRaw</code>) are sufficient to describe any tessellated shape in a generic fashion. An additional <code>kShapeSpecific</code> section is added in <strong><code>TBuffer3D</code></strong>
 derived classes, allowing a more abstract shape description (“a sphere 
of inner radius x, outer radius y”). This enables a viewer, which knows 
how to draw (tessellate) the shape itself to do so, while providing a 
generic fallback suitable for all viewers. The rules for client 
negotiation with the viewer are:</p>
<ul>
<li><p>If suitable specialized <strong><code>TBuffer3D</code></strong> class exists, use it, otherwise use <strong><code>TBuffer3D</code></strong>.</p></li>
<li><p>Complete the mandatory <code>kCore</code> section.</p></li>
<li><p>Complete the <code>kShapeSpecific</code> section if applicable.</p></li>
<li><p>Complete the <code>kBoundingBox</code> if you can.</p></li>
<li><p>Pass this buffer to the viewer using one of the <code>TBuffer3D::AddObject()</code> methods.</p></li>
</ul>
<p>If the viewer requires more sections to be completed (<code>kRaw/kRawSizes</code>) <code>TBuffer3D::AddObject()</code> will return flags indicating which ones, otherwise it returns <code>kNone</code>. If requested, you must fill the buffer, mark these sections valid, and call <code>TBuffer3D::AddObject</code> again, to complete adding the object. For example, in out <strong><code>TGeo</code></strong> geometry package, in <code>TGeoPainter::PaintShape</code>, we perform the negotiation with viewer:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb422-1" title="1">TVirtualViewer3D * viewer = gPad-&gt;GetViewer3D();</a>
<a class="sourceLine" id="cb422-2" title="2"><span class="cf">if</span> (shape.IsA() != TGeoCompositeShape::Class()) {</a>
<a class="sourceLine" id="cb422-3" title="3">   <span class="co">// Does viewer prefer local frame positions?</span></a>
<a class="sourceLine" id="cb422-4" title="4">   <span class="dt">Bool_t</span> localFrame = viewer-&gt;PreferLocalFrame();</a>
<a class="sourceLine" id="cb422-5" title="5">   <span class="co">// Perform first fetch of buffer from the shape and adding</span></a>
<a class="sourceLine" id="cb422-6" title="6">   <span class="co">// it to the viewer</span></a>
<a class="sourceLine" id="cb422-7" title="7">   <span class="at">const</span> TBuffer3D &amp;buffer = shape.GetBuffer3D(TBuffer3D::kCore |</a>
<a class="sourceLine" id="cb422-8" title="8">   TBuffer3D::kBoundingBox |</a>
<a class="sourceLine" id="cb422-9" title="9">   TBuffer3D::kShapeSpecific, localFrame);</a>
<a class="sourceLine" id="cb422-10" title="10">   <span class="dt">Int_t</span> reqSections = viewer-&gt;AddObject(buffer, &amp;addDaughters);</a>
<a class="sourceLine" id="cb422-11" title="11">   <span class="co">// If the viewer requires additional sections fetch from the</span></a>
<a class="sourceLine" id="cb422-12" title="12">   <span class="co">// shape (if possible) and add again</span></a>
<a class="sourceLine" id="cb422-13" title="13">   <span class="cf">if</span> (reqSections != TBuffer3D::kNone) {</a>
<a class="sourceLine" id="cb422-14" title="14">      shape.GetBuffer3D(reqSections, localFrame);</a>
<a class="sourceLine" id="cb422-15" title="15">      viewer-&gt;AddObject(buffer, &amp;addDaughters);</a>
<a class="sourceLine" id="cb422-16" title="16">   }</a>
<a class="sourceLine" id="cb422-17" title="17">}</a></code></pre></div>
<p>The buffer is supplied/filled by the appropriate <code>TShape::GetBuffer3D()</code> and <strong><code>TShape::FillBuffer3D</code> overloads e.g.&nbsp;for a sphere in <code>TGeoSphere</code></strong>.</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb423-1" title="1"><span class="at">const</span> TBuffer3D &amp;TGeoSphere::GetBuffer3D(<span class="dt">Int_t</span> reqSections,</a>
<a class="sourceLine" id="cb423-2" title="2"><span class="dt">Bool_t</span> localFrame) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb423-3" title="3">   <span class="co">// Fills a static 3D buffer and returns a reference.</span></a>
<a class="sourceLine" id="cb423-4" title="4">   <span class="at">static</span> TBuffer3DSphere buffer;</a>
<a class="sourceLine" id="cb423-5" title="5">   <span class="co">// Filling of kBoundingBox is defered to TGeoBBox, and</span></a>
<a class="sourceLine" id="cb423-6" title="6">   <span class="co">// kCore on up to TGeoShape</span></a>
<a class="sourceLine" id="cb423-7" title="7">   TGeoBBox::FillBuffer3D(buffer, reqSections, localFrame);</a>
<a class="sourceLine" id="cb423-8" title="8">   <span class="co">// Complete kShapeSpecific section for sphere</span></a>
<a class="sourceLine" id="cb423-9" title="9">   <span class="cf">if</span> (reqSections &amp; TBuffer3D::kShapeSpecific) {</a>
<a class="sourceLine" id="cb423-10" title="10">      buffer.fRadiusInner  = fRmin;</a>
<a class="sourceLine" id="cb423-11" title="11">      buffer.fRadiusOuter  = fRmax;</a>
<a class="sourceLine" id="cb423-12" title="12">      ...</a>
<a class="sourceLine" id="cb423-13" title="13">      buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);</a>
<a class="sourceLine" id="cb423-14" title="14">   }</a>
<a class="sourceLine" id="cb423-15" title="15">   <span class="co">// Complete kRawSizes section</span></a>
<a class="sourceLine" id="cb423-16" title="16">   <span class="cf">if</span> (reqSections &amp; TBuffer3D::kRawSizes) {</a>
<a class="sourceLine" id="cb423-17" title="17">      ...</a>
<a class="sourceLine" id="cb423-18" title="18">      buffer.SetSectionsValid(TBuffer3D::kRawSizes);</a>
<a class="sourceLine" id="cb423-19" title="19">   }</a>
<a class="sourceLine" id="cb423-20" title="20">}</a>
<a class="sourceLine" id="cb423-21" title="21">   <span class="co">// Complete kRaw tesselation section</span></a>
<a class="sourceLine" id="cb423-22" title="22">   <span class="cf">if</span> ((reqSections &amp; TBuffer3D::kRaw) &amp;&amp;</a>
<a class="sourceLine" id="cb423-23" title="23">        buffer.SectionsValid(TBuffer3D::kRawSizes)) {</a>
<a class="sourceLine" id="cb423-24" title="24">      SetPoints(buffer.fPnts);</a>
<a class="sourceLine" id="cb423-25" title="25">      <span class="co">// Transform points to master frame if viewer requires it</span></a>
<a class="sourceLine" id="cb423-26" title="26">      <span class="co">// The fLocalFrame flag and translation matrix will have</span></a>
<a class="sourceLine" id="cb423-27" title="27">      <span class="co">// already been set in TGeoShape::FillBuffer3D() as required</span></a>
<a class="sourceLine" id="cb423-28" title="28">      <span class="cf">if</span> (!buffer.fLocalFrame)</a>
<a class="sourceLine" id="cb423-29" title="29">         TransformPoints(buffer.fPnts, buffer.NbPnts());</a>
<a class="sourceLine" id="cb423-30" title="30">      SetSegsAndPols(buffer);</a>
<a class="sourceLine" id="cb423-31" title="31">      buffer.SetSectionsValid(TBuffer3D::kRaw);</a>
<a class="sourceLine" id="cb423-32" title="32">   }</a>
<a class="sourceLine" id="cb423-33" title="33">   <span class="cf">return</span> buffer;</a>
<a class="sourceLine" id="cb423-34" title="34">}</a></code></pre></div>
<p>Note:</p>
<ul>
<li><p>we use a static <strong><code>TBuffer3D</code></strong> derived object for efficiency - once the object is added the buffer can be reused.</p></li>
<li><p><code>kRawSize</code> (the calculation of tessellation sizing required in buffer) and <code>kRaw</code>
 (the actual filling of tessellation) is split, as the X3D viewer 
requires two publication passes - one to establish the full tessellation
 capacity for all shapes, and another to actually add them. Splitting 
avoids having to do the expensive tessellation on the first pass.</p></li>
</ul>
<h4 id="shape-specific-tbuffer3d-derived-classes"><span class="header-section-number">9.13.4.4</span> Shape Specific TBuffer3D Derived Classes</h4>
<p>Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see <code>TBuffer3D.h</code> and <code>TBuffer3DTypes.h</code>)</p>
<ul>
<li><p><strong><code>TBuffer3DSphere</code></strong> - solid, hollow and
 cut spheres (GL Viewer only supports solid spheres at present - cut / 
hollow ones will be requested as tessellated objects by client.)</p></li>
<li><p><strong><code>TBuffer3DTube</code></strong> - basic tube with inner/outer radius and length.</p></li>
<li><p><strong><code>TBuffer3DTubeSeg</code></strong> - angle tube segment.</p></li>
<li><p><strong><code>TBuffer3DCutTube</code></strong> - angle tube segment with plane cut ends.</p></li>
</ul>
<p>See the above example from <code>TGeoSphere::GetBuffer3D</code> and also equivalent functions in <strong><code>TGeoTube</code></strong>, <strong><code>TGeoTubeSeg</code></strong> and <strong><code>TGeoCtub</code></strong>. Anyone is free to add new <strong><code>TBuffer3D</code></strong>
 classes, but it should be clear that one or more viewers will require 
updating to be able to take advantage of them. Hence we only provide 
classes which existing viewers can benefit from. The number of native 
shapes in GL Viewer will be expanded in the future.</p>
<h4 id="master-local-reference-frames"><span class="header-section-number">9.13.4.5</span> Master / Local Reference Frames</h4>
<p>The Core section of <strong><code>TBuffer3D</code></strong> contains two members relating to reference frames:</p>
<ul>
<li><p><code>fLocalFrame</code>: indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame).</p></li>
<li><p><code>fLocalMaster</code>: is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.</p></li>
</ul>
<p>If <code>fLocalFrame</code> is false, <code>fLocalMaster</code> should contain an identity matrix. This is set by default, and can be reset using the <strong><code>TBuffer3D::SetLocalMasterIdentity()</code> method.</strong></p>
<h4 id="bounding-boxes"><span class="header-section-number">9.13.4.6</span> Bounding Boxes</h4>
<p>You are not obliged to complete the <code>kBoundingBox</code> 
section, as any viewer requiring one internally (GL Viewer) will build 
it if you do not provide. However to do this the viewer will force you 
to provide the (expensive) raw tessellation, and the resulting box will 
be axis aligned with the overall scene, which is non-ideal for rotated 
shapes. As we need to support orientated (rotated) bounding boxes, <strong><code>TBuffer3D</code></strong> requires the 6 vertices of the box. We also provide a convenience function, <code>TBuffer::SetAABoundingBox()</code>,
 for simpler case of setting an axis aligned bounding box. The bounding 
box should be filled in same frame (local / master) as the rest of the <strong><code>TBuffer3D</code></strong>, and in accordance with <code>fLocalFrame</code> flag.</p>
<p>A typical example from TGeoBBox::FillBuffer3D:</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb424-1" title="1">   <span class="cf">if</span> (reqSections &amp; TBuffer3D::kBoundingBox) {</a>
<a class="sourceLine" id="cb424-2" title="2">      <span class="dt">Double_t</span> halfLengths[<span class="dv">3</span>] = { fDX, fDY, fDZ };</a>
<a class="sourceLine" id="cb424-3" title="3">      buffer.SetAABoundingBox(fOrigin, halfLengths);</a>
<a class="sourceLine" id="cb424-4" title="4">      <span class="cf">if</span> (!buffer.fLocalFrame) {</a>
<a class="sourceLine" id="cb424-5" title="5">         TransformPoints(buffer.fBBVertex[<span class="dv">0</span>], <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb424-6" title="6">      }</a>
<a class="sourceLine" id="cb424-7" title="7">      buffer.SetSectionsValid(TBuffer3D::kBoundingBox);</a>
<a class="sourceLine" id="cb424-8" title="8">   }</a></code></pre></div>
<h4 id="logical-and-physical-objects"><span class="header-section-number">9.13.4.7</span> Logical and Physical Objects</h4>
<p>Some viewers can support two types of object placement:</p>
<ul>
<li><p>Add object as a single independent entity in the world reference frame - e.g.&nbsp;a sphere, radius <code>r</code>, at <code>x</code>, <code>y</code>, <code>z</code>.</p></li>
<li><p>Repeated placement (copying) in world frame of this locally 
unique piece of geometry (described in local reference frame) 
e.g.&nbsp;define a sphere <code>S</code> (radius <code>r</code>), place copy at <code>x1</code>, <code>y1</code>, <code>z1</code>, another copy at <code>x2</code>, <code>y2</code>, <code>z2</code> etc.</p></li>
</ul>
<p>The second case is very typical in geometry packages, e.g.&nbsp;ROOT’s <strong><code>TGeo</code></strong> package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.</p>
<p>Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the <code>fID</code> logical ID member of <strong><code>TBuffer3D</code></strong>. If repeated addition of the same <code>fID</code>
 is found, the shape is cached already - and the costly tessellation 
does not need to be sent again. The viewer can also perform internal GL 
specific caching (display lists) with considerable performance gains in 
these cases. For this to work correctly the logical object in must be 
described in <strong><code>TBuffer3D</code></strong> in the local reference frame, complete with the local<code>/</code>master translation. In some cases you will not have a real object you can reasonably set <strong><code>TBuffer3D::fID</code> to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set <code>TBuffer3D::fID</code> to 0 (null).</strong></p>
<p>The viewer indicates it can support local frame objects through the <strong><code>TVirtualViewer3D</code></strong> interface method: <code>PreferLocalFrame()</code>. If this returns <code>kTRUE</code> you can make repeated calls to <code>AddObject()</code>, with <strong><code>TBuffer3D</code></strong> containing the same <code>fID</code>, and different <code>fLocalMaster</code> placements.</p>
<p>For viewers supporting logical/physical objects, the TBuffer3D 
content refers to the properties of the logical object, with the 
exception of:</p>
<ul>
<li><p><code>fLocalMaster</code> transform</p></li>
<li><p><code>fColor</code></p></li>
<li><p><code>fTransparency</code></p></li>
</ul>
<p>attributes, which can be varied for <strong>each</strong> physical object.</p>
<p>As <strong>a minimum requirement</strong> all clients must be capable
 of filling the raw tessellation of the object buffer, in the master 
reference frame. Conversely viewers must always be capable of displaying
 the object described by this buffer. If either does not meet this 
requirement the object may not be displayed.</p>
<h4 id="scene-rebuilds"><span class="header-section-number">9.13.4.8</span> Scene Rebuilds</h4>
<p><code>TBuffer3D::AddObject</code> is not an explicit command to the viewer - it may for various reasons decide to ignore it:</p>
<ul>
<li><p>It already has the object internally cached.</p></li>
<li><p>The object falls outside some ‘interest’ limits of the viewer camera.</p></li>
<li><p>The object is too small to be worth drawing.</p></li>
</ul>
<p>In all these cases <code>TBuffer3D::AddObject()</code> returns kNone,
 as it does for successful addition, indicating it does not require 
further information about this object. Hence you should not try to make 
any assumptions about what the viewer did with the object. The viewer 
may decide to force the client to rebuild (republish) the scene, 
obtaining a different collection of objects, if the internal viewer 
state changes .e.g. significant camera move. It does this presently by 
forcing a repaint on the attached <strong><code>TPad</code></strong> object - hence you should attach you master geometry object to the pad (via <code>TObject::Draw()</code>), and perform the publishing to the viewer in response to <strong><code>TObject::Paint()</code></strong>.</p>
<h4 id="physical-ids"><span class="header-section-number">9.13.4.9</span> Physical IDs</h4>
<p>TVirtualViewer3D provides for two methods of object addition:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb425-1" title="1"><span class="kw">virtual</span> <span class="dt">Int_t</span> AddObject(<span class="at">const</span> TBuffer3D &amp;buffer,</a>
<a class="sourceLine" id="cb425-2" title="2">                        <span class="dt">Bool_t</span> * addChildren = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb425-3" title="3"><span class="kw">virtual</span> <span class="dt">Int_t</span> AddObject(<span class="dt">UInt_t</span> physicalID,</a>
<a class="sourceLine" id="cb425-4" title="4">                        <span class="at">const</span> TBuffer3D &amp; buffer,</a>
<a class="sourceLine" id="cb425-5" title="5">                        <span class="dt">Bool_t</span> *addChildren = <span class="dv">0</span>)</a></code></pre></div>
<p>If you use the first (simple) case a viewer using logical/physical 
pairs will generate sequential IDs for each physical object internally. 
Scene rebuilds will require destruction and recreation of all physical 
objects. For the second you can specify an identifier from the client 
side, which must be unique and stable - i.e.&nbsp;the IDs of a published
 object is consistent, regardless of changes in termination of contained
 child geometry branches. In this case the viewer can safely cache the 
physical objects across scene rebuilds, discarding those no longer of 
interest.</p>
<h4 id="child-objects"><span class="header-section-number">9.13.4.10</span> Child Objects</h4>
<p>In many geometries there is a rigid containment hierarchy, and so if 
the viewer is not interested in a certain object due to limits/size then
 it will also not be interest in any of the contained branch of 
siblings. Both <code>TBuffer3D::AddObject()</code> methods have an <code>addChildren</code> return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.</p>
<h4 id="recycling-tbuffer3d"><span class="header-section-number">9.13.4.11</span> Recycling TBuffer3D</h4>
<p>Once add <code>TBuffer3D::AddObject()</code> has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this <strong><code>TBuffer3D</code></strong>, or recycle it for the next object if suitable.</p>
<h4 id="examples-1"><span class="header-section-number">9.13.4.12</span> Examples</h4>
<p>For an example of a simple geometry, working in master reference frame examine the code under <code>$ROOTSYS/g3d</code>. For a more complex example, which works in both master and local frames, and uses logical<code>/</code>physical division of shape geometry and placement, examine the code under <code>$ROOTSYS/geom</code> - in particular <strong><code>TGeoShape</code></strong> hierarchy, and the painter object <strong><code>TGeoPainter</code></strong> (under geopainter) where the negotiation with the viewer is performed.</p>
<h1 id="folders-and-tasks"><span class="header-section-number">10</span> Folders and Tasks</h1>
<h2 id="folders"><span class="header-section-number">10.1</span> Folders</h2>
<p><img src="ROOTUsersGuide_files/030000E1.png"></p>
<p>A <strong><code>TFolder</code></strong> is a collection of objects 
visible and expandable in the ROOT object browser. Folders have a name 
and a title and are identified in the folder hierarchy by an “UNIX-like”
 naming convention. The base of all folders is <code>//root</code>. It is visible at the top of the left panel in the browser. The browser shows several folders under <code>//root</code>.</p>
<p>New folders can be added and removed to/from a folder.</p>
<h2 id="why-use-folders"><span class="header-section-number">10.2</span> Why Use Folders?</h2>
<p>One reason to use folders is to reduce class dependencies and improve
 modularity. Each set of data has a producer class and one or many 
consumer classes. When using folders, the producer class places a 
pointer to the data into a folder, and the consumer class retrieves a 
reference to the folder.</p>
<p>The consumer can access the objects in a folder by specifying the path name of the folder.</p>
<p>Here is an example of a folder’s path name:</p>
<p><code>//root/Event/Hits/TCP</code></p>
<p>One does not have to specify the full path name. If the partial path 
name is unique, it will find it; otherwise it will return the first 
occurrence of the path.</p>
<p>The first diagram shows a system without folders. The objects have 
pointers to each other to access each other’s data. Pointers are an 
efficient way to share data between classes. However, a direct pointer 
creates a direct coupling between classes. This design can become a very
 tangled web of dependencies in a system with a large number of classes.</p>
<p><img src="ROOTUsersGuide_files/020000E2.jpg"></p>
<p>In the second diagram, a reference to the data is in the folder and 
the consumers refer to the folder rather than each other to access the 
data. The naming and search service provided by the ROOT folders 
hierarchy provides an alternative. It loosely couples the classes and 
greatly enhances I/O operations. In this way, folders separate the data 
from the algorithms and greatly improve the modularity of an application
 by minimizing the class dependencies.</p>
<p><img src="ROOTUsersGuide_files/020000E3.jpg"></p>
<p>In addition, the folder hierarchy creates a picture of the data 
organization. This is useful when discussing data design issues or when 
learning the data organization. The example below illustrates this 
point.</p>
<h2 id="how-to-use-folders"><span class="header-section-number">10.3</span> How to Use Folders</h2>
<p>Using folders means to build a hierarchy of folders, posting the 
reference to the data in the folder by the producer, and creating a 
reference to the folder by the user.</p>
<h3 id="creating-a-folder-hierarchy"><span class="header-section-number">10.3.1</span> Creating a Folder Hierarchy</h3>
<p>To create a folder hierarchy you add the top folder of your hierarchy to <code>//root</code>. Then you add a folder to an existing folder with the <strong><code>TFolder::AddFolder</code></strong>
 method. This method takes two parameters: the name and title of the 
folder to be added. It returns a pointer of the newly created folder.</p>
<p>The code below creates the folder hierarchy shown in the browser. In 
this macro, the folder is also added to the list of browsable. This way,
 it is visible in the browser on the top level.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb426-1" title="1">{</a>
<a class="sourceLine" id="cb426-2" title="2">   <span class="co">// Add the top folder of my hierary to //root</span></a>
<a class="sourceLine" id="cb426-3" title="3">   TFolder *aliroot=gROOT-&gt;GetRootFolder()-&gt;AddFolder(<span class="st">"aliroot"</span>,</a>
<a class="sourceLine" id="cb426-4" title="4">                                   <span class="st">"aliroot top level folders"</span>);</a>
<a class="sourceLine" id="cb426-5" title="5">   <span class="co">// Add the hierarchy to the list of browsables</span></a>
<a class="sourceLine" id="cb426-6" title="6">   gROOT-&gt;GetListOfBrowsables()-&gt;Add(aliroot,<span class="st">"aliroot"</span>);</a>
<a class="sourceLine" id="cb426-7" title="7"></a>
<a class="sourceLine" id="cb426-8" title="8">   <span class="co">// Create and add the constants folder</span></a>
<a class="sourceLine" id="cb426-9" title="9">   TFolder *constants=aliroot-&gt;AddFolder(<span class="st">"Constants"</span>,</a>
<a class="sourceLine" id="cb426-10" title="10">                                         <span class="st">"Detector constants"</span>);</a>
<a class="sourceLine" id="cb426-11" title="11"></a>
<a class="sourceLine" id="cb426-12" title="12">   <span class="co">// Create and add the pdg folder to pdg</span></a>
<a class="sourceLine" id="cb426-13" title="13">   TFolder *pdg = constants-&gt;AddFolder(<span class="st">"DatabasePDG"</span>,<span class="st">"PDG database"</span>);</a>
<a class="sourceLine" id="cb426-14" title="14"></a>
<a class="sourceLine" id="cb426-15" title="15">   <span class="co">// Create and add the run folder</span></a>
<a class="sourceLine" id="cb426-16" title="16">   TFolder *run = aliroot-&gt;AddFolder(<span class="st">"Run"</span>,<span class="st">"Run dependent folders"</span>);</a>
<a class="sourceLine" id="cb426-17" title="17"></a>
<a class="sourceLine" id="cb426-18" title="18">   <span class="co">// Create and add the configuration folder to run</span></a>
<a class="sourceLine" id="cb426-19" title="19">   TFolder *configuration = run-&gt;AddFolder(<span class="st">"Configuration"</span>,</a>
<a class="sourceLine" id="cb426-20" title="20">                                           <span class="st">"Run configuration"</span>);</a>
<a class="sourceLine" id="cb426-21" title="21"></a>
<a class="sourceLine" id="cb426-22" title="22">   <span class="co">// Create and add the run_mc folder</span></a>
<a class="sourceLine" id="cb426-23" title="23">   TFolder *run_mc = aliroot-&gt;AddFolder(<span class="st">"RunMC"</span>,</a>
<a class="sourceLine" id="cb426-24" title="24">                     <span class="st">"MonteCarlo run dependent folders"</span>);</a>
<a class="sourceLine" id="cb426-25" title="25"></a>
<a class="sourceLine" id="cb426-26" title="26">   <span class="co">// Create and add the configuration_mc folder to run_mc</span></a>
<a class="sourceLine" id="cb426-27" title="27">   TFolder *configuration_mc = run_mc-&gt;AddFolder(<span class="st">"Configuration"</span>,</a>
<a class="sourceLine" id="cb426-28" title="28">                                    <span class="st">"MonteCarlo run configuration"</span>);</a>
<a class="sourceLine" id="cb426-29" title="29">}</a></code></pre></div>
<h3 id="posting-data-to-a-folder-producer"><span class="header-section-number">10.3.2</span> Posting Data to a Folder (Producer)</h3>
<p><img src="ROOTUsersGuide_files/030000E4.png"></p>
<p>A <strong><code>TFolder</code></strong> can contain other folders as shown above or any <strong><code>TObject</code></strong>
 descendents. In general, users will not post a single object to a 
folder; they will store a collection or multiple collections in a 
folder. For example, to add an array to a folder:</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb427-1" title="1">TObjArray *array;</a>
<a class="sourceLine" id="cb427-2" title="2">run_mc-&gt;Add(array);</a></code></pre></div>
<h3 id="reading-data-from-a-folder-consumer"><span class="header-section-number">10.3.3</span> Reading Data from a Folder (Consumer)</h3>
<p>One can search for a folder or an object in a folder using the <code>TROOT::FindObjectAny</code>
 method. It analyzes the string passed as its argument and searches in 
the hierarchy until it finds an object or folder matching the name. With
 <code>FindObjectAny</code>, you can give the full path name, or the 
name of the folder. If only the name of the folder is given, it will 
return the first instance of that name. A string-based search is time 
consuming. If the retrieved object is used frequently or inside a loop, 
you should save a pointer to the object as a class data member. Use the 
naming service only in the initialization of the consumer class. When a 
folder is deleted, any reference to it in the parent or other folder is 
deleted also.</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb428-1" title="1">   conf=(TFolder*)gROOT-&gt;FindObjectAny(<span class="st">"/aliroot/Run/Configuration"</span>);</a>
<a class="sourceLine" id="cb428-2" title="2">   <span class="co">// or ...</span></a>
<a class="sourceLine" id="cb428-3" title="3">   conf=(TFolder*)gROOT-&gt;FindObjectAny(<span class="st">"Configuration"</span>);</a></code></pre></div>
<p>By default, a folder does not own the object it contains. You can overwrite that with <code>TFolder::SetOwner</code>.
 Once the folder is the owner of its contents, the contents are deleted 
when the folder is deleted. Some ROOT objects are automatically added to
 the folder hierarchy. For example, the following folders exist on start
 up:</p>
<p><code>//root/ROOT Files</code> with the list of open Root files</p>
<p><code>//root/Classes</code> with the list of active classes</p>
<p><code>//root/Geometries</code> with active geometries</p>
<p><code>//root/Canvases</code> with the list of active canvases</p>
<p><code>//root/Styles</code> with the list of graphics styles</p>
<p><code>//root/Colors</code> with the list of active colors</p>
<p>For example, if a file <code>myFile.root</code> is added to the list of files, one can retrieve a pointer to the corresponding <strong><code>TFile</code></strong> object with a statement like:</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb429-1" title="1">   TFile *myFile = (TFile*)gROOT-&gt;FindObjectAny(</a>
<a class="sourceLine" id="cb429-2" title="2">      <span class="st">"/ROOTFiles/myFile.root"</span>);</a>
<a class="sourceLine" id="cb429-3" title="3">   <span class="co">//or...</span></a>
<a class="sourceLine" id="cb429-4" title="4">   TFile *myFile = (TFile*)gROOT-&gt;FindObjectAny(<span class="st">"myFile.root"</span>);</a></code></pre></div>
<h2 id="tasks"><span class="header-section-number">10.4</span> Tasks</h2>
<p>Tasks can be organized into a hierarchy and displayed in the browser. The <strong><code>TTask</code></strong> class is the base class from which the tasks are derived. To give task functionality, you need to subclass the <strong><code>TTask</code></strong> class and override the <code>Exec</code> method. An example of <strong><code>TTask</code></strong> subclasses<code>is $ROOTSYS/tutorials/MyTasks.cxx</code>. The script that creates a task hierarchy and adds it to the browser is $<code>ROOTSYS/tutorials/tasks.C</code>. Here is a part of <code>MyTasks.cxx</code> that shows how to subclass from <strong><code>TTask</code></strong>.</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb430-1" title="1"><span class="co">// A set of classes deriving from TTask see macro tasks.C. The Exec</span></a>
<a class="sourceLine" id="cb430-2" title="2"><span class="co">// function of each class prints one line when it is called.</span></a>
<a class="sourceLine" id="cb430-3" title="3"><span class="pp">#include </span><span class="im">"TTask.h"</span></a>
<a class="sourceLine" id="cb430-4" title="4"><span class="kw">class</span> MyRun : <span class="kw">public</span> TTask {</a>
<a class="sourceLine" id="cb430-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb430-6" title="6">   MyRun() { ; }</a>
<a class="sourceLine" id="cb430-7" title="7">   MyRun(<span class="at">const</span> <span class="dt">char</span> *name,<span class="at">const</span> <span class="dt">char</span> *title);</a>
<a class="sourceLine" id="cb430-8" title="8">   <span class="kw">virtual</span> ~MyRun() { ; }</a>
<a class="sourceLine" id="cb430-9" title="9">   <span class="dt">void</span> Exec(<span class="dt">Option_t</span> *option=<span class="st">""</span>);</a>
<a class="sourceLine" id="cb430-10" title="10">   ClassDef(MyRun,<span class="dv">1</span>)         <span class="co">// Run Reconstruction task</span></a>
<a class="sourceLine" id="cb430-11" title="11">};</a>
<a class="sourceLine" id="cb430-12" title="12"></a>
<a class="sourceLine" id="cb430-13" title="13"><span class="kw">class</span> MyEvent : <span class="kw">public</span> TTask {</a>
<a class="sourceLine" id="cb430-14" title="14"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb430-15" title="15">   MyEvent() { ; }</a>
<a class="sourceLine" id="cb430-16" title="16">   MyEvent(<span class="at">const</span> <span class="dt">char</span> *name,<span class="at">const</span> <span class="dt">char</span> *title);</a>
<a class="sourceLine" id="cb430-17" title="17">   <span class="kw">virtual</span> ~MyEvent() { ; }</a>
<a class="sourceLine" id="cb430-18" title="18">   <span class="dt">void</span> Exec(<span class="dt">Option_t</span> *option=<span class="st">""</span>);</a>
<a class="sourceLine" id="cb430-19" title="19">   ClassDef(MyEvent,<span class="dv">1</span>)   <span class="co">// Event Reconstruction task</span></a>
<a class="sourceLine" id="cb430-20" title="20">};</a></code></pre></div>
<p>Later in <code>MyTasks.cxx</code>, we can see examples of the constructor and overridden <code>Exec()</code> method:</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb431-1" title="1">ClassImp(MyRun)</a>
<a class="sourceLine" id="cb431-2" title="2">MyRun::MyRun(<span class="at">const</span> <span class="dt">char</span> *name,<span class="at">const</span> <span class="dt">char</span> *title):TTask(name,title)</a>
<a class="sourceLine" id="cb431-3" title="3">{</a>
<a class="sourceLine" id="cb431-4" title="4">...</a>
<a class="sourceLine" id="cb431-5" title="5">}</a>
<a class="sourceLine" id="cb431-6" title="6"><span class="dt">void</span> MyRun::Exec(<span class="dt">Option_t</span> *option)</a>
<a class="sourceLine" id="cb431-7" title="7">{</a>
<a class="sourceLine" id="cb431-8" title="8">   printf(<span class="st">"MyRun executingn"</span>);</a>
<a class="sourceLine" id="cb431-9" title="9">}</a></code></pre></div>
<p>Each <strong><code>TTask</code></strong> derived class may contain other <strong><code>TTasks</code></strong>
 that can be executed recursively. In this way, a complex program can be
 dynamically built and executed by invoking the services of the top 
level task or one of its subtasks. The constructor of <strong><code>TTask</code></strong> has two arguments: the name and the title. This script creates the task defined above, and creates a hierarchy of tasks.</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb432-1" title="1"><span class="co">// Show the tasks in a browser. To execute a Task, select</span></a>
<a class="sourceLine" id="cb432-2" title="2"><span class="co">// "ExecuteTask" in the context menu see also other functions in the</span></a>
<a class="sourceLine" id="cb432-3" title="3"><span class="co">// TTask context menu, such as:</span></a>
<a class="sourceLine" id="cb432-4" title="4"><span class="co">//           -setting a breakpoint in one or more tasks</span></a>
<a class="sourceLine" id="cb432-5" title="5"><span class="co">//           -enabling/disabling one task, etc</span></a>
<a class="sourceLine" id="cb432-6" title="6"><span class="dt">void</span> tasks() {</a>
<a class="sourceLine" id="cb432-7" title="7">   gROOT-&gt;ProcessLine(<span class="st">".L MyTasks.cxx+"</span>);</a>
<a class="sourceLine" id="cb432-8" title="8"></a>
<a class="sourceLine" id="cb432-9" title="9">   TTask *run = <span class="kw">new</span> MyRun(<span class="st">"run"</span>,<span class="st">"Process one run"</span>);</a>
<a class="sourceLine" id="cb432-10" title="10">   TTask *event = <span class="kw">new</span> MyEvent(<span class="st">"event"</span>,<span class="st">"Process one event"</span>);</a>
<a class="sourceLine" id="cb432-11" title="11">   TTask *geomInit = <span class="kw">new</span> MyGeomInit(<span class="st">"geomInit"</span>,</a>
<a class="sourceLine" id="cb432-12" title="12">                         <span class="st">"Geometry Initialisation"</span>);</a>
<a class="sourceLine" id="cb432-13" title="13">   TTask *matInit    = <span class="kw">new</span> MyMaterialInit(<span class="st">"matInit"</span>,</a>
<a class="sourceLine" id="cb432-14" title="14">                         <span class="st">"MaterialsInitialisation"</span>);</a>
<a class="sourceLine" id="cb432-15" title="15">   TTask *tracker = <span class="kw">new</span> MyTracker(<span class="st">"tracker"</span>,<span class="st">"Tracker manager"</span>);</a>
<a class="sourceLine" id="cb432-16" title="16">   TTask *tpc     = <span class="kw">new</span> MyRecTPC(<span class="st">"tpc"</span>,<span class="st">"TPC Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-17" title="17">   TTask *its     = <span class="kw">new</span> MyRecITS(<span class="st">"its"</span>,<span class="st">"ITS Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-18" title="18">   TTask *muon    = <span class="kw">new</span> MyRecMUON(<span class="st">"muon"</span>,<span class="st">"MUON Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-19" title="19">   TTask *phos    = <span class="kw">new</span> MyRecPHOS(<span class="st">"phos"</span>,<span class="st">"PHOS Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-20" title="20">   TTask *rich    = <span class="kw">new</span> MyRecRICH(<span class="st">"rich"</span>,<span class="st">"RICH Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-21" title="21">   TTask *trd     = <span class="kw">new</span> MyRecTRD(<span class="st">"trd"</span>,<span class="st">"TRD Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-22" title="22">   TTask *global  = <span class="kw">new</span> MyRecGlobal(<span class="st">"global"</span>,<span class="st">"Global Reconstruction"</span>);</a>
<a class="sourceLine" id="cb432-23" title="23"></a>
<a class="sourceLine" id="cb432-24" title="24">   <span class="co">// Create a hierarchy by adding sub tasks</span></a>
<a class="sourceLine" id="cb432-25" title="25">   run-&gt;Add(geomInit);</a>
<a class="sourceLine" id="cb432-26" title="26">   run-&gt;Add(matInit);</a>
<a class="sourceLine" id="cb432-27" title="27">   run-&gt;Add(event);</a>
<a class="sourceLine" id="cb432-28" title="28">   event-&gt;Add(tracker);</a>
<a class="sourceLine" id="cb432-29" title="29">   event-&gt;Add(global);</a>
<a class="sourceLine" id="cb432-30" title="30">   tracker-&gt;Add(tpc);</a>
<a class="sourceLine" id="cb432-31" title="31">   tracker-&gt;Add(its);</a>
<a class="sourceLine" id="cb432-32" title="32">   tracker-&gt;Add(muon);</a>
<a class="sourceLine" id="cb432-33" title="33">   tracker-&gt;Add(phos);</a>
<a class="sourceLine" id="cb432-34" title="34">   tracker-&gt;Add(rich);</a>
<a class="sourceLine" id="cb432-35" title="35">   tracker-&gt;Add(trd);</a>
<a class="sourceLine" id="cb432-36" title="36"></a>
<a class="sourceLine" id="cb432-37" title="37">   <span class="co">// Add the top level task</span></a>
<a class="sourceLine" id="cb432-38" title="38">   gROOT-&gt;GetListOfTasks()-&gt;Add(run);</a>
<a class="sourceLine" id="cb432-39" title="39"></a>
<a class="sourceLine" id="cb432-40" title="40">   <span class="co">// Add the task to the browser</span></a>
<a class="sourceLine" id="cb432-41" title="41">   gROOT-&gt;GetListOfBrowsables()-&gt;Add(run);</a>
<a class="sourceLine" id="cb432-42" title="42">   <span class="kw">new</span> TBrowser;</a>
<a class="sourceLine" id="cb432-43" title="43">}</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000E5.png" alt="Tasks in the ROOT browser"><figcaption>Tasks in the ROOT browser</figcaption>
</figure>
<p>Note that the first line loads the class definitions in <code>MyTasks.cxx</code> with ACLiC. ACLiC builds a shared library and adds the classes to the Cling dictionary. See “Adding a Class with ACLiC”.</p>
<p>To execute a <strong><code>TTask</code></strong>, you call the <code>ExecuteTask</code> method. <code>ExecuteTask</code> will recursively call:</p>
<ul>
<li><p>the <code>TTask::Exec</code>method of the derived class;</p></li>
<li><p>the <code>TTask::ExecuteTasks</code> to execute for each task the list of its subtasks;</p></li>
</ul>
<p>If the top level task is added to the list of ROOT browsable objects,
 the tree of tasks can be seen in the ROOT browser. To add it to the 
browser, get the list of browsable objects first and add it to the 
collection.</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb433-1" title="1">   gROOT-&gt;GetListOfBrowsables()-&gt;Add(run);</a></code></pre></div>
<p>The first parameter of the <code>Add</code> method is a pointer to a <strong><code>TTask</code></strong>, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.</p>
<p>After executing, the script above the browser will look like in this figure.</p>
<h2 id="execute-and-debug-tasks"><span class="header-section-number">10.5</span> Execute and Debug Tasks</h2>
<p>The browser can be used to start a task, set break points at the 
beginning of a task or when the task has completed. At a breakpoint, 
data structures generated by the execution up this point may be 
inspected asynchronously and then the execution can be resumed by 
selecting the “<code>Continue</code>” function of a task.</p>
<p>A task may be active or inactive (controlled by <code>TTask::SetActive</code>).
 When a task is inactive, its sub tasks are not executed. A task tree 
may be made persistent, saving the status of all the tasks.</p>
<h1 id="inputoutput"><span class="header-section-number">11</span> Input/Output</h1>
<p></p>
<p>This chapter covers the saving and reading of objects to and from 
ROOT files. It begins with an explanation of the physical layout of a 
ROOT file. It includes a discussion on compression, and file recovery. 
Then we explain the logical file, the class <strong><code>TFile</code></strong> and its methods. We show how to navigate in a file, how to save objects and read them back. We also include a discussion on <code>Streamers</code>. <code>Streamers</code>
 are the methods responsible to capture an objects current state to save
 it to disk or send it over the network. At the end of the chapter is a 
discussion on the two specialized ROOT files: <strong><code>TNetFile</code></strong> and <strong><code>TWebFile</code></strong>.</p>
<h2 id="the-physical-layout-of-root-files"><span class="header-section-number">11.1</span> The Physical Layout of ROOT Files</h2>
<p>A ROOT file is like a UNIX file directory. It can contain directories
 and objects organized in unlimited number of levels. It also is stored 
in machine independent format (ASCII, IEEE floating point, Big Endian 
byte ordering). To look at the physical layout of a ROOT file, we first 
create one. This example creates a ROOT file and 15 histograms, fills 
each histogram with 1000 entries from a Gaussian distribution, and 
writes them to the file.</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb434-1" title="1">{</a>
<a class="sourceLine" id="cb434-2" title="2">   <span class="dt">char</span> name[<span class="dv">10</span>], title[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb434-3" title="3">   TObjArray Hlist(<span class="dv">0</span>);      <span class="co">// create an array of Histograms</span></a>
<a class="sourceLine" id="cb434-4" title="4">   TH1F* h;                 <span class="co">// create a pointer to a histogram</span></a>
<a class="sourceLine" id="cb434-5" title="5">   <span class="co">// make and fill 15 histograms and add them to the object array</span></a>
<a class="sourceLine" id="cb434-6" title="6">   <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">15</span>; i++) {</a>
<a class="sourceLine" id="cb434-7" title="7">      sprintf(name,<span class="st">"h</span><span class="sc">%d</span><span class="st">"</span>,i);</a>
<a class="sourceLine" id="cb434-8" title="8">      sprintf(title,<span class="st">"histo nr:</span><span class="sc">%d</span><span class="st">"</span>,i);</a>
<a class="sourceLine" id="cb434-9" title="9">      h = <span class="kw">new</span> TH1F(name,title,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb434-10" title="10">      Hlist.Add(h);</a>
<a class="sourceLine" id="cb434-11" title="11">      h-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb434-12" title="12">   }</a>
<a class="sourceLine" id="cb434-13" title="13">   <span class="co">// open a file and write the array to the file</span></a>
<a class="sourceLine" id="cb434-14" title="14">   TFile f(<span class="st">"demo.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb434-15" title="15">   Hlist.Write();</a>
<a class="sourceLine" id="cb434-16" title="16">   f.Close();</a>
<a class="sourceLine" id="cb434-17" title="17">}</a></code></pre></div>
<p>The example begins with a call to the <strong><code>TFile</code></strong> constructor. This class is describing the ROOT file (that has the extension “<code>.root</code>”). In the next section, we will cover <strong><code>TFile</code></strong> in details. The last line of the example closes the file. To view its contents we need to open it again, and to create a <strong><code>TBrowser</code></strong> object by:</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb435-1" title="1">root[] TFile f(<span class="st">"demo.root"</span>)</a>
<a class="sourceLine" id="cb435-2" title="2">root[] TBrowser browser;</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000E6.png" alt="The browser with 15 created histograms"><figcaption>The browser with 15 created histograms</figcaption>
</figure>
<p>You can check if the file is correctly opened by:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb436-1" title="1">   TFile f(<span class="st">"demo.root"</span>);</a>
<a class="sourceLine" id="cb436-2" title="2">   <span class="cf">if</span> (f.IsZombie()) {</a>
<a class="sourceLine" id="cb436-3" title="3">      cout &lt;&lt; <span class="st">"Error opening file"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb436-4" title="4">      exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb436-5" title="5">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb436-6" title="6">      ...</a>
<a class="sourceLine" id="cb436-7" title="7">   }</a></code></pre></div>
<p>Once we have the <code>TFile</code> object, we can call the <strong><code>TFile::Map()</code></strong>
 method to view the physical layout. The output prints the date/time, 
the start record address, the number of bytes in the record, the class 
name of the record and the compression factor.</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb437-1" title="1">root[] f.Map()</a>
<a class="sourceLine" id="cb437-2" title="2"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">100</span>    N=<span class="dv">114</span>       TFile</a>
<a class="sourceLine" id="cb437-3" title="3"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">214</span>    N=<span class="dv">413</span>       TH1F           CX =  <span class="fl">2.35</span></a>
<a class="sourceLine" id="cb437-4" title="4"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">627</span>    N=<span class="dv">410</span>       TH1F           CX =  <span class="fl">2.36</span></a>
<a class="sourceLine" id="cb437-5" title="5"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">1037</span>   N=<span class="dv">396</span>       TH1F           CX =  <span class="fl">2.45</span></a>
<a class="sourceLine" id="cb437-6" title="6"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">1433</span>   N=<span class="dv">400</span>       TH1F           CX =  <span class="fl">2.42</span></a>
<a class="sourceLine" id="cb437-7" title="7"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">1833</span>   N=<span class="dv">402</span>       TH1F           CX =  <span class="fl">2.41</span></a>
<a class="sourceLine" id="cb437-8" title="8"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">2235</span>   N=<span class="dv">416</span>       TH1F           CX =  <span class="fl">2.33</span></a>
<a class="sourceLine" id="cb437-9" title="9"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">2651</span>   N=<span class="dv">406</span>       TH1F           CX =  <span class="fl">2.39</span></a>
<a class="sourceLine" id="cb437-10" title="10"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">3057</span>   N=<span class="dv">403</span>       TH1F           CX =  <span class="fl">2.40</span></a>
<a class="sourceLine" id="cb437-11" title="11"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">3460</span>   N=<span class="dv">411</span>       TH1F           CX =  <span class="fl">2.36</span></a>
<a class="sourceLine" id="cb437-12" title="12"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">3871</span>   N=<span class="dv">400</span>       TH1F           CX =  <span class="fl">2.42</span></a>
<a class="sourceLine" id="cb437-13" title="13"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">4271</span>   N=<span class="dv">409</span>       TH1F           CX =  <span class="fl">2.38</span></a>
<a class="sourceLine" id="cb437-14" title="14"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">4680</span>   N=<span class="dv">409</span>       TH1F           CX =  <span class="fl">2.38</span></a>
<a class="sourceLine" id="cb437-15" title="15"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">5089</span>   N=<span class="dv">420</span>       TH1F           CX =  <span class="fl">2.32</span></a>
<a class="sourceLine" id="cb437-16" title="16"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">5509</span>   N=<span class="dv">406</span>       TH1F           CX =  <span class="fl">2.40</span></a>
<a class="sourceLine" id="cb437-17" title="17"><span class="dv">20051208</span>/<span class="dv">124502</span>  At:<span class="dv">5915</span>   N=<span class="dv">405</span>       TH1F           CX =  <span class="fl">2.40</span></a>
<a class="sourceLine" id="cb437-18" title="18"><span class="dv">20051208</span>/<span class="dv">124503</span>  At:<span class="dv">6320</span>   N=<span class="dv">3052</span>      StreamerInfo   CX =  <span class="fl">3.16</span></a>
<a class="sourceLine" id="cb437-19" title="19"><span class="dv">20051208</span>/<span class="dv">124503</span>  At:<span class="dv">9372</span>   N=<span class="dv">732</span>       KeysList</a>
<a class="sourceLine" id="cb437-20" title="20"><span class="dv">20051208</span>/<span class="dv">124503</span>  At:<span class="dv">10104</span>  N=<span class="dv">53</span>        FreeSegments</a>
<a class="sourceLine" id="cb437-21" title="21"><span class="dv">20051208</span>/<span class="dv">124503</span>  At:<span class="dv">10157</span>  N=<span class="dv">1</span>         END</a></code></pre></div>
<p>Here we see the fifteen histograms (<strong><code>TH1F</code></strong>’s) with the first one starting at byte 148. We also see an entry <strong><code>TFile</code></strong>. You may notice that the first entry starts at byte 100. The first 100 bytes are taken by the file header.</p>
<h3 id="the-file-header"><span class="header-section-number">11.1.1</span> The File Header</h3>
<p>This table shows the file header information. When fVersion is 
greater than 1000000, the file is a large file (&gt; 2 GB) and the 
offsets will be 8 bytes long. The location in brackets are the location 
in the case of a large file.</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 24%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td>Byte</td>
<td>Value Name</td>
<td>Description</td>
</tr>
<tr class="even">
<td>1 <code>-&gt;</code> 4</td>
<td>“<code>root</code>”</td>
<td>Root file identifier</td>
</tr>
<tr class="odd">
<td>5 <code>-&gt;</code> 8</td>
<td><code>fVersion</code></td>
<td>File format version</td>
</tr>
<tr class="even">
<td>9 <code>-&gt;</code> 12</td>
<td><code>fBEGIN</code></td>
<td>Pointer to first data record</td>
</tr>
<tr class="odd">
<td>13 <code>-&gt;</code> 16 [13-&gt;20]</td>
<td><code>fEND</code></td>
<td>Pointer to first free word at the EOF</td>
</tr>
<tr class="even">
<td>17 <code>-&gt;</code> 20 [21-&gt;28]</td>
<td><code>fSeekFree</code></td>
<td>Pointer to FREE data record</td>
</tr>
<tr class="odd">
<td>21 <code>-&gt;</code> 24 [29-&gt;32]</td>
<td><code>fNbytesFree</code></td>
<td>Number of bytes in FREE data record</td>
</tr>
<tr class="even">
<td>25 <code>-&gt;</code> 28 [33-&gt;36]</td>
<td><code>nfree</code></td>
<td>Number of free data records</td>
</tr>
<tr class="odd">
<td>29 <code>-&gt;</code> 32 [37-&gt;40]</td>
<td><code>fNbytesName</code></td>
<td>Number of bytes in <strong><code>TNamed</code></strong> at creation time</td>
</tr>
<tr class="even">
<td>33 <code>-&gt;</code> 33 [41-&gt;41]</td>
<td><code>fUnits</code></td>
<td>Number of bytes for file pointers</td>
</tr>
<tr class="odd">
<td>34 <code>-&gt;</code> 37 [42-&gt;45]</td>
<td><code>fCompress</code></td>
<td>Zip compression level</td>
</tr>
<tr class="even">
<td>38 <code>-&gt;</code> 41 [46-&gt;53]</td>
<td><code>fSeekInfo</code></td>
<td>Pointer to <strong><code>TStreamerInfo</code></strong> record</td>
</tr>
<tr class="odd">
<td>42 <code>-&gt;</code> 45 [54-&gt;57]</td>
<td><code>fNBytesInfo</code></td>
<td>Number of bytes in <strong><code>TStreamerInfo</code></strong> record</td>
</tr>
<tr class="even">
<td>46 <code>-&gt;</code> 63 [58-&gt;75]</td>
<td><code>fCompress</code></td>
<td>Universal Unique ID</td>
</tr>
</tbody>
</table>
<p>The first four bytes of the file header contain the string “root” 
which identifies a file as a ROOT file. Because of this identifier, ROOT
 is not dependent on the “<code>.root</code>” extension. It is still a good idea to use the extension, just for us to recognize them easier. The <code>nfree</code> and value is the number of free records. This variable along with <code>FNBytesFree</code>
 keeps track of the free space in terms of records and bytes. This count
 also includes the deleted records, which are available again.</p>
<h3 id="the-top-directory-description"><span class="header-section-number">11.1.2</span> The Top Directory Description</h3>
<p>The 84 bytes after the file header contain the top directory 
description, including the name, the date and time it was created, and 
the date and time of the last modification.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb438-1" title="1"><span class="dv">20010404</span>/<span class="er">092347</span>  At:<span class="dv">64</span>        N=<span class="dv">84</span>        TFile</a></code></pre></div>
<h3 id="the-histogram-records"><span class="header-section-number">11.1.3</span> The Histogram Records</h3>
<p>What follows are the 15 histograms, in records of variable length.</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb439-1" title="1"><span class="dv">20010404</span>/<span class="er">092347</span>  At:<span class="dv">148</span>       N=<span class="dv">380</span>       TH1F           CX =  <span class="fl">2.49</span></a>
<a class="sourceLine" id="cb439-2" title="2"><span class="dv">20010404</span>/<span class="er">092347</span>  At:<span class="dv">528</span>       N=<span class="dv">377</span>       TH1F           CX =  <span class="fl">2.51</span></a></code></pre></div>
<p>The first 4 bytes of each record is an integer holding the number of 
bytes in this record. A negative number flags the record as deleted, and
 makes the space available for recycling in the next writing. The rest 
of bytes in the header contain all the information to identify uniquely a
 data block on the file. It is followed by the object data.</p>
<p>The next table explains the values in each individual record. If the 
key is located past the 32 bit file limit (&gt; 2 GB) then some fields 
will be 8 bytes instead of 4 bytes (values between the brackets):</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 25%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td>Byte</td>
<td>Value Name</td>
<td>Description</td>
</tr>
<tr class="even">
<td>1 <code>-&gt;</code> 4</td>
<td><code>Nbytes</code></td>
<td>Length of compressed object (in bytes)</td>
</tr>
<tr class="odd">
<td>5 <code>-&gt;</code> 6</td>
<td><code>Version</code></td>
<td><strong><code>TKey</code></strong> version identifier</td>
</tr>
<tr class="even">
<td>7 <code>-&gt;</code> 10</td>
<td><code>ObjLen</code></td>
<td>Length of uncompressed object</td>
</tr>
<tr class="odd">
<td>11 <code>-&gt;</code> 14</td>
<td><code>Datime</code></td>
<td>Date and time when object was written to file</td>
</tr>
<tr class="even">
<td>15 <code>-&gt;</code> 16</td>
<td><code>KeyLen</code></td>
<td>Length of the key structure (in bytes)</td>
</tr>
<tr class="odd">
<td>17 <code>-&gt;</code> 18</td>
<td><code>Cycle</code></td>
<td>Cycle of key</td>
</tr>
<tr class="even">
<td>19 <code>-&gt;</code> 22 [19-&gt;26]</td>
<td><code>SeekKey</code></td>
<td>Pointer to record itself (consistency check)</td>
</tr>
<tr class="odd">
<td>23 <code>-&gt;</code> 26 [27-&gt;34]</td>
<td><code>SeekPdir</code></td>
<td>Pointer to directory header</td>
</tr>
<tr class="even">
<td>27 <code>-&gt;</code> 27 [35-&gt;35]</td>
<td><code>lname</code></td>
<td>Number of bytes in the class name</td>
</tr>
<tr class="odd">
<td>28 <code>-&gt;</code> … [36-&gt;..</td>
<td>.] | <code>ClassName</code></td>
<td>| Object Class Name</td>
</tr>
<tr class="even">
<td>… <code>-&gt;</code> …</td>
<td>| <code>lname</code></td>
<td>| Number of bytes in the object name</td>
</tr>
<tr class="odd">
<td>… <code>-&gt;</code> …</td>
<td>| <code>Name</code></td>
<td>| <code>lName</code> bytes with the name of the object</td>
</tr>
<tr class="even">
<td>… <code>-&gt;</code> …</td>
<td>| <code>lTitle</code></td>
<td>| Number of bytes in the object title</td>
</tr>
<tr class="odd">
<td>… <code>-&gt;</code> …</td>
<td>| <code>Title</code></td>
<td>| Title of the object</td>
</tr>
<tr class="even">
<td>… <code>-&gt;</code> …</td>
<td>| <code>DATA</code></td>
<td>| Data bytes associated to the object</td>
</tr>
</tbody>
</table>
<p>You see a reference to <strong><code>TKey</code></strong>. It is explained in detail in the next section.</p>
<h3 id="the-class-description-list-streamerinfo-list"><span class="header-section-number">11.1.4</span> The Class Description List (StreamerInfo List)</h3>
<p>The histogram records are followed by the <code>StreamerInfo</code> list of class descriptions. The list contains the description of each class that has been written to file.</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb440-1" title="1"><span class="dv">20010404</span>/<span class="er">092347</span>  At:<span class="dv">5854</span>   N=<span class="dv">2390</span>   StreamerInfo   CX =  <span class="fl">3.41</span></a></code></pre></div>
<p>The class description is recursive, because to fully describe a 
class, its ancestors and object data members have to be described also. 
In <code>demo.root</code>, the class description list contains the description for:</p>
<ul>
<li><p><strong><code>TH1F</code></strong></p></li>
<li><p>all classes in the <strong><code>TH1F</code></strong> inheritance tree</p></li>
<li><p>all classes of the object data members</p></li>
<li><p>all classes in the object data members’ inheritance tree.</p></li>
</ul>
<p>This description is implemented by the <strong><code>TStreamerInfo</code></strong> class<code>,</code> and is often referred to as simply <code>StreamerInfo</code>. You can print a file’s <code>StreamerInfo</code>list with the <code>TFile::ShowStreamerInfo</code> method. Below is an example of the output. Only the first line of each class description is shown. The <code>demo.root</code> example contains only <strong><code>TH1F</code></strong> objects. Here we see the recursive nature of the class description; it contains the <code>StreamerInfo</code>of all the classes needed to describe <strong><code>TH1F</code></strong>.</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb441-1" title="1">root[] f.ShowStreamerInfo()</a>
<a class="sourceLine" id="cb441-2" title="2">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TH1F, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-3" title="3">  BASE     TH1         offset=<span class="dv">0</span> type= <span class="dv">0</span> <span class="dv">1</span>-Dim histogram base <span class="kw">class</span></a>
<a class="sourceLine" id="cb441-4" title="4">  BASE     TArrayF     offset=<span class="dv">0</span> type= <span class="dv">0</span> Array of floats</a>
<a class="sourceLine" id="cb441-5" title="5"></a>
<a class="sourceLine" id="cb441-6" title="6">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TH1, version=<span class="dv">3</span></a>
<a class="sourceLine" id="cb441-7" title="7">  BASE     TNamed      offset=<span class="dv">0</span> type=<span class="dv">67</span> The basis <span class="cf">for</span> named object(name,title)</a>
<a class="sourceLine" id="cb441-8" title="8">  BASE     TAttLine    offset=<span class="dv">0</span> type=<span class="dv">0</span>  Line attributes</a>
<a class="sourceLine" id="cb441-9" title="9">  BASE     TAttFill    offset=<span class="dv">0</span> type=<span class="dv">0</span>  Fill area attributes</a>
<a class="sourceLine" id="cb441-10" title="10">  BASE     TAttMarker  offset=<span class="dv">0</span> type=<span class="dv">0</span>  Marker attributes</a>
<a class="sourceLine" id="cb441-11" title="11">  <span class="dt">Int_t</span>    fNcells     offset=<span class="dv">0</span> type=<span class="dv">3</span>  number bins(<span class="dv">1</span><span class="er">D</span>),cells(<span class="dv">2</span><span class="er">D</span>)+U/Overflows</a>
<a class="sourceLine" id="cb441-12" title="12">  TAxis    fXaxis      offset=<span class="dv">0</span> type=<span class="dv">61</span> X axis descriptor</a>
<a class="sourceLine" id="cb441-13" title="13">  TAxis    fYaxis      offset=<span class="dv">0</span> type=<span class="dv">61</span> Y axis descriptor</a>
<a class="sourceLine" id="cb441-14" title="14">  TAxis    fZaxis      offset=<span class="dv">0</span> type=<span class="dv">61</span> Z axis descriptor</a>
<a class="sourceLine" id="cb441-15" title="15">  <span class="dt">Short_t</span>  fBarOffset  offset=<span class="dv">0</span> type=<span class="dv">2</span>  (<span class="dv">1000</span>*offset) <span class="cf">for</span> barcharts <span class="kw">or</span> legos</a>
<a class="sourceLine" id="cb441-16" title="16">  <span class="dt">Short_t</span>  fBarWidth   offset=<span class="dv">0</span> type=<span class="dv">2</span>  (<span class="dv">1000</span>*width) <span class="cf">for</span> bar charts <span class="kw">or</span> legos</a>
<a class="sourceLine" id="cb441-17" title="17">  <span class="dt">Stat_t</span>   fEntries    offset=<span class="dv">0</span> type=<span class="dv">8</span>  Number of entries<span class="co">//continued...</span></a>
<a class="sourceLine" id="cb441-18" title="18">  <span class="dt">Stat_t</span>   fTsumw      offset=<span class="dv">0</span> type=<span class="dv">8</span>  Total Sum of weights</a>
<a class="sourceLine" id="cb441-19" title="19">  <span class="dt">Stat_t</span>   fTsumw2     offset=<span class="dv">0</span> type=<span class="dv">8</span>  Total Sum of squares of weights</a>
<a class="sourceLine" id="cb441-20" title="20">  <span class="dt">Stat_t</span>   fTsumwx     offset=<span class="dv">0</span> type=<span class="dv">8</span>  Total Sum of weight*X</a>
<a class="sourceLine" id="cb441-21" title="21">  <span class="dt">Stat_t</span>   fTsumwx2    offset=<span class="dv">0</span> type=<span class="dv">8</span>  Total Sum of weight*X*X</a>
<a class="sourceLine" id="cb441-22" title="22">  <span class="dt">Double_t</span> fMaximum    offset=<span class="dv">0</span> type=<span class="dv">8</span>  Maximum value <span class="cf">for</span> plotting</a>
<a class="sourceLine" id="cb441-23" title="23">  <span class="dt">Double_t</span> fMinimum    offset=<span class="dv">0</span> type=<span class="dv">8</span>  Minimum value <span class="cf">for</span> plotting</a>
<a class="sourceLine" id="cb441-24" title="24">  <span class="dt">Double_t</span> fNormFactor offset=<span class="dv">0</span> type=<span class="dv">8</span>  Normalization factor</a>
<a class="sourceLine" id="cb441-25" title="25">  TArrayD  fContour    offset=<span class="dv">0</span> type=<span class="dv">62</span> Array to display contour levels</a>
<a class="sourceLine" id="cb441-26" title="26">  TArrayD  fSumw2      offset=<span class="dv">0</span> type=<span class="dv">62</span> Array of sum of squares of weights</a>
<a class="sourceLine" id="cb441-27" title="27">  TString  fOption     offset=<span class="dv">0</span> type=<span class="dv">65</span> histogram options</a>
<a class="sourceLine" id="cb441-28" title="28">  TList*   fFunctions  offset=<span class="dv">0</span> type=<span class="dv">63</span> -&gt;Pointer to list of functions(fits,user)</a>
<a class="sourceLine" id="cb441-29" title="29"></a>
<a class="sourceLine" id="cb441-30" title="30">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TNamed, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-31" title="31">...</a>
<a class="sourceLine" id="cb441-32" title="32">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TAttLine, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-33" title="33">...</a>
<a class="sourceLine" id="cb441-34" title="34">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TAttFill, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-35" title="35">...</a>
<a class="sourceLine" id="cb441-36" title="36">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TAttMarker, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-37" title="37">...</a>
<a class="sourceLine" id="cb441-38" title="38">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TArrayF, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-39" title="39">...</a>
<a class="sourceLine" id="cb441-40" title="40">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TArray, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb441-41" title="41">...</a>
<a class="sourceLine" id="cb441-42" title="42">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TAxis, version=<span class="dv">6</span></a>
<a class="sourceLine" id="cb441-43" title="43">...</a>
<a class="sourceLine" id="cb441-44" title="44">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TAttAxis, version=<span class="dv">4</span></a>
<a class="sourceLine" id="cb441-45" title="45">...</a></code></pre></div>
<p>ROOT allows a class to have multiple versions, and each version has its own description in form of a <code>StreamerInfo</code>. Above you see the class name and version number. The <code>StreamerInfo</code>list
 has only one description for each class/version combination it 
encountered. The file can have multiple versions of the same class, for 
example objects of old and new versions of a class can be in the same 
file. The <code>StreamerInfo</code>is described in detail in the section on Streamers.</p>
<h3 id="the-list-of-keys-and-the-list-of-free-blocks"><span class="header-section-number">11.1.5</span> The List of Keys and the List of Free Blocks</h3>
<p>The last three entries on the output of <code>TFile::Map()</code> are
 the list of keys, the list of free segments, and the address where the 
data ends.. When a file is closed, it writes a linked list of keys at 
the end of the file. This is what we see in the third to the last entry.
 In our example, the list of keys is stored in 732 bytes beginning at 
byte# 8244.</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb442-1" title="1"><span class="dv">20010404</span>/<span class="er">092347</span>    At:<span class="dv">8244</span>      N=<span class="dv">732</span>       KeysList</a>
<a class="sourceLine" id="cb442-2" title="2"><span class="dv">20010404</span>/<span class="er">092347</span>    At:<span class="dv">8976</span>      N=<span class="dv">53</span>        FreeSegments</a>
<a class="sourceLine" id="cb442-3" title="3"><span class="dv">20010404</span>/<span class="er">092347</span>    At:<span class="dv">9029</span>      N=<span class="dv">1</span>         END</a></code></pre></div>
<p>The second to last entry is a list of free segments. In our case, 
this starts 8976 and is not very long, only 53 bytes, since we have not 
deleted any objects. The last entry is the address of the last byte in 
the file.</p>
<h3 id="file-recovery"><span class="header-section-number">11.1.6</span> File Recovery</h3>
<p>A file may become corrupted or it may be impossible to write it to 
disk and close it properly. For example if the file is too large and 
exceeds the disk quota, or the job crashes or a batch job reaches its 
time limit before the file can be closed. In these cases, it is 
imperative to recover and retain as much information as possible. ROOT 
provides an intelligent and elegant file recovery mechanism using the 
redundant directory information in the record header.</p>
<p>If a file that has been not properly closed is opened again, it is 
scanned and rebuilt according to the information in the record header. 
The recovery algorithm reads the file and creates the saved objects in 
memory according to the header information. It then rebuilds the 
directory and file structure. If the file is opened in write mode, the 
recovery makes the correction on disk when the file is closed; however 
if the file is opened in read mode, the correction can not be written to
 disk. You can also explicitly invoke the recovery procedure by calling 
the <code>TFile::Recover()</code> method. You can recover the directory 
structure, but you cannot save what you recovered to the file on disk. 
In the following example, we interrupted and aborted the previous ROOT 
session, causing the file not to be closed. When we start a new session 
and attempt to open the file, it gives us an explanation and status on 
the recovery attempt.</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb443-1" title="1">root[] TFile f(<span class="st">"demo.root"</span>)</a>
<a class="sourceLine" id="cb443-2" title="2">Warning in &lt;TFile::TFile&gt;: file demo.root probably <span class="kw">not</span> closed, trying to recover successfully recovered <span class="dv">15</span> keys</a></code></pre></div>
<h2 id="the-logical-root-file-tfile-and-tkey"><span class="header-section-number">11.2</span> The Logical ROOT File: TFile and TKey</h2>
<p>We saw that the <code>TFile::Map()</code> method reads the file 
sequentially and prints information about each record while scanning the
 file. It is not feasible to support only sequential access and hence 
ROOT provides random or direct access, i.e.&nbsp;reading a specified 
object at a time. To do so, <code>TFile</code> keeps a list of <strong><code>TKeys</code></strong>, which is essentially an index to the objects in the file. The <strong><code>TKey</code></strong>
 class describes the record headers of objects in the file. For example,
 we can get the list of keys and print them. To find a specific object 
on the file we can use the <strong><code>TFile::Get()</code> method.</strong></p>
<div class="sourceCode" id="cb444"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb444-1" title="1">root[] TFile f(<span class="st">"demo.root"</span>)</a>
<a class="sourceLine" id="cb444-2" title="2">root[] f.GetListOfKeys()-&gt;Print()</a>
<a class="sourceLine" id="cb444-3" title="3">TKey Name = h0, Title = histo nr:<span class="dv">0</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-4" title="4">TKey Name = h1, Title = histo nr:<span class="dv">1</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-5" title="5">TKey Name = h2, Title = histo nr:<span class="dv">2</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-6" title="6">TKey Name = h3, Title = histo nr:<span class="dv">3</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-7" title="7">TKey Name = h4, Title = histo nr:<span class="dv">4</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-8" title="8">TKey Name = h5, Title = histo nr:<span class="dv">5</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-9" title="9">TKey Name = h6, Title = histo nr:<span class="dv">6</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-10" title="10">TKey Name = h7, Title = histo nr:<span class="dv">7</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-11" title="11">TKey Name = h8, Title = histo nr:<span class="dv">8</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-12" title="12">TKey Name = h9, Title = histo nr:<span class="dv">9</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-13" title="13">TKey Name = h10, Title = histo nr:<span class="dv">10</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-14" title="14">TKey Name = h11, Title = histo nr:<span class="dv">11</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-15" title="15">TKey Name = h12, Title = histo nr:<span class="dv">12</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-16" title="16">TKey Name = h13, Title = histo nr:<span class="dv">13</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-17" title="17">TKey Name = h14, Title = histo nr:<span class="dv">14</span>, Cycle = <span class="dv">1</span></a>
<a class="sourceLine" id="cb444-18" title="18">root[] TH1F *h9 = (TH1F*)f.Get(<span class="st">"h9"</span>);</a></code></pre></div>
<p>The <code>TFile::Get()</code> finds the <strong><code>TKey</code></strong> object with name “<code>h9</code>”. Using the <strong><code>TKey</code></strong> info it will import in memory the object in the file at the file address #3352 (see the output from the <code>TFile::Map</code> above). This is done by the <code>Streamer</code> method that is covered in detail in a later section. Since the keys are available in a <strong><code>TList</code></strong> of <strong><code>TKeys</code> we can iterate over the list of keys:</strong></p>
<div class="sourceCode" id="cb445"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb445-1" title="1">{</a>
<a class="sourceLine" id="cb445-2" title="2">   TFile f(<span class="st">"demo.root"</span>);</a>
<a class="sourceLine" id="cb445-3" title="3">   TIter next(f.GetListOfKeys());</a>
<a class="sourceLine" id="cb445-4" title="4">   TKey *key;</a>
<a class="sourceLine" id="cb445-5" title="5">   <span class="cf">while</span> ((key=(TKey*)next())) {</a>
<a class="sourceLine" id="cb445-6" title="6">      printf(<span class="st">"key: </span><span class="sc">%s</span><span class="st"> points to an object of class: </span><span class="sc">%s</span><span class="st"> at </span><span class="sc">%d</span><span class="st">n"</span>,</a>
<a class="sourceLine" id="cb445-7" title="7">      key-&gt;GetName(),</a>
<a class="sourceLine" id="cb445-8" title="8">      key-&gt;GetClassName(),key-&gt;GetSeekKey());</a>
<a class="sourceLine" id="cb445-9" title="9">   }</a>
<a class="sourceLine" id="cb445-10" title="10">}</a></code></pre></div>
<p>The output of this script is:</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb446-1" title="1">root[] .x iterate.C</a>
<a class="sourceLine" id="cb446-2" title="2">key: h0 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">150</span></a>
<a class="sourceLine" id="cb446-3" title="3">key: h1 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">503</span></a>
<a class="sourceLine" id="cb446-4" title="4">key: h2 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">854</span></a>
<a class="sourceLine" id="cb446-5" title="5">key: h3 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">1194</span></a>
<a class="sourceLine" id="cb446-6" title="6">key: h4 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">1539</span></a>
<a class="sourceLine" id="cb446-7" title="7">key: h5 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">1882</span></a>
<a class="sourceLine" id="cb446-8" title="8">key: h6 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">2240</span></a>
<a class="sourceLine" id="cb446-9" title="9">key: h7 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">2582</span></a>
<a class="sourceLine" id="cb446-10" title="10">key: h8 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">2937</span></a>
<a class="sourceLine" id="cb446-11" title="11">key: h9 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">3293</span></a>
<a class="sourceLine" id="cb446-12" title="12">key: h10 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">3639</span></a>
<a class="sourceLine" id="cb446-13" title="13">key: h11 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">3986</span></a>
<a class="sourceLine" id="cb446-14" title="14">key: h12 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">4339</span></a>
<a class="sourceLine" id="cb446-15" title="15">key: h13 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">4694</span></a>
<a class="sourceLine" id="cb446-16" title="16">key: h14 points to an object of <span class="kw">class</span>: TH1F at <span class="dv">5038</span></a></code></pre></div>
<p>In addition to the list of keys, <strong><code>TFile</code></strong> also keeps two other lists: <strong><code>TFile</code></strong><code>::fFree</code> is a <strong><code>TList</code></strong>
 of free blocks used to recycle freed up space in the file. ROOT tries 
to find the best free block. If a free block matches the size of the new
 object to be stored, the object is written in the free block and this 
free block is deleted from the list. If not, the first free block bigger
 than the object is used. <code>TFile::fListHead</code> contains a sorted list (<strong><code>TSortedList</code></strong>) of objects in memory. The diagram below illustrates the logical view of the <strong><code>TFile</code></strong> and <strong><code>TKey</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/030000E7.png" alt="ROOT File/Directory/Key description"><figcaption>ROOT File/Directory/Key description</figcaption>
</figure>
<h3 id="viewing-the-logical-file-contents"><span class="header-section-number">11.2.1</span> Viewing the Logical File Contents</h3>
<p><strong><code>TFile</code></strong> is a descendent of <strong><code>TDirectory</code></strong>, which means it behaves like a <strong><code>TDirectory</code></strong>.
 We can list the contents, print the name, and create subdirectories. In
 a ROOT session, you are always in a directory and the directory you are
 in is called the current directory and is stored in the global variable
 <strong><em><code>gDirectory</code></em></strong>. Let us look at a 
more detailed example of a ROOT file and its role as the current 
directory. First, we create a ROOT file by executing a sample script.</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb447-1" title="1">root[] .x <span class="er">$</span>ROOTSYS/tutorials/hsimple.C</a></code></pre></div>
<p>Now you should have <code>hsimple.root</code> in your directory. The 
file was closed by the script so we have to open it again to work with 
it. We open the file with the intent to update it, and list its 
contents.</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb448-1" title="1">root[] TFile f (<span class="st">"hsimple.root"</span>,<span class="st">"UPDATE"</span>)</a>
<a class="sourceLine" id="cb448-2" title="2">root[] f.ls()</a>
<a class="sourceLine" id="cb448-3" title="3">TFile** hsimple.root</a>
<a class="sourceLine" id="cb448-4" title="4">TFile* hsimple.root</a>
<a class="sourceLine" id="cb448-5" title="5">KEY: TH1F hpx;<span class="dv">1</span> This is the px distribution</a>
<a class="sourceLine" id="cb448-6" title="6">KEY: TH2F hpxpy;<span class="dv">1</span> py vs px</a>
<a class="sourceLine" id="cb448-7" title="7">KEY: TProfile hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb448-8" title="8">KEY: TNtuple ntuple;<span class="dv">1</span> Demo ntuple</a></code></pre></div>
<p>It shows the two lines starting with <strong><code>TFile</code></strong> followed by four lines starting with the word “<code>KEY</code>”. The four keys tell us that there are four objects on disk in this file. The syntax of the listing is:</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb449-1" title="1">KEY: &lt;<span class="kw">class</span>&gt; &lt;variable&gt;;&lt;cycle number&gt; &lt;title&gt;</a></code></pre></div>
<p>For example, the first line in the list means there is an object in the file on disk, called <code>hpx</code>. It is of the class <strong><code>TH1F</code></strong> (one-dimensional histogram of floating numbers). The object’s title is “This is the <code>px</code> distribution”. If the line starts with <code>OBJ</code>,
 the object is in memory. The &lt;class&gt; is the name of the ROOT 
class (T-something). The &lt;variable&gt; is the name of the object. The
 cycle number along with the variable name uniquely identifies the 
object. The &lt;title&gt; is the string given in the constructor of the 
object as title.</p>
<figure>
<img src="ROOTUsersGuide_files/030000E8.png" alt="The structure of TFile"><figcaption>The structure of TFile</figcaption>
</figure>
<p>The figure shows a <strong><code>TFile</code></strong> with five objects in the top directory <code>(kObjA;1, kObjA;2, kObjB;1, kObjC;1</code> and <code>kObjD;1)</code>. <code>ObjA</code> is on file twice with two different cycle numbers. It also shows four objects in memory (<code>mObjE</code>, <code>mObjeF</code>, <code>mObjM</code>, <code>mObjL</code>). It also shows several subdirectories.</p>
<h3 id="the-current-directory"><span class="header-section-number">11.2.2</span> The Current Directory</h3>
<p>When you create a <strong><code>TFile</code></strong> object, it 
becomes the current directory. Therefore, the last file to be opened is 
always the current directory. To check your current directory you can 
type:</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb450-1" title="1">root[] gDirectory-&gt;pwd()</a>
<a class="sourceLine" id="cb450-2" title="2">Rint:/</a></code></pre></div>
<p>This means that the current directory is the ROOT session (<code>Rint</code>). When you create a file, and repeat the command the file becomes the current directory.</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb451-1" title="1">root[] TFile f1(<span class="st">"AFile1.root"</span>);</a>
<a class="sourceLine" id="cb451-2" title="2">root[] gDirectory-&gt;pwd()</a>
<a class="sourceLine" id="cb451-3" title="3">AFile1.root:/</a></code></pre></div>
<p>If you create two files, the last becomes the current directory.</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb452-1" title="1">root[] TFile f2(<span class="st">"AFile2.root"</span>);</a>
<a class="sourceLine" id="cb452-2" title="2">root[] gDirectory-&gt;pwd()</a>
<a class="sourceLine" id="cb452-3" title="3">AFile2.root:/</a></code></pre></div>
<p>To switch back to the first file, or to switch to any file in general, you can use the <code>TDirectory::cd</code> method. The next command changes the current directory back to the first file.</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb453-1" title="1">root[] f1.cd();</a>
<a class="sourceLine" id="cb453-2" title="2">root[] gDirectory-&gt;pwd()</a>
<a class="sourceLine" id="cb453-3" title="3">AFile1.root:/</a></code></pre></div>
<p>Note that even if you open the file in “READ” mode, it still becomes the current directory. Cling also offers a shortcut for <code>gDirectory-&gt;pwd()</code> and <code>gDirectory-&gt;ls()</code>, you can type:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb454-1" title="1">root[] .pwd</a>
<a class="sourceLine" id="cb454-2" title="2">AFile1.root:/</a>
<a class="sourceLine" id="cb454-3" title="3">root[] .ls</a>
<a class="sourceLine" id="cb454-4" title="4">TFile**        AFile1.root</a>
<a class="sourceLine" id="cb454-5" title="5">TFile*         AFile1.root</a></code></pre></div>
<p>To return to the home directory where we were before:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb455-1" title="1">root[] gROOT-&gt;cd()</a>
<a class="sourceLine" id="cb455-2" title="2">(<span class="dt">unsigned</span> <span class="dt">char</span>)<span class="dv">1</span></a>
<a class="sourceLine" id="cb455-3" title="3">root[] gROOT-&gt;pwd()</a>
<a class="sourceLine" id="cb455-4" title="4">Rint:/</a></code></pre></div>
<h3 id="objects-in-memory-and-objects-on-disk"><span class="header-section-number">11.2.3</span> Objects in Memory and Objects on Disk</h3>
<p>The <code>TFile::ls()</code> method has an option to list the objects on disk (“<code>-d</code>”) or the objects in memory (“<code>-m</code>”). If no option is given it lists both, first the objects in memory, then the objects on disk. For example:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb456-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>);</a>
<a class="sourceLine" id="cb456-2" title="2">root[] gDirectory-&gt;ls(<span class="st">"-m"</span>)</a>
<a class="sourceLine" id="cb456-3" title="3">TFile**         hsimple.root</a>
<a class="sourceLine" id="cb456-4" title="4">TFile*         hsimple.root</a></code></pre></div>
<p>Remember that <strong><em><code>gDirectory</code></em></strong> is the current directory and at this time is equivalent to “<code>f</code>”. This correctly states that no objects are in memory.</p>
<p>The next command lists the objects on disk in the current directory.</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb457-1" title="1">root[] gDirectory-&gt;ls(<span class="st">"-d"</span>)</a>
<a class="sourceLine" id="cb457-2" title="2">TFile**         hsimple.root</a>
<a class="sourceLine" id="cb457-3" title="3">TFile*         hsimple.root</a>
<a class="sourceLine" id="cb457-4" title="4">KEY: TH1F     hpx;<span class="dv">1</span>    This is the px distribution</a>
<a class="sourceLine" id="cb457-5" title="5">KEY: TH2F     hpxpy;<span class="dv">1</span>  py vs px</a>
<a class="sourceLine" id="cb457-6" title="6">KEY: TProfile hprof;<span class="dv">1</span>  Profile of pz versus px</a>
<a class="sourceLine" id="cb457-7" title="7">KEY: TNtuple  ntuple;<span class="dv">1</span> Demo ntuple</a></code></pre></div>
<p>To bring an object from disk into memory, we have to use it or “Get” 
it explicitly. When we use the object, ROOT gets it for us. Any 
reference to <code>hprof</code> will read it from the file. For example drawing <code>hprof</code> will read it from the file and create an object in memory. Here we draw the profile histogram, and then we list the contents.</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb458-1" title="1">root[] hprof-&gt;Draw()</a>
<a class="sourceLine" id="cb458-2" title="2">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a>
<a class="sourceLine" id="cb458-3" title="3">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb458-4" title="4">TFile** hsimple.root</a>
<a class="sourceLine" id="cb458-5" title="5">TFile* hsimple.root</a>
<a class="sourceLine" id="cb458-6" title="6">OBJ: TProfile hprof Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb458-7" title="7">KEY: TH1F hpx;<span class="dv">1</span> This is the px distribution</a>
<a class="sourceLine" id="cb458-8" title="8">KEY: TH2F hpxpy;<span class="dv">1</span> py vs px</a>
<a class="sourceLine" id="cb458-9" title="9">KEY: TProfile hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb458-10" title="10">KEY: TNtuple ntuple;<span class="dv">1</span> Demo ntuple</a></code></pre></div>
<p>We now see a new line that starts with OBJ. This means that an object of class <strong><code>TProfile</code></strong>, called <code>hprof</code> has been added in memory to this directory. This new <code>hprof</code> in memory is independent from the <code>hprof</code> on disk. If we make changes to the <code>hprof</code> in memory, they are not propagated to the <code>hprof</code> on disk. A new version of <code>hprof</code> will be saved once we call <code>Write</code>.</p>
<p>You may wonder why <code>hprof</code> is added to the objects in the current directory. <code>hprof</code> is of the class <strong><code>TProfile</code></strong> that inherits from <strong><code>TH1D</code></strong>, which inherits from <strong><code>TH1</code></strong>. <strong><code>TH1</code></strong>
 is the basic histogram. All histograms and trees are created in the 
current directory (also see “Histograms and the Current Directory”). The
 reference to “all histograms” includes objects of any class descending 
directly or indirectly from <strong><code>TH1</code></strong>. Hence, our <strong><code>TProfile</code></strong> <code>hprof</code> is created in the current directory <code>f.</code>There was another side effect when we called the <code>TH1::Draw</code> method. ROOT printed this statement:</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb459-1" title="1">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a></code></pre></div>
<p>It tells us that a <strong><code>TCanvas</code></strong> was created and it named it <code>c1</code>.
 This is where ROOT is being nice, and it creates a canvas for drawing 
the histogram if no canvas was named in the draw command, and if no 
active canvas exists. The newly created canvas, however, is NOT listed 
in the contents of the current directory. Why is that? The canvas is not
 added to the current directory, because by default ONLY histograms and 
trees are added to the object list of the current directory. Actually, <strong><code>TEventList</code></strong>
 objects are also added to the current directory, but at this time, we 
don’t have to worry about those. If the canvas is not in the current 
directory then where is it? Because it is a canvas, it was added to the 
list of canvases.</p>
<p>This list can be obtained by the command <code>gROOT-&gt;GetListOfCanvases()-&gt;ls()</code>. The <code>ls()</code> will print the contents of the list. In our list, we have one canvas called <code>c1</code>. It has a <strong><code>TFrame</code></strong>, a <strong><code>TProfile</code></strong>, and a <strong><code>TPaveStats</code></strong>.</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb460-1" title="1">root[] gROOT-&gt;GetListOfCanvases()-&gt;ls()</a>
<a class="sourceLine" id="cb460-2" title="2">Canvas Name=c1 Title=c<span class="dv">1</span></a>
<a class="sourceLine" id="cb460-3" title="3">Option=TCanvas fXlowNDC=<span class="dv">0</span> fYlowNDC=<span class="dv">0</span> fWNDC=<span class="dv">1</span> fHNDC=<span class="dv">1</span></a>
<a class="sourceLine" id="cb460-4" title="4">Name= c1 Title= c<span class="dv">1</span></a>
<a class="sourceLine" id="cb460-5" title="5">Option=TFrame  X1= -<span class="fl">4.000000</span> Y1=<span class="fl">0.000000</span> X2=<span class="fl">4.000000</span> Y2=<span class="fl">19.384882</span></a>
<a class="sourceLine" id="cb460-6" title="6">OBJ: TProfile hprof   Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb460-7" title="7">TPaveText  X1=-<span class="fl">4.900000</span> Y1=<span class="fl">20.475282</span> X2=-<span class="fl">0.950000</span> Y2=<span class="fl">21.686837</span> title</a>
<a class="sourceLine" id="cb460-8" title="8">TPaveStats X1=<span class="fl">2.800000</span>  Y1=<span class="fl">17.446395</span> X2=<span class="fl">4.800000</span>  Y2=<span class="fl">21.323371</span> stats</a></code></pre></div>
<p>Lets proceed with our example and draw one more histogram, and we see one more OBJ entry.</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb461-1" title="1">root[] hpx-&gt;Draw()</a>
<a class="sourceLine" id="cb461-2" title="2">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb461-3" title="3">TFile**         hsimple.root</a>
<a class="sourceLine" id="cb461-4" title="4">TFile*         hsimple.root</a>
<a class="sourceLine" id="cb461-5" title="5">OBJ: TProfile hprof    Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb461-6" title="6">OBJ: TH1F     hpx      This is the px distribution : <span class="dv">0</span></a>
<a class="sourceLine" id="cb461-7" title="7">KEY: TH1F     hpx;<span class="dv">1</span>    This is the px distribution</a>
<a class="sourceLine" id="cb461-8" title="8">KEY: TH2F     hpxpy;<span class="dv">1</span>  py vs px</a>
<a class="sourceLine" id="cb461-9" title="9">KEY: TProfile hprof;<span class="dv">1</span>  Profile of pz versus px</a>
<a class="sourceLine" id="cb461-10" title="10">KEY: TNtuple  ntuple;<span class="dv">1</span> Demo ntuple</a></code></pre></div>
<p><code>TFile::ls()</code> loops over the list of objects in memory and the list of objects on disk. In both cases, it calls the <code>ls()</code> method of each object. The implementation of the <code>ls</code> method is specific to the class of the object, all of these objects are descendants of <strong><code>TObject</code></strong> and inherit the <strong><code>TObject</code></strong><code>::ls()</code> implementation. The histogram classes are descendants of <strong><code>TNamed</code></strong> that in turn is a descent of <code>TObject</code>. In this case, <strong><code>TNamed::ls()</code></strong>
 is executed, and it prints the name of the class, and the name and 
title of the object. Each directory keeps a list of its objects in the 
memory. You can get this list by <strong><code>TDirectory::GetList()</code></strong>. To see the lists in memory contents you can do:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb462-1" title="1">root[]f-&gt;GetList()-&gt;ls()</a>
<a class="sourceLine" id="cb462-2" title="2">OBJ: TProfile   hprof   Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb462-3" title="3">OBJ: TH1F       hpx     This is the px distribution : <span class="dv">0</span></a></code></pre></div>
<p>Since the file <code>f</code> is the current directory (<strong><em><code>gDirectory</code></em></strong>), this will yield the same result:</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb463-1" title="1">root[] gDirectory-&gt;GetList()-&gt;ls()</a>
<a class="sourceLine" id="cb463-2" title="2">OBJ: TProfile   hprof   Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb463-3" title="3">OBJ: TH1F       hpx     This is the px distribution : <span class="dv">0</span></a></code></pre></div>
<h3 id="saving-histograms-to-disk"><span class="header-section-number">11.2.4</span> Saving Histograms to Disk</h3>
<p>At this time, the objects in memory (OBJ) are identical to the objects on disk (KEY). Let’s change that by adding a fill to the <code>hpx</code> we have in memory.</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb464-1" title="1">root[] hpx-&gt;Fill(<span class="dv">0</span>)</a></code></pre></div>
<p>Now the <code>hpx</code> in memory is different from the histogram (<code>hpx</code>) on disk. Only one version of the object can be in memory, however, on disk we can store multiple versions of the object. The <code>TFile::Write</code> method will write the list of objects in the current directory to disk. It will add a new version of <code>hpx</code> and <code>hprof</code>.</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb465-1" title="1">root[] f-&gt;Write()</a>
<a class="sourceLine" id="cb465-2" title="2">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb465-3" title="3">TFile**         hsimple.root</a>
<a class="sourceLine" id="cb465-4" title="4">TFile*         hsimple.root</a>
<a class="sourceLine" id="cb465-5" title="5">OBJ: TProfile hprof  Profile of pz versus px : <span class="dv">0</span></a>
<a class="sourceLine" id="cb465-6" title="6">OBJ: TH1F     hpx    This is the px distribution : <span class="dv">0</span></a>
<a class="sourceLine" id="cb465-7" title="7">KEY: TH1F     hpx;<span class="dv">2</span>  This is the px distribution</a>
<a class="sourceLine" id="cb465-8" title="8">KEY: TH1F     hpx;<span class="dv">1</span>  This is the px distribution</a>
<a class="sourceLine" id="cb465-9" title="9">KEY: TH2F     hpxpy;<span class="dv">1</span> py vs px</a>
<a class="sourceLine" id="cb465-10" title="10">KEY: TProfile hprof;<span class="dv">2</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb465-11" title="11">KEY: TProfile hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb465-12" title="12">KEY: TNtuple  ntuple;<span class="dv">1</span>        Demo ntuple</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/030000E9.png" alt="The file before and after the call to Write"><figcaption>The file before and after the call to <code>Write</code></figcaption>
</figure>
<p>The <code>TFile::Write</code> method wrote the entire list of objects in the current directory to the file. You see that it added two new keys: <code>hpx;2</code> and <code>hprof;2</code>
 to the file. Unlike memory, a file is capable of storing multiple 
objects with the same name. Their cycle number, the number after the 
semicolon, differentiates objects on disk with the same name. If you 
wanted to save only <code>hpx</code> to the file, but not the entire list of objects, you could use the <code>TH1::Write</code>method of <code>hpx</code>:</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb466-1" title="1">root[] hpx-&gt;Write()</a></code></pre></div>
<p>A call to <code>obj-&gt;Write</code> without any parameters will call <code>obj-&gt;GetName()</code>
 to find the name of the object and use it to create a key with the same
 name. You can specify a new name by giving it as a parameter to the <code>Write</code> method.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb467-1" title="1">root[] hpx-&gt;Write(<span class="st">"newName"</span>)</a></code></pre></div>
<p>If you want to re-write the same object, with the same key, use the overwrite option.</p>
<div class="sourceCode" id="cb468"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb468-1" title="1">root[] hpx-&gt;Write(<span class="st">""</span>,TObject::kOverwrite)</a></code></pre></div>
<p>If you give a new name and use the <code>kOverwrite</code>, the 
object on disk with the matching name is overwritten if such an object 
exists. If not, a new object with the new name will be created.</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb469-1" title="1">root[] hpx-&gt;Write(<span class="st">"newName"</span>,TObject::kOverwrite)</a></code></pre></div>
<p>The <code>Write</code> method did not affect the objects in memory at
 all. However, if the file is closed, the directory is emptied and the 
objects on the list are deleted.</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb470-1" title="1">root[] f-&gt;Close()</a>
<a class="sourceLine" id="cb470-2" title="2">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb470-3" title="3">TFile**     hsimple.root</a>
<a class="sourceLine" id="cb470-4" title="4">TFile*      hsimple.root</a></code></pre></div>
<p>In the code snipped above, you can see that the directory is now empty. If you followed along so far, you can see that <code>c1</code> which was displaying <code>hpx</code> is now blank. Furthermore, <code>hpx</code> no longer exists.</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb471-1" title="1">root[] hpx-&gt;Draw()</a>
<a class="sourceLine" id="cb471-2" title="2">Error: No symbol hpx in current scope</a></code></pre></div>
<p>This is important to remember, do not close the file until you are 
done with the objects or any attempt to reference the objects will fail.</p>
<h3 id="histograms-and-the-current-directory"><span class="header-section-number">11.2.5</span> Histograms and the Current Directory</h3>
<p>When a histogram is created, it is added by default to the list of 
objects in the current directory. You can get the list of histograms in a
 directory and retrieve a pointer to a specific histogram.</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb472-1" title="1">   TH1F *h = (TH1F*)gDirectory-&gt;Get(<span class="st">"myHist"</span>); <span class="co">// or</span></a>
<a class="sourceLine" id="cb472-2" title="2">   TH1F *h = (TH1F*)gDirectory-&gt;GetList()-&gt;FindObject(<span class="st">"myHist"</span>);</a></code></pre></div>
<p>The method <code>TDirectory::GetList()</code> returns a <strong><code>TList</code></strong> of objects in the directory. You can change the directory of a histogram with the <code>SetDirectory</code> method.</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb473-1" title="1">   h-&gt;SetDirectory(newDir);</a></code></pre></div>
<p>If the parameter is 0, the histogram is no longer associated with a directory.</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb474-1" title="1">   h-&gt;SetDirectory(<span class="dv">0</span>);</a></code></pre></div>
<p>Once a histogram is removed from the directory, it will no longer be 
deleted when the directory is closed. It is now your responsibility to 
delete this histogram object once you are finished with it. To change 
the default that automatically adds the histogram to the current 
directory, you can call the static function:</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb475-1" title="1">   TH1::AddDirectory(kFALSE);</a></code></pre></div>
<p>In this case, you will need to do all the bookkeeping for all the created histograms.</p>
<h3 id="saving-objects-to-disk"><span class="header-section-number">11.2.6</span> Saving Objects to Disk</h3>
<p>In addition to histograms and trees, you can save any object in a 
ROOT file. For example to save a canvas to the ROOT file you can use 
either <strong><code>TObject::Write()</code> or <code>TDirectory</code></strong><code>::WriteTObject()</code>. The example:</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb476-1" title="1">root[] c1-&gt;Write()</a></code></pre></div>
<p>This is equivalent to:</p>
<div class="sourceCode" id="cb477"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb477-1" title="1">root[] f-&gt;WriteTObject(c1)</a></code></pre></div>
<p>For objects that do not inherit from <strong><code>TObject</code></strong> use:</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb478-1" title="1">root[] f-&gt;WriteObject(ptr,<span class="st">"nameofobject"</span>)</a></code></pre></div>
<p><strong><em><code>Another example:</code></em></strong></p>
<div class="sourceCode" id="cb479"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb479-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>,<span class="st">"UPDATE"</span>)</a>
<a class="sourceLine" id="cb479-2" title="2">root[] hpx-&gt;Draw()</a>
<a class="sourceLine" id="cb479-3" title="3">&lt;TCanvas::MakeDefCanvas&gt;: created <span class="cf">default</span> TCanvas with name c<span class="dv">1</span></a>
<a class="sourceLine" id="cb479-4" title="4">root[] c1-&gt;Write()</a>
<a class="sourceLine" id="cb479-5" title="5">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb479-6" title="6">TFile**        hsimple.root</a>
<a class="sourceLine" id="cb479-7" title="7">TFile*         hsimple.root</a>
<a class="sourceLine" id="cb479-8" title="8">OBJ: TH1F      hpx      This is the px distribution : <span class="dv">0</span></a>
<a class="sourceLine" id="cb479-9" title="9">KEY: TH1F     hpx;<span class="dv">2</span>   This is the px distribution</a>
<a class="sourceLine" id="cb479-10" title="10">KEY: TH1F     hpx;<span class="dv">1</span>   This is the px distribution</a>
<a class="sourceLine" id="cb479-11" title="11">KEY: TH2F     hpxpy;<span class="dv">1</span> py vs px</a>
<a class="sourceLine" id="cb479-12" title="12">KEY: TProfile hprof;<span class="dv">2</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb479-13" title="13">KEY: TProfile hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb479-14" title="14">KEY: TNtuple  ntuple;<span class="dv">1</span>   Demo ntuple</a>
<a class="sourceLine" id="cb479-15" title="15">KEY: TCanvas  c1;<span class="dv">1</span>    c<span class="dv">1</span></a></code></pre></div>
<h3 id="saving-collections-to-disk"><span class="header-section-number">11.2.7</span> Saving Collections to Disk</h3>
<p>All collection classes inherit from <strong><code>TCollection</code></strong> and hence inherit the <strong><code>TCollection::Write()</code> method. When you call <code>TCollection</code></strong><code>::Write()</code>
 each object in the container is written individually into its own key 
in the file. To write all objects into one key you can specify the name 
of the key and use the option<code>TObject::kSingleKey</code>. For example:</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb480-1" title="1">root[] TList * list = <span class="kw">new</span> TList;</a>
<a class="sourceLine" id="cb480-2" title="2">root[] TNamed * n1, * n2;</a>
<a class="sourceLine" id="cb480-3" title="3">root[] n1 = <span class="kw">new</span> TNamed(<span class="st">"name1"</span>,<span class="st">"title1"</span>);</a>
<a class="sourceLine" id="cb480-4" title="4">root[] n2 = <span class="kw">new</span> TNamed(<span class="st">"name2"</span>,<span class="st">"title2"</span>);</a>
<a class="sourceLine" id="cb480-5" title="5">root[] list-&gt;Add(n1);</a>
<a class="sourceLine" id="cb480-6" title="6">root[] list-&gt;Add(n2);</a>
<a class="sourceLine" id="cb480-7" title="7">root[] gFile-&gt;WriteObject(list,<span class="st">"list"</span>,TObject::kSingleKey);</a></code></pre></div>
<h3 id="a-tfile-object-going-out-of-scope"><span class="header-section-number">11.2.8</span> A TFile Object Going Out of Scope</h3>
<p>There is another important point to remember about <code>TFile::Close</code> and <strong><code>TFile::Write</code></strong>.
 When a variable is declared on the stack in a function such as in the 
code below, it will be deleted when it goes out of scope.</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb481-1" title="1"><span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb481-2" title="2">   TFile f(<span class="st">"AFile.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb481-3" title="3">}</a></code></pre></div>
<p>As soon as the function <code>foo</code>has finished executing, the variable <code>f</code> is deleted. When a <strong><code>TFile</code></strong> object is deleted an implicit call to <code>TFile::Close</code> is made. This will save only the file descriptor to disk. It contains the file header, the <code>StreamerInfo</code>list, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The <code>TFile::Close</code> does not make a call to <code>Write()</code>, which means that the objects in memory will not be saved in the file. You need to explicitly call <code>TFile::Write()</code> to save the object in memory to file before the exit of the function.</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb482-1" title="1"><span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb482-2" title="2">   TFile f(<span class="st">"AFile.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb482-3" title="3">   ... stuff ...</a>
<a class="sourceLine" id="cb482-4" title="4">   f.Write();</a>
<a class="sourceLine" id="cb482-5" title="5">}</a></code></pre></div>
<p>To prevent an object in a function from being deleted when it goes 
out of scope, you can create it on the heap instead of on the stack. 
This will create a <strong><code>TFile</code></strong> object <code>f</code>, that is available on a global scope, and it will still be available when exiting the function.</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb483-1" title="1"><span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb483-2" title="2">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"AFile.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb483-3" title="3">}</a></code></pre></div>
<h3 id="retrieving-objects-from-disk"><span class="header-section-number">11.2.9</span> Retrieving Objects from Disk</h3>
<p>If you have a ROOT session running, please quit and start fresh.</p>
<p>We saw that multiple versions of an object with the same name could 
be in a ROOT file. In our example, we saved a modified histogram <code>hpx</code> to the file, which resulted in two <code>hpx's</code> uniquely identified by the cycle number: <code>hpx;1</code> and <code>hpx;2</code>. The question is how we can retrieve the right version of <code>hpx</code>. When opening the file and using <code>hpx</code>, Cling retrieves the one with the highest cycle number. To read the <code>hpx;1</code> into memory, rather than the <code>hpx:2</code> we would get by default, we have to explicitly get it and assign it to a variable.</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb484-1" title="1">root[] TFile *f1 = <span class="kw">new</span> TFile(<span class="st">"hsimple.root"</span>)</a>
<a class="sourceLine" id="cb484-2" title="2">root[] TH1F *hpx1; f1-&gt;GetObject(<span class="st">"hpx;1"</span>,hpx)</a>
<a class="sourceLine" id="cb484-3" title="3">root[] hpx1-&gt;Draw()</a></code></pre></div>
<h3 id="subdirectories-and-navigation"><span class="header-section-number">11.2.10</span> Subdirectories and Navigation</h3>
<p>The <strong><code>TDirectory</code></strong> class lets you organize its contents into subdirectories, and <strong><code>TFile</code></strong> being a descendent of <strong><code>TDirectory</code></strong>
 inherits this ability. Here is an example of a ROOT file with multiple 
subdirectories as seen in the ROOT browser. To add a subdirectory to a 
file use <code>TDirectory::mkdir</code>. The example below opens the 
file for writing and creates a subdirectory called “Wed011003”. Listing 
the contents of the file shows the new directory in the file and the <strong><code>TDirectory</code></strong> object in memory.</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb485-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"AFile.root"</span>,<span class="st">"RECREATE"</span>)</a>
<a class="sourceLine" id="cb485-2" title="2">root[] f-&gt;mkdir(<span class="st">"Wed011003"</span>)</a>
<a class="sourceLine" id="cb485-3" title="3">(<span class="kw">class</span> TDirectory*)<span class="bn">0x1072b5c8</span></a></code></pre></div>
<div class="sourceCode" id="cb486"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb486-1" title="1">root[] f-&gt;ls()</a>
<a class="sourceLine" id="cb486-2" title="2">TFile**         AFile.root</a>
<a class="sourceLine" id="cb486-3" title="3">TFile*          AFile.root</a>
<a class="sourceLine" id="cb486-4" title="4">TDirectory*           Wed011003       Wed<span class="bn">011003</span></a>
<a class="sourceLine" id="cb486-5" title="5">KEY: TDirectory       Wed011003;<span class="dv">1</span>     Wed<span class="bn">011003</span></a></code></pre></div>
<p>We can change the current directory by navigating into the subdirectory, and after changing directory; we can see that <strong><em><code>gDirectory</code></em></strong> is now “<code>Wed011003</code>”.</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb487-1" title="1">root[] f-&gt;cd(<span class="st">"Wed011003"</span>)</a>
<a class="sourceLine" id="cb487-2" title="2">root[] gDirectory-&gt;pwd()</a>
<a class="sourceLine" id="cb487-3" title="3">AFile.root:/Wed<span class="bn">011003</span></a></code></pre></div>
<p>In addition to <strong><em><code>gDirectory</code></em></strong> we have <strong><em><code>gFile</code></em></strong>, another global that points to the current file. In our example, <strong><em><code>gDirectory</code></em></strong> points to the subdirectory, and <strong><em><code>gFile</code></em></strong> points to the file (i.e. the files’ top directory).</p>
<div class="sourceCode" id="cb488"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb488-1" title="1">root[] gFile-&gt;pwd()</a>
<a class="sourceLine" id="cb488-2" title="2">AFile.root:/</a></code></pre></div>
<p>Use <code>cd()</code> without any arguments to return to the file’s top directory.</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb489-1" title="1">root[] f-&gt;cd()</a>
<a class="sourceLine" id="cb489-2" title="2">AFile.root:/</a></code></pre></div>
<p>Change to the subdirectory again, and create a histogram. It is added to the current directory, which is the subdirectory “<code>Wed011003</code>”.</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb490-1" title="1">root[] f-&gt;cd(<span class="st">"Wed011003"</span>)</a>
<a class="sourceLine" id="cb490-2" title="2">root[] TH1F *histo = <span class="kw">new</span> TH1F(<span class="st">"histo"</span>,<span class="st">"histo"</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb490-3" title="3">root[] gDirectory-&gt;ls()</a>
<a class="sourceLine" id="cb490-4" title="4">TDirectory* Wed011003   Wed<span class="bn">011003</span></a>
<a class="sourceLine" id="cb490-5" title="5">OBJ: TH1F      histo   histo : <span class="dv">0</span></a></code></pre></div>
<p>If you are in a subdirectory and you want to have a pointer to the file containing the subdirectory, you can do:</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb491-1" title="1">root[] gDirectory-&gt;GetFile()</a></code></pre></div>
<p>If you are in the top directory <strong><em><code>gDirectory</code></em></strong> is the same as <strong><em><code>gFile</code></em></strong>. We write the file to save the histogram on disk, to show you how to retrieve it later.</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb492-1" title="1">root[] f-&gt;Write()</a>
<a class="sourceLine" id="cb492-2" title="2">root[] gDirectory-&gt;ls()</a>
<a class="sourceLine" id="cb492-3" title="3">TDirectory*             Wed011003       Wed<span class="bn">011003</span></a>
<a class="sourceLine" id="cb492-4" title="4">OBJ: TH1F      histo   histo : <span class="dv">0</span></a>
<a class="sourceLine" id="cb492-5" title="5">KEY: TH1F      histo;<span class="dv">1</span> histo</a></code></pre></div>
<p>When retrieving an object from a subdirectory, you can navigate to 
the subdirectory first or give it the path name relative to the file. 
The read object is created in memory in the current directory. In this 
first example, we get <code>histo</code> from the top directory and the object will be in the top directory.</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb493-1" title="1">root[] TH1 *h; f-&gt;GetObject(<span class="st">"Wed011003/histo;1"</span>,h)</a></code></pre></div>
<p>If file is written, a copy of <code>histo</code> will be in the top 
directory. This is an effective way to copy an object from one directory
 to another. In contrast, in the code box below, <code>histo</code> will be in memory in the subdirectory because we changed the current directory.</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb494-1" title="1">root[] f-&gt;cd(<span class="st">"Wed011003"</span>)</a>
<a class="sourceLine" id="cb494-2" title="2">root[] TH1 *h; gDirectory-&gt;GetObject(<span class="st">"histo;1"</span>,h)</a></code></pre></div>
<p>Note that there is no warning if the retrieving was not successful. 
You need to explicitly check the value of h, and if it is null, the 
object could not be found. For example, if you did not give the path 
name the histogram cannot be found and the pointer to h is null:</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb495-1" title="1">root[] TH1 *h; gDirectory-&gt;GetObject(<span class="st">"Wed011003/histo;1"</span>,h)</a>
<a class="sourceLine" id="cb495-2" title="2">root[] h</a>
<a class="sourceLine" id="cb495-3" title="3">(<span class="kw">class</span> TH1*)<span class="bn">0x10767de0</span></a>
<a class="sourceLine" id="cb495-4" title="4">root[] TH1 *h; gDirectory-&gt;GetObject(<span class="st">"histo;1"</span>,h)</a>
<a class="sourceLine" id="cb495-5" title="5">root[] h</a>
<a class="sourceLine" id="cb495-6" title="6">(<span class="kw">class</span> TH1*)<span class="bn">0x0</span></a></code></pre></div>
<p>To remove a subdirectory you need to use <code>TDirectory::Delete</code>. There is no <strong><code>TDirectory::rmdir</code></strong>. The Delete method takes a string containing the variable name and cycle number as a parameter.</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb496-1" title="1"><span class="dt">void</span> Delete(<span class="at">const</span> <span class="dt">char</span> *namecycle)</a></code></pre></div>
<p>The <code>namecycle</code> string has the format <code>name;cycle</code>. The next are some rules to remember:</p>
<ul>
<li><p><code>name</code> = * means all, but don’t remove the subdirectories</p></li>
<li><p><code>cycle</code> =* means all cycles (memory and file)</p></li>
<li><p><code>cycle</code> ="" means apply to a memory object</p></li>
<li><p><code>cycle</code> = 9999 also means apply to a memory object</p></li>
<li><p><code>namecycle</code> = "" means the same as <code>namecycle</code> =“T*”</p></li>
<li><p><code>namecycle</code> = <code>T*</code> delete subdirectories</p></li>
</ul>
<p>For example to delete a directory from a file, you must specify the directory cycle:</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb497-1" title="1">root[] f-&gt;Delete(<span class="st">"Wed011003;1"</span>)</a></code></pre></div>
<p>Some other examples of <code>namecycle</code> format are:</p>
<ul>
<li><p><code>foo</code>:delete the object named <code>foo</code> from memory</p></li>
<li><p><code>foo;1</code>: delete the cycle 1 of the object named <code>foo</code> from the file</p></li>
<li><p><code>foo;*</code>: delete all cycles of <code>foo</code> from the file and also from memory</p></li>
<li><p><code>*;2</code>: delete all objects with cycle number 2 from the file</p></li>
<li><p><code>*;*:  delete</code> all objects from memory and from the file</p></li>
<li><p><code>T*;*</code>: delete all objects from memory and from the file including all subdirectories</p></li>
</ul>
<h2 id="streamers"><span class="header-section-number">11.3</span> Streamers</h2>
<p>To follow the discussion on <code>Streamers</code>, you need to know what a <em>simple</em>
 data type is. A variable is of a simple data type if it cannot be 
decomposed into other types. Examples of simple data types are longs, 
shorts, floats, and chars. In contrast, a variable is of a <em>composite</em>
 data type if it can be decomposed. For example, classes, structures, 
and arrays are composite types. Simple types are also called primitive 
types, basic types, and Cling sometimes calls them fundamental types.</p>
<p>When we say, “writing an object to a file”, we actually mean writing 
the current values of the data members. The most common way to do this 
is to decompose (also called the serialization of) the object into its 
data members and write them to disk. The decomposition is the job of the
 <code>Streamer</code>. Every class with ambitions to be stored in a file has a <code>Streamer</code>that decomposes it and “streams” its members into a buffer.</p>
<p>The methods of the class are not written to the file, it contains 
only the persistent data members. To decompose the parent classes, the <code>Streamer</code>calls the <code>Streamer</code>of
 the parent classes. It moves up the inheritance tree until it reaches 
an ancestor without a parent. To serialize the object data members it 
calls their <code>Streamer</code>. They in turn move up their own 
inheritance tree and so forth. The simple data members are written to 
the buffer directly. Eventually the buffer contains all simple data 
members of all the classes that make up this particular object. Data 
members that are references (as <code>MyClass &amp;fObj;</code>) are never saved, it is always the responsibility of the object’s constructor to set them properly.</p>
<h3 id="automatically-generated-streamers"><span class="header-section-number">11.3.1</span> Automatically Generated Streamers</h3>
<p>A <code>Streamer</code>usually calls other <code>Streamers</code>: the <code>Streamer</code>of its parents and data members. This architecture depends on all classes having <code>Streamers</code>, because eventually they will be called. To ensure that a class has a <code>Streamer</code>, <code>rootcling</code> automatically creates one in the <code>ClassDef</code> macro that is defined in <code>$ROOTSYS/include/Rtypes.h</code>. <code>ClassDef</code> defines several methods for any class, and one of them is the <code>Streamer</code>. The automatically generated <code>Streamer</code>is complete and can be used as long as no customization is needed.</p>
<p>The <code>Event</code> class is defined in <code>$ROOTSYS/test/Event.h</code>. Looking at the class definition, we find that it inherits from <strong><code>TObject</code></strong>. It is a simple example of a class with diverse data members.</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb498-1" title="1"><span class="kw">class</span> Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb498-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb498-3" title="3">   TDirectory    *fTransient;            <span class="co">//! current directory</span></a>
<a class="sourceLine" id="cb498-4" title="4">   <span class="dt">Float_t</span>     fPt;                   <span class="co">//! transient value</span></a>
<a class="sourceLine" id="cb498-5" title="5"><span class="dt">char</span>           fType[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb498-6" title="6"><span class="dt">Int_t</span>          fNtrack;</a>
<a class="sourceLine" id="cb498-7" title="7"><span class="dt">Int_t</span>          fNseg;</a>
<a class="sourceLine" id="cb498-8" title="8"><span class="dt">Int_t</span>          fNvertex;</a>
<a class="sourceLine" id="cb498-9" title="9"><span class="dt">UInt_t</span>         fFlag;</a>
<a class="sourceLine" id="cb498-10" title="10"><span class="dt">Float_t</span>        fTemperature;</a>
<a class="sourceLine" id="cb498-11" title="11">EventHeader    fEvtHdr;           <span class="co">//|| don't split</span></a>
<a class="sourceLine" id="cb498-12" title="12">TClonesArray  *fTracks;           <span class="co">//-&gt;</span></a>
<a class="sourceLine" id="cb498-13" title="13">TH1F          *fH;                <span class="co">//-&gt;</span></a>
<a class="sourceLine" id="cb498-14" title="14"><span class="dt">Int_t</span>          fMeasures[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb498-15" title="15"><span class="dt">Float_t</span>        fMatrix[<span class="dv">4</span>][<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb498-16" title="16"><span class="dt">Float_t</span>       *fClosestDistance;  <span class="co">//[fNvertex]</span></a>
<a class="sourceLine" id="cb498-17" title="17">...</a></code></pre></div>
<p>The Event class is added to the dictionary by the <code>rootcling</code> utility. This is the <code>rootcling</code> statement in the <code>$ROOTSYS/test/Makefile</code>:</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb499-1" title="1"><span class="er">@</span>rootcling -f EventDict.cxx -c Event.h EventLinkDef.h</a></code></pre></div>
<p>The <code>EventDict.cxx</code> file contains the automatically generated <code>Streamer</code>for Event:</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb500-1" title="1"><span class="dt">void</span> Event::Streamer(TBuffer &amp;R__b){</a>
<a class="sourceLine" id="cb500-2" title="2">   <span class="co">// Stream an object of class Event.</span></a>
<a class="sourceLine" id="cb500-3" title="3">   <span class="cf">if</span> (R__b.IsReading()) {</a>
<a class="sourceLine" id="cb500-4" title="4">      Event::Class()-&gt;ReadBuffer(R__b, <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb500-5" title="5">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb500-6" title="6">      Event::Class()-&gt;WriteBuffer(R__b, <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb500-7" title="7">   }</a>
<a class="sourceLine" id="cb500-8" title="8">}</a></code></pre></div>
<p>When writing an <code>Event</code> object, <code>TClass::WriteBuffer</code> is called. <code>WriteBuffer</code> writes the current version number of the <code>Event class,</code> and its contents into the buffer <code>R__b</code>. The <code>Streamer</code>calls <strong><code>TClass::ReadBuffer</code></strong> when reading an <code>Event</code> object. The <code>ReadBuffer</code> method reads the information from buffer <code>R__b</code> into the <code>Event</code> object.</p>
<h3 id="transient-data-members"><span class="header-section-number">11.3.2</span> Transient Data Members (//!)</h3>
<p>To prevent a data member from being written to the file, insert a “<code>!</code>”
 as the first character after the comment marks. It tells ROOT not to 
save that data member in a root file when saving the class. For example,
 in this version of Event, the <code>fPt</code> and <code>fTransient</code> data members are not persistent.</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb501-1" title="1"><span class="kw">class</span> Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb501-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb501-3" title="3">   TDirectory    *fTransient; <span class="co">//! current directory</span></a>
<a class="sourceLine" id="cb501-4" title="4">   <span class="dt">Float_t</span> fPt;               <span class="co">//! transient value</span></a>
<a class="sourceLine" id="cb501-5" title="5">...</a></code></pre></div>
<h3 id="the-pointer-to-objects--"><span class="header-section-number">11.3.3</span> The Pointer to Objects (//-&gt;)</h3>
<p>The string “<code>-&gt;</code>” in the comment field of the members <code>*fH</code> and <code>*fTracks</code> instruct the automatic <code>Streamer</code> to assume these will point to valid objects and the <code>Streamer</code>of the objects can be called rather than the more expensive <code>R__b &lt;&lt; fH</code>.
 It is important to note that no check is done on the validity of the 
pointer value. In particular if the pointer points, directly or 
indirectly, back to the current object, this will result in an infinite 
recursion and the abrupt end of the process.</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb502-1" title="1">TClonesArray  *fTracks;            <span class="co">//-&gt;</span></a>
<a class="sourceLine" id="cb502-2" title="2">TH1F          *fH;                 <span class="co">//-&gt;</span></a></code></pre></div>
<h3 id="variable-length-array"><span class="header-section-number">11.3.4</span> Variable Length Array</h3>
<p>When the <code>Streamer</code>comes across a pointer to a simple 
type, it assumes it is an array. Somehow, it has to know how many 
elements are in the array to reserve enough space in the buffer and 
write out the appropriate number of elements. This is done in the class 
definition. For example:</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb503-1" title="1"><span class="kw">class</span> Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb503-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb503-3" title="3">   <span class="dt">char</span>           fType[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb503-4" title="4">   <span class="dt">Int_t</span>          fNtrack;</a>
<a class="sourceLine" id="cb503-5" title="5">   <span class="dt">Int_t</span>          fNseg;</a>
<a class="sourceLine" id="cb503-6" title="6">   <span class="dt">Int_t</span>          fNvertex;</a>
<a class="sourceLine" id="cb503-7" title="7">...</a>
<a class="sourceLine" id="cb503-8" title="8">   <span class="dt">Float_t</span>       *fClosestDistance;   <span class="co">//[fNvertex]</span></a></code></pre></div>
<p>The array <code>fClosestDistance</code> is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the <code>Streamer</code>the length of the array for this object. In general the syntax is:</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb504-1" title="1">&lt;simple type&gt; *&lt;name&gt;<span class="co">//[&lt;length&gt;]</span></a></code></pre></div>
<p>The length cannot be an expression. If a variable is used, it needs 
to be an integer data member of the class. It must be defined ahead of 
its use, or in a base class.</p>
<p>The same notation also applies to variable length array of object and variable length array of pointer to objects.</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb505-1" title="1">MyObject *obj; <span class="co">//[fNojbs]</span></a>
<a class="sourceLine" id="cb505-2" title="2">MyObject **objs; <span class="co">//[fDatas]</span></a></code></pre></div>
<h3 id="double32_t"><span class="header-section-number">11.3.5</span> Double32_t</h3>
<p>Math operations very often require double precision, but on saving 
single usually precision is sufficient. For this purpose we support the 
typedef Double32_t which is stored in memory as a double and on disk as a
 float or integer. The actual size of disk (before compression) is 
determined by the parameter next to the data member declaration. For 
example:</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb506-1" title="1"><span class="dt">Double32_t</span> <span class="va">m_data</span>;     <span class="co">//[min,max&lt;,nbits&gt;]</span></a></code></pre></div>
<p>If the comment is absent or does not contain <code>min</code>, <code>max</code>, <code>nbits</code>, the member is saved as a <code>float</code>.</p>
<p>If <code>min</code> and <code>max</code> are present, they are saved with 32 bits precision. <code>min</code> and <code>max</code> can be explicit values or expressions of values known to Cling (e.g.&nbsp;<code>pi</code>).</p>
<p>If <code>nbits</code> is present, the member is saved as <code>int</code> with <code>nbits</code> bits precision. For more details see the io tutorials <code>double32.C</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/030000EA.png" alt="Compression and precision of Double32_t"><figcaption>Compression and precision of Double32_t</figcaption>
</figure>
<h3 id="prevent-splitting"><span class="header-section-number">11.3.6</span> Prevent Splitting (//|| )</h3>
<p>If you want to prevent a data member from being split when writing it
 to a tree, append the characters || right after the comment string. 
This only makes sense for object data members. For example:</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb507-1" title="1">EventHeader    fEvtHdr;       <span class="co">//|| do not split the header</span></a></code></pre></div>
<h3 id="streamers-with-special-additions"><span class="header-section-number">11.3.7</span> Streamers with Special Additions</h3>
<p>Most of the time you can let <code>rootcling</code> generate a <code>Streamer</code> for you. However if you want to write your own <code>Streamer</code>you
 can do so. For some classes, it may be necessary to execute some code 
before or after the read or write block in the automatic <code>Streamer</code>.
 For example after the execution of the read block, one can initialize 
some non persistent members. There are two reasons why you would need to
 write your own Streamer: 1) if you have a non-persistent data member 
that you want to initialize to a value depending on the read data 
members; 2) if you want or need to handle the schema evolution on your 
own. Note that an alternative for those cases is to consider write a 
schema evolution rule.</p>
<p>First, you need to tell <code>rootcling</code> not to build a <code>Streamer</code>for you. The input to the <code>rootcling</code> command (in the <code>makefile</code>) is a list of classes in a <code>LinkDef.h</code> file. For example, the list of classes for <code>Event</code> is listed in <code>$ROOTSYS/test/EventLinkDef.h</code>. The “<code>-</code>” at the end of the class name tells <code>rootcling</code> not to generate a <code>Streamer</code>. In the example, you can see the <code>Event</code> class is the only one for which <code>rootcling</code> is instructed not to generate a <code>Streamer</code>.</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb508-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb508-2" title="2"></a>
<a class="sourceLine" id="cb508-3" title="3"><span class="pp">#pragma link off all globals;</span></a>
<a class="sourceLine" id="cb508-4" title="4"><span class="pp">#pragma link off all classes;</span></a>
<a class="sourceLine" id="cb508-5" title="5"><span class="pp">#pragma link off all functions;</span></a>
<a class="sourceLine" id="cb508-6" title="6"><span class="pp">#pragma link C++ class EventHeader+;</span></a>
<a class="sourceLine" id="cb508-7" title="7"><span class="pp">#pragma link C++ class Event-;</span></a>
<a class="sourceLine" id="cb508-8" title="8"><span class="pp">#pragma link C++ class HistogramManager+;</span></a>
<a class="sourceLine" id="cb508-9" title="9"><span class="pp">#pragma link C++ class Track+;</span></a>
<a class="sourceLine" id="cb508-10" title="10"></a>
<a class="sourceLine" id="cb508-11" title="11"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb508-12" title="12"><span class="pp">#pragma link C++ class EventHeader+;</span></a></code></pre></div>
<p>The “<code>+</code>” sign tells <code>rootcling</code> to use the new <code>Streamer</code>system introduced in ROOT 3.0. The following is an example of a customized <code>Streamer</code>for <code>Event</code>. The <code>Streamer</code> takes a <strong><code>TBuffer</code></strong> as a parameter, and first checks to see if this is a case of reading or writing the buffer.</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb509-1" title="1"><span class="dt">void</span> Event::Streamer(TBuffer &amp;R__b) {</a>
<a class="sourceLine" id="cb509-2" title="2">   <span class="cf">if</span> (R__b.IsReading()) {</a>
<a class="sourceLine" id="cb509-3" title="3">      Event::Class()-&gt;ReadBuffer(R__b, <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb509-4" title="4">      fTransient = gDirectory;       <span class="co">//save current directory</span></a>
<a class="sourceLine" id="cb509-5" title="5">      fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);</a>
<a class="sourceLine" id="cb509-6" title="6">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb509-7" title="7">      Event::Class()-&gt;WriteBuffer(R__b, <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb509-8" title="8">   }</a>
<a class="sourceLine" id="cb509-9" title="9">}</a></code></pre></div>
<h3 id="writing-objects"><span class="header-section-number">11.3.8</span> Writing Objects</h3>
<p>The <code>Streamer</code> decomposes the objects into data members 
and writes them to a buffer. It does not write the buffer to a file, it 
simply populates a buffer with bytes representing the object. This 
allows us to write the buffer to a file or do anything else we could do 
with the buffer. For example, we can write it to a socket to send it 
over the network. This is beyond the scope of this chapter, but it is 
worthwhile to emphasize the need and advantage of separating the 
creation of the buffer from its use. Let us look how a buffer is written
 to a file. The dictionary for a class needs to be loaded before any 
object of that type can be saved.</p>
<p>The <code>TObject::Write</code> method does the following:</p>
<ul>
<li><p>Creates a <strong><code>TKey</code></strong> object in the current directory</p></li>
<li><p>Creates a <strong><code>TBuffer</code></strong> object which is part of the newly created <strong><code>TKey</code></strong></p></li>
<li><p>Fills the <strong><code>TBuffer</code></strong> with a call to the <code>class::Streamer</code> method</p></li>
<li><p>Creates a second buffer for compression, if needed</p></li>
<li><p>Reserves space by scanning the <strong><code>TFree</code></strong> list. At this point, the size of the buffer is known.</p></li>
<li><p>Writes the buffer to the file</p></li>
<li><p>Releases the <strong><code>TBuffer</code></strong> part of the key</p></li>
</ul>
<p>In other words, the <code>TObject::Write</code> calls the <code>Streamer</code>
 method of the class to build the buffer. The buffer is in the key and 
the key is written to disk. Once written to disk the memory consumed by 
the buffer part is released. The key part of the <strong><code>TKey</code></strong> is kept.</p>
<figure>
<img src="ROOTUsersGuide_files/020000EB.jpg" alt="A diagram of a streamed TH1F in the buffer"><figcaption>A diagram of a streamed TH1F in the buffer</figcaption>
</figure>
<p>The key consumes about 60 bytes, whereas the buffer, since it contains the object data, can be very large.</p>
<h3 id="ignore-object-streamers"><span class="header-section-number">11.3.9</span> Ignore Object Streamers</h3>
<p>Your class can ignore the <strong><code>TObject</code></strong> <code>Streamer</code>with the <code>MyClass-&gt;Class::IgnoreObjectStreamer()</code> method. When the class <code>kIgnoreTObjectStreamer</code>bit is set (by calling the <code>IgnoreTObjectStreamer</code>method<code>)</code>, the automatically generated <code>Streamer</code>will not call <code>TObject::Streamer</code>, and the <strong><code>TObject</code></strong> part of the class is not streamed to the file. This is useful in case you do not use the <strong><code>TObject</code></strong> <code>fBits</code> and <code>fUniqueID</code>data members. You gain space on the file, and you do not loose functionality if you do not use the <code>fBits</code> and <code>fUniqueID.</code>See “The Role of TObject” on the use of <code>fBits</code> and <code>fUniqueID</code>.</p>
<h3 id="streaming-a-tclonesarray"><span class="header-section-number">11.3.10</span> Streaming a TClonesArray</h3>
<p>When writing a <strong><code>TClonesArray</code></strong> it bypasses by default the <code>Streamer</code>of
 the member class and uses a more efficient internal mechanism to write 
the members to the file. You can override the default and specify that 
the member class <code>Streamer</code>is used by setting the <code>TClonesArray::BypassStreamer</code> bit to false:</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb510-1" title="1">   TClonesArray *fTracks;</a>
<a class="sourceLine" id="cb510-2" title="2">   fTracks-&gt;BypassStreamer(kFALSE);    <span class="co">// use the member Streamer</span></a></code></pre></div>
<p>When the <code>kBypassStreamer</code> bit is set, the automatically generated <code>Streamer</code>can call directly the method <strong><code>TClass::WriteBuffer</code></strong>. Bypassing the <code>Streamer</code> improves the performance when writing/reading the objects in the <strong><code>TClonesArray</code></strong>. However, the drawback is when a <strong><code>TClonesArray</code></strong> is written with <code>split=0</code> bypassing the <code>Streamer</code>, the <code>StreamerInfo</code>of the class in the array being optimized, one cannot later use the <strong><code>TClonesArray</code></strong> with <code>split &gt; 0</code>. For example, there is a problem with the following scenario: a class <code>Foo</code> has a <strong><code>TClonesArray</code></strong> of <code>Bar</code> objects the <code>Foo</code> object is written with <code>split=0</code> to <code>Tree</code> <code>T1</code>. In this case the <code>StreamerInfo</code> for the class <code>Bar</code>
 is created in optimized mode in such a way that data members of the 
same type are written as an array improving the I/O performance. In a 
new program, <code>T1</code> is read and a new <code>Tree</code> <code>T2</code> is created with the object <code>Foo</code> in <code>split &gt; 1</code>.</p>
<p>When the <code>T2</code>branch is created, the <code>StreamerInfo</code> for the class <code>Bar</code> is created with no optimization (mandatory for the split mode). The optimized Bar <code>StreamerInfo</code> is going to be used to read the <strong><code>TClonesArray</code></strong> in <code>T1</code>. The result will be <code>Bar</code> objects with data member values not in the right sequence. The solution to this problem is to call <code>BypassStreamer(kFALSE)</code> for the <strong><code>TClonesArray</code></strong>. In this case, the normal <code>Bar::Streamer</code> function will be called. The <code>Bar::Streamer</code> function works OK independently if the <code>Bar</code> <code>StreamerInfo</code>had been generated in optimized mode or not.</p>
<h2 id="pointers-and-references-in-persistency"><span class="header-section-number">11.4</span> Pointers and References in Persistency</h2>
<p>An object pointer as a data member presents a challenge to the 
streaming software. If the object pointed to is saved every time, it 
could create circular dependencies and consume a large amount of disk 
space. The network of references must be preserved on disk and recreated
 upon reading the file.</p>
<p>If you use independent I/O operations for pointers and their referenced objects you can use the <strong><code>TRef</code></strong> class. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and <strong><code>TRef</code></strong><code>s</code>. In general, a <strong><code>TRef</code></strong> is faster than C++ but the advantage of a C++ pointer is that it is already C++.</p>
<h3 id="streaming-c-pointers"><span class="header-section-number">11.4.1</span> Streaming C++ Pointers</h3>
<p>When ROOT encounters a pointer data member it calls the <code>Streamer</code>
 of the object and labels it with a unique object identifier. The object
 identifier is unique for one I/O operation. If there is another pointer
 to the object in the same I/O operation, the first object is referenced
 i.e.&nbsp;it is not saved again. When reading the file, the object is 
rebuilt and the references recalculated.</p>
<figure>
<img src="ROOTUsersGuide_files/020000EC.jpg" alt="Streaming object pointers"><figcaption>Streaming object pointers</figcaption>
</figure>
<p>In this way, the network of pointers and their objects is rebuilt and
 ready to use the same way it was used before it was persistent. If the 
pointer hold the address of an object which in embedded in another 
object (as opposed to being pointed to by a pointer), the object will be
 duplicate at read time. To avoid this, make the pointer a transient 
data member.</p>
<h3 id="motivation-for-the-tref-class"><span class="header-section-number">11.4.2</span> Motivation for the TRef Class</h3>
<p>If the object is split into several files or into several branches of one or more <code>TTrees</code>,
 standard C++ pointers cannot be used because each I/O operation will 
write the referenced objects, and multiple copies will exist. In 
addition, if the pointer is read before the referenced object, it is 
null and may cause a run time system error. To address these 
limitations, ROOT offers the <strong><code>TRef</code></strong> class.</p>
<p><strong><code>TRef</code></strong> allows referencing an object in a different branch and/or in a different file. <strong><code>TRef</code></strong> also supports the complex situation where a <strong><code>TFile</code></strong> is updated multiple times on the same machine or a different machine. When a <strong><code>TRef</code></strong> is read before its referenced object, it is null. As soon as the referenced object is read, the <strong><code>TRef</code></strong> points to it. In addition, one can specify an action to be taken by <strong><code>TRef</code></strong> in the case it is read before its reference object (see“Action on Demand” below).</p>
<h3 id="using-tref"><span class="header-section-number">11.4.3</span> Using TRef</h3>
<p>A <strong><code>TRef</code></strong> is a lightweight object pointing to any <strong><code>TObject</code></strong>. This object can be used instead of normal C++ pointers in case:</p>
<ul>
<li><p>The referenced object R and the pointer P are not written to the same file</p></li>
<li><p>P is read before R</p></li>
<li><p>R and P are written to different Tree branches</p></li>
</ul>
<p>Below is a line from the example in <code>$ROOTSYS/test/Event.cxx.</code></p>
<div class="sourceCode" id="cb511"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb511-1" title="1">   TRef   fLastTrack;             <span class="co">//pointer to last track</span></a>
<a class="sourceLine" id="cb511-2" title="2">...</a>
<a class="sourceLine" id="cb511-3" title="3">   Track *track = (Track*)fTracks-&gt;ConstructedAt(fNtrack++);</a>
<a class="sourceLine" id="cb511-4" title="4">   track-&gt;Set(random);</a>
<a class="sourceLine" id="cb511-5" title="5">   <span class="co">// Save reference to last Track in the collection of Tracks</span></a>
<a class="sourceLine" id="cb511-6" title="6">   fLastTrack = track;</a></code></pre></div>
<p>The <code>track</code> and its reference <code>fLastTrack</code> can be written with two separate I/O calls in the same or in different files, in the same or in different branches of a <strong><code>TTree</code></strong>. If the <strong><code>TRef</code></strong> is read and the referenced object has not yet been read, <strong><code>TRef</code></strong> will return a null pointer. As soon as the referenced object will be read, <strong><code>TRef</code></strong> will point to it.</p>
<h3 id="how-does-it-work"><span class="header-section-number">11.4.4</span> How Does It Work?</h3>
<p>A <strong><code>TRef</code></strong> is itself a <strong><code>TObject</code></strong> with an additional transient pointer <code>fPID</code>. When a <strong><code>TRef</code></strong> is used to point to a <strong><code>TObject</code></strong><code>*R</code>, for example in a class with</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb512-1" title="1">   TRef  P;</a></code></pre></div>
<p>one can do:</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb513-1" title="1">   P = R;      <span class="co">//to set the pointer</span></a></code></pre></div>
<p>When the statement <code>P = R</code>is executed, the following happens:</p>
<ul>
<li><p>The pointer <code>fPID</code> is set to the current <code>TProcessID (see below)</code>.</p></li>
<li><p>The current <code>ObjectNumber</code> (see below) is incremented by one.</p></li>
<li><p><code>R.fUniqueID</code> is set to <code>ObjectNumber</code>.</p></li>
<li><p>In the <code>fPID</code> object, the element <code>fObjects[ObjectNumber]</code> is set to <code>R</code></p></li>
<li><p><code>P.fUniqueID</code> is also set to <code>ObjectNumber</code>.</p></li>
</ul>
<p>After having set <code>P</code>, one can immediately return the value of <code>R</code> using <code>P.GetObject()</code>. This function returns the <code>fObjects[fUniqueID]</code> from the <code>fPID</code> object.</p>
<p>When the <strong><code>TRef</code></strong> is written, the process id number <code>pidf</code> of <code>fPID</code> is written in addition to the <strong><code>TObject</code></strong> part of the <strong><code>TRef</code></strong> (<code>fBits,fUniqueID</code>). When the <strong><code>TRef</code></strong> is read, its pointer <code>fPID</code> is set to the value stored in the <strong><code>TObjArray</code></strong> of <code>TFile::fProcessIDs</code>(<code>fProcessIDs[pidf]</code>).</p>
<p>When a referenced object is written, <code>TObject::Streamer</code> writes the <code>pidf</code> in addition to the standard <code>fBits and fUniqueID</code>. When <code>TObject::Streamer</code> reads a reference object, the <code>pidf</code> is read. At this point, the referenced object is entered into the table of objects of the <strong><code>TProcessID</code></strong> corresponding to <code>pidf</code>.</p>
<p>WARNING: If <code>MyClass</code> is the class of the referenced object, The <strong><code>TObject</code></strong> part of <code>MyClass</code> must be streamed. One should not call <code>MyClass::Class()-&gt;IgnoreTObjectStreamer()</code>.</p>
<h4 id="tproccessid-and-tuuid"><span class="header-section-number">11.4.4.1</span> TProccessID and TUUID</h4>
<p>A <strong><code>TProcessID</code></strong> uniquely identifies a ROOT job. The <strong><code>TProcessID</code></strong> title consists of a <strong><code>TUUID</code></strong> object, which provides a globally unique identifier. The <strong><code>TUUID</code></strong>
 class implements the UUID (Universally Unique Identifier), also known 
as GUID (Globally Unique Identifier). A UUID is 128 bits long, and if 
generated according to this algorithm, is either guaranteed to be 
different from all other UUID generated until 3400 A.D. or extremely 
likely to be different.</p>
<p>The <strong><code>TROOT</code></strong> constructor automatically creates a <strong><code>TProcessID</code></strong>. When a <strong><code>TFile</code></strong> contains referenced objects, the <strong><code>TProcessID</code></strong> object is written to the file. If a file has been written in multiple sessions (same machine or not), a <strong><code>TProcessID</code></strong> is written for each session. The <strong><code>TProcessID</code></strong> objects are used by <strong><code>TRef</code></strong> to uniquely identify the referenced <strong><code>TObject</code></strong>.</p>
<p>When a referenced object is read from a file (its bit <code>kIsReferenced</code> is set), this object is entered into the objects table of the corresponding <strong><code>TProcessID</code></strong>. Each <strong><code>TFile</code></strong> has a list of <strong><code>TProcessIDs</code></strong> (see <code>TFile::fProcessIDs</code>) also accessible from <code>TProcessID::fgPIDs</code> (for all files). When this object is deleted, it is removed from the table via the cleanup mechanism invoked by the <strong><code>TObject</code></strong> destructor. Each <strong><code>TProcessID</code></strong> has a table (<code>TObjArray *fObjects</code>) that keeps track of all referenced objects. If a referenced object has a <code>fUniqueID</code>, a pointer to this unique object may be found using <code>fObjects-&gt;At(fUniqueID)</code>. In the same way, when a <strong><code>TRef::GetObject</code></strong> is called, <code>GetObject</code> uses its own <code>fUniqueID</code> to find the pointer to the referenced object. See <code>TProcessID::GetObjectWithID</code> and <code>PutObjectWithID</code>.</p>
<h4 id="object-number"><span class="header-section-number">11.4.4.2</span> Object Number</h4>
<p>When an object is referenced, a unique identifier is computed and stored in both the <code>fUniqueID</code> of the referenced and referencing object. This <code>uniqueID</code> is computed by incrementing by one the static global in <code>TProcessID::fgNumber</code>. The <code>fUniqueID</code> is the serial object number in the current session. One can retrieve the current <code>fgNumber</code> value by calling the static function <code>TProcessID::GetObjectCount</code> at any time or can set this number by <strong><code>TProcessID::SetObjectCount</code></strong>. To avoid a growing table of <code>fObjects</code> in <code>TProcessID</code>,
 in case, for example, one processes many events in a loop, it might be 
necessary to reset the object number at the end of processing of one 
event. See an example in <code>$ROOTSYS/test/Event.cxx</code> (look at function <code>Build</code>). The value of <code>ObjectNumber</code>may
 be saved at the beginning of one event and reset to this original value
 at the end of the event. These actions may be nested.</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb514-1" title="1">   saveNumber = TProcessID::GetObjectCount();</a>
<a class="sourceLine" id="cb514-2" title="2">...</a>
<a class="sourceLine" id="cb514-3" title="3">   TProcessID::SetObjectCount(savedNumber);</a></code></pre></div>
<h3 id="action-on-demand"><span class="header-section-number">11.4.5</span> Action on Demand</h3>
<p>The normal behavior of a <strong><code>TRef</code></strong> has been described above. In addition, <strong><code>TRef</code></strong>
 supports “Actions on Demand”. It may happen that the referenced object 
is not yet in the memory, on a separate file or not yet computed. In 
this case, <strong><code>TRef</code></strong> is able to execute automatically an action:</p>
<ul>
<li><p>Call to a compiled function (static function of member function)</p></li>
<li><p>Call to an interpreted function</p></li>
<li><p>Execution of a Cling script</p></li>
</ul>
<h4 id="how-to-select-this-option"><span class="header-section-number">11.4.5.1</span> How to Select This Option?</h4>
<p>In the definition of the <strong><code>TRef</code></strong> data member in the original class, do:</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb515-1" title="1">    TRef fRef;   <span class="co">//EXEC:execName points to something</span></a></code></pre></div>
<p>When the special keyword <code>"EXEC:"</code> is found in the comment field of the member, the next string is assumed to be the name of a <strong><code>TExec</code></strong> object. When a file is connected, the dictionary of the classes on the file is read in memory (see <strong><code>TFile::ReadStreamerInfo).</code> When the <code>TStreamerElement</code></strong> object is read, a <strong><code>TExec</code></strong> object is automatically created with the name specified after the keyword <code>"EXEC:"</code> in case a <strong><code>TExec</code></strong> with a same name does not already exist.</p>
<p>The action to be executed via <code>this</code> <strong><code>TExec</code></strong> can be specified with:</p>
<ul>
<li><p>A call to the <strong><code>TExec</code></strong> constructor, if the constructor is called before</p></li>
<li><p>Opening the file.</p></li>
<li><p>A call to <code>TExec::SetAction</code> at any time.</p></li>
</ul>
<p>One can compute a pointer to an existing <strong><code>TExec</code></strong> with a name with:</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb516-1" title="1">   TExec *myExec = gROOT-&gt;GetExec(execName);</a>
<a class="sourceLine" id="cb516-2" title="2">   myExec-&gt;SetAction(actionCommand);</a></code></pre></div>
<p>The parameter <code>actionCommand</code> is a string containing a Cling instruction. Examples:</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb517-1" title="1">   myExec-&gt;SetAction(<span class="st">"LoadHits()"</span>);</a>
<a class="sourceLine" id="cb517-2" title="2">   myExec-&gt;SetAction(<span class="st">".x script.C"</span>);</a></code></pre></div>
<p>When a <code>TRef</code> is de-referenced via <strong><code>TRef::GetObject</code>, its </strong><code>TExec</code>** is automatically executed. The <strong><code>TExec</code></strong> function/script can do one or more of the following:**</p>
<ul>
<li><p>Load a file containing the referenced object. This function typically looks in the file catalog.</p></li>
<li><p>Compute a pointer to the referenced object and communicate this pointer back to the calling function <strong><code>TRef</code></strong><code>::SetObject</code> via:</p></li>
</ul>
<div class="sourceCode" id="cb518"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb518-1" title="1">   TRef::SetObject(object)</a></code></pre></div>
<p>As soon as an object is returned to <code>GetObject</code>, the <code>fUniqueID</code> of the <strong><code>TRef</code></strong> is set to the <code>fUniqueID</code> of the referenced object. At the next call to <code>GetObject</code>, the pointer stored in <code>fPid:fObjects[fUniqueID]</code> will be returned directly. An example of action on demand is in <code>$ROOTSYS/test/Event.h</code>:</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb519-1" title="1">   TRef    fWebHistogram;       <span class="co">//EXEC:GetWebHistogram</span></a></code></pre></div>
<p>When calling <code>fWebHistogram.GetObject()</code>, the function <code>GetObject</code> will automatically invoke the script <code>GetWebHistogram.C</code> via the interpreter. An example of a <code>GetWebHistogram.C</code> script is shown below:</p>
<div class="sourceCode" id="cb520"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb520-1" title="1"><span class="dt">void</span> GetWebHistogram() {</a>
<a class="sourceLine" id="cb520-2" title="2">   TFile *f=TFile::Open(<span class="st">"http://root.cern.ch/files/pippa.root"</span>);</a>
<a class="sourceLine" id="cb520-3" title="3">   f-&gt;cd(<span class="st">"DM/CJ"</span>);</a>
<a class="sourceLine" id="cb520-4" title="4">   TH1 *h6 = (TH1*)gDirectory-&gt;Get(<span class="st">"h6"</span>);</a>
<a class="sourceLine" id="cb520-5" title="5">   h6-&gt;SetDirectory(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb520-6" title="6">   <span class="kw">delete</span> f;</a>
<a class="sourceLine" id="cb520-7" title="7">   TRef::SetObject(h6);</a>
<a class="sourceLine" id="cb520-8" title="8">}</a></code></pre></div>
<p>In the above example, a call to <code>fWebHistogram.GetObject()</code> executes the script with the function <code>GetWebHistogram</code>. This script connects a file with histograms: <code>pippa.root</code> on the ROOT Web site and returns the object <code>h6</code> to <strong><code>TRef</code></strong><code>::GetObject</code>.</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb521-1" title="1"> TRef    fWebHistogram;           <span class="co">//EXEC:GetWebHistogram()</span></a></code></pre></div>
<p>Note that if the definition of the <code>TRef fWebHistogram</code> had been changed the compiled or interpreted function <code>GetWebHistogram()</code> would have been called instead of the Cling script <code>GetWebHistogram.C.</code></p>
<h3 id="array-of-tref"><span class="header-section-number">11.4.6</span> Array of TRef</h3>
<p>When storing multiple <strong><code>TRef</code></strong>s, it is more efficient to use a <strong><code>TRefArray</code></strong>. The efficiency is due to having a single pointer <code>fPID</code> for all <code>TRefs</code> in the array. It has a dynamic compact table of <code>fUniqueIDs</code>. We recommend that you use a <strong><code>TRefArray</code></strong> rather then a collection of <code>TRefs</code>.</p>
<p>Example:</p>
<ul>
<li><p>Suppose a <code>TObjArray *mytracks</code> containing a list of <code>Track</code> objects.</p></li>
<li><p>Suppose a <code>TRefArray *pions</code> containing pointers to the pion tracks in <code>mytracks</code>. This list is created with statements like: <code>pions-&gt;Add(track);</code></p></li>
<li><p>Suppose a <code>TRefArray *muons</code> containing pointers to the muon tracks in <code>mytracks</code>.</p></li>
</ul>
<p>The 3 arrays <code>mytracks</code>,<code>pions</code> and <code>muons</code> may be written separately.</p>
<h2 id="schema-evolution"><span class="header-section-number">11.5</span> Schema Evolution</h2>
<p>Schema evolution is a problem faced by long-lived data. When a schema
 changes, existing persistent data can become inaccessible unless the 
system provides a mechanism to access data created with previous 
versions of the schema. In the lifetime of collaboration, the class 
definitions (i.e.&nbsp;the schema) are likely to change frequently. Not 
only can the class itself change, but any of its parent classes or data 
member classes can change also. This makes the support for schema 
evolution necessary.</p>
<p>ROOT fully supports schema evolution. The next figure below illustrates some of the scenarios.</p>
<figure>
<img src="ROOTUsersGuide_files/020000ED.jpg" alt="The ROOT schema evolution"><figcaption>The ROOT schema evolution</figcaption>
</figure>
<p>The top half represents different versions of the shared library with
 the class definitions. These are the in-memory class versions. The 
bottom half represents data files that contain different versions of the
 classes.</p>
<ul>
<li><p>An old version of a shared library and a file with new class 
definitions - this can be the case when someone has not updated the 
library and is reading a new file.</p></li>
<li><p>Reading a file with a shared library that is missing a class definition (i.e.&nbsp;missing class D).</p></li>
<li><p>Reading a file without any class definitions. This can be the case where the class definition is lost, or unavailable.</p></li>
<li><p>The current version of a shared library and an old file with old 
class versions (backward compatibility). This is often the case when 
reading old data.</p></li>
<li><p>Reading a file with a shared library built with <code>MakeProject</code>. This is the case when someone has already read the data without a shared library and has used ROOT <code>MakeProject</code> feature to reconstruct the class definitions and shared library (<code>MakeProject</code> is explained in detail later on).</p></li>
</ul>
<p>In case of a mismatch between the in-memory version and the 
persistent version of a class, ROOT maps the persistent one to the one 
in memory. This allows you to change the class definition at will, for 
example:</p>
<ul>
<li><p>Change the order of data members in the class.</p></li>
<li><p>Add new data members. By default, the value of the missing member will be 0 or in case of an object it will be set to null.</p></li>
<li><p>Remove data members.</p></li>
<li><p>Move a data member to a base class or vice-versa.</p></li>
<li><p>Change the type of a member if it is a simple type or a pointer 
to a simple type. If a loss of precision occurs, a warning is given.</p></li>
<li><p>Add or remove a base class</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/020000EE.jpg" alt="The schema evolution for objects written on disk and in memory"><figcaption>The schema evolution for objects written on disk and in memory</figcaption>
</figure>
<p>ROOT supports schema evolution by keeping a class description of each
 version of the class that was ever written to disk, with the class. 
When it writes an object to file, it also writes the description of the 
current class version along with it. This description is implemented in 
the <code>StreamerInfo</code>class.</p>
<h3 id="the-tstreamerinfo-class"><span class="header-section-number">11.5.1</span> The TStreamerInfo Class</h3>
<p>Each class has a list of <code>StreamerInfo</code> objects, one for 
each version of the class if that version was written to disk at least 
once. When reading an object from a file, the system uses the <code>StreamerInfo</code> list to decode an object into the current version. The <code>StreamerInfo</code> is made up of <strong><code>TStreamerElements</code></strong>
 . Each describes one persistent data member of the class. By default, 
all data members of a class are persistent. To exclude a data member 
(i.e.&nbsp;make it not persistent), add a “<code>!</code>” after the comment marks. For example the pointer *<code>fPainter</code> of a <strong><code>TH1</code></strong> is not persistent:</p>
<div class="sourceCode" id="cb522"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb522-1" title="1">   TVirtualHistPainter* fPainter <span class="co">//!pointer to histogram painter</span></a></code></pre></div>
<h3 id="the-tstreamerelement-class"><span class="header-section-number">11.5.2</span> The TStreamerElement Class</h3>
<p>A <strong><code>TStreamerElement</code></strong> describes a data member of a simple type, object, array, pointer, or container. The offset in the <strong><code>TStreamerElement</code></strong> is the starting address of the data for that data member.</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb523-1" title="1">BASE   TNamed        offset=  <span class="dv">0</span> type=<span class="dv">67</span> The basis <span class="cf">for</span> a named object</a>
<a class="sourceLine" id="cb523-2" title="2">BASE   TAttLine      offset= <span class="dv">28</span> type= <span class="dv">0</span> Line attributes</a></code></pre></div>
<p>In this example, the <strong><code>TNamed</code></strong> data starts at byte 0, and <strong><code>TAttLine</code></strong> starts at byte 28. The offset is machine and compiler dependent and is computed when the <code>StreamerInfo</code> is analyzed. The types are defined in the file <code>TStreamerInfo.h</code> and listed here:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb524-1" title="1"><span class="kw">enum</span> EReadWrite {</a>
<a class="sourceLine" id="cb524-2" title="2">kBase=<span class="dv">0</span>,   kChar=<span class="dv">1</span>,kShort=<span class="dv">2</span>,kInt=<span class="dv">3</span>,kLong=<span class="dv">4</span>,</a>
<a class="sourceLine" id="cb524-3" title="3">kFloat=<span class="dv">5</span>,         kCounter=<span class="dv">6</span>,kCharStar=<span class="dv">7</span>, kDouble=<span class="dv">8</span>,kUChar=<span class="dv">11</span>,</a>
<a class="sourceLine" id="cb524-4" title="4">kUShort=<span class="dv">12</span>,         kUInt=<span class="dv">13</span>,kULong=<span class="dv">14</span>,kBits=<span class="dv">15</span>,kOffsetL=<span class="dv">20</span>,</a>
<a class="sourceLine" id="cb524-5" title="5">kOffsetP=<span class="dv">40</span>,  kObject=<span class="dv">61</span>,kAny=<span class="dv">62</span>,kObjectp=<span class="dv">63</span>,kObjectP=<span class="dv">64</span>,</a>
<a class="sourceLine" id="cb524-6" title="6">kTString=<span class="dv">65</span>,  kTObject=<span class="dv">66</span>,kTNamed=<span class="dv">67</span>,kSkip=<span class="dv">100</span>,kSkipL=<span class="dv">120</span>,</a>
<a class="sourceLine" id="cb524-7" title="7">kSkipP=<span class="dv">140</span>,    kConv=<span class="dv">200</span>,       kConvL=<span class="dv">220</span>,kConvP=<span class="dv">240</span>,kStreamer=<span class="dv">500</span>,</a>
<a class="sourceLine" id="cb524-8" title="8">kStreamLoop=<span class="dv">501</span>,    kMissing=<span class="dv">99999</span></a>
<a class="sourceLine" id="cb524-9" title="9">};</a></code></pre></div>
<p>The method <code>TClass::GetStreamerInfo</code> analyzes the <code>StreamerInfo</code> the same way it would be analyzed by referring to the class. While analyzing the <code>StreamerInfo</code>, it computes the offsets. The type field is the type of the <strong><code>TStreamerElement</code></strong>. It is specific to the <code>StreamerInfo</code> definition.</p>
<h3 id="example-th1-streamerinfo"><span class="header-section-number">11.5.3</span> Example: TH1 StreamerInfo</h3>
<p>In the <code>StreamerInfo</code> of the <strong><code>TH1</code></strong> class we see the four base classes: <strong><code>TNamed</code></strong>, <strong><code>TAttLine</code></strong>, <strong><code>TAttFill</code></strong>, <code>and</code><strong><code>TAttMarker</code></strong>. These are followed by a list of the data members. Each data member is implemented by a <strong><code>TStreamerElement</code></strong> object.</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb525-1" title="1">root[] TH1::Class()-&gt;GetStreamerInfo()-&gt;ls()</a>
<a class="sourceLine" id="cb525-2" title="2">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: TH1, version=<span class="dv">3</span></a>
<a class="sourceLine" id="cb525-3" title="3">BASE    TNamed  offset=  <span class="dv">0</span> type=<span class="dv">67</span> The basis <span class="cf">for</span> a named object</a>
<a class="sourceLine" id="cb525-4" title="4">BASE    TAttLine      offset= <span class="dv">28</span> type= <span class="dv">0</span> Line attributes</a>
<a class="sourceLine" id="cb525-5" title="5">BASE    TAttFill      offset= <span class="dv">40</span> type= <span class="dv">0</span> Fill area attributes</a>
<a class="sourceLine" id="cb525-6" title="6">BASE    TAttMarker    offset= <span class="dv">48</span> type= <span class="dv">0</span> Marker attributes</a>
<a class="sourceLine" id="cb525-7" title="7"><span class="dt">Int_t</span>   fNcells       offset= <span class="dv">60</span> type= <span class="dv">3</span> number of bins(<span class="dv">1</span><span class="er">D</span></a>
<a class="sourceLine" id="cb525-8" title="8">TAxis   fXaxis        offset= <span class="dv">64</span> type=<span class="dv">61</span> X axis descriptor</a>
<a class="sourceLine" id="cb525-9" title="9">TAxis   fYaxis        offset=<span class="dv">192</span> type=<span class="dv">61</span> Y axis descriptor</a>
<a class="sourceLine" id="cb525-10" title="10">TAxis   fZaxis        offset=<span class="dv">320</span> type=<span class="dv">61</span> Z axis descriptor</a>
<a class="sourceLine" id="cb525-11" title="11"><span class="dt">Short_t</span> fBarOffset    offset=<span class="dv">448</span> type= <span class="dv">2</span>(<span class="dv">1000</span>*offset)<span class="cf">for</span> bar charts <span class="kw">or</span> legos</a>
<a class="sourceLine" id="cb525-12" title="12"><span class="dt">Short_t</span> fBarWidth     offset=<span class="dv">450</span> type= <span class="dv">2</span> (<span class="dv">1000</span>*width)<span class="cf">for</span> bar charts <span class="kw">or</span> legos</a>
<a class="sourceLine" id="cb525-13" title="13"><span class="dt">Stat_t</span>  fEntries      offset=<span class="dv">452</span> type= <span class="dv">8</span> Number of entries</a>
<a class="sourceLine" id="cb525-14" title="14"><span class="dt">Stat_t</span>  fTsumw        offset=<span class="dv">460</span> type= <span class="dv">8</span> Total Sum of weights</a>
<a class="sourceLine" id="cb525-15" title="15"><span class="dt">Stat_t</span>  fTsumw2       offset=<span class="dv">468</span> type= <span class="dv">8</span> Total Sum of squares of weights</a>
<a class="sourceLine" id="cb525-16" title="16"><span class="dt">Stat_t</span>  fTsumwx       offset=<span class="dv">476</span> type= <span class="dv">8</span> Total Sum of weight*X</a>
<a class="sourceLine" id="cb525-17" title="17"><span class="dt">Stat_t</span>  fTsumwx2      offset=<span class="dv">484</span> type= <span class="dv">8</span> Total Sum of weight*X*X</a>
<a class="sourceLine" id="cb525-18" title="18"><span class="dt">Double_t</span> fMaximum     offset=<span class="dv">492</span> type= <span class="dv">8</span> Maximum value <span class="cf">for</span> plotting</a>
<a class="sourceLine" id="cb525-19" title="19"><span class="dt">Double_t</span> fMinimum     offset=<span class="dv">500</span> type= <span class="dv">8</span> Minimum value <span class="cf">for</span> plotting</a>
<a class="sourceLine" id="cb525-20" title="20"><span class="dt">Double_t</span> fNormFactor  offset=<span class="dv">508</span> type= <span class="dv">8</span> Normalization factor</a>
<a class="sourceLine" id="cb525-21" title="21">TArrayD  fContour     offset=<span class="dv">516</span> type=<span class="dv">62</span> Array to display contour levels</a>
<a class="sourceLine" id="cb525-22" title="22">TArrayD  fSumw2       offset=<span class="dv">528</span> type=<span class="dv">62</span> Array of sum of squares of weights</a>
<a class="sourceLine" id="cb525-23" title="23">TString  fOption      offset=<span class="dv">540</span> type=<span class="dv">65</span> histogram options</a>
<a class="sourceLine" id="cb525-24" title="24">TList*   fFunctions   offset=<span class="dv">548</span> type=<span class="dv">63</span> -&gt;Pointer to list of functions</a>
<a class="sourceLine" id="cb525-25" title="25">i= <span class="dv">0</span>, TNamed       type= <span class="dv">67</span>, offset=  <span class="dv">0</span>, len=<span class="dv">1</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb525-26" title="26">i= <span class="dv">1</span>, TAttLine     type=  <span class="dv">0</span>, offset= <span class="dv">28</span>, len=<span class="dv">1</span>, method=<span class="dv">142484480</span></a>
<a class="sourceLine" id="cb525-27" title="27">i= <span class="dv">2</span>, TAttFill     type=  <span class="dv">0</span>, offset= <span class="dv">40</span>, len=<span class="dv">1</span>, method=<span class="dv">142496992</span></a>
<a class="sourceLine" id="cb525-28" title="28">i= <span class="dv">3</span>, TAttMarker   type=  <span class="dv">0</span>, offset= <span class="dv">48</span>, len=<span class="dv">1</span>, method=<span class="dv">142509704</span></a>
<a class="sourceLine" id="cb525-29" title="29">i= <span class="dv">4</span>, fNcells      type=  <span class="dv">3</span>, offset= <span class="dv">60</span>, len=<span class="dv">1</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb525-30" title="30">i= <span class="dv">5</span>, fXaxis       type= <span class="dv">61</span>, offset= <span class="dv">64</span>, len=<span class="dv">1</span>, method=<span class="dv">1081287424</span></a>
<a class="sourceLine" id="cb525-31" title="31">i= <span class="dv">6</span>, fYaxis       type= <span class="dv">61</span>, offset=<span class="dv">192</span>, len=<span class="dv">1</span>, method=<span class="dv">1081287548</span></a>
<a class="sourceLine" id="cb525-32" title="32">i= <span class="dv">7</span>, fZaxis       type= <span class="dv">61</span>, offset=<span class="dv">320</span>, len=<span class="dv">1</span>, method=<span class="dv">1081287676</span></a>
<a class="sourceLine" id="cb525-33" title="33">i= <span class="dv">8</span>, fBarOffset   type= <span class="dv">22</span>, offset=<span class="dv">448</span>, len=<span class="dv">2</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb525-34" title="34">i= <span class="dv">9</span>, fEntries     type= <span class="dv">28</span>, offset=<span class="dv">452</span>, len=<span class="dv">8</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb525-35" title="35">i=<span class="dv">10</span>, fContour     type= <span class="dv">62</span>, offset=<span class="dv">516</span>, len=<span class="dv">1</span>, method=<span class="dv">1081287804</span></a>
<a class="sourceLine" id="cb525-36" title="36">i=<span class="dv">11</span>, fSumw2       type= <span class="dv">62</span>, offset=<span class="dv">528</span>, len=<span class="dv">1</span>, method=<span class="dv">1081287924</span></a>
<a class="sourceLine" id="cb525-37" title="37">i=<span class="dv">12</span>, fOption      type= <span class="dv">65</span>, offset=<span class="dv">540</span>, len=<span class="dv">1</span>, method=<span class="dv">1081288044</span></a>
<a class="sourceLine" id="cb525-38" title="38">i=<span class="dv">13</span>, fFunctions   type= <span class="dv">63</span>, offset=<span class="dv">548</span>, len=<span class="dv">1</span>, method=<span class="dv">1081288164</span></a></code></pre></div>
<h3 id="optimized-streamerinfo"><span class="header-section-number">11.5.4</span> Optimized StreamerInfo</h3>
<p>The entries starting with “<code>i = 0</code>” is the optimized format of the <code>StreamerInfo</code>.
 Consecutive data members of the same simple type and size are collapsed
 and read at once into an array for performance optimization.</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb526-1" title="1">i= <span class="dv">0</span>, TNamed       type= <span class="dv">67</span>, offset=  <span class="dv">0</span>, len=<span class="dv">1</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb526-2" title="2">i= <span class="dv">1</span>, TAttLine     type=  <span class="dv">0</span>, offset= <span class="dv">28</span>, len=<span class="dv">1</span>, method=<span class="dv">142484480</span></a>
<a class="sourceLine" id="cb526-3" title="3">i= <span class="dv">2</span>, TAttFill     type=  <span class="dv">0</span>, offset= <span class="dv">40</span>, len=<span class="dv">1</span>, method=<span class="dv">142496992</span></a>
<a class="sourceLine" id="cb526-4" title="4">i= <span class="dv">3</span>, TAttMarker   type=  <span class="dv">0</span>, offset= <span class="dv">48</span>, len=<span class="dv">1</span>, method=<span class="dv">142509704</span></a></code></pre></div>
<p>For example, the five data members beginning with <code>fEnties</code>and the three data members beginning with <code>fMaximum</code>, are put into an array called <code>fEntries</code> (<code>i = 9</code>) with the length 8.</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb527-1" title="1">i= <span class="dv">9</span>, fEntries     type= <span class="dv">28</span>, offset=<span class="dv">452</span>, len=<span class="dv">8</span>, method=<span class="dv">0</span></a></code></pre></div>
<p>Only simple type data members are combined, object data members are 
not combined. For example the three axis data members remain separate. 
The “method” is a handle to the method that reads the object.</p>
<h3 id="automatic-schema-evolution"><span class="header-section-number">11.5.5</span> Automatic Schema Evolution</h3>
<p>When a class is defined in ROOT, it must include the <code>ClassDef</code> macro as the last line in the header file inside the class definition. The syntax is:</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb528-1" title="1">ClassDef(&lt;ClassName&gt;,&lt;VersionNumber&gt;)</a></code></pre></div>
<p>The version number identifies this particular version of the class. 
When a class has version 0 it is not stored in a root file but its base 
class(es) is(are). The reason can be that this class has no data members
 worth saving or all real info is in the base classes. The version 
number is written to the file in the <code>Streamer</code> by the call <code>TBuffer::WriteVersion</code>. You, as the designer of the class, do not need to do any manual modification in the <code>Streamer</code>. ROOT schema evolution mechanism is automatic and handled by the <code>StreamerInfo</code>.</p>
<h3 id="manual-data-model-evolution-capabilities"><span class="header-section-number">11.5.6</span> Manual Data Model Evolution Capabilities</h3>
<p>The automatic data model schema evolution implemented in ROOT makes 
it possible to read back the serialized data object in the situation 
when the definition of the classes those objects represent changed 
slightly (some of the data members were removed or some new ones added).
 It is also possible to manually specify the rules for more 
sophisticated data transformations done while reading to load the 
serialized objects into data structures that changed quite 
significantly.</p>
<p>ROOT provides two interface enabling users to specify the conversion 
rules. The first way is to define a rule in the dictionary file and the 
second way is to insert it to the TClass object using the C++ API.</p>
<p>There are two types of conversion rules. The first of them, the 
normal rules, are the ones that should be used in the most of the cases.
 They provide a buffered input data and an address of the in-memory 
target object and allow user to specify the conversion function mapping 
the data being read to the output format. The second type of the rules, 
the raw rules, also provide the pointer to the target object but the 
input is a raw TBuffer object containing the input data member declared 
as an input to the rule. This type of a rule is provided mainly to 
handle the file format changes that couldn’t have been handled otherwise
 and in general should not be used unless there is no other option.</p>
<h4 id="the-dictionaries"><span class="header-section-number">11.5.6.1</span> The dictionaries</h4>
<p>The most convenient place to specify the conversion rules is a 
dictionary. One can do that either in a LinkDef file or in the selection
 xml file being fed to genreflex. The syntax of the rules is the 
following:</p>
<ul>
<li>For dictionaries created from a LinkDef file:</li>
</ul>
<div class="sourceCode" id="cb529"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb529-1" title="1"><span class="pp">#pragma read                                              \</span></a>
<a class="sourceLine" id="cb529-2" title="2"><span class="pp">    sourceClass="ClassA"                                  \</span></a>
<a class="sourceLine" id="cb529-3" title="3"><span class="pp">    source="double m_a; double m_b; double m_c"           \</span></a>
<a class="sourceLine" id="cb529-4" title="4"><span class="pp">    version="[4-5,7,9,12-]"                               \</span></a>
<a class="sourceLine" id="cb529-5" title="5"><span class="pp">    checksum="[12345,123456]"                             \</span></a>
<a class="sourceLine" id="cb529-6" title="6"><span class="pp">    targetClass="ClassB"                                  \</span></a>
<a class="sourceLine" id="cb529-7" title="7"><span class="pp">    target="m_x"                                          \</span></a>
<a class="sourceLine" id="cb529-8" title="8"><span class="pp">    embed="true"                                          \</span></a>
<a class="sourceLine" id="cb529-9" title="9"><span class="pp">    include="iostream,cstdlib"                            \</span></a>
<a class="sourceLine" id="cb529-10" title="10"><span class="pp">    code="{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }" \</span></a>
<a class="sourceLine" id="cb529-11" title="11"></a>
<a class="sourceLine" id="cb529-12" title="12"></a>
<a class="sourceLine" id="cb529-13" title="13"><span class="pp">#pragma readraw           \</span></a>
<a class="sourceLine" id="cb529-14" title="14"><span class="pp">      sourceClass="TAxis" \</span></a>
<a class="sourceLine" id="cb529-15" title="15"><span class="pp">      source="fXbins"     \</span></a>
<a class="sourceLine" id="cb529-16" title="16"><span class="pp">      targetClass="TAxis" \</span></a>
<a class="sourceLine" id="cb529-17" title="17"><span class="pp">      target="fXbins"     \</span></a>
<a class="sourceLine" id="cb529-18" title="18"><span class="pp">      version="[-5]"      \</span></a>
<a class="sourceLine" id="cb529-19" title="19"><span class="pp">      include="TAxis.h"   \</span></a>
<a class="sourceLine" id="cb529-20" title="20"><span class="pp">      code="\</span></a>
<a class="sourceLine" id="cb529-21" title="21"><span class="pp">{\</span></a>
<a class="sourceLine" id="cb529-22" title="22"><span class="pp">Float_t * xbins=0; \</span></a>
<a class="sourceLine" id="cb529-23" title="23"><span class="pp">Int_t n = buffer.ReadArray( xbins ); \</span></a>
<a class="sourceLine" id="cb529-24" title="24"><span class="pp">fXbins.Set( xbins ); \</span></a>
<a class="sourceLine" id="cb529-25" title="25"><span class="pp">}"</span></a></code></pre></div>
<ul>
<li>For REFLEX dictionaries:</li>
</ul>
<div class="sourceCode" id="cb530"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb530-1" title="1">&lt;ioread sourceClass=<span class="st">"ClassA"</span></a>
<a class="sourceLine" id="cb530-2" title="2">        source=<span class="st">"double m_a; double m_b; double m_c"</span></a>
<a class="sourceLine" id="cb530-3" title="3">        version=<span class="st">"[4-5,7,9,12-]"</span></a>
<a class="sourceLine" id="cb530-4" title="4">        checksum=<span class="st">"[12345,123456]"</span></a>
<a class="sourceLine" id="cb530-5" title="5">        targetClass=<span class="st">"ClassB"</span></a>
<a class="sourceLine" id="cb530-6" title="6">        target=<span class="st">"m_x"</span></a>
<a class="sourceLine" id="cb530-7" title="7">        embed=<span class="st">"true"</span></a>
<a class="sourceLine" id="cb530-8" title="8">        include=<span class="st">"iostream,cstdlib"</span>&gt;</a>
<a class="sourceLine" id="cb530-9" title="9">&lt;![CDATA[</a>
<a class="sourceLine" id="cb530-10" title="10">   <span class="va">m_x</span> = onfile.<span class="va">m_a</span> * onfile.<span class="va">m_b</span> * onfile.<span class="va">m_c</span>;</a>
<a class="sourceLine" id="cb530-11" title="11">]] &gt;</a>
<a class="sourceLine" id="cb530-12" title="12">&lt;/ioread&gt;</a>
<a class="sourceLine" id="cb530-13" title="13"></a>
<a class="sourceLine" id="cb530-14" title="14">&lt;ioreadraw sourceClass=<span class="st">"TAxis"</span></a>
<a class="sourceLine" id="cb530-15" title="15">           source=<span class="st">"fXbins"</span></a>
<a class="sourceLine" id="cb530-16" title="16">           targetClass=<span class="st">"TAxis"</span></a>
<a class="sourceLine" id="cb530-17" title="17">           target=<span class="st">"fXbins"</span></a>
<a class="sourceLine" id="cb530-18" title="18">           version=<span class="st">"[-5]"</span></a>
<a class="sourceLine" id="cb530-19" title="19">           include=<span class="st">"TAxis.h"</span>&gt;</a>
<a class="sourceLine" id="cb530-20" title="20">&lt;![CDATA[</a>
<a class="sourceLine" id="cb530-21" title="21">      <span class="dt">Float_t</span> *xbins = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb530-22" title="22">      <span class="dt">Int_t</span> n = buffer.ReadArray( xbins ) ;</a>
<a class="sourceLine" id="cb530-23" title="23">      fXbins.Set( xbins );</a>
<a class="sourceLine" id="cb530-24" title="24">]] &gt;</a>
<a class="sourceLine" id="cb530-25" title="25">&lt;/ioreadraw&gt;</a></code></pre></div>
<p>The variables in the rules have the following meaning:</p>
<ul>
<li>sourceClass
<ul>
<li>The field defines the on-disk class that is the input for the rule.</li>
</ul></li>
<li>source
<ul>
<li>A semicolon-separated list of values defining the source class data 
members that need to be cached and accessible via object proxy when the 
rule is executed. The values are either the names of the data members or
 the type-name pairs (separated by a space). If types are specified then
 the ondisk structure can be generated and used in the code snippet 
defined by the user.</li>
</ul></li>
<li>version
<ul>
<li>A list of versions of the source class that can be an input for this
 rule. The list has to be enclosed in a square bracket and be a 
comma-separated list of versions or version ranges. The version is an 
integer number, whereas the version range is one of the following:</li>
<li>“a-b”: a and b are integers and the expression means all the numbers between and including a and b</li>
<li>“-a”: a is an integer and the expression means all the version numbers smaller than or equal to a</li>
<li>“a-”: a is an integer and the expression means all the version numbers greater than or equal to a</li>
</ul></li>
<li>checksum
<ul>
<li>A list of checksums of the source class that can be an input for 
this rule. The list has to be enclosed in a square brackets and is a 
comma-separated list of integers.</li>
</ul></li>
<li>targetClass
<ul>
<li>The field is obligatory and defines the name of the in-memory class that this rule can be applied to.</li>
</ul></li>
<li>target
<ul>
<li>A comma-separated list of target class data member names that this rule is capable of calculating.</li>
</ul></li>
<li>embed
<ul>
<li>This property tells the system if the rule should be written in the output file is some objects of this class are serialized.</li>
</ul></li>
<li>include
<ul>
<li>A list of header files that should be included in order to provide 
the functionality used in the code snippet; the list is comma delimited.</li>
</ul></li>
<li>code
<ul>
<li>An user specified code snippet</li>
</ul></li>
</ul>
<p>The user can assume that in the provided code snippet the following variables will be defined:</p>
<pre><code>The user provided code snippets have to consist of valid C++ code. The system can do</code></pre>
<p>some preprocessing before wrapping the code into function calls and 
declare some variables to facilitate the rule definitions. The user can 
expect the following variables being predeclared:</p>
<ul>
<li>newObj
<ul>
<li>variable representing the target in-memory object, its type is that of the target object</li>
</ul></li>
<li>oldObj
<ul>
<li>in normal conversion rules, an object of TVirtualObject class 
representing the input data, guaranteed to hold the data members 
declared in the source property of the rule</li>
</ul></li>
<li>buffer
<ul>
<li>in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule</li>
</ul></li>
<li>names of the data members of the target object declared in the target property of the rule declared to be the appropriate type</li>
<li>onfile.xxx
<ul>
<li>in normal conversion rules, names of the variables of basic types declared in the source property of the rule</li>
</ul></li>
</ul>
<h4 id="the-c-api"><span class="header-section-number">11.5.6.2</span> The C++ API</h4>
<p>The schema evolution C++ API consists of two classes: <code>ROOT::TSchemaRuleSet</code> and <code>ROOT::TSchemaRule</code>.
 Objects of the TSchemaRule class represent the rules and their fields 
have exactly the same meaning as the ones of rules specified in the 
dictionaries. <code>TSchemaRuleSet</code> objects manage the sets of 
rules and ensure their consistency. There can be no conflicting rules in
 the rule sets. The rule sets are owned by the <code>TClass</code> objects corresponding to the target classes defined in the rules and can be accessed using <code>TClass::{Get|Adopt}SchemaRules</code>.</p>
<h3 id="manual-schema-evolution"><span class="header-section-number">11.5.7</span> Manual Schema Evolution</h3>
<p>If you have written your own <code>Streamer</code> as described in 
the section “Streamers with Special Additions”, you will have to 
manually add code for each version and manage the evolution of your 
class. When you add or remove data members, you must modify the <code>Streamer</code> by hand. ROOT assumes that you have increased the class version number in the <code>ClassDef</code> statement and introduced the relevant test in the read part of the Streamer. For example, if a new version of the <code>Event</code> class above includes a new member: <code>Int_t fNew</code> the <code>ClassDef</code> statement should be changed to <code>ClassDef(Event,2)</code> and the following lines should be added to the read part of the <code>Streamer</code>:</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb532-1" title="1">   <span class="cf">if</span> (R__v &gt; <span class="dv">1</span>) R__b &gt;&gt; fNew;</a>
<a class="sourceLine" id="cb532-2" title="2">   <span class="cf">else</span> fNew = <span class="dv">0</span>;        <span class="co">// set to some default value</span></a></code></pre></div>
<p>If, in the same new version 2 you remove the member <code>fH</code>, you must add the following code to read the histogram object into some temporary object and delete it:</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb533-1" title="1"><span class="cf">if</span> (R__v) &lt; <span class="dv">2</span> {</a>
<a class="sourceLine" id="cb533-2" title="2">   TH1F *dummy = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb533-3" title="3">   R__b &gt;&gt; dummy;</a>
<a class="sourceLine" id="cb533-4" title="4">   <span class="kw">delete</span> dummy;</a>
<a class="sourceLine" id="cb533-5" title="5">}</a></code></pre></div>
<p>Our experience with manual schema evolution shows that it is easy to make and mismatches between <code>Streamer</code> writers and readers are frequent and increase as the number of classes increase. We recommend you use <code>rootcling</code> generated <code>Streamers</code> whenever you can, and profit from the automatic schema evolution.</p>
<h3 id="building-class-definitions-with-the-streamerinfo"><span class="header-section-number">11.5.8</span> Building Class Definitions with the StreamerInfo</h3>
<p>A ROOT file’s <code>StreamerInfo</code>list contains the description of all versions of all classes in the file. When a file is opened the <code>StreamerInfo</code>is read into memory and it provides enough information to make the file browsable. The <code>TStreamerInfo</code>enables us to recreate a header file for the class in case the compiled class is not available. This is done with the <code>TFile::MakeProject</code> method. It creates a directory with the header files for the named classes and a <code>makefile</code> to compile a shared library with the class definitions.</p>
<h3 id="example-makeproject"><span class="header-section-number">11.5.9</span> Example: MakeProject</h3>
<p>To explain the details, we use the example of the <code>ATLFast</code> project that is a fast simulation for the ATLAS experiment. The complete source for <code>ATLFast</code> can be down loaded at <a href="ftp://root.cern.ch/root/atlfast.tar.gz" class="uri">ftp://root.cern.ch/root/atlfast.tar.gz</a>. Once we compile and run <code>ATLFast</code> we get a ROOT file called <code>atlfast.root</code>, containing the <code>ATLFast</code>
 objects. When we open the file, we get a warning that the file contains
 classes that are not in the dictionary. This is correct since we did 
not load the class definitions.</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb534-1" title="1">root[] TFile f(<span class="st">"atlfast.root"</span>)</a>
<a class="sourceLine" id="cb534-2" title="2">Warning in &lt;TClass::TClass&gt;: no dictionary <span class="cf">for</span> <span class="kw">class</span> TMCParticle is available</a>
<a class="sourceLine" id="cb534-3" title="3">Warning in &lt;TClass::TClass&gt;: no dictionary <span class="cf">for</span> <span class="kw">class</span> ATLFMuon available</a></code></pre></div>
<p>We can see the <code>StreamerInfo</code>for the classes:</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb535-1" title="1">root[] f.ShowStreamerInfo()</a>
<a class="sourceLine" id="cb535-2" title="2">...</a>
<a class="sourceLine" id="cb535-3" title="3">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: ATLFMuon, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb535-4" title="4">BASE  TObject      offset=  <span class="dv">0</span> type=<span class="dv">66</span> Basic ROOT object</a>
<a class="sourceLine" id="cb535-5" title="5">BASE  TAtt3D       offset=  <span class="dv">0</span> type= <span class="dv">0</span> <span class="dv">3</span><span class="er">D</span> attributes</a>
<a class="sourceLine" id="cb535-6" title="6"><span class="dt">Int_t</span> <span class="va">m_KFcode</span>     offset=  <span class="dv">0</span> type= <span class="dv">3</span> Muon KF-code</a>
<a class="sourceLine" id="cb535-7" title="7"><span class="dt">Int_t</span> <span class="va">m_MCParticle</span> offset=  <span class="dv">0</span> type= <span class="dv">3</span> Muon position in MCParticles list</a>
<a class="sourceLine" id="cb535-8" title="8"><span class="dt">Int_t</span> <span class="va">m_KFmother</span>   offset=  <span class="dv">0</span> type= <span class="dv">3</span> Muon mother KF-code</a>
<a class="sourceLine" id="cb535-9" title="9"><span class="dt">Int_t</span> <span class="va">m_UseFlag</span>    offset=  <span class="dv">0</span> type= <span class="dv">3</span> Muon energy usage flag</a>
<a class="sourceLine" id="cb535-10" title="10"><span class="dt">Int_t</span> <span class="va">m_Isolated</span>   offset=  <span class="dv">0</span> type= <span class="dv">3</span> Muon isolation (<span class="dv">1</span> <span class="cf">for</span> isolated)</a>
<a class="sourceLine" id="cb535-11" title="11"><span class="dt">Float_t</span> <span class="va">m_Eta</span>      offset=  <span class="dv">0</span> type= <span class="dv">5</span> Eta coordinate</a>
<a class="sourceLine" id="cb535-12" title="12"><span class="dt">Float_t</span> <span class="va">m_Phi</span>      offset=  <span class="dv">0</span> type= <span class="dv">5</span> Phi coordinate</a>
<a class="sourceLine" id="cb535-13" title="13"><span class="dt">Float_t</span> <span class="va">m_PT</span>       offset=  <span class="dv">0</span> type= <span class="dv">5</span> Transverse energy</a>
<a class="sourceLine" id="cb535-14" title="14"><span class="dt">Int_t</span>   <span class="va">m_Trigger</span>  offset=  <span class="dv">0</span> type= <span class="dv">3</span> Result of trigger...</a></code></pre></div>
<p>However, when we try to use a specific class we get a warning because
 the class is not in the dictionary. We can create a class using <code>gROOT-&gt;GetClass()</code> which makes a fake class from the <code>StreamerInfo</code>.</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb536-1" title="1"><span class="co">// Build a 'fake' class</span></a>
<a class="sourceLine" id="cb536-2" title="2">root[] gROOT-&gt;GetClass(<span class="st">"ATLFMuon"</span>)</a>
<a class="sourceLine" id="cb536-3" title="3">(<span class="at">const</span> <span class="kw">class</span> TClass*)<span class="bn">0x87e5c08</span></a>
<a class="sourceLine" id="cb536-4" title="4"><span class="co">// The fake class has a StreamerInfo</span></a>
<a class="sourceLine" id="cb536-5" title="5">root[] gROOT-&gt;GetClass(<span class="st">"ATLFMuon"</span>)-&gt;GetStreamerInfo()-&gt;ls()</a>
<a class="sourceLine" id="cb536-6" title="6">StreamerInfo <span class="cf">for</span> <span class="kw">class</span>: ATLFMuon, version=<span class="dv">1</span></a>
<a class="sourceLine" id="cb536-7" title="7">  BASE    TObject       offset=  <span class="dv">0</span> type=<span class="dv">66</span> Basic ROOT object</a>
<a class="sourceLine" id="cb536-8" title="8">  BASE    TAtt3D        offset=  <span class="dv">0</span> type= <span class="dv">0</span> <span class="dv">3</span><span class="er">D</span> attributes</a>
<a class="sourceLine" id="cb536-9" title="9">  <span class="dt">Int_t</span>   <span class="va">m_KFcode</span>      offset= <span class="dv">16</span> type= <span class="dv">3</span> Muon KF-code</a>
<a class="sourceLine" id="cb536-10" title="10">  <span class="dt">Int_t</span>   <span class="va">m_MCParticle</span>  offset= <span class="dv">20</span> type= <span class="dv">3</span> Muon position in MCParticles list</a>
<a class="sourceLine" id="cb536-11" title="11">  <span class="dt">Int_t</span>   <span class="va">m_KFmother</span>    offset= <span class="dv">24</span> type= <span class="dv">3</span> Muon mother KF-code</a>
<a class="sourceLine" id="cb536-12" title="12">  <span class="dt">Int_t</span>   <span class="va">m_UseFlag</span>     offset= <span class="dv">28</span> type= <span class="dv">3</span> Muon energy usage flag</a>
<a class="sourceLine" id="cb536-13" title="13">  <span class="dt">Int_t</span>   <span class="va">m_Isolated</span>    offset= <span class="dv">32</span> type= <span class="dv">3</span> Muon isolation</a>
<a class="sourceLine" id="cb536-14" title="14">  <span class="dt">Float_t</span> <span class="va">m_Eta</span>         offset= <span class="dv">36</span> type= <span class="dv">5</span> Eta coordinate</a>
<a class="sourceLine" id="cb536-15" title="15">  <span class="dt">Float_t</span> <span class="va">m_Phi</span>         offset= <span class="dv">40</span> type= <span class="dv">5</span> Phi coordinate</a>
<a class="sourceLine" id="cb536-16" title="16">  <span class="dt">Float_t</span> <span class="va">m_PT</span>          offset= <span class="dv">44</span> type= <span class="dv">5</span> Transverse energy</a>
<a class="sourceLine" id="cb536-17" title="17">  <span class="dt">Int_t</span>   <span class="va">m_Trigger</span>     offset= <span class="dv">48</span> type= <span class="dv">3</span> Result of trigger</a>
<a class="sourceLine" id="cb536-18" title="18">  i= <span class="dv">0</span>, TObject         type= <span class="dv">66</span>, offset=  <span class="dv">0</span>, len=<span class="dv">1</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb536-19" title="19">  i= <span class="dv">1</span>, TAtt3D          type=  <span class="dv">0</span>, offset=  <span class="dv">0</span>, len=<span class="dv">1</span>, method=<span class="dv">142684688</span></a>
<a class="sourceLine" id="cb536-20" title="20">  i= <span class="dv">2</span>, <span class="va">m_KFcode</span>        type= <span class="dv">23</span>, offset= <span class="dv">16</span>, len=<span class="dv">5</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb536-21" title="21">  i= <span class="dv">3</span>, <span class="va">m_Eta</span>           type= <span class="dv">25</span>, offset= <span class="dv">36</span>, len=<span class="dv">3</span>, method=<span class="dv">0</span></a>
<a class="sourceLine" id="cb536-22" title="22">  i= <span class="dv">4</span>, <span class="va">m_Trigger</span>       type=  <span class="dv">3</span>, offset= <span class="dv">48</span>, len=<span class="dv">1</span>, method=<span class="dv">0</span></a></code></pre></div>
<p><code>MakeProject</code> has three parameters:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb537-1" title="1">MakeProject(<span class="at">const</span> <span class="dt">char</span> *dirname,<span class="at">const</span> <span class="dt">char</span> *classes,<span class="dt">Option_t</span> *option)</a></code></pre></div>
<p>The first is the directory name in which to place the generated 
header files. The second parameter is the name of the classes to include
 in the project. By default, all classes are included. It recognizes the
 wild card character *, for example, “ATLF*” includes all classes 
beginning with ATLF. The third parameter is an option with the following
 values:</p>
<ul>
<li><p>“<code>new</code>” If the directory does not exist, it is created.</p></li>
<li><p>“<code>recreate</code>” If the directory does not exist, it is 
creates as in “new”, in addition if the directory does exist, all 
existing files are deleted before creating the new files.</p></li>
<li><p>“<code>update</code>” The new classes are added to the existing 
directory and the existing classes are replaced with the new definition.
 If the directory does not exist, it creates it as in “new”.</p></li>
<li><p>“+”: This option can be used in combination with the other three.
 It will create the necessary files to easily build a shared library 
containing the class definitions.Specifically it will:</p></li>
<li><p>Generate a script called <code>MAKE</code> that builds the shared library containing the definition of all classes in the directory.</p></li>
<li><p>Generate a <code>LinkDef.h</code>files to use with <code>rootcling</code> in <code>MAKE</code>.</p></li>
<li><p>Run <code>rootcling</code> to generate a <code>&lt;dirname&gt;ProjectDict.cxx</code> file.</p></li>
<li><p>Compile the &lt;<code>dirname&gt;ProjectDict.cxx</code>with the current options in <code>compiledata.h</code>.</p></li>
<li><p>Build a shared library<code>&lt;dirname&gt;.so</code>.</p></li>
<li><p>“++”:This option can be used instead of the single “+”. It does 
everything the single “+” does, and dynamically loads the shared library
 <code>&lt;dirname&gt;.so</code>.</p></li>
</ul>
<p>This example makes a directory called <code>MyProject</code> that will contain all class definitions from the <code>atlfast.root</code> file. The necessary <code>makefile</code> to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb538-1" title="1">root[] f.MakeProject(<span class="st">"MyProject"</span>,<span class="st">"*"</span>, <span class="st">"recreate++"</span>)</a>
<a class="sourceLine" id="cb538-2" title="2">MakeProject has generated <span class="dv">0</span> classes in MyProject</a>
<a class="sourceLine" id="cb538-3" title="3">MyProject/MAKE file has been generated</a>
<a class="sourceLine" id="cb538-4" title="4">Shared lib MyProject/MyProject.so has been generated</a>
<a class="sourceLine" id="cb538-5" title="5">Shared lib MyProject/MyProject.so has been dynamically linked</a></code></pre></div>
<p>The contents of <code>MyProject</code>:</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb539-1" title="1">root[]     .! ls MyProject</a>
<a class="sourceLine" id="cb539-2" title="2">ATLFCluster.h      ATLFJet.h           ATLFMiscMaker.h     ATLFTrack.h</a>
<a class="sourceLine" id="cb539-3" title="3">TMCParticle.h      ATLFClusterMaker.h  ATLFJetMaker.h      ATLFMuon.h</a>
<a class="sourceLine" id="cb539-4" title="4">ATLFElectron.h     ATLFMCMaker.h       ATLFMuonMaker.h     ATLFElectronMaker.h</a>
<a class="sourceLine" id="cb539-5" title="5">ATLFMaker.h        ATLFPhoton.h        ATLFHistBrowser.h   ATLFMisc.h</a>
<a class="sourceLine" id="cb539-6" title="6">ATLFPhotonMaker.h  ATLFTrackMaker.h    ATLFTrigger.h       ATLFTriggerMaker.h</a>
<a class="sourceLine" id="cb539-7" title="7">LinkDef.h          MAKE                MyProject.so        MyProjectProjectDict.h</a>
<a class="sourceLine" id="cb539-8" title="8">MyProjectProjectDict.cxx               MyProjectProjectDict.o</a></code></pre></div>
<p>Now you can load the shared library in any consecutive root session to use the <code>atlfast</code> classes.</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb540-1" title="1">root[]gSystem-&gt;Load(<span class="st">"MyProject/MyProject"</span>)</a>
<a class="sourceLine" id="cb540-2" title="2">root[]ATLFMuon muon</a></code></pre></div>
<p>This is an example of a generated header file:</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb541-1" title="1"><span class="co">//////////////////////////////////////////////////////////</span></a>
<a class="sourceLine" id="cb541-2" title="2"><span class="co">//   This class has been generated by TFile::MakeProject</span></a>
<a class="sourceLine" id="cb541-3" title="3"><span class="co">//     (Thu Apr  5 10:18:37 2001 by ROOT version 3.00/06)</span></a>
<a class="sourceLine" id="cb541-4" title="4"><span class="co">//      from the TStreamerInfo in file atlfast.root</span></a>
<a class="sourceLine" id="cb541-5" title="5"><span class="co">//////////////////////////////////////////////////////////</span></a>
<a class="sourceLine" id="cb541-6" title="6"><span class="pp">#ifndef ATLFMuon_h</span></a>
<a class="sourceLine" id="cb541-7" title="7"><span class="pp">#define A</span>TLFMuon_h</a>
<a class="sourceLine" id="cb541-8" title="8"><span class="pp">#include </span><span class="im">"TObject.h"</span></a>
<a class="sourceLine" id="cb541-9" title="9"><span class="pp">#include </span><span class="im">"TAtt3D.h"</span></a>
<a class="sourceLine" id="cb541-10" title="10"><span class="kw">class</span> ATLFMuon : <span class="kw">public</span> TObject , <span class="kw">public</span> TAtt3D {</a>
<a class="sourceLine" id="cb541-11" title="11"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb541-12" title="12">   <span class="dt">Int_t</span>     <span class="va">m_KFcode</span>;           <span class="co">//Muon KF-code</span></a>
<a class="sourceLine" id="cb541-13" title="13">   <span class="dt">Int_t</span>     <span class="va">m_MCParticle</span>;       <span class="co">//Muon position in MCParticles list</span></a>
<a class="sourceLine" id="cb541-14" title="14">   <span class="dt">Int_t</span>     <span class="va">m_KFmother</span>;         <span class="co">//Muon mother KF-code</span></a>
<a class="sourceLine" id="cb541-15" title="15">   <span class="dt">Int_t</span>     <span class="va">m_UseFlag</span>;          <span class="co">//Muon energy usage flag</span></a>
<a class="sourceLine" id="cb541-16" title="16">   <span class="dt">Int_t</span>     <span class="va">m_Isolated</span>;         <span class="co">//Muon isolation (1 for isolated)</span></a>
<a class="sourceLine" id="cb541-17" title="17">   <span class="dt">Float_t</span>   <span class="va">m_Eta</span>;              <span class="co">//Eta coordinate</span></a>
<a class="sourceLine" id="cb541-18" title="18">   <span class="dt">Float_t</span>   <span class="va">m_Phi</span>;              <span class="co">//Phi coordinate</span></a>
<a class="sourceLine" id="cb541-19" title="19">   <span class="dt">Float_t</span>   <span class="va">m_PT</span>;               <span class="co">//Transverse energy</span></a>
<a class="sourceLine" id="cb541-20" title="20">   <span class="dt">Int_t</span>     <span class="va">m_Trigger</span>;          <span class="co">//Result of trigger</span></a>
<a class="sourceLine" id="cb541-21" title="21">   ATLFMuon() {;}</a>
<a class="sourceLine" id="cb541-22" title="22">   <span class="kw">virtual</span> ~ATLFMuon() {;}</a>
<a class="sourceLine" id="cb541-23" title="23">   ClassDef(ATLFMuon,<span class="dv">1</span>) <span class="co">//</span></a>
<a class="sourceLine" id="cb541-24" title="24">};</a>
<a class="sourceLine" id="cb541-25" title="25">   ClassImp(ATLFMuon)</a>
<a class="sourceLine" id="cb541-26" title="26"><span class="pp">#endif</span></a></code></pre></div>
<h2 id="compression-and-performance"><span class="header-section-number">11.6</span> Compression and Performance</h2>
<p>ROOT uses a compression algorithm based on the well-known <code>gzip</code>
 algorithm. It supports nine levels of compression. The default for ROOT
 is one. The compression level can be set with the method <code>TFile::SetCompressionLevel</code>.
 The experience with this algorithm shows that a compression level of 
1.3 for raw data files and around two on most DST files is the optimum. 
The choice of one for the default is a compromise between the time it 
takes to read and write the object vs. the disk space savings.</p>
<p>To specify no compression, set the level to zero.</p>
<p>We recommend using compression when the time spent in I/O is small 
compared to the total processing time. If the I/O operation is increased
 by a factor of 5 it is still a small percentage of the total time and 
it may compress the data by a factor of 10. On the other hand if the 
time spend on I/O is large, compression may have a large impact on the 
program’s performance.</p>
<p>The compression factor, i.e.&nbsp;the savings of disk space, varies 
with the type of data. A buffer with a same value array is compressed so
 that the value is only written once. For example, a track has the mass 
of a pion that it is always the same, and the charge of the pion that is
 either positive or negative. For 1000 pions, the mass will be written 
only once, and the charge only twice (positive and negative). When the 
data is sparse, i.e.&nbsp;when there are many zeros, the compression 
factor is also high.</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 23%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<tbody>
<tr class="odd">
<td>Compression level</td>
<td>Bytes</td>
<td>Write Time (sec)</td>
<td>Read Time (sec.)</td>
</tr>
<tr class="even">
<td>0</td>
<td>1,004,998</td>
<td>4.77</td>
<td>0.07</td>
</tr>
<tr class="odd">
<td>1</td>
<td>438,366</td>
<td>6.67</td>
<td>0.05</td>
</tr>
<tr class="even">
<td>5</td>
<td>429,871</td>
<td>7.03</td>
<td>0.06</td>
</tr>
<tr class="odd">
<td>9</td>
<td>426,899</td>
<td>8.47</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p>The time to uncompress an object is small compared to the compression
 time and is independent of the selected compression level. Note that 
the compression level may be changed at any time, but the new 
compression level will only apply to newly written objects. 
Consequently, a ROOT file may contain objects with different compression
 levels. This table shows four runs of the demo script that creates 15 
histograms with different compression parameters. To make the numbers 
more significant, the macro was modified to create 1000 histograms. We 
have included two more examples to show the impact of compression on 
Trees in the next chapter.</p>
<h3 id="using-the-general-open-function-of-tfile"><span class="header-section-number">11.6.1</span> Using the General Open Function of TFile</h3>
<p>To make life simple we provide a general function to open any type of file (except shared memory files of class <strong><code>TMapFile</code></strong>). This functionality is provided by the static <code>TFile::Open()</code> function:</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb542-1" title="1">TFile *TFile::Open(<span class="at">const</span> <span class="dt">Text_t</span> *name,<span class="dt">Option_t</span> *option=<span class="st">""</span>,</a>
<a class="sourceLine" id="cb542-2" title="2"><span class="at">const</span> <span class="dt">Text_t</span> *title=<span class="st">""</span>,<span class="dt">Int_t</span> compress,<span class="dt">Int_t</span> netopt)</a></code></pre></div>
<p>Depending on the <code>name</code> argument, the function returns a <strong><code>TFile</code></strong> or one of its derivations, for example a <strong><code>TXNetFile</code></strong> or a <strong><code>TDavixFile</code></strong> object. In case a URL specifies a local file, a <strong><code>TFile</code></strong> object will be returned (and of course no login information is needed). The arguments of the <code>Open()</code> function are the same as the ones for the <strong><code>TFile</code></strong> constructor.</p>
<p>Using <code>ReOpen()</code> method it is possible to reopen a file 
with a different access mode, like from READ to UPDATE or from NEW, 
CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either 
“READ” or “UPDATE”. The method returns:</p>
<ul>
<li><p>0 in case the mode was successfully modified;</p></li>
<li><p>1 in case the mode did not change (it was already as requested or there were wrong input arguments);</p></li>
<li><p>-1 in case of failure. In the last case the file cannot be used anymore.</p></li>
</ul>
<h2 id="remotely-access-to-root-files"><span class="header-section-number">11.7</span> Remotely Access to ROOT Files</h2>
<p>ROOT files can be accessed remotely in many ways, on the base of the 
protocol URL. Among the most popular are XRootD (protocols ‘root://’ and
 ‘xrd://’) and a Web server (protocl ‘http://’ or ‘https://’).</p>
<p>The rootd daemon is deprecated and has been removed in version 6.16/00.</p>
<p>Please refer to the XRootD documentation for starting and ensuring that such a daemon is running.</p>
<p>Reading and writing ROOT&nbsp;files over the net can be done by creating a <strong><code>TFile</code></strong> object using the static method <strong><code>TFile::Open()</code></strong> object. This will instantiate the appropriate derivation of <strong><code>TFile</code></strong> to handle the request. Inheriting from the <strong><code>TFile</code></strong> class, the returned instance will have exactly the same interface and behavior of <strong><code>TFile</code></strong>.
 The only difference is that it reads and writes from a remote service. 
In the example below the file is read via a web server through the 
TDavixFile plug-in.</p>
<h3 id="a-simple-session"><span class="header-section-number">11.7.1</span> A Simple Session</h3>
<div class="sourceCode" id="cb543"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb543-1" title="1">root[] TFile *f1 = TFile::Open(<span class="st">"local/file.root"</span>,<span class="st">"update"</span>)</a>
<a class="sourceLine" id="cb543-2" title="2">root[] TFile *f2 = TFile::Open(<span class="st">"root://my.server.org/data/file.root"</span>,<span class="st">"new"</span>)</a>
<a class="sourceLine" id="cb543-3" title="3">root[] TFile *f3 = TFile::Open(<span class="st">"http://root.cern.ch/files/hsimple.root"</span>)</a>
<a class="sourceLine" id="cb543-4" title="4">root[] f3.ls()</a>
<a class="sourceLine" id="cb543-5" title="5">TDavixFile** http:<span class="co">//root.cern.ch/files/hsimple.root</span></a>
<a class="sourceLine" id="cb543-6" title="6">TDavixFile* http:<span class="co">//root.cern.ch/files/hsimple.root</span></a>
<a class="sourceLine" id="cb543-7" title="7">KEY: TH1F hpx;<span class="dv">1</span> This is the px distribution</a>
<a class="sourceLine" id="cb543-8" title="8">KEY: TH2F hpxpy;<span class="dv">1</span> py vs px</a>
<a class="sourceLine" id="cb543-9" title="9">KEY: TProfile hprof;<span class="dv">1</span> Profile of pz versus px</a>
<a class="sourceLine" id="cb543-10" title="10">KEY: TNtuple ntuple;<span class="dv">1</span> Demo ntuple</a>
<a class="sourceLine" id="cb543-11" title="11">root[] hpx.Draw()</a></code></pre></div>
<h2 id="xml-interface"><span class="header-section-number">11.8</span> XML Interface</h2>
<p>A new module <code>xml</code> as implemented by Sergey Linev (GSI). It is an optional package that can be used to save a canvas into <code>file.xml</code> file format instead of <code>file.root</code>.
 XML files do not have any advantages compared to the normal ROOT files,
 except that the information in these files can be edited via a normal 
editor. The main motivation for this new format is to facilitate the 
communication with other non ROOT applications. Currently writing and 
reading XML files is limited to ROOT applications. It is our intention 
to develop a simple reader independent of the ROOT libraries that could 
be used as an example for real applications.</p>
<p>The XML format should be used only for small data volumes, typically 
histogram files, pictures, geometries, calibrations. The XML file is 
built in memory before being dumped to disk. Like for normal ROOT files,
 XML files use the same I/O mechanism exploiting the ROOT/Cling 
dictionary. Any class having a dictionary can be saved in XML format. 
This first implementation does not support subdirectories or trees.</p>
<p>The shared library <code>libRXML.so</code> may be loaded dynamically via <code>gSystem-&gt;Load("libRXML")</code>.
 This library is also automatically loaded by the plug-in manager as 
soon a XML file is created. To create an XTM file, simply specify a 
filename with an .xml extension when calling <strong><code>TFile</code></strong><code>::Open</code>. <strong><code>TFile</code></strong><code>::Open</code> will recognize that you are trying to open an XML file and return a <strong><code>TXMLFile</code></strong> object. When a XML file is open in write mode, one can use the normal <code>TObject::Write</code> to write an object in the file.</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb544-1" title="1">   <span class="co">// example of a session saving a histogram to a XML file</span></a>
<a class="sourceLine" id="cb544-2" title="2">   TFile *f = TFile::Open(<span class="st">"Example.xml"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb544-3" title="3">   TH1F *h = <span class="kw">new</span> TH1F(<span class="st">"h"</span>,<span class="st">"test"</span>,<span class="dv">1000</span>,-<span class="dv">2</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb544-4" title="4">   h-&gt;FillRandom(<span class="st">"gaus"</span>);</a>
<a class="sourceLine" id="cb544-5" title="5">   h-&gt;Write();</a>
<a class="sourceLine" id="cb544-6" title="6">   <span class="kw">delete</span> f;</a>
<a class="sourceLine" id="cb544-7" title="7">   <span class="co">// example of a session saving a histogram to a XML file</span></a>
<a class="sourceLine" id="cb544-8" title="8">   TFile *f = TFile::Open(<span class="st">"Example.xml"</span>);</a>
<a class="sourceLine" id="cb544-9" title="9">   TH1F *h = (TH1F*)f-&gt;Get(<span class="st">"h"</span>);</a>
<a class="sourceLine" id="cb544-10" title="10">   h-&gt;Draw();</a></code></pre></div>
<p>The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb545-1" title="1">   canvas-&gt;Print(<span class="st">"Example.xml"</span>);</a></code></pre></div>
<h1 id="trees"><span class="header-section-number">12</span> Trees</h1>
<h2 id="why-should-you-use-a-tree"><span class="header-section-number">12.1</span> Why Should You Use a Tree?</h2>
<p>In the “Input/Output” chapter, we saw how objects can be saved in 
ROOT files. In case you want to store large quantities of same-class 
objects, ROOT has designed the <strong><code>TTree</code></strong> and <strong><code>TNtuple</code></strong> classes specifically for that purpose. The <strong><code>TTree</code></strong> class is optimized to reduce disk space and enhance access speed. A <strong><code>TNtuple</code></strong> is a <strong><code>TTree</code></strong> that is limited to only hold floating-point numbers; a <strong><code>TTree</code></strong> on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.</p>
<p>When using a <strong><code>TTree</code></strong>, we fill its branch 
buffers with leaf data and the buffers are written to disk when it is 
full. Branches, buffers, and leafs, are explained a little later in this
 chapter, but for now, it is important to realize that each object is 
not written individually, but rather collected and written a bunch at a 
time.</p>
<p>This is where the <strong><code>TTree</code></strong> takes advantage
 of compression and will produce a much smaller file than if the objects
 were written individually. Since the unit to be compressed is a buffer,
 and the <strong><code>TTree</code></strong> contains many same-class objects, the header of the objects can be compressed.</p>
<p>The <strong><code>TTree</code></strong> reduces the header of each 
object, but it still contains the class name. Using compression, the 
class name of each same-class object has a good chance of being 
compressed, since the compression algorithm recognizes the bit pattern 
representing the class name. Using a <strong><code>TTree</code></strong>
 and compression the header is reduced to about 4 bytes compared to the 
original 60 bytes. However, if compression is turned off, you will not 
see these large savings.</p>
<p>The <strong><code>TTree</code></strong> is also used to optimize the 
data access. A tree uses a hierarchy of branches, and each branch can be
 read independently from any other branch. Now, assume that <code>Px</code> and <code>Py</code> are data members of the event, and we would like to compute <code>Px2 + Py2</code> for every event and histogram the result.</p>
<p>If we had saved the million events without a <strong><code>TTree</code></strong> we would have to:</p>
<ul>
<li>read each event in its entirety into memory</li>
<li>extract the <code>Px</code> and <code>Py</code> from the event</li>
<li>compute the sum of the squares</li>
<li>fill a histogram</li>
</ul>
<p>We would have to do that a million times! This is very time 
consuming, and we really do not need to read the entire event, every 
time. All we need are two little data members (<code>Px</code> and <code>Py</code>). On the other hand, if we use a tree with one branch containing <code>Px</code> and another branch containing <code>Py</code>, we can read all values of <code>Px</code> and <code>Py</code> by only reading the <code>Px</code> and <code>Py</code> branches. This makes the use of the <strong><code>TTree</code></strong> very attractive.</p>
<h2 id="a-simple-ttree"><span class="header-section-number">12.2</span> A Simple TTree</h2>
<p>This script builds a <strong><code>TTree</code></strong> from an ASCII file containing statistics about the staff at CERN. This script, <code>cernbuild.C</code> and its input file <code>cernstaff.dat</code> are in <code>$ROOTSYS/tutorials/tree</code>.</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb546-1" title="1">{</a>
<a class="sourceLine" id="cb546-2" title="2">   <span class="co">// Simplified version of cernbuild.C.</span></a>
<a class="sourceLine" id="cb546-3" title="3">   <span class="co">// This macro to read data from an ascii file and</span></a>
<a class="sourceLine" id="cb546-4" title="4">   <span class="co">// create a root file with a TTree</span></a>
<a class="sourceLine" id="cb546-5" title="5"></a>
<a class="sourceLine" id="cb546-6" title="6">   <span class="dt">Int_t</span>           Category;</a>
<a class="sourceLine" id="cb546-7" title="7">   <span class="dt">UInt_t</span>          Flag;</a>
<a class="sourceLine" id="cb546-8" title="8">   <span class="dt">Int_t</span>           Age;</a>
<a class="sourceLine" id="cb546-9" title="9">   <span class="dt">Int_t</span>           Service;</a>
<a class="sourceLine" id="cb546-10" title="10">   <span class="dt">Int_t</span>           Children;</a>
<a class="sourceLine" id="cb546-11" title="11">   <span class="dt">Int_t</span>           Grade;</a>
<a class="sourceLine" id="cb546-12" title="12">   <span class="dt">Int_t</span>           Step;</a>
<a class="sourceLine" id="cb546-13" title="13">   <span class="dt">Int_t</span>           Hrweek;</a>
<a class="sourceLine" id="cb546-14" title="14">   <span class="dt">Int_t</span>           Cost;</a>
<a class="sourceLine" id="cb546-15" title="15">   <span class="dt">Char_t</span>          Division[<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb546-16" title="16">   <span class="dt">Char_t</span>          Nation[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb546-17" title="17"></a>
<a class="sourceLine" id="cb546-18" title="18">   <span class="dt">FILE</span> *fp = fopen(<span class="st">"cernstaff.dat"</span>,<span class="st">"r"</span>);</a>
<a class="sourceLine" id="cb546-19" title="19"></a>
<a class="sourceLine" id="cb546-20" title="20">   TFile *hfile = hfile = TFile::Open(<span class="st">"cernstaff.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb546-21" title="21"></a>
<a class="sourceLine" id="cb546-22" title="22">   TTree *tree = <span class="kw">new</span> TTree(<span class="st">"T"</span>,<span class="st">"CERN 1988 staff data"</span>);</a>
<a class="sourceLine" id="cb546-23" title="23">   tree-&gt;Branch(<span class="st">"Category"</span>,&amp;Category,<span class="st">"Category/I"</span>);</a>
<a class="sourceLine" id="cb546-24" title="24">   tree-&gt;Branch(<span class="st">"Flag"</span>,&amp;Flag,<span class="st">"Flag/i"</span>);</a>
<a class="sourceLine" id="cb546-25" title="25">   tree-&gt;Branch(<span class="st">"Age"</span>,&amp;Age,<span class="st">"Age/I"</span>);</a>
<a class="sourceLine" id="cb546-26" title="26">   tree-&gt;Branch(<span class="st">"Service"</span>,&amp;Service,<span class="st">"Service/I"</span>);</a>
<a class="sourceLine" id="cb546-27" title="27">   tree-&gt;Branch(<span class="st">"Children"</span>,&amp;Children,<span class="st">"Children/I"</span>);</a>
<a class="sourceLine" id="cb546-28" title="28">   tree-&gt;Branch(<span class="st">"Grade"</span>,&amp;Grade,<span class="st">"Grade/I"</span>);</a>
<a class="sourceLine" id="cb546-29" title="29">   tree-&gt;Branch(<span class="st">"Step"</span>,&amp;Step,<span class="st">"Step/I"</span>);</a>
<a class="sourceLine" id="cb546-30" title="30">   tree-&gt;Branch(<span class="st">"Hrweek"</span>,&amp;Hrweek,<span class="st">"Hrweek/I"</span>);</a>
<a class="sourceLine" id="cb546-31" title="31">   tree-&gt;Branch(<span class="st">"Cost"</span>,&amp;Cost,<span class="st">"Cost/I"</span>);</a>
<a class="sourceLine" id="cb546-32" title="32">   tree-&gt;Branch(<span class="st">"Division"</span>,Division,<span class="st">"Division/C"</span>);</a>
<a class="sourceLine" id="cb546-33" title="33">   tree-&gt;Branch(<span class="st">"Nation"</span>,Nation,<span class="st">"Nation/C"</span>);</a>
<a class="sourceLine" id="cb546-34" title="34">   <span class="dt">char</span> line[<span class="dv">80</span>];</a>
<a class="sourceLine" id="cb546-35" title="35">   <span class="cf">while</span> (fgets(line,<span class="dv">80</span>,fp)) {</a>
<a class="sourceLine" id="cb546-36" title="36">      sscanf(&amp;line[<span class="dv">0</span>],<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">  </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">"</span>,</a>
<a class="sourceLine" id="cb546-37" title="37">      &amp;Category,&amp;Flag,&amp;Age,&amp;Service,&amp;Children,&amp;Grade,&amp;Step,&amp;Hrweek,&amp;Cost,Division,Nation);</a>
<a class="sourceLine" id="cb546-38" title="38">      tree-&gt;Fill();</a>
<a class="sourceLine" id="cb546-39" title="39">   }</a>
<a class="sourceLine" id="cb546-40" title="40">   tree-&gt;Print();</a>
<a class="sourceLine" id="cb546-41" title="41">   tree-&gt;Write();</a>
<a class="sourceLine" id="cb546-42" title="42"></a>
<a class="sourceLine" id="cb546-43" title="43">   fclose(fp);</a>
<a class="sourceLine" id="cb546-44" title="44">   <span class="kw">delete</span> hfile;</a>
<a class="sourceLine" id="cb546-45" title="45">}</a></code></pre></div>
<p>The script opens the ASCII file, creates a ROOT file and a <strong><code>TTree</code></strong>. Then it creates branches with the <code>TTree::Branch</code> method. The first parameter of the <code>Branch</code>
 method is the branch name. The second parameter is the address from 
which the first leaf is to be read. Once the branches are defined, the 
script reads the data from the ASCII file into C variables and fills the
 <code>tree</code>. The ASCII file is closed, and the ROOT file is written to disk saving the <code>tree</code>. Remember, trees (and histograms) are created in the current directory, which is the file in our example. Hence a <code>f-&gt;Write()</code>saves the tree.</p>
<h2 id="show-an-entry-with-ttreeshow"><span class="header-section-number">12.3</span> Show an Entry with TTree::Show</h2>
<p>An easy way to access one entry of a tree is the use the <code>TTree::Show</code> method. For example to look at the 10th entry in the <code>cernstaff.root</code> tree:</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb547-1" title="1">root[] TFile f(<span class="st">"cernstaff.root"</span>)</a>
<a class="sourceLine" id="cb547-2" title="2">root[] T-&gt;Show(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb547-3" title="3">======&gt; EVENT:<span class="dv">10</span></a>
<a class="sourceLine" id="cb547-4" title="4"> Category        = <span class="dv">361</span></a>
<a class="sourceLine" id="cb547-5" title="5"> Flag            = <span class="dv">15</span></a>
<a class="sourceLine" id="cb547-6" title="6"> Age             = <span class="dv">51</span></a>
<a class="sourceLine" id="cb547-7" title="7"> Service         = <span class="dv">29</span></a>
<a class="sourceLine" id="cb547-8" title="8"> Children        = <span class="dv">0</span></a>
<a class="sourceLine" id="cb547-9" title="9"> Grade           = <span class="dv">7</span></a>
<a class="sourceLine" id="cb547-10" title="10"> Step            = <span class="dv">13</span></a>
<a class="sourceLine" id="cb547-11" title="11"> Hrweek          = <span class="dv">40</span></a>
<a class="sourceLine" id="cb547-12" title="12"> Cost            = <span class="dv">7599</span></a>
<a class="sourceLine" id="cb547-13" title="13"> Division        = PS</a>
<a class="sourceLine" id="cb547-14" title="14"> Nation          = FR</a></code></pre></div>
<h2 id="print-the-tree-structure-with-ttreeprint"><span class="header-section-number">12.4</span> Print the Tree Structure with TTree::Print</h2>
<p>A helpful command to see the tree structure meaning the number of entries, the branches and the leaves, is <code>TTree::Print</code>.</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb548-1" title="1">root[] T-&gt;Print()</a>
<a class="sourceLine" id="cb548-2" title="2">**********************************************************************</a>
<a class="sourceLine" id="cb548-3" title="3">*Tree    :T         : staff data from ascii file                     *</a>
<a class="sourceLine" id="cb548-4" title="4">*Entries :<span class="dv">3354</span>      : Total = <span class="dv">245417</span> bytes  File  Size =        <span class="dv">59945</span>*</a>
<a class="sourceLine" id="cb548-5" title="5">*                     Tree compression factor =   <span class="fl">2.90</span>               *</a>
<a class="sourceLine" id="cb548-6" title="6">**********************************************************************</a>
<a class="sourceLine" id="cb548-7" title="7">*Br    <span class="dv">0</span> :staff     :Category/I:Flag:Age:Service:Children:Grade:...  *</a>
<a class="sourceLine" id="cb548-8" title="8">*         | Cost                                                     *</a>
<a class="sourceLine" id="cb548-9" title="9">*Entries :<span class="dv">3354</span> : Total Size  = <span class="dv">154237</span> bytes  File Size = <span class="dv">32316</span>       *</a>
<a class="sourceLine" id="cb548-10" title="10">*Baskets :   <span class="dv">3</span> : Basket Size =  <span class="dv">32000</span> bytes  Compression= <span class="fl">2.97</span>       *</a></code></pre></div>
<h2 id="scan-a-variable-the-tree-with-ttreescan"><span class="header-section-number">12.5</span> Scan a Variable the Tree with TTree::Scan</h2>
<p>The <code>TTree::Scan</code> method shows all values of the list of leaves separated by a colon.</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb549-1" title="1">root[] T-&gt;Scan(<span class="st">"Cost:Age:Children"</span>)</a>
<a class="sourceLine" id="cb549-2" title="2">************************************************</a>
<a class="sourceLine" id="cb549-3" title="3">*    Row   *      Cost *       Age *  Children *</a>
<a class="sourceLine" id="cb549-4" title="4">************************************************</a>
<a class="sourceLine" id="cb549-5" title="5">*        <span class="dv">0</span> *     <span class="dv">11975</span> *        <span class="dv">58</span> *         <span class="dv">0</span> *</a>
<a class="sourceLine" id="cb549-6" title="6">*        <span class="dv">1</span> *     <span class="dv">10228</span> *        <span class="dv">63</span> *         <span class="dv">0</span> *</a>
<a class="sourceLine" id="cb549-7" title="7">*        <span class="dv">2</span> *     <span class="dv">10730</span> *        <span class="dv">56</span> *         <span class="dv">2</span> *</a>
<a class="sourceLine" id="cb549-8" title="8">*        <span class="dv">3</span> *      <span class="dv">9311</span> *        <span class="dv">61</span> *         <span class="dv">0</span> *</a>
<a class="sourceLine" id="cb549-9" title="9">*        <span class="dv">4</span> *      <span class="dv">9966</span> *        <span class="dv">52</span> *         <span class="dv">2</span> *</a>
<a class="sourceLine" id="cb549-10" title="10">*        <span class="dv">5</span> *      <span class="dv">7599</span> *        <span class="dv">60</span> *         <span class="dv">0</span> *</a>
<a class="sourceLine" id="cb549-11" title="11">*        <span class="dv">6</span> *      <span class="dv">9868</span> *        <span class="dv">53</span> *         <span class="dv">1</span> *</a>
<a class="sourceLine" id="cb549-12" title="12">*        <span class="dv">7</span> *      <span class="dv">8012</span> *        <span class="dv">60</span> *         <span class="dv">1</span> *</a>
<a class="sourceLine" id="cb549-13" title="13">...</a></code></pre></div>
<h2 id="the-tree-viewer"><span class="header-section-number">12.6</span> The Tree Viewer</h2>
<figure>
<img src="ROOTUsersGuide_files/030000EF.png" alt="Activating the tree viewer"><figcaption>Activating the tree viewer</figcaption>
</figure>
<p>The tree viewer is a quick and easy way to examine a tree. To start 
the tree viewer, open a file and object browser. Right click on a <strong><code>TTree</code></strong> and select <code>StartViewer</code>. You can also start the tree viewer from the command line. First load the viewer library.</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb550-1" title="1">root[] TFile f(<span class="st">"cernstaff.root"</span>)</a>
<a class="sourceLine" id="cb550-2" title="2">root[] T-&gt;StartViewer()</a></code></pre></div>
<p>If you want to start a tree viewer without a tree, you need to load the tree player library first:</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb551-1" title="1">root[] gSystem-&gt;Load(<span class="st">"libTreeViewer.so"</span>)</a>
<a class="sourceLine" id="cb551-2" title="2">root[] <span class="kw">new</span> TTreeViewer()</a></code></pre></div>
<p>The figure above shows how the tree viewer looks like for the example file <code>cernstaff.root</code>.
 The left panel contains the list of trees and their branches; in this 
case there is only one tree. You can add more trees with the File-Open 
command to open the file containing the new tree, then use the context 
menu on the right panel, select <code>SetTreeName</code> and enter the 
name of the tree to add. On the right are the leaves or variables in the
 tree. You can double click on any leaf to a histogram it.</p>
<p>The toolbar in the upper part can be used for user commands, changing
 the drawing option and the histogram name. The lower part contains 
three picture buttons that draw a histogram, stop the current command, 
and refresh the tree.</p>
<p>The three check buttons toggle the following:</p>
<p><code>Hist</code>- the histogram drawing mode;</p>
<p><code>Scan</code>- enables redirecting of <code>TTree::Scan</code>command in an ASCII file;</p>
<p><code>Rec</code> - enables recording of the last issued command.</p>
<ul>
<li><p><img src="ROOTUsersGuide_files/020000F1.jpg"> To draw more than one dimension you can drag and drop any leaf to the <code>X,Y,Z</code> boxes". Then push the Draw button, witch is marked with the purple icon on the bottom left.</p></li>
<li><p><img src="ROOTUsersGuide_files/030000F2.png"> All commands can be interrupted at any time by pressing this button.</p></li>
<li><p><img src="ROOTUsersGuide_files/030000F3.png"> The method <strong><code>TTree::Refresh</code></strong> is called by pressing the refresh button in <code>TTreeViewer</code>. It redraws the current exposed expression. Calling <code>TTree::Refresh</code> is useful when a tree is produced by a writer process and concurrently analyzed by one or more readers.</p></li>
<li><p><img src="ROOTUsersGuide_files/030000F4.png"> To add a cut/weight to the histogram, enter an expression in the “cut box”. The cut box is the one with the scissor icon.</p></li>
</ul>
<p>Below them there are two text widgets for specifying the input and 
output event lists. A Tree Viewer session is made by the list of 
user-defined expressions and cuts, applying to a specified tree. A 
session can be saved using File / <code>SaveSource</code> menu or the <code>SaveSource</code> method from the context menu of the right panel. This will create a macro having as default name <code>treeviewer.C</code> that can be ran at any time to reproduce the session.</p>
<p>Besides the list of user-defined expressions, a session may contain a
 list of RECORDS. A record can be produced in the following way: 
dragging leaves/expression on X/Y/Z; changing drawing options; clicking 
the RED button on the bottom when happy with the histogram</p>
<p>NOTE that just double clicking a leaf will not produce a record: the 
histogram must be produced when clicking the DRAW button on the 
bottom-left. The records will appear on the list of records in the 
bottom right of the tree viewer. Selecting a record will draw the 
corresponding histogram. Records can be played using the arrow buttons 
near to the record button. When saving the session, the list of records 
is being saved as well.</p>
<p>Records have a default name corresponding to the Z: Y: X selection, but this can be changed using <code>SetRecordName()</code> method from the right panel context menu. You can create a new expression by right clicking on any of the<code>E()</code> boxes. The expression can be dragged and dropped into any of the boxes (<code>X,</code> <code>Y,</code> <code>Z,</code> <code>Cut</code>, or <code>Scan</code>).
 To scan one or more variables, drop them into the Scan box, then double
 click on the box. You can also redirect the result of the scan to a 
file by checking the Scan box on top.</p>
<p><img src="ROOTUsersGuide_files/030000F5.png"></p>
<p>When the “<code>Rec</code>” box is checked, the <code>Draw</code> and <code>Scan</code>
 commands are recorded in the history file and echoed on the command 
line. The “Histogram” text box contains the name of the resulting 
histogram. By default it is <code>htemp</code>. You can type any name, 
if the histogram does not exist it will create one. The Option text box 
contains the list of Draw options. See “Draw Options”. You can select 
the options with the Options menu. The Command box lets you enter any 
command that you could also enter on the command line. The vertical 
slider on the far left side can be used to select the minimum and 
maximum of an event range. The actual start and end index are shown in 
on the bottom in the status window.</p>
<p>There is an extensive help utility accessible with the Help menu. The <code>IList</code> and <code>OList</code> are to <code>specify</code> an input list of entry indices and a name for the output list respectively. Both need to be of type <strong><code>TList</code></strong> and contain integers of entry indices. These lists are described below in the paragraph “<strong>Error! Reference source not found.</strong>”.</p>
<figure>
<img src="ROOTUsersGuide_files/030000F6.png" alt="A couple of graphs"><figcaption>A couple of graphs</figcaption>
</figure>
<p>The first one is a plot of the age distribution, the second a scatter
 plot of the cost vs.&nbsp;age. The second one was generated by dragging
 the age leaf into the Y-box and the cost leaf into the X-box, and 
pressing the Draw button. By default, this will generate a scatter plot.
 Select a different option, for example <code>"lego"</code> to create a 2D histogram.</p>
<h2 id="creating-and-saving-trees"><span class="header-section-number">12.7</span> Creating and Saving Trees</h2>
<p>This picture shows the <strong><code>TTree</code></strong> class:</p>
<figure>
<img src="ROOTUsersGuide_files/030000F8.png" alt="The TTree class"><figcaption>The TTree class</figcaption>
</figure>
<p>To create a <strong><code>TTree</code></strong> we use its constructor. Then we design our data layout and add the branches. A tree can be created by giving a name and title:</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb552-1" title="1">   TTree t(<span class="st">"MyTree"</span>,<span class="st">"Example Tree"</span>);</a></code></pre></div>
<h3 id="creating-a-tree-from-a-folder-hierarchy"><span class="header-section-number">12.7.1</span> Creating a Tree from a Folder Hierarchy</h3>
<p>An alternative way to create a tree and organize it is to use folders
 (see “Folders and Tasks”). You can build a folder structure and create a
 tree with branches for each of the sub-folders:</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb553-1" title="1">   TTree folder_tree(<span class="st">"MyFolderTree"</span>,<span class="st">"/MyFolder"</span>);</a></code></pre></div>
<p>The second argument <code>"/MyFolder"</code>is the top folder, and the “/” signals the <strong><code>TTree</code></strong>
 constructor that this is a folder not just the title. You fill the tree
 by placing the data into the folder structure and calling <code>TTree::Fill</code>.</p>
<h3 id="tree-and-tref-objects"><span class="header-section-number">12.7.2</span> Tree and TRef Objects</h3>
<div class="sourceCode" id="cb554"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb554-1" title="1">   MyTree-&gt;BranchRef();</a></code></pre></div>
<p>This call requests the construction of an optional branch supporting table of references (<strong><code>TRefTable</code></strong>). This branch (<strong><code>TBranchRef</code></strong>) will keep all the information needed to find the branches containing referenced objects at each <code>Tree::Fill</code>, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via <code>TTree::Write</code>
 for example), the branch is saved, keeping the information with the 
pointers to the branches having referenced objects. Enabling this 
optional table, allow <code>TTree::Draw</code> to automatically load the branches needed to dereference a <strong><code>TRef</code></strong> (or <strong><code>TRefArray</code></strong>) object.</p>
<h3 id="autosave"><span class="header-section-number">12.7.3</span> Autosave</h3>
<p><code>Autosave</code> gives the option to save all branch buffers every <code>n</code> byte. We recommend using <code>Autosave</code> for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last <code>Autosave</code>. To set the number of bytes between <code>Autosave</code> you can use the <code>TTree::SetAutosave()</code> method. You can also call <strong><code>TTree::Autosave</code> in the acquisition loop every <code>n</code>entry.</strong></p>
<h3 id="trees-with-circular-buffers"><span class="header-section-number">12.7.4</span> Trees with Circular Buffers</h3>
<p>When a <strong><code>TTree</code></strong> is memory resident, you 
set it up so that it retains retain only the last few entries. For 
example, this can be very useful for monitoring purpose.</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb555-1" title="1">   <span class="dt">void</span> TTree::SetCircular(<span class="dt">Long64_t</span> maxEntries);</a></code></pre></div>
<p>where <code>maxEntries</code> is the maximum number of entries to be 
kept in the buffers. When the number of entries exceeds this value, the 
first entries in the <strong><code>Tree</code></strong> are deleted and the buffers used again. An example of a script using a circular buffer is shown below:</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb556-1" title="1"><span class="dt">void</span> circular() {</a>
<a class="sourceLine" id="cb556-2" title="2">   gROOT-&gt;cd(); <span class="co">//make sure that the Tree is memory resident</span></a>
<a class="sourceLine" id="cb556-3" title="3">   TTree *T = <span class="kw">new</span> TTree(<span class="st">"T"</span>,<span class="st">"test circular buffers"</span>);</a>
<a class="sourceLine" id="cb556-4" title="4">   TRandom r;</a>
<a class="sourceLine" id="cb556-5" title="5">   <span class="dt">Float_t</span> px,py,pz;</a>
<a class="sourceLine" id="cb556-6" title="6">   <span class="dt">Double_t</span> random;</a>
<a class="sourceLine" id="cb556-7" title="7">   <span class="dt">UShort_t</span> i;</a>
<a class="sourceLine" id="cb556-8" title="8">   T-&gt;Branch(<span class="st">"px"</span>,&amp;px,<span class="st">"px/F"</span>);</a>
<a class="sourceLine" id="cb556-9" title="9">   T-&gt;Branch(<span class="st">"py"</span>,&amp;py,<span class="st">"py/F"</span>);</a>
<a class="sourceLine" id="cb556-10" title="10">   T-&gt;Branch(<span class="st">"pz"</span>,&amp;pz,<span class="st">"pz/F"</span>);</a>
<a class="sourceLine" id="cb556-11" title="11">   T-&gt;Branch(<span class="st">"random"</span>,&amp;random,<span class="st">"random/D"</span>);</a>
<a class="sourceLine" id="cb556-12" title="12">   T-&gt;Branch(<span class="st">"i"</span>,&amp;i,<span class="st">"i/s"</span>);</a>
<a class="sourceLine" id="cb556-13" title="13">   T-&gt;SetCircular(<span class="dv">20000</span>);</a>
<a class="sourceLine" id="cb556-14" title="14">   <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">65000</span>; i++) {</a>
<a class="sourceLine" id="cb556-15" title="15">      r.Rannor(px,py);</a>
<a class="sourceLine" id="cb556-16" title="16">      pz = px*px + py*py;</a>
<a class="sourceLine" id="cb556-17" title="17">      random = r.Rndm();</a>
<a class="sourceLine" id="cb556-18" title="18">      T-&gt;Fill();</a>
<a class="sourceLine" id="cb556-19" title="19">   }</a>
<a class="sourceLine" id="cb556-20" title="20">   T-&gt;Print();</a>
<a class="sourceLine" id="cb556-21" title="21">}</a></code></pre></div>
<h3 id="size-of-ttree-in-the-file"><span class="header-section-number">12.7.5</span> Size of TTree in the File</h3>
<p>When writing a <strong><code>TTree</code></strong> to a file, if the file size reaches the value stored in the <code>TTree::GetMaxTreeSize()</code>, the current file is closed and a new file is created. If the original file is named “<code>myfile.root</code>”, subsequent files are named “<code>myfile_1.root</code>”, “<code>myfile_2.root</code>”, etc.</p>
<p>Currently, the automatic change of file is restricted to the case 
where the tree is in the top level directory. The file should not 
contain sub-directories. Before switching to a new file, the tree header
 is written to the current file, then the current file is closed. To 
process the multiple files created by <code>ChangeFile()</code>, one must use a <strong><code>TChain</code></strong>.</p>
<p>The new file name has a suffix “<code>_N</code>” where <code>N</code> is equal to <code>fFileNumber+1</code>. By default a Root session starts with <code>fFileNumber=0</code>. One can set <code>fFileNumber</code> to a different value via <code>TTree::SetFileNumber()</code>. In case a file named “<code>_N</code>” already exists, the function will try a file named “<code>__N</code>”, then “<code>___N</code>”, etc. The maximum tree size can be set via the static function <code>TTree::SetMaxTreeSize()</code>. The default value of <code>fgMaxTreeSize</code> is 100 GB. If the current file contains other objects (like <strong><code>TH1</code></strong> and <strong><code>TTree</code></strong>), these objects are automatically moved to the new file.</p>
<h3 id="user-info-attached-to-a-ttree-object"><span class="header-section-number">12.7.6</span> User Info Attached to a TTree Object</h3>
<p>The function <code>TTree::GetUserInfo()</code> allows adding any object defined by a user to the tree that is not depending on the entry number. For example:</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb557-1" title="1">   tree-&gt;GetUserInfo()-&gt;Add(myruninfo);</a></code></pre></div>
<h3 id="indexing-a-tree"><span class="header-section-number">12.7.7</span> Indexing a Tree</h3>
<p>Use <code>TTree::BuildIndex()</code>, to build an index table using expressions depending on the value in the leaves.</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb558-1" title="1">tree-&gt;BuildIndex(majorname, minorname);</a></code></pre></div>
<p>The index is built in the following way:</p>
<ul>
<li>a pass on all entries is made like in <code>TTree::Draw()</code></li>
<li><code>var1 = majorname</code></li>
<li><code>var2 = minorname</code></li>
<li><code>sel  =</code> <span class="math inline">\(2^{31} \times majorname + minorname\)</span></li>
<li>for each entry in the tree the sel expression is evaluated and the results array is sorted into <code>fIndexValues</code></li>
</ul>
<p>Once the index is computed, using the <code>TTree::GetEntryWithIndex(majornumber, minornumber)</code> one entry can be retrieved. Example:</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb559-1" title="1">   <span class="co">// to create an index using leaves Run and Event</span></a>
<a class="sourceLine" id="cb559-2" title="2">   tree.BuildIndex(<span class="st">"Run"</span>,<span class="st">"Event"</span>);</a>
<a class="sourceLine" id="cb559-3" title="3">   <span class="co">// to read entry corresponding to Run=1234 and Event=56789</span></a>
<a class="sourceLine" id="cb559-4" title="4">   tree.GetEntryWithIndex(<span class="dv">1234</span>,<span class="dv">56789</span>);</a></code></pre></div>
<p>Note that <code>majorname</code> and <code>minorname</code> may be expressions using original tree variables e.g.: “<code>run-90000</code>”, “<code>event +3*xx</code>”. In case an expression is specified, the equivalent expression must be computed when calling <code>GetEntryWithIndex()</code>. To build an index with only <code>majorname</code>, specify <code>minorname="0"</code> (default).</p>
<p>Note that once the index is built, it can be saved with the <strong><code>TTree</code></strong> object with:</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb560-1" title="1">   tree.Write();     <span class="co">//if the file has been open in "update" mode</span></a></code></pre></div>
<p>The most convenient place to create the index is at the end of the 
filling process just before saving the tree header. If a previous index 
was computed, it is redefined by this new call.</p>
<p>Note that this function can also be applied to a <strong><code>TChain</code></strong>. The return value is the number of entries in the Index (&lt; 0 indicates failure).</p>
<h2 id="branches"><span class="header-section-number">12.8</span> Branches</h2>
<p>The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called <strong><code>TBranch</code></strong>.
 If two variables are independent, and the designer knows the variables 
will not be used together, they should be placed on separate branches. 
If, however, the variables are related, such as the coordinates of a 
point, it is most efficient to create one branch with both coordinates 
on it. A variable on a <strong><code>TBranch</code></strong> is called a leaf (yes - <strong><code>TLeaf</code></strong>). Another point to keep in mind when designing trees is that branches of the same <strong><code>TTree</code></strong> can be written to separate files. To add a <strong><code>TBranch</code></strong> to a <strong><code>TTree</code></strong> we call the method <strong><code>TTree::Branch()</code></strong>. Note that we DO NOT use the <code>TBranch</code> constructor.</p>
<p>The <code>TTree::Branch</code> method has several signatures. The 
branch type differs by what is stored in it. A branch can hold an entire
 object, a list of simple variables, contents of a folder, contents of a
 <strong><code>TList</code></strong>, or an array of objects. Let’s see some examples. To follow along you will need the shared library <code>libEvent.so</code>. First, check if it is in <code>$ROOTSYS/test</code>. If it is, copy it to your own area. If it is not there, you have to build it by typing make in <code>$ROOTSYS/test</code>.</p>
<h2 id="adding-a-branch-to-hold-a-list-of-variables"><span class="header-section-number">12.9</span> Adding a Branch to Hold a List of Variables</h2>
<p>As in the very first example (<code>cernstaff.root.root</code>) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following <code>TTree::Branch</code> signature:</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb561-1" title="1">   tree-&gt;Branch(<span class="st">"Ev_Branch"</span>,&amp;event,</a>
<a class="sourceLine" id="cb561-2" title="2">                <span class="st">"temp/F:ntrack/I:nseg:nvtex:flag/i"</span>);</a></code></pre></div>
<p>The first parameter is the branch name.</p>
<p>The second parameter is the address from which the first variable is 
to be read. In the code above, “event” is a structure with one float and
 three integers and one unsigned integer. You should not assume that the
 compiler aligns the elements of a structure without gaps. To avoid 
alignment problems, you need to use structures with same length members.
 If your structure does not qualify, you need to create one branch for 
each element of the structure.</p>
<p>The leaf name is NOT used to pick the variable out of the structure, 
but is only used as the name for the leaf. This means that the list of 
variables needs to be in a structure in the order described in the third
 parameter.</p>
<p>This third parameter is a string describing the leaf list. Each leaf 
has a name and a type separated by a “/” and it is separated from the 
next leaf by a “<code>:</code>”.</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb562-1" title="1">&lt;Variable&gt;/&lt;type&gt;:&lt;Variable&gt;/&lt;type&gt;</a></code></pre></div>
<p>The example on the next line has two leafs: a floating-point number called temp and an integer named <code>ntrack</code>.</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb563-1" title="1"><span class="st">"temp/F:ntrack/I:"</span></a></code></pre></div>
<p>The type can be omitted and if no type is given, the same type as the
 previous variable is assumed. This leaf list has three integers called <code>ntrack</code>, <code>nseg</code>, and <code>nvtex</code>.</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb564-1" title="1"><span class="st">"ntrack/I:nseg:nvtex"</span></a></code></pre></div>
<p>There is one more rule: when no type is given for the very first leaf, it becomes a <code>float</code> (F). This leaf list has three floats called <code>temp</code>, <code>mass</code>, and <code>px</code>.</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb565-1" title="1"><span class="st">"temp:mass:px"</span></a></code></pre></div>
<p>The symbols used for the type are:</p>
<ul>
<li><code>C</code>: a character string terminated by the 0 character</li>
<li><code>B</code>: an 8 bit signed integer</li>
<li><code>b</code>: an 8 bit unsigned integer</li>
<li><code>S</code>: a 16 bit signed integer</li>
<li><code>s</code>: a 16 bit unsigned integer</li>
<li><code>I</code>: a 32 bit signed integer</li>
<li><code>i</code>: a 32 bit unsigned integer</li>
<li><code>L</code>: a 64 bit signed integer</li>
<li><code>l</code>: a 64 bit unsigned integer</li>
<li><code>G</code>: a long signed integer, stored as 64 bit</li>
<li><code>g</code>: a long unsigned integer, stored as 64 bit</li>
<li><code>F</code>: a 32 bit floating point</li>
<li><code>D</code>: a 64 bit floating point</li>
<li><code>O</code>: [the letter ‘o’, not a zero] a boolean (Bool_t)</li>
</ul>
<p>The type is used for a byte count to decide how much space to 
allocate. The variable written is simply the block of bytes starting at 
the starting address given in the second parameter. It may or may not 
match the leaf list depending on whether or not the programmer is being 
careful when choosing the leaf address, name, and type.</p>
<p>By default, a variable will be copied with the number of bytes 
specified in the type descriptor symbol. However, if the type consists 
of two characters, the number specifies the number of bytes to be used 
when copying the variable to the output buffer. The line below describes
 <code>ntrack</code> to be written as a 16-bit integer (rather than a 32-bit integer).</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb566-1" title="1"><span class="st">"ntrack/I2"</span></a></code></pre></div>
<p>With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the <code>f[n]</code> notation when describing the leaf.</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb567-1" title="1">   <span class="dt">Float_t</span>  f[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb567-2" title="2">   tree-&gt;Branch(<span class="st">"fBranch"</span>,f,<span class="st">"f[10]/F"</span>);</a></code></pre></div>
<p>You can also add an array of variable length:</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb568-1" title="1">{</a>
<a class="sourceLine" id="cb568-2" title="2">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"peter.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb568-3" title="3">   <span class="dt">Int_t</span> nPhot;</a>
<a class="sourceLine" id="cb568-4" title="4">   <span class="dt">Float_t</span> E[<span class="dv">500</span>];</a>
<a class="sourceLine" id="cb568-5" title="5">   TTree* nEmcPhotons = <span class="kw">new</span> TTree(<span class="st">"nEmcPhotons"</span>,<span class="st">"EMC Photons"</span>);</a>
<a class="sourceLine" id="cb568-6" title="6">   nEmcPhotons-&gt;Branch(<span class="st">"nPhot"</span>,&amp;nPhot,<span class="st">"nPhot/I"</span>);</a>
<a class="sourceLine" id="cb568-7" title="7">   nEmcPhotons-&gt;Branch(<span class="st">"E"</span>,E,<span class="st">"E[nPhot]/F"</span>);</a>
<a class="sourceLine" id="cb568-8" title="8">}</a></code></pre></div>
<p>See “Example 2: A Tree with a C Structure” below (<code>$ROOTSYS/tutorials/tree/tree2.C</code>) and <code>staff.C</code> at the beginning of this chapter.</p>
<h2 id="adding-a-tbranch-to-hold-an-object"><span class="header-section-number">12.10</span> Adding a TBranch to Hold an Object</h2>
<p>To write a branch to hold an event object, we need to load the definition of the <code>Event</code> class, which is in <code>$ROOTSYS/test/libEvent.so</code> (if it doesn’t exist type make in <code>$ROOTSYS/test</code>). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb569-1" title="1">root[] .L libEvent.so</a></code></pre></div>
<p>First, we need to open a file and create a tree.</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb570-1" title="1">root[]     TFile *f = <span class="kw">new</span> TFile(<span class="st">"AFile.root"</span>,<span class="st">"RECREATE"</span>)</a>
<a class="sourceLine" id="cb570-2" title="2">root[]     TTree *tree = <span class="kw">new</span> TTree(<span class="st">"T"</span>,<span class="st">"A Root Tree"</span>)</a></code></pre></div>
<p>We need to create a pointer to an <code>Event</code> object that will be used as a reference in the <code>TTree::Branch</code> method. Then we create a branch with the <code>TTree::Branch</code> method.</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb571-1" title="1">root[]     Event *event = <span class="kw">new</span> Event()</a>
<a class="sourceLine" id="cb571-2" title="2">root[]     tree-&gt;Branch(<span class="st">"EventBranch"</span>,<span class="st">"Event"</span>,&amp;event,<span class="dv">32000</span>,<span class="dv">99</span>)</a></code></pre></div>
<p>To add a branch to hold an object we use the signature above. The 
first parameter is the name of the branch. The second parameter is the 
name of the class of the object to be stored. The third parameter is the
 address of a pointer to the object to be stored.</p>
<p>Note that it is an address of a pointer to the object, not just a pointer to the object.</p>
<p>The fourth parameter is the buffer size and is by default 32000 
bytes. It is the number of bytes of data for that branch to save to a 
buffer until it is saved to the file. The last parameter is the 
split-level, which is the topic of the next section. Static class 
members are not part of an object and thus not written with the object. 
You could store them separately by collecting these values in a special 
“status” object and write it to the file outside of the tree. If it 
makes sense to store them for each object, make them a regular data 
member.</p>
<h3 id="setting-the-split-level"><span class="header-section-number">12.10.1</span> Setting the Split-level</h3>
<p>To split a branch means to create a sub-branch for each data member 
in the object. The split-level can be set to 0 to disable splitting or 
it can be set to a number between 1 and 99 indicating the depth of 
splitting.</p>
<p>If the split-level is set to zero, the whole object is written in its entirety to one branch. The <strong><code>TTree</code></strong> will look like the one on the right, with one branch and one leaf holding the entire event object.</p>
<figure>
<img src="ROOTUsersGuide_files/030000FA.png" alt="A split and not split tree"><figcaption>A split and not split tree</figcaption>
</figure>
<p>When the split-level is 1, an object data member is assigned a 
branch. If the split-level is 2, the data member objects will be split 
also, and a split level of 3 its data members objects, will be split. As
 the split-level increases so does the splitting depth. The ROOT default
 for the split-level is 99. This means the object will be split to the 
maximum.</p>
<h4 id="memory-considerations-when-splitting-a-branch"><span class="header-section-number">12.10.1.1</span> Memory Considerations when Splitting a Branch</h4>
<p>Splitting a branch can quickly generate many branches. Each branch 
has its own buffer in memory. In case of many branches (say more than 
100), you should adjust the buffer size accordingly. A recommended 
buffer size is 32000 bytes if you have less than 50 branches. Around 
16000 bytes if you have less than 100 branches and 4000 bytes if you 
have more than 500 branches. These numbers are recommended for computers
 with memory size ranging from 32MB to 256MB. If you have more memory, 
you should specify larger buffer sizes. However, in this case, do not 
forget that your file might be used on another machine with a smaller 
memory configuration.</p>
<h4 id="performance-considerations-when-splitting-a-branch"><span class="header-section-number">12.10.1.2</span> Performance Considerations when Splitting a Branch</h4>
<p>A split branch is faster to read, but slightly slower to write. The 
reading is quicker because variables of the same type are stored 
consecutively and the type does not have to be read each time. It is 
slower to write because of the large number of buffers as described 
above. See "</p>
<p>Performance Benchmarks" for performance impact of split and non-split mode.</p>
<h4 id="rules-for-splitting"><span class="header-section-number">12.10.1.3</span> Rules for Splitting</h4>
<p>When splitting a branch, variables of different types are handled 
differently. Here are the rules that apply when splitting a branch.</p>
<ul>
<li><p>If a data member is a basic type, it becomes one branch of class <strong><code>TBranchElement</code></strong>.</p></li>
<li><p>A data member can be an array of basic types. In this case, one single branch is created for the array.</p></li>
<li><p>A data member can be a pointer to an array of basic types. The 
length can vary, and must be specified in the comment field of the data 
member in the class definition. See “Input/Output”.</p></li>
<li><p>Pointer data member are not split, except for pointers to a <strong><code>TClonesArray</code></strong>. The <strong><code>TClonesArray</code></strong> (pointed to) is split if the split level is greater than two. When the split level is one, the <strong><code>TClonesArray</code></strong> is not split.</p></li>
<li><p>If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class <code>Streamer</code> function to serialize the object into the branch buffer.</p></li>
<li><p>If a data member is an object, the data members of this object 
are split into branches according to the split-level 
(i.e.&nbsp;split-level &gt; 2).</p></li>
<li><p>Base classes are split when the object is split.</p></li>
<li><p>Abstract base classes are never split.</p></li>
<li><p>All STL containers are supported.</p></li>
</ul>
<div class="sourceCode" id="cb572"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb572-1" title="1">   <span class="co">// STL vector of vectors of TAxis*</span></a>
<a class="sourceLine" id="cb572-2" title="2">   vector&lt;vector&lt;TAxis *&gt; &gt;  fVectAxis;</a>
<a class="sourceLine" id="cb572-3" title="3">   <span class="co">// STL map of string/vector</span></a>
<a class="sourceLine" id="cb572-4" title="4">   map&lt;string,vector&lt;<span class="dt">int</span>&gt; &gt;  fMapString;</a>
<a class="sourceLine" id="cb572-5" title="5">   <span class="co">// STL deque of pair</span></a>
<a class="sourceLine" id="cb572-6" title="6">   deque&lt;pair&lt;<span class="dt">float</span>,<span class="dt">float</span>&gt; &gt; fDequePair;</a></code></pre></div>
<ul>
<li><p>C-structure data members are not supported in split mode.</p></li>
<li><p>An object that is not split may be slow to browse.</p></li>
<li><p>A STL container that is not split will not be accessible in the browser.</p></li>
</ul>
<h3 id="exempt-a-data-member-from-splitting"><span class="header-section-number">12.10.2</span> Exempt a Data Member from Splitting</h3>
<p>If you are creating a branch with an object and in general you want 
the data members to be split, but you want to exempt a data member from 
the split. You can specify this in the comment field of the data member:</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb573-1" title="1"><span class="kw">class</span> Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb573-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb573-3" title="3">      EventHeader    fEvtHdr;      <span class="co">//|| Don't split the header</span></a></code></pre></div>
<h3 id="adding-a-branch-to-hold-a-tclonesarray"><span class="header-section-number">12.10.3</span> Adding a Branch to Hold a TClonesArray</h3>
<p>ROOT has two classes to manage arrays of objects. The <strong><code>TObjArray</code></strong> can manage objects of different classes, and the <strong><code>TClonesArray</code></strong> that specializes in managing objects of the same class (hence the name Clones Array). <strong><code>TClonesArray</code></strong>
 takes advantage of the constant size of each element when adding the 
elements to the array. Instead of allocating memory for each new object 
as it is added, it reuses the memory. Here is an example of the time a <strong><code>TClonesArray</code></strong> can save over a <strong><code>TObjArray</code></strong>. We have 100,000 events, and each has 10,000 tracks, which gives 1,000,000,000 tracks. If we use a <strong><code>TObjArray</code></strong>
 for the tracks, we implicitly make a call to new and a corresponding 
call to delete for each track. The time it takes to make a pair of 
new/delete calls is about 7 s (10-6). If we multiply the number of 
tracks by 7 s, (1,000,000,000 * 7 * 10-6) we calculate that the time 
allocating and freeing memory is about 2 hours. This is the chunk of 
time saved when a <strong><code>TClonesArray</code></strong> is used rather than a <strong><code>TObjArray</code></strong>. If you do not want to wait 2 hours for your tracks (or equivalent objects), be sure to use a <strong><code>TClonesArray</code></strong> for same-class objects arrays. Branches with <strong><code>TClonesArrays</code></strong> use the same method (<code>TTree::Branch</code>) as any other object described above. If splitting is specified the objects in the <strong><code>TClonesArray</code></strong> are split, not the <strong><code>TClonesArray</code></strong> itself.</p>
<h3 id="identical-branch-names"><span class="header-section-number">12.10.4</span> Identical Branch Names</h3>
<p>When a top-level object (say <code>event</code>), has two data 
members of the same class the sub branches end up with identical names. 
To distinguish the sub branch we must associate them with the master 
branch by including a “<code>.</code>” (a dot) at the end of the master branch name. This will force the name of the sub branch to be <code>master.sub</code> branch instead of simply <code>sub</code> branch. For example, a tree has two branches <code>Trigger</code> and <code>MuonTrigger</code>, each containing an object of the same class (<code>Trigger</code>). To identify uniquely the sub branches we add the dot:</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb574-1" title="1">   tree-&gt;Branch(<span class="st">"Trigger."</span>,<span class="st">"Trigger"</span>,&amp;b1,<span class="dv">8000</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb574-2" title="2">   tree-&gt;Branch(<span class="st">"MuonTrigger."</span>,<span class="st">"Trigger"</span>,&amp;b2,<span class="dv">8000</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>If <code>Trigger</code> has three members, <code>T1</code>, <code>T2</code>, <code>T3</code>, the two instructions above will generate sub branches called: <code>Trigger.T1</code>, <code>Trigger.T2</code>, <code>Trigger.T3</code>, <code>MuonTrigger.T1</code>, <code>MuonTrigger.T2</code>, and<code>MuonTrigger.T3</code>.</p>
<h2 id="adding-a-branch-with-a-folder"><span class="header-section-number">12.11</span> Adding a Branch with a Folder</h2>
<p>Use the syntax below to add a branch from a folder:</p>
<div class="sourceCode" id="cb575"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb575-1" title="1">   tree-&gt;Branch(<span class="st">"/aFolder"</span>);</a></code></pre></div>
<p>This method creates one branch for each element in the folder. The method returns the total number of branches created.</p>
<h2 id="adding-a-branch-with-a-collection"><span class="header-section-number">12.12</span> Adding a Branch with a Collection</h2>
<p>This <code>Branch</code> method creates one branch for each element in the collection.</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb576-1" title="1">   tree-&gt;Branch(*aCollection, <span class="dv">8000</span>, <span class="dv">99</span>);</a>
<a class="sourceLine" id="cb576-2" title="2">   <span class="co">// Int_t TTree::Branch(TCollection *list, Int_t bufsize,</span></a>
<a class="sourceLine" id="cb576-3" title="3">   <span class="co">//                     Int_t splitlevel, const char *name)</span></a></code></pre></div>
<p>The method returns the total number of branches created. Each entry 
in the collection becomes a top level branch if the corresponding class 
is not a collection. If it is a collection, the entry in the collection 
becomes in turn top level branches, etc. The split level is decreased by
 1 every time a new collection is found. For example if <code>list</code> is a <strong><code>TObjArray</code></strong>*</p>
<ul>
<li><p>If <code>splitlevel = 1</code>, one top level branch is created for each element of the <strong><code>TObjArray</code></strong>.</p></li>
<li><p>If <code>splitlevel = 2</code>, one top level branch is created for each array element. If one of the array elements is a <strong><code>TCollection</code></strong>, one top level branch will be created for each element of this collection.</p></li>
</ul>
<p>In case a collection element is a <strong><code>TClonesArray</code></strong>, the special Tree constructor for <strong><code>TClonesArray</code></strong> is called. The collection itself cannot be a <strong><code>TClonesArray</code></strong>. If <code>name</code> is given, all branch names will be prefixed with <code>name_</code>.</p>
<p><em>IMPORTANT NOTE1:</em> This function should not be called if <code>splitlevel&lt;1</code>. <em>IMPORTANT NOTE2:</em>
 The branches created by this function will have names corresponding to 
the collection or object names. It is important to give names to 
collections to avoid misleading branch names or identical branch names. 
By default collections have a name equal to the corresponding class 
name, e.g.&nbsp;the default name of <strong><code>TList</code></strong> is “<code>TList</code>”.</p>
<h2 id="examples-for-writing-and-reading-trees"><span class="header-section-number">12.13</span> Examples for Writing and Reading Trees</h2>
<p>The following sections are examples of writing and reading trees 
increasing in complexity from a simple tree with a few variables to a 
tree containing folders and complex Event objects. Each example has a 
named script in the <code>$ROOTSYS/tutorials/tree</code> directory. They are called tree1.C to tree4.C. The examples are:</p>
<ul>
<li><p><code>tree1.C</code>: a tree with several simple (integers and floating point) variables.</p></li>
<li><p><code>tree2.C</code>: a tree built from a C structure (<code>struct</code>). This example uses the <code>Geant3</code> C wrapper as an example of a FORTRAN common block ported to C with a C structure.</p></li>
<li><p><code>tree3.C:</code> in this example, we will show how to extend
 a tree with a branch from another tree with the Friends feature. These 
trees have branches with variable length arrays. Each entry has a 
variable number of tracks, and each track has several variables.</p></li>
<li><p><code>tree4.C:</code> a tree with a class (<code>Event</code>). The class Event is defined in <code>$ROOTSYS/test</code>. In this example we first encounter the impact of splitting a branch.</p></li>
</ul>
<p>Each script contains the main function, with the same name as the file (i.e.&nbsp;<code>tree1</code>), the function to write - <code>tree1w</code>, and the function to read - <code>tree1r</code>.
 If the script is not run in batch mode, it displays the tree in the 
browser and tree viewer. To study the example scripts, you can either 
execute the main script, or load the script and execute a specific 
function. For example:</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb577-1" title="1"><span class="co">// execute the function that writes, reads, shows the tree</span></a>
<a class="sourceLine" id="cb577-2" title="2">root[]     x tree1.C</a>
<a class="sourceLine" id="cb577-3" title="3"><span class="co">// use ACLiC to build shared library, check syntax, execute</span></a>
<a class="sourceLine" id="cb577-4" title="4">root[] x tree1.C++</a>
<a class="sourceLine" id="cb577-5" title="5"><span class="co">// Load the script and select a function to execute</span></a>
<a class="sourceLine" id="cb577-6" title="6">root[]     L tree1.C</a>
<a class="sourceLine" id="cb577-7" title="7">root[]     tree1w()</a>
<a class="sourceLine" id="cb577-8" title="8">root[]     tree1r()</a></code></pre></div>
<h2 id="example-1-a-tree-with-simple-variables"><span class="header-section-number">12.14</span> Example 1: A Tree with Simple Variables</h2>
<p>This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.</p>
<h3 id="writing-the-tree"><span class="header-section-number">12.14.1</span> Writing the Tree</h3>
<p>Below is the function that writes the tree (<code>tree1w</code>). First, the variables are defined (<code>px, py, pz,</code> <code>random</code> and <code>ev</code>). Then we add a branch for each of the variables to the tree, by calling the <code>TTree::Branch</code> method for each variable.</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb578-1" title="1"><span class="dt">void</span> tree1w(){</a>
<a class="sourceLine" id="cb578-2" title="2"></a>
<a class="sourceLine" id="cb578-3" title="3">   <span class="co">// create a tree file tree1.root - create the file, the Tree and</span></a>
<a class="sourceLine" id="cb578-4" title="4">   <span class="co">// a few branches</span></a>
<a class="sourceLine" id="cb578-5" title="5">   TFile f(<span class="st">"tree1.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb578-6" title="6">   TTree t1(<span class="st">"t1"</span>,<span class="st">"a simple Tree with simple variables"</span>);</a>
<a class="sourceLine" id="cb578-7" title="7">   <span class="dt">Float_t</span> px, py, pz;</a>
<a class="sourceLine" id="cb578-8" title="8">   <span class="dt">Double_t</span> random;</a>
<a class="sourceLine" id="cb578-9" title="9">   <span class="dt">Int_t</span> ev;</a>
<a class="sourceLine" id="cb578-10" title="10">   t1.Branch(<span class="st">"px"</span>,&amp;px,<span class="st">"px/F"</span>);</a>
<a class="sourceLine" id="cb578-11" title="11">   t1.Branch(<span class="st">"py"</span>,&amp;py,<span class="st">"py/F"</span>);</a>
<a class="sourceLine" id="cb578-12" title="12">   t1.Branch(<span class="st">"pz"</span>,&amp;pz,<span class="st">"pz/F"</span>);</a>
<a class="sourceLine" id="cb578-13" title="13">   t1.Branch(<span class="st">"ev"</span>,&amp;ev,<span class="st">"ev/I"</span>);</a>
<a class="sourceLine" id="cb578-14" title="14"></a>
<a class="sourceLine" id="cb578-15" title="15">   <span class="co">// fill the tree</span></a>
<a class="sourceLine" id="cb578-16" title="16">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10000</span>; i++) {</a>
<a class="sourceLine" id="cb578-17" title="17">      gRandom-&gt;Rannor(px,py);</a>
<a class="sourceLine" id="cb578-18" title="18">      pz = px*px + py*py;</a>
<a class="sourceLine" id="cb578-19" title="19">      random = gRandom-&gt;Rndm();</a>
<a class="sourceLine" id="cb578-20" title="20">      ev = i;</a>
<a class="sourceLine" id="cb578-21" title="21">      t1.Fill();</a>
<a class="sourceLine" id="cb578-22" title="22">   }</a>
<a class="sourceLine" id="cb578-23" title="23">   <span class="co">// save the Tree heade; the file will be automatically closed</span></a>
<a class="sourceLine" id="cb578-24" title="24">   <span class="co">// when going out of the function scope</span></a>
<a class="sourceLine" id="cb578-25" title="25">   t1.Write();</a>
<a class="sourceLine" id="cb578-26" title="26">}</a></code></pre></div>
<h4 id="creating-branches-with-a-single-variable"><span class="header-section-number">12.14.1.1</span> Creating Branches with A single Variable</h4>
<p>This is the signature of <code>TTree::Branch</code> to create a branch with a list of variables:</p>
<div class="sourceCode" id="cb579"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb579-1" title="1">   TBranch* TTree::Branch(<span class="at">const</span> <span class="dt">char</span>* name,<span class="dt">void</span>* address,</a>
<a class="sourceLine" id="cb579-2" title="2">                          <span class="at">const</span> <span class="dt">char</span>* leaflist,</a>
<a class="sourceLine" id="cb579-3" title="3">                          <span class="dt">Int_t</span> bufsize = <span class="dv">32000</span>)</a></code></pre></div>
<p>The first parameter is the branch name. The second parameter is the 
address from which to read the value. The third parameter is the leaf 
list with the name and type of each leaf. In this example, each branch 
has only one leaf. In the box below, the branch is named <code>px</code> and has one floating point type leaf also called <code>px</code>.</p>
<div class="sourceCode" id="cb580"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb580-1" title="1">   t1.Branch(<span class="st">"px"</span>,&amp;px,<span class="st">"px/F"</span>);</a></code></pre></div>
<h4 id="filling-the-tree"><span class="header-section-number">12.14.1.2</span> Filling the Tree</h4>
<p>First we find some random values for the variables. We assign <code>px</code> and <code>py</code> a Gaussian with mean = 0 and sigma = 1 by calling <code>gRandom-&gt;Rannor(px,py)</code>, and calculate<code>pz</code>. Then we call the <code>TTree::Fill()</code> method. The call <code>t1.Fill()</code>
 fills all branches in the tree because we have already organized the 
tree into branches and told each branch where to get the value from. 
After this script is executed we have a ROOT file called <code>tree1.root</code> with a tree called <code>t1</code>. There is a possibility to fill branches one by one using the method <code>TBranch::Fill()</code>. In this case you do not need to call <code>TTree::Fill()</code> method. The entries can be set by <code>TTree::SetEntries(Double_t n)</code>. Calling this method makes sense only if the number of existing entries is null.</p>
<h3 id="viewing-the-tree"><span class="header-section-number">12.14.2</span> Viewing the Tree</h3>
<figure>
<img src="ROOTUsersGuide_files/030000FC.png" alt="The tree1.root file and its tree in the browser and a leaf histogram"><figcaption>The tree1.root file and its tree in the browser and a leaf histogram</figcaption>
</figure>
<p>In the right panel of the ROOT object browse are the branches: <code>ev</code>, <code>px</code>, <code>py</code>, <code>pz</code>, and <code>random</code>.
 Note that these are shown as leaves because they are “end” branches 
with only one leaf. To histogram a leaf, we can simply double click on 
it in the browser. This is how the tree <code>t1</code> looks in the 
Tree Viewer. Here we can add a cut and add other operations for 
histogramming the leaves. See “The Tree Viewer”. For example, we can 
plot a two dimensional histogram.</p>
<figure>
<img src="ROOTUsersGuide_files/030000FE.png" alt="The tree viewer"><figcaption>The tree viewer</figcaption>
</figure>
<h3 id="reading-the-tree"><span class="header-section-number">12.14.3</span> Reading the Tree</h3>
<p>The <code>tree1r</code> function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb581-1" title="1">   <span class="dt">Float_t</span> px, py, pz;</a></code></pre></div>
<p>Then we tell the tree to populate these variables when reading an entry. We do this with the method <code>TTree::SetBranchAddress</code>.
 The first parameter is the branch name, and the second is the address 
of the variable where the branch data is to be placed. In this example, 
the branch name is <code>px</code>. This name was given when the tree was written (see <code>tree1w</code>). The second parameter is the address of the variable <code>px</code>.</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb582-1" title="1">   t1-&gt;SetBranchAddress(<span class="st">"px"</span>,&amp;px);</a></code></pre></div>
<h4 id="getentry"><span class="header-section-number">12.14.3.1</span> GetEntry</h4>
<p>Once the branches have been given the address, a specific entry can be read into the variables with the method <code>TTree::GetEntry(n)</code>. It reads all the branches for entry (n) and populates the given address accordingly. By default, <code>GetEntry()</code>
 reuses the space allocated by the previous object for each branch. You 
can force the previous object to be automatically deleted if you call <code>mybranch.SetAutoDelete(kTRUE)</code> (default is <code>kFALSE</code>).</p>
<p>Consider the example in <code>$ROOTSYS/test/Event.h</code>. The top-level branch in the tree <code>T</code> is declared with:</p>
<div class="sourceCode" id="cb583"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb583-1" title="1">   Event *event = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb583-2" title="2">   <span class="co">// event must be null or point to a valid object;</span></a>
<a class="sourceLine" id="cb583-3" title="3">   <span class="co">// it must be initialized</span></a>
<a class="sourceLine" id="cb583-4" title="4">   T.SetBranchAddress(<span class="st">"event"</span>,&amp;event);</a></code></pre></div>
<p>When reading the Tree, one can choose one of these 3 options:</p>
<p>Option 1:</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb584-1" title="1">   <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i&lt;nentries; i++) {</a>
<a class="sourceLine" id="cb584-2" title="2">      T.GetEntry(i);</a>
<a class="sourceLine" id="cb584-3" title="3">      <span class="co">//the object event has been filled at this point</span></a>
<a class="sourceLine" id="cb584-4" title="4">   }</a></code></pre></div>
<p>This is the default and recommended way to create an object of the class <code>Event.</code>It will be pointed by <code>event</code>.</p>
<p>At the following entries, <code>event</code> will be overwritten by the new data. All internal members that are <strong><code>TObject</code></strong>* are automatically deleted. It is important that these members be in a valid state when <code>GetEntry</code> is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters “<code>-&gt;</code>” are specified as the first characters in the comment field of the data member declaration.</p>
<p>The pointer member is read via the <code>pointer-&gt;Streamer(buf)</code> if “<code>-&gt;</code>” is specified. In this case, it is assumed that the pointer is never null (see pointer <code>TClonesArray *fTracks</code> in the <code>$ROOTSYS/test/Event</code> example). If “<code>-&gt;</code>” is not specified, the pointer member is read via <code>buf &gt;&gt; pointer</code>. In this case the pointer may be null. Note that the option with “<code>-&gt;</code>” is faster to read or write and it also consumes less space in the file.</p>
<p>Option 2 - the option <code>AutoDelete</code> is set:</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb585-1" title="1">   TBranch *branch = T.GetBranch(<span class="st">"event"</span>);</a>
<a class="sourceLine" id="cb585-2" title="2">   branch-&gt;SetAddress(&amp;event);</a>
<a class="sourceLine" id="cb585-3" title="3">   branch-&gt;SetAutoDelete(kTRUE);</a>
<a class="sourceLine" id="cb585-4" title="4">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;nentries; i++) {</a>
<a class="sourceLine" id="cb585-5" title="5">      T.GetEntry(i); <span class="co">// the object event has been filled at this point</span></a>
<a class="sourceLine" id="cb585-6" title="6">   }</a></code></pre></div>
<p>At any iteration, the <code>GetEntry</code> deletes the object <code>event</code> and a new instance of <code>Event</code> is created and filled.</p>
<p>Option 3 - same as option 1, but you delete the event yourself:</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb586-1" title="1">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;nentries; i++) {</a>
<a class="sourceLine" id="cb586-2" title="2">      <span class="kw">delete</span> event;</a>
<a class="sourceLine" id="cb586-3" title="3">      event = <span class="dv">0</span>;      <span class="co">//EXTREMELY IMPORTANT</span></a>
<a class="sourceLine" id="cb586-4" title="4">      T.GetEntry(i);</a>
<a class="sourceLine" id="cb586-5" title="5">      <span class="co">// the objrect event has been filled at this point</span></a>
<a class="sourceLine" id="cb586-6" title="6">   }</a></code></pre></div>
<p>It is strongly recommended to use the default option 1. It has the additional advantage that functions like <code>TTree::Draw</code> (internally calling <code>TTree::GetEntry</code>)
 will be functional even when the classes in the file are not available.
 Reading selected branches is quicker than reading an entire entry. If 
you are interested in only one branch, you can use the <code>TBranch::GetEntry</code> method and only that branch is read. Here is the script <code>tree1r</code>:</p>
<div class="sourceCode" id="cb587"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb587-1" title="1"><span class="dt">void</span> tree1r(){</a>
<a class="sourceLine" id="cb587-2" title="2">   <span class="co">// read the Tree generated by tree1w and fill two histograms</span></a>
<a class="sourceLine" id="cb587-3" title="3">   <span class="co">// note that we use "new" to create the TFile and TTree objects,</span></a>
<a class="sourceLine" id="cb587-4" title="4">   <span class="co">// to keep them alive after leaving this function.</span></a>
<a class="sourceLine" id="cb587-5" title="5">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"tree1.root"</span>);</a>
<a class="sourceLine" id="cb587-6" title="6">   TTree *t1 = (TTree*)f-&gt;Get(<span class="st">"t1"</span>);</a>
<a class="sourceLine" id="cb587-7" title="7">   <span class="dt">Float_t</span> px, py, pz;</a>
<a class="sourceLine" id="cb587-8" title="8">   <span class="dt">Double_t</span> random;</a>
<a class="sourceLine" id="cb587-9" title="9">   <span class="dt">Int_t</span> ev;</a>
<a class="sourceLine" id="cb587-10" title="10">   t1-&gt;SetBranchAddress(<span class="st">"px"</span>,&amp;px);</a>
<a class="sourceLine" id="cb587-11" title="11">   t1-&gt;SetBranchAddress(<span class="st">"py"</span>,&amp;py);</a>
<a class="sourceLine" id="cb587-12" title="12">   t1-&gt;SetBranchAddress(<span class="st">"pz"</span>,&amp;pz);</a>
<a class="sourceLine" id="cb587-13" title="13">   t1-&gt;SetBranchAddress(<span class="st">"random"</span>,&amp;random);</a>
<a class="sourceLine" id="cb587-14" title="14">   t1-&gt;SetBranchAddress(<span class="st">"ev"</span>,&amp;ev);</a>
<a class="sourceLine" id="cb587-15" title="15">   <span class="co">// create two histograms</span></a>
<a class="sourceLine" id="cb587-16" title="16">   TH1F *hpx   = <span class="kw">new</span> TH1F(<span class="st">"hpx"</span>,<span class="st">"px distribution"</span>,<span class="dv">100</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb587-17" title="17">   TH2F *hpxpy = <span class="kw">new</span> TH2F(<span class="st">"hpxpy"</span>,<span class="st">"py vs px"</span>,<span class="dv">30</span>,-<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">30</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb587-18" title="18">   <span class="co">//read all entries and fill the histograms</span></a>
<a class="sourceLine" id="cb587-19" title="19">   <span class="dt">Int_t</span> nentries = (<span class="dt">Int_t</span>)t1-&gt;GetEntries();</a>
<a class="sourceLine" id="cb587-20" title="20">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;nentries; i++) {</a>
<a class="sourceLine" id="cb587-21" title="21">      t1-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb587-22" title="22">      hpx-&gt;Fill(px);</a>
<a class="sourceLine" id="cb587-23" title="23">      hpxpy-&gt;Fill(px,py);</a>
<a class="sourceLine" id="cb587-24" title="24">   }</a>
<a class="sourceLine" id="cb587-25" title="25">   <span class="co">// We do not close the file. We want to keep the generated</span></a>
<a class="sourceLine" id="cb587-26" title="26">   <span class="co">// histograms we open a browser and the TreeViewer</span></a>
<a class="sourceLine" id="cb587-27" title="27">   <span class="cf">if</span> (gROOT-&gt;IsBatch()) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb587-28" title="28">   <span class="kw">new</span> TBrowser ();</a>
<a class="sourceLine" id="cb587-29" title="29">   t1-&gt;StartViewer();</a>
<a class="sourceLine" id="cb587-30" title="30"></a>
<a class="sourceLine" id="cb587-31" title="31">   <span class="co">//In the browser, click on "ROOT Files", then on "tree1.root"</span></a>
<a class="sourceLine" id="cb587-32" title="32">   <span class="co">//You can click on the histogram icons in the right panel to draw</span></a>
<a class="sourceLine" id="cb587-33" title="33">   <span class="co">//them in the TreeViewer, follow the instructions in the Help.</span></a>
<a class="sourceLine" id="cb587-34" title="34">}</a></code></pre></div>
<h2 id="example-2-a-tree-with-a-c-structure"><span class="header-section-number">12.15</span> Example 2: A Tree with a C Structure</h2>
<p>The executable script for this example is <code>$ROOTSYS/tutorials/tree/tree2.C.</code>In this example we show:</p>
<ul>
<li>how to build branches from a C structure</li>
<li>how to make a branch with a fixed length array</li>
<li>how to make a branch with a variable length array</li>
<li>how to read selective branches</li>
<li>how to fill a histogram from a branch</li>
<li>how to use <code>TTree::Draw</code> to show a 3D plot</li>
</ul>
<p>A C structure (<code>struct</code>) is used to build a ROOT tree. In general we discourage the use of C structures<code>,</code> we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example <code>struct</code> holds simple variables and arrays. It maps to a Geant3 common block <code>/gctrak/.</code>This is the definition of the common block/structure:</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb588-1" title="1"><span class="at">const</span> <span class="dt">Int_t</span> MAXMEC = <span class="dv">30</span>;</a>
<a class="sourceLine" id="cb588-2" title="2"><span class="co">// PARAMETER (MAXMEC=30)</span></a>
<a class="sourceLine" id="cb588-3" title="3"><span class="co">// COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7)</span></a>
<a class="sourceLine" id="cb588-4" title="4"><span class="co">//     + ,NMEC,LMEC(MAXMEC)</span></a>
<a class="sourceLine" id="cb588-5" title="5"><span class="co">//     + ,NAMEC(MAXMEC),NSTEP</span></a>
<a class="sourceLine" id="cb588-6" title="6"><span class="co">//     + ,PID,DESTEP,DESTEL,SAFETY,SLENG</span></a>
<a class="sourceLine" id="cb588-7" title="7"><span class="co">//     + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT</span></a>
<a class="sourceLine" id="cb588-8" title="8"></a>
<a class="sourceLine" id="cb588-9" title="9"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb588-10" title="10">   <span class="dt">Float_t</span>  vect[<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb588-11" title="11">   <span class="dt">Float_t</span>  getot;</a>
<a class="sourceLine" id="cb588-12" title="12">   <span class="dt">Float_t</span>  gekin;</a>
<a class="sourceLine" id="cb588-13" title="13">   <span class="dt">Float_t</span>  vout[<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb588-14" title="14">   <span class="dt">Int_t</span>    nmec;</a>
<a class="sourceLine" id="cb588-15" title="15">   <span class="dt">Int_t</span>    lmec[MAXMEC];</a>
<a class="sourceLine" id="cb588-16" title="16">   <span class="dt">Int_t</span>    namec[MAXMEC];</a>
<a class="sourceLine" id="cb588-17" title="17">   <span class="dt">Int_t</span>    nstep;</a>
<a class="sourceLine" id="cb588-18" title="18">   <span class="dt">Int_t</span>    pid;</a>
<a class="sourceLine" id="cb588-19" title="19">   <span class="dt">Float_t</span>  destep;</a>
<a class="sourceLine" id="cb588-20" title="20">   <span class="dt">Float_t</span>  destel;</a>
<a class="sourceLine" id="cb588-21" title="21">   <span class="dt">Float_t</span>  safety;</a>
<a class="sourceLine" id="cb588-22" title="22">   <span class="dt">Float_t</span>  sleng;</a>
<a class="sourceLine" id="cb588-23" title="23">   <span class="dt">Float_t</span>  step;</a>
<a class="sourceLine" id="cb588-24" title="24">   <span class="dt">Float_t</span>  snext;</a>
<a class="sourceLine" id="cb588-25" title="25">   <span class="dt">Float_t</span>  sfield;</a>
<a class="sourceLine" id="cb588-26" title="26">   <span class="dt">Float_t</span>  tofg;</a>
<a class="sourceLine" id="cb588-27" title="27">   <span class="dt">Float_t</span>  gekrat;</a>
<a class="sourceLine" id="cb588-28" title="28">   <span class="dt">Float_t</span>  upwght;</a>
<a class="sourceLine" id="cb588-29" title="29">} <span class="dt">Gctrak_t</span>;</a></code></pre></div>
<p>When using Geant3, the common block is filled by Geant3 routines at each step and only the <code>TTree::Fill</code> method needs to be called. In this example we emulate the Geant3 step routine with the <code>helixStep</code> function. We also emulate the filling of the particle values. The calls to the <code>Branch</code> methods are the same as if Geant3 were used.</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb589-1" title="1"><span class="dt">void</span> helixStep(<span class="dt">Float_t</span> step, <span class="dt">Float_t</span> *vect, <span class="dt">Float_t</span> *vout)</a>
<a class="sourceLine" id="cb589-2" title="2">{</a>
<a class="sourceLine" id="cb589-3" title="3">   <span class="co">// extrapolate track in constant field</span></a>
<a class="sourceLine" id="cb589-4" title="4">   <span class="dt">Float_t</span> field = <span class="dv">20</span>; <span class="co">// field in kilogauss</span></a>
<a class="sourceLine" id="cb589-5" title="5">   <span class="kw">enum</span> Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};</a>
<a class="sourceLine" id="cb589-6" title="6">   vout[kPP] = vect[kPP];</a>
<a class="sourceLine" id="cb589-7" title="7"></a>
<a class="sourceLine" id="cb589-8" title="8">   <span class="dt">Float_t</span> h4    = field*<span class="fl">2.99792e-4</span>;</a>
<a class="sourceLine" id="cb589-9" title="9">   <span class="dt">Float_t</span> rho   = -h4/vect[kPP];</a>
<a class="sourceLine" id="cb589-10" title="10">   <span class="dt">Float_t</span> tet   = rho*step;</a>
<a class="sourceLine" id="cb589-11" title="11">   <span class="dt">Float_t</span> tsint = tet*tet/<span class="dv">6</span>;</a>
<a class="sourceLine" id="cb589-12" title="12">   <span class="dt">Float_t</span> sintt = <span class="dv">1</span> - tsint;</a>
<a class="sourceLine" id="cb589-13" title="13">   <span class="dt">Float_t</span> sint  = tet*sintt;</a>
<a class="sourceLine" id="cb589-14" title="14">   <span class="dt">Float_t</span> cos1t = tet/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb589-15" title="15">   <span class="dt">Float_t</span> f1 = step*sintt;</a>
<a class="sourceLine" id="cb589-16" title="16">   <span class="dt">Float_t</span> f2 = step*cos1t;</a>
<a class="sourceLine" id="cb589-17" title="17">   <span class="dt">Float_t</span> f3 = step*tsint*vect[kPZ];</a>
<a class="sourceLine" id="cb589-18" title="18">   <span class="dt">Float_t</span> f4 = -tet*cos1t;</a>
<a class="sourceLine" id="cb589-19" title="19">   <span class="dt">Float_t</span> f5 = sint;</a>
<a class="sourceLine" id="cb589-20" title="20">   <span class="dt">Float_t</span> f6 = tet*cos1t*vect[kPZ];</a>
<a class="sourceLine" id="cb589-21" title="21"></a>
<a class="sourceLine" id="cb589-22" title="22">   vout[kX]  = vect[kX]  + (f1*vect[kPX] - f2*vect[kPY]);</a>
<a class="sourceLine" id="cb589-23" title="23">   vout[kY]  = vect[kY]  + (f1*vect[kPY] + f2*vect[kPX]);</a>
<a class="sourceLine" id="cb589-24" title="24">   vout[kZ]  = vect[kZ]  + (f1*vect[kPZ] + f3);</a>
<a class="sourceLine" id="cb589-25" title="25">   vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);</a>
<a class="sourceLine" id="cb589-26" title="26">   vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);</a>
<a class="sourceLine" id="cb589-27" title="27">   vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);</a>
<a class="sourceLine" id="cb589-28" title="28">}</a></code></pre></div>
<h3 id="writing-the-tree-1"><span class="header-section-number">12.15.1</span> Writing the Tree</h3>
<div class="sourceCode" id="cb590"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb590-1" title="1"><span class="dt">void</span> tree2w() {</a>
<a class="sourceLine" id="cb590-2" title="2">   <span class="co">// write tree2 example</span></a>
<a class="sourceLine" id="cb590-3" title="3">   <span class="co">//create a Tree file tree2.root</span></a>
<a class="sourceLine" id="cb590-4" title="4">   TFile f(<span class="st">"tree2.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb590-5" title="5"></a>
<a class="sourceLine" id="cb590-6" title="6">   <span class="co">//create the file, the Tree</span></a>
<a class="sourceLine" id="cb590-7" title="7">   TTree t2(<span class="st">"t2"</span>,<span class="st">"a Tree with data from a fake Geant3"</span>);</a>
<a class="sourceLine" id="cb590-8" title="8">   <span class="co">// declare a variable of the C structure type</span></a>
<a class="sourceLine" id="cb590-9" title="9">   <span class="dt">Gctrak_t</span> gstep;</a>
<a class="sourceLine" id="cb590-10" title="10"></a>
<a class="sourceLine" id="cb590-11" title="11">   <span class="co">// add the branches for a subset of gstep</span></a>
<a class="sourceLine" id="cb590-12" title="12">   t2.Branch(<span class="st">"vect"</span>,gstep.vect,<span class="st">"vect[7]/F"</span>);</a>
<a class="sourceLine" id="cb590-13" title="13">   t2.Branch(<span class="st">"getot"</span>,&amp;gstep.getot,<span class="st">"getot/F"</span>);</a>
<a class="sourceLine" id="cb590-14" title="14">   t2.Branch(<span class="st">"gekin"</span>,&amp;gstep.gekin,<span class="st">"gekin/F"</span>);</a>
<a class="sourceLine" id="cb590-15" title="15">   t2.Branch(<span class="st">"nmec"</span>,&amp;gstep.nmec,<span class="st">"nmec/I"</span>);</a>
<a class="sourceLine" id="cb590-16" title="16">   t2.Branch(<span class="st">"lmec"</span>,gstep.lmec,<span class="st">"lmec[nmec]/I"</span>);</a>
<a class="sourceLine" id="cb590-17" title="17">   t2.Branch(<span class="st">"destep"</span>,&amp;gstep.destep,<span class="st">"destep/F"</span>);</a>
<a class="sourceLine" id="cb590-18" title="18">   t2.Branch(<span class="st">"pid"</span>,&amp;gstep.pid,<span class="st">"pid/I"</span>);</a>
<a class="sourceLine" id="cb590-19" title="19"></a>
<a class="sourceLine" id="cb590-20" title="20">   <span class="co">//Initialize particle parameters at first point</span></a>
<a class="sourceLine" id="cb590-21" title="21">   <span class="dt">Float_t</span> px,py,pz,p,charge=<span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-22" title="22">   <span class="dt">Float_t</span> vout[<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb590-23" title="23">   <span class="dt">Float_t</span> mass  = <span class="fl">0.137</span>;</a>
<a class="sourceLine" id="cb590-24" title="24">   <span class="dt">Bool_t</span> newParticle = kTRUE;</a>
<a class="sourceLine" id="cb590-25" title="25">   gstep.step    = <span class="fl">0.1</span>;</a>
<a class="sourceLine" id="cb590-26" title="26">   gstep.destep  = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-27" title="27">   gstep.nmec    = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-28" title="28">   gstep.pid     = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-29" title="29"></a>
<a class="sourceLine" id="cb590-30" title="30">   <span class="co">//transport particles</span></a>
<a class="sourceLine" id="cb590-31" title="31">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10000</span>; i++) {</a>
<a class="sourceLine" id="cb590-32" title="32">      <span class="co">//generate a new particle if necessary (Geant3 emulation)</span></a>
<a class="sourceLine" id="cb590-33" title="33">      <span class="cf">if</span> (newParticle) {</a>
<a class="sourceLine" id="cb590-34" title="34">      px = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="fl">.02</span>);</a>
<a class="sourceLine" id="cb590-35" title="35">      py = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="fl">.02</span>);</a>
<a class="sourceLine" id="cb590-36" title="36">      pz = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="fl">.02</span>);</a>
<a class="sourceLine" id="cb590-37" title="37">      p  = TMath::Sqrt(px*px+py*py+pz*pz);</a>
<a class="sourceLine" id="cb590-38" title="38">      charge = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb590-39" title="39">      <span class="cf">if</span> (gRandom-&gt;Rndm() &lt; <span class="fl">0.5</span>) charge = -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb590-40" title="40">         gstep.pid    += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb590-41" title="41">         gstep.vect[<span class="dv">0</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-42" title="42">         gstep.vect[<span class="dv">1</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-43" title="43">         gstep.vect[<span class="dv">2</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb590-44" title="44">         gstep.vect[<span class="dv">3</span>] = px/p;</a>
<a class="sourceLine" id="cb590-45" title="45">         gstep.vect[<span class="dv">4</span>] = py/p;</a>
<a class="sourceLine" id="cb590-46" title="46">         gstep.vect[<span class="dv">5</span>] = pz/p;</a>
<a class="sourceLine" id="cb590-47" title="47">         gstep.vect[<span class="dv">6</span>] = p*charge;</a>
<a class="sourceLine" id="cb590-48" title="48">         gstep.getot   = TMath::Sqrt(p*p + mass*mass);</a>
<a class="sourceLine" id="cb590-49" title="49">         gstep.gekin   = gstep.getot - mass;</a>
<a class="sourceLine" id="cb590-50" title="50">         newParticle   = kFALSE;</a>
<a class="sourceLine" id="cb590-51" title="51">      }</a>
<a class="sourceLine" id="cb590-52" title="52">      <span class="co">// fill the Tree with current step parameters</span></a>
<a class="sourceLine" id="cb590-53" title="53">      t2.Fill();</a>
<a class="sourceLine" id="cb590-54" title="54"></a>
<a class="sourceLine" id="cb590-55" title="55"></a>
<a class="sourceLine" id="cb590-56" title="56">      <span class="co">//transport particle in magnetic field (Geant3 emulation)</span></a>
<a class="sourceLine" id="cb590-57" title="57">      helixStep(gstep.step, gstep.vect, vout);</a>
<a class="sourceLine" id="cb590-58" title="58">      <span class="co">//make one step</span></a>
<a class="sourceLine" id="cb590-59" title="59">      <span class="co">//apply energy loss</span></a>
<a class="sourceLine" id="cb590-60" title="60">      gstep.destep   = gstep.step*gRandom-&gt;Gaus(<span class="fl">0.0002</span>,<span class="fl">0.00001</span>);</a>
<a class="sourceLine" id="cb590-61" title="61">      gstep.gekin -= gstep.destep;</a>
<a class="sourceLine" id="cb590-62" title="62">      gstep.getot  = gstep.gekin + mass;</a>
<a class="sourceLine" id="cb590-63" title="63">      gstep.vect[<span class="dv">6</span>]= charge*TMath::Sqrt(gstep.getot*gstep.getot</a>
<a class="sourceLine" id="cb590-64" title="64">                      - mass*mass);</a>
<a class="sourceLine" id="cb590-65" title="65">      gstep.vect[<span class="dv">0</span>] = vout[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb590-66" title="66">      gstep.vect[<span class="dv">1</span>] = vout[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb590-67" title="67">      gstep.vect[<span class="dv">2</span>] = vout[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb590-68" title="68">      gstep.vect[<span class="dv">3</span>] = vout[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb590-69" title="69">      gstep.vect[<span class="dv">4</span>] = vout[<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb590-70" title="70">      gstep.vect[<span class="dv">5</span>] = vout[<span class="dv">5</span>];</a>
<a class="sourceLine" id="cb590-71" title="71">      gstep.nmec    = (<span class="dt">Int_t</span>)(<span class="dv">5</span>*gRandom-&gt;Rndm());</a>
<a class="sourceLine" id="cb590-72" title="72">      <span class="cf">for</span> (<span class="dt">Int_t</span> l=<span class="dv">0</span>; l&lt;gstep.nmec; l++) gstep.lmec[l] = l;</a>
<a class="sourceLine" id="cb590-73" title="73">      <span class="cf">if</span>  (gstep.gekin &lt; <span class="fl">0.001</span>) newParticle = kTRUE;</a>
<a class="sourceLine" id="cb590-74" title="74">      <span class="cf">if</span>  (TMath::Abs(gstep.vect[<span class="dv">2</span>]) &gt; <span class="dv">30</span>) newParticle = kTRUE;</a>
<a class="sourceLine" id="cb590-75" title="75">   }</a>
<a class="sourceLine" id="cb590-76" title="76">   <span class="co">//save the Tree header. The file will be automatically</span></a>
<a class="sourceLine" id="cb590-77" title="77">   <span class="co">// closed when going out of the function scope</span></a>
<a class="sourceLine" id="cb590-78" title="78">   t2.Write();</a>
<a class="sourceLine" id="cb590-79" title="79">}</a></code></pre></div>
<h4 id="adding-a-branch-with-a-fixed-length-array"><span class="header-section-number">12.15.1.1</span> Adding a Branch with a Fixed Length Array</h4>
<p>At first, we create a tree and create branches for a subset of variables in the C structure<code>Gctrak_t</code>. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of <code>'gstep.vect'</code>. You do not need to specify <code>&amp;gstep.vect</code>, because in C and C++ the array variable holds the address of the first element.</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb591-1" title="1">   t2.Branch(<span class="st">"vect"</span>,gstep.vect,<span class="st">"vect[7]/F"</span>);</a>
<a class="sourceLine" id="cb591-2" title="2">   t2.Branch(<span class="st">"getot"</span>,&amp;gstep.getot,<span class="st">"getot/F"</span>);</a>
<a class="sourceLine" id="cb591-3" title="3">   t2.Branch(<span class="st">"gekin"</span>,&amp;gstep.gekin,<span class="st">"gekin/F"</span>);</a></code></pre></div>
<h4 id="adding-a-branch-with-a-variable-length-array"><span class="header-section-number">12.15.1.2</span> Adding a Branch with a Variable Length Array</h4>
<p>The next two branches are dependent on each other. The first holds 
the length of the variable length array and the second holds the 
variable length array. The <code>lmec</code> branch reads <code>nmec</code> number of integers beginning at the address <code>gstep.lmec</code>.</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb592-1" title="1">   t2.Branch(<span class="st">"nmec"</span>,&amp;gstep.nmec,<span class="st">"nmec/I"</span>);</a>
<a class="sourceLine" id="cb592-2" title="2">   t2.Branch(<span class="st">"lmec"</span>,gstep.lmec,<span class="st">"lmec[nmec]/I"</span>);</a></code></pre></div>
<p>The variable <code>nmec</code> is a random number and is reset for each entry.</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb593-1" title="1">   gstep.nmec = (<span class="dt">Int_t</span>)(<span class="dv">5</span>*gRandom-&gt;Rndm());</a></code></pre></div>
<h4 id="filling-the-tree-1"><span class="header-section-number">12.15.1.3</span> Filling the Tree</h4>
<p>In this emulation of Geant3, we generate and transport particles in a
 magnetic field and store the particle parameters at each tracking step 
in a ROOT tree.</p>
<h3 id="analysis"><span class="header-section-number">12.15.2</span> Analysis</h3>
<p>In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file <code>dstep</code>, and then we use the <code>TBranch::GetEntry</code> method. Then we fill a histogram with the <code>dstep</code>
 branch entries, draw it and fit it with a Gaussian. In addition, we 
draw the particle’s path using the three values in the vector. Here we 
use the <strong><code>TTree::Draw</code></strong> method. It automatically creates a histogram and plots the 3 expressions (see Trees in Analysis).</p>
<p><img src="ROOTUsersGuide_files/030000FF.png"></p>
<div class="sourceCode" id="cb594"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb594-1" title="1"><span class="dt">void</span> tree2r() {</a>
<a class="sourceLine" id="cb594-2" title="2"></a>
<a class="sourceLine" id="cb594-3" title="3">   <span class="co">// read the Tree generated by tree2w and fill one histogram</span></a>
<a class="sourceLine" id="cb594-4" title="4">   <span class="co">// we are only interested by the destep branch</span></a>
<a class="sourceLine" id="cb594-5" title="5"></a>
<a class="sourceLine" id="cb594-6" title="6">   <span class="co">// note that we use "new" to create the TFile and TTree objects because we</span></a>
<a class="sourceLine" id="cb594-7" title="7">   <span class="co">// want to keep these objects alive when we leave this function</span></a>
<a class="sourceLine" id="cb594-8" title="8">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"tree2.root"</span>);</a>
<a class="sourceLine" id="cb594-9" title="9">   TTree *t2 = (TTree*)f-&gt;Get(<span class="st">"t2"</span>);</a>
<a class="sourceLine" id="cb594-10" title="10">   <span class="at">static</span> <span class="dt">Float_t</span> destep;</a>
<a class="sourceLine" id="cb594-11" title="11">   TBranch *b_destep = t2-&gt;GetBranch(<span class="st">"destep"</span>);</a>
<a class="sourceLine" id="cb594-12" title="12">   b_destep-&gt;SetAddress(&amp;destep);</a>
<a class="sourceLine" id="cb594-13" title="13"></a>
<a class="sourceLine" id="cb594-14" title="14">   <span class="co">//create one histogram</span></a>
<a class="sourceLine" id="cb594-15" title="15">   TH1F *hdestep = <span class="kw">new</span> TH1F(<span class="st">"hdestep"</span>,<span class="st">"destep in Mev"</span>,<span class="dv">100</span>,<span class="fl">1e-5</span>,<span class="fl">3e-5</span>);</a>
<a class="sourceLine" id="cb594-16" title="16">   <span class="co">//read only the destep branch for all entries</span></a>
<a class="sourceLine" id="cb594-17" title="17">   <span class="dt">Int_t</span> nentries = (<span class="dt">Int_t</span>)t2-&gt;GetEntries();</a>
<a class="sourceLine" id="cb594-18" title="18">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;nentries;i++) {</a>
<a class="sourceLine" id="cb594-19" title="19">      b_destep-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb594-20" title="20">      <span class="co">// fill the histogram with the destep entry</span></a>
<a class="sourceLine" id="cb594-21" title="21">      hdestep-&gt;Fill(destep);</a>
<a class="sourceLine" id="cb594-22" title="22">   }</a>
<a class="sourceLine" id="cb594-23" title="23"></a>
<a class="sourceLine" id="cb594-24" title="24">   <span class="co">// we do not close the file; we want to keep the generated histograms;</span></a>
<a class="sourceLine" id="cb594-25" title="25">   <span class="co">// we fill a 3-d scatter plot with the particle step coordinates</span></a>
<a class="sourceLine" id="cb594-26" title="26">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"c1"</span>,<span class="dv">600</span>,<span class="dv">800</span>);</a>
<a class="sourceLine" id="cb594-27" title="27">   c1-&gt;SetFillColor(<span class="dv">42</span>);</a>
<a class="sourceLine" id="cb594-28" title="28">   c1-&gt;Divide(<span class="dv">1</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb594-29" title="29"></a>
<a class="sourceLine" id="cb594-30" title="30">   c1-&gt;cd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb594-31" title="31">   hdestep-&gt;SetFillColor(<span class="dv">45</span>);</a>
<a class="sourceLine" id="cb594-32" title="32">   hdestep-&gt;Fit(<span class="st">"gaus"</span>);</a>
<a class="sourceLine" id="cb594-33" title="33"></a>
<a class="sourceLine" id="cb594-34" title="34">   c1-&gt;cd(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb594-35" title="35">   gPad-&gt;SetFillColor(<span class="dv">37</span>);                       <span class="co">// continued...</span></a>
<a class="sourceLine" id="cb594-36" title="36">   t2-&gt;SetMarkerColor(kRed);</a>
<a class="sourceLine" id="cb594-37" title="37">   t2-&gt;Draw(<span class="st">"vect[0]:vect[1]:vect[2]"</span>);</a>
<a class="sourceLine" id="cb594-38" title="38">   <span class="cf">if</span> (gROOT-&gt;IsBatch()) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb594-39" title="39"></a>
<a class="sourceLine" id="cb594-40" title="40">   <span class="co">// invoke the x3d viewer</span></a>
<a class="sourceLine" id="cb594-41" title="41">   gPad-&gt;GetViewer3D(<span class="st">"x3d"</span>);</a>
<a class="sourceLine" id="cb594-42" title="42">}</a></code></pre></div>
<h2 id="example-3-adding-friends-to-trees"><span class="header-section-number">12.16</span> Example 3: Adding Friends to Trees</h2>
<p>In this example, we will show how to extend a tree with a branch from another tree with the Friends feature.</p>
<h3 id="adding-a-branch-to-an-existing-tree"><span class="header-section-number">12.16.1</span> Adding a Branch to an Existing Tree</h3>
<p>You may want to add a branch to an existing tree. For example, if one
 variable in the tree was computed with a certain algorithm, you may 
want to try another algorithm and compare the results. One solution is 
to add a new branch, fill it, and save the tree. The code below adds a 
simple branch to an existing tree. Note that the <code>kOverwrite</code> option in the <code>Write</code> method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb595-1" title="1"><span class="dt">void</span> tree3AddBranch() {</a>
<a class="sourceLine" id="cb595-2" title="2">   TFile f(<span class="st">"tree3.root"</span>,<span class="st">"update"</span>);</a>
<a class="sourceLine" id="cb595-3" title="3">   <span class="dt">Float_t</span> new_v;</a>
<a class="sourceLine" id="cb595-4" title="4">   TTree *t3 = (TTree*)f-&gt;Get(<span class="st">"t3"</span>);</a>
<a class="sourceLine" id="cb595-5" title="5">   TBranch *newBranch = t3-&gt; Branch(<span class="st">"new_v"</span>,&amp;new_v,<span class="st">"new_v/F"</span>);</a>
<a class="sourceLine" id="cb595-6" title="6">   <span class="co">//read the number of entries in the t3</span></a>
<a class="sourceLine" id="cb595-7" title="7">   <span class="dt">Int_t</span> nentries = (<span class="dt">Int_t</span>)t3-&gt;GetEntries();</a>
<a class="sourceLine" id="cb595-8" title="8">   <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i &lt; nentries; i++){</a>
<a class="sourceLine" id="cb595-9" title="9">      new_v= gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb595-10" title="10">      newBranch-&gt;Fill();</a>
<a class="sourceLine" id="cb595-11" title="11">   }</a>
<a class="sourceLine" id="cb595-12" title="12">   t3-&gt;Write(<span class="st">""</span>,TObject::kOverwrite); <span class="co">// save only the new version of</span></a>
<a class="sourceLine" id="cb595-13" title="13">                                      <span class="co">// the tree</span></a>
<a class="sourceLine" id="cb595-14" title="14">}</a></code></pre></div>
<p>Adding a branch is often not possible because the tree is in a 
read-only file and you do not have permission to save the modified tree 
with the new branch. Even if you do have the permission, you risk 
loosing the original tree with an unsuccessful attempt to save the 
modification. Since trees are usually large, adding a branch could 
extend it over the 2GB limit. In this case, the attempt to write the 
tree fails, and the original data is may also be corrupted. In addition,
 adding a branch to a tree enlarges the tree and increases the amount of
 memory needed to read an entry, and therefore decreases the 
performance. For these reasons, ROOT offers the concept of friends for 
trees (and chains). We encourage you to use <code>TTree::AddFriend</code> rather than adding a branch manually.</p>
<h3 id="ttreeaddfriend"><span class="header-section-number">12.16.2</span> TTree::AddFriend</h3>
<p>A tree keeps a list of friends. In the context of a tree (or a 
chain), friendship means unrestricted access to the friends data. In 
this way it is much like adding another branch to the tree without 
taking the risk of damaging it. To add a friend to the list, you can use
 the <code>TTree::AddFriend</code> method. The <strong><code>TTree</code></strong> (<code>tree</code>) below has two friends (<code>ft1</code> and <code>ft2</code>) and now has access to the variables <code>a,b,c,i,j,k,l</code> and <code>m</code>.</p>
<p><img src="ROOTUsersGuide_files/02000101.jpg"></p>
<p>The <code>AddFriend</code> method has two parameters, the first is 
the tree name and the second is the name of the ROOT file where the 
friend tree is saved. <code>AddFriend</code> automatically opens the friend file. If no file name is given, the tree called <code>ft1</code> is assumed to be in the same file as the original tree.</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb596-1" title="1">   tree.AddFriend(<span class="st">"ft1"</span>,<span class="st">"friendfile1.root"</span>);</a></code></pre></div>
<p>If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb597-1" title="1">   tree.AddFriend(<span class="st">"tree1 = tree"</span>,<span class="st">"friendfile1.root"</span>);</a></code></pre></div>
<p>Once the tree has friends, we can use <code>TTree::Draw</code> as if the friend’s variables were in the original tree. To specify which tree to use in the <code>Draw</code> method, use the syntax:</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb598-1" title="1">&lt;treeName&gt;.&lt;branchname&gt;.&lt;varname&gt;</a></code></pre></div>
<p>If the <code>variablename</code> is enough to identify uniquely the variable, you can leave out the tree and/or branch name.</p>
<p>For example, these commands generate a 3-d scatter plot of variable “<code>var</code>” in the <strong><code>TTree</code></strong> <code>tree</code> versus variable <code>v1 in</code>TTree ft1<code>versus variable</code>v2<code>in **</code>TTree<code>**</code>ft2`.</p>
<div class="sourceCode" id="cb599"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb599-1" title="1">   tree.AddFriend(<span class="st">"ft1"</span>,<span class="st">"friendfile1.root"</span>);</a>
<a class="sourceLine" id="cb599-2" title="2">   tree.AddFriend(<span class="st">"ft2"</span>,<span class="st">"friendfile2.root"</span>);</a>
<a class="sourceLine" id="cb599-3" title="3">   tree.Draw(<span class="st">"var:ft1.v1:ft2.v2"</span>);</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/02000102.jpg">The picture illustrates the access of the tree and its friends with a <code>Draw</code> command.</p>
<p>When <code>AddFriend</code> is called, the ROOT file is automatically opened and the friend tree (<code>ft1)</code> header is read into memory. The new friend (<code>ft1</code>) is added to the list of friends of <code>tree</code>.
 The number of entries in the friend must be equal or greater to the 
number of entries of the original tree. If the friend tree has fewer 
entries, a warning is given and the missing entries are not included in 
the histogram.</p>
<p>Use <code>TTree::GetListOfFriends</code> to retrieve the list of friends from a tree.</p>
<p>When the tree is written to file (<code>TTree::Write</code>), the 
friends list is saved with it. Moreover, when the tree is retrieved, the
 trees on the friends list are also retrieved and the friendship 
restored. When a tree is deleted, the elements of the friend list are 
also deleted. It is possible to declare a friend tree that has the same 
internal structure (same branches and leaves) as the original tree, and 
compare the same values by specifying the tree.</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb600-1" title="1">   tree.Draw(<span class="st">"var:ft1.var:ft2.var"</span>);</a></code></pre></div>
<p>The example code is in <code>$ROOTSYS/tutorials/tree/tree3.C</code>. Here is the script:</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb601-1" title="1"><span class="dt">void</span> tree3w() {</a>
<a class="sourceLine" id="cb601-2" title="2">   <span class="co">// Example of a Tree where branches are variable length arrays</span></a>
<a class="sourceLine" id="cb601-3" title="3">   <span class="co">// A second Tree is created and filled in parallel.</span></a>
<a class="sourceLine" id="cb601-4" title="4">   <span class="co">// Run this script with .x tree3.C</span></a>
<a class="sourceLine" id="cb601-5" title="5">   <span class="co">// In the function treer, the first Tree is open.</span></a>
<a class="sourceLine" id="cb601-6" title="6">   <span class="co">// The second Tree is declared friend of the first tree.</span></a>
<a class="sourceLine" id="cb601-7" title="7">   <span class="co">// TTree::Draw is called with variables from both Trees.</span></a>
<a class="sourceLine" id="cb601-8" title="8">   <span class="at">const</span> <span class="dt">Int_t</span> kMaxTrack = <span class="dv">500</span>;</a>
<a class="sourceLine" id="cb601-9" title="9">   <span class="dt">Int_t</span> ntrack;</a>
<a class="sourceLine" id="cb601-10" title="10">   <span class="dt">Int_t</span> stat[kMaxTrack];</a>
<a class="sourceLine" id="cb601-11" title="11">   <span class="dt">Int_t</span> sign[kMaxTrack];</a>
<a class="sourceLine" id="cb601-12" title="12">   <span class="dt">Float_t</span> px[kMaxTrack];</a>
<a class="sourceLine" id="cb601-13" title="13">   <span class="dt">Float_t</span> py[kMaxTrack];</a>
<a class="sourceLine" id="cb601-14" title="14">   <span class="dt">Float_t</span> pz[kMaxTrack];</a>
<a class="sourceLine" id="cb601-15" title="15">   <span class="dt">Float_t</span> pt[kMaxTrack];</a>
<a class="sourceLine" id="cb601-16" title="16">   <span class="dt">Float_t</span> zv[kMaxTrack];</a>
<a class="sourceLine" id="cb601-17" title="17">   <span class="dt">Float_t</span> chi2[kMaxTrack];</a>
<a class="sourceLine" id="cb601-18" title="18">   <span class="dt">Double_t</span> sumstat;</a>
<a class="sourceLine" id="cb601-19" title="19"></a>
<a class="sourceLine" id="cb601-20" title="20">   <span class="co">// create the first root file with a tree</span></a>
<a class="sourceLine" id="cb601-21" title="21">   TFile f(<span class="st">"tree3.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb601-22" title="22">   TTree *t3 = <span class="kw">new</span> TTree(<span class="st">"t3"</span>,<span class="st">"Reconst ntuple"</span>);</a>
<a class="sourceLine" id="cb601-23" title="23">   t3-&gt;Branch(<span class="st">"ntrack"</span>,&amp;ntrack,<span class="st">"ntrack/I"</span>);</a>
<a class="sourceLine" id="cb601-24" title="24">   t3-&gt;Branch(<span class="st">"stat"</span>,stat,<span class="st">"stat[ntrack]/I"</span>);</a>
<a class="sourceLine" id="cb601-25" title="25">   t3-&gt;Branch(<span class="st">"sign"</span>,sign,<span class="st">"sign[ntrack]/I"</span>);</a>
<a class="sourceLine" id="cb601-26" title="26">   t3-&gt;Branch(<span class="st">"px"</span>,px,<span class="st">"px[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-27" title="27">   t3-&gt;Branch(<span class="st">"py"</span>,py,<span class="st">"py[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-28" title="28">   t3-&gt;Branch(<span class="st">"pz"</span>,pz,<span class="st">"pz[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-29" title="29">   t3-&gt;Branch(<span class="st">"zv"</span>,zv,<span class="st">"zv[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-30" title="30">   t3-&gt;Branch(<span class="st">"chi2"</span>,chi2,<span class="st">"chi2[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-31" title="31"></a>
<a class="sourceLine" id="cb601-32" title="32">   <span class="co">// create the second root file with a different tree</span></a>
<a class="sourceLine" id="cb601-33" title="33">   TFile fr(<span class="st">"tree3f.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb601-34" title="34">   TTree *t3f = <span class="kw">new</span> TTree(<span class="st">"t3f"</span>,<span class="st">"a friend Tree"</span>);</a>
<a class="sourceLine" id="cb601-35" title="35">   t3f-&gt;Branch(<span class="st">"ntrack"</span>,&amp;ntrack,<span class="st">"ntrack/I"</span>);</a>
<a class="sourceLine" id="cb601-36" title="36">   t3f-&gt;Branch(<span class="st">"sumstat"</span>,&amp;sumstat,<span class="st">"sumstat/D"</span>);</a>
<a class="sourceLine" id="cb601-37" title="37">   t3f-&gt;Branch(<span class="st">"pt"</span>,pt,<span class="st">"pt[ntrack]/F"</span>);</a>
<a class="sourceLine" id="cb601-38" title="38"></a>
<a class="sourceLine" id="cb601-39" title="39">   <span class="co">// Fill the trees</span></a>
<a class="sourceLine" id="cb601-40" title="40">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;<span class="dv">1000</span>;i++) {</a>
<a class="sourceLine" id="cb601-41" title="41">      <span class="dt">Int_t</span> nt = gRandom-&gt;Rndm()*(kMaxTrack-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb601-42" title="42">      ntrack = nt;</a>
<a class="sourceLine" id="cb601-43" title="43">      sumstat = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb601-44" title="44">      <span class="co">// set the values in each track</span></a>
<a class="sourceLine" id="cb601-45" title="45">      <span class="cf">for</span> (<span class="dt">Int_t</span> n=<span class="dv">0</span>;n&lt;nt;n++) {</a>
<a class="sourceLine" id="cb601-46" title="46">         stat[n] = n%<span class="dv">3</span>;</a>
<a class="sourceLine" id="cb601-47" title="47">         sign[n] = i%<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb601-48" title="48">         px[n]   = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb601-49" title="49">         py[n]   = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb601-50" title="50">         pz[n]   = gRandom-&gt;Gaus(<span class="dv">10</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb601-51" title="51">         zv[n]   = gRandom-&gt;Gaus(<span class="dv">100</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb601-52" title="52">         chi2[n] = gRandom-&gt;Gaus(<span class="dv">0</span>,<span class="fl">.01</span>);</a>
<a class="sourceLine" id="cb601-53" title="53">         sumstat += chi2[n];</a>
<a class="sourceLine" id="cb601-54" title="54">         pt[n]   = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);</a>
<a class="sourceLine" id="cb601-55" title="55">      }</a>
<a class="sourceLine" id="cb601-56" title="56">      t3-&gt;Fill();</a>
<a class="sourceLine" id="cb601-57" title="57">      t3f-&gt;Fill();</a>
<a class="sourceLine" id="cb601-58" title="58">   }</a>
<a class="sourceLine" id="cb601-59" title="59">   <span class="co">// Write the two files</span></a>
<a class="sourceLine" id="cb601-60" title="60">   t3-&gt;Print();</a>
<a class="sourceLine" id="cb601-61" title="61">   f.cd();</a>
<a class="sourceLine" id="cb601-62" title="62">   t3-&gt;Write();</a>
<a class="sourceLine" id="cb601-63" title="63">   fr.cd();</a>
<a class="sourceLine" id="cb601-64" title="64">   t3f-&gt;Write();</a>
<a class="sourceLine" id="cb601-65" title="65">}</a>
<a class="sourceLine" id="cb601-66" title="66"></a>
<a class="sourceLine" id="cb601-67" title="67"><span class="co">// Function to read the two files and add the friend</span></a>
<a class="sourceLine" id="cb601-68" title="68"><span class="dt">void</span> tree3r()         {</a>
<a class="sourceLine" id="cb601-69" title="69">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"tree3.root"</span>);</a>
<a class="sourceLine" id="cb601-70" title="70">   TTree *t3 = (TTree*)f-&gt;Get(<span class="st">"t3"</span>);</a>
<a class="sourceLine" id="cb601-71" title="71">   <span class="co">// Add the second tree to the first tree as a friend</span></a>
<a class="sourceLine" id="cb601-72" title="72">   t3-&gt;AddFriend(<span class="st">"t3f"</span>,<span class="st">"tree3f.root"</span>);</a>
<a class="sourceLine" id="cb601-73" title="73">   <span class="co">// Draw pz which is in the first tree and use pt</span></a>
<a class="sourceLine" id="cb601-74" title="74">   <span class="co">// in the condition. pt is in the friend tree.</span></a>
<a class="sourceLine" id="cb601-75" title="75">   t3-&gt;Draw(<span class="st">"pz"</span>,<span class="st">"pt&gt;3"</span>);</a>
<a class="sourceLine" id="cb601-76" title="76">}</a>
<a class="sourceLine" id="cb601-77" title="77"></a>
<a class="sourceLine" id="cb601-78" title="78"><span class="co">// This is executed when typing .x tree3.C</span></a>
<a class="sourceLine" id="cb601-79" title="79"><span class="dt">void</span> tree3() {</a>
<a class="sourceLine" id="cb601-80" title="80">   tree3w();</a>
<a class="sourceLine" id="cb601-81" title="81">   tree3r();</a>
<a class="sourceLine" id="cb601-82" title="82">}</a></code></pre></div>
<h2 id="example-4-a-tree-with-an-event-class"><span class="header-section-number">12.17</span> Example 4: A Tree with an Event Class</h2>
<p>This example is a simplified version of <code>$ROOTSYS/test/MainEvent.cxx</code> and where Event objects are saved in a tree. The full definition of <code>Event</code> is in <code>$ROOTSYS/test</code>/<code>Event.h</code>. To execute this macro, you will need the library <code>$ROOTSYS/test/libEvent.so</code>. If it does not exist you can build the test directory applications by following the instruction in the <code>$ROOTSYS/test/README</code> file.</p>
<p>In this example we will show</p>
<ul>
<li>the difference in splitting or not splitting a branch</li>
<li>how to read selected branches of the tree,</li>
<li>how to print a selected entry</li>
</ul>
<h3 id="the-event-class"><span class="header-section-number">12.17.1</span> The Event Class</h3>
<p><code>Event</code> is a descendent of <strong><code>TObject</code></strong>. As such it inherits the data members of <strong><code>TObject</code></strong> and its methods such as <code>Dump()</code> and <code>Inspect()</code>and<code>Write()</code>. In addition, because it inherits from <strong><code>TObject</code></strong> it can be a member of a collection. To summarize, the advantages of inheriting from a <strong><code>TObject</code></strong> are:</p>
<ul>
<li>Inherit the <code>Write</code>, <code>Inspect</code>, and <code>Dump</code> methods</li>
<li>Enables a class to be a member of a ROOT collection</li>
<li>Enables RTTI</li>
</ul>
<p>Below is the list of the <code>Event</code> data members. It contains a character array, several integers, a floating-point number, and an <code>EventHeader</code> object. The <code>EventHeader</code> class is described in the following paragraph. <code>Event</code> also has two pointers, one to a <strong><code>TClonesArray</code></strong> of tracks and one to a histogram. The string “<code>-&gt;</code>” in the comment field of the members <code>*fTracks</code> and <code>*fH</code> instructs the automatic <code>Streamer</code> to assume that the objects <code>*fTracks</code> and <code>*fH</code> are never null pointers and that <code>fTracks-&gt;Streamer</code> can be used instead of the more time consuming form <code>R__b &lt;&lt; fTracks</code>.</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb602-1" title="1"><span class="kw">class</span> Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb602-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb602-3" title="3">      <span class="dt">char</span>                 fType[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb602-4" title="4">      <span class="dt">Int_t</span>                fNtrack;</a>
<a class="sourceLine" id="cb602-5" title="5">      <span class="dt">Int_t</span>                fNseg;</a>
<a class="sourceLine" id="cb602-6" title="6">      <span class="dt">Int_t</span>                fNvertex;</a>
<a class="sourceLine" id="cb602-7" title="7">      <span class="dt">UInt_t</span>               fFlag;</a>
<a class="sourceLine" id="cb602-8" title="8">      <span class="dt">Float_t</span>              fTemperature;</a>
<a class="sourceLine" id="cb602-9" title="9">      EventHeader          fEvtHdr;</a>
<a class="sourceLine" id="cb602-10" title="10">      TClonesArray        *fTracks;            <span class="co">//-&gt;</span></a>
<a class="sourceLine" id="cb602-11" title="11">      TH1F                *fH;                 <span class="co">//-&gt;</span></a>
<a class="sourceLine" id="cb602-12" title="12">      <span class="dt">Int_t</span>                fMeasures[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb602-13" title="13">      <span class="dt">Float_t</span>              fMatrix[<span class="dv">4</span>][<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb602-14" title="14">      <span class="dt">Float_t</span>             *fClosestDistance;   <span class="co">//[fNvertex]</span></a>
<a class="sourceLine" id="cb602-15" title="15">      <span class="at">static</span> TClonesArray *fgTracks;</a>
<a class="sourceLine" id="cb602-16" title="16">      <span class="at">static</span> TH1F         *fgHist;</a>
<a class="sourceLine" id="cb602-17" title="17">      <span class="co">// ... list of methods</span></a>
<a class="sourceLine" id="cb602-18" title="18">      ClassDef(Event,<span class="dv">1</span>)  <span class="co">//Event structure</span></a>
<a class="sourceLine" id="cb602-19" title="19">};</a></code></pre></div>
<h3 id="the-eventheader-class"><span class="header-section-number">12.17.2</span> The EventHeader Class</h3>
<p>The <code>EventHeader</code> class (also defined in <code>Event.h</code>) does not inherit from <strong><code>TObject</code></strong>. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from <strong><code>TObject</code></strong>. In previous releases branches were restricted to objects inheriting from the <strong><code>TObject</code></strong>. However, it has always been possible to write a class not inheriting from <strong><code>TObject</code></strong> to a tree by encapsulating it in a <strong><code>TObject</code></strong> descending class as is the case in <code>EventHeader</code> and <code>Event</code>.</p>
<div class="sourceCode" id="cb603"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb603-1" title="1"><span class="kw">class</span> EventHeader {</a>
<a class="sourceLine" id="cb603-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb603-3" title="3">      <span class="dt">Int_t</span>   fEvtNum;</a>
<a class="sourceLine" id="cb603-4" title="4">      <span class="dt">Int_t</span>   fRun;</a>
<a class="sourceLine" id="cb603-5" title="5">      <span class="dt">Int_t</span>   fDate;</a>
<a class="sourceLine" id="cb603-6" title="6">      <span class="co">// ... list of methods</span></a>
<a class="sourceLine" id="cb603-7" title="7">      ClassDef(EventHeader,<span class="dv">1</span>)      <span class="co">//Event Header</span></a>
<a class="sourceLine" id="cb603-8" title="8">};</a></code></pre></div>
<h3 id="the-track-class"><span class="header-section-number">12.17.3</span> The Track Class</h3>
<p>The <code>Track</code> class descends from <strong><code>TObject</code></strong> since tracks are in a <strong><code>TClonesArray</code></strong> (i.e.&nbsp;a ROOT collection class) and contains a selection of basic types and an array of vertices. Its <strong><code>TObject</code></strong> inheritance enables <code>Track</code> to be in a collection and in <code>Event</code> is a <strong><code>TClonesArray</code></strong> of <code>Tracks</code>.</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb604-1" title="1"><span class="kw">class</span> Track : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb604-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb604-3" title="3">      <span class="dt">Float_t</span>   fPx;         <span class="co">//X component of the momentum</span></a>
<a class="sourceLine" id="cb604-4" title="4">      <span class="dt">Float_t</span>   fPy;         <span class="co">//Y component of the momentum</span></a>
<a class="sourceLine" id="cb604-5" title="5">      <span class="dt">Float_t</span>   fPz;         <span class="co">//Z component of the momentum</span></a>
<a class="sourceLine" id="cb604-6" title="6">      <span class="dt">Float_t</span>   fRandom;     <span class="co">//A random track quantity</span></a>
<a class="sourceLine" id="cb604-7" title="7">      <span class="dt">Float_t</span>   fMass2;      <span class="co">//The mass square of this particle</span></a>
<a class="sourceLine" id="cb604-8" title="8">      <span class="dt">Float_t</span>   fBx;         <span class="co">//X intercept at the vertex</span></a>
<a class="sourceLine" id="cb604-9" title="9">      <span class="dt">Float_t</span>   fBy;         <span class="co">//Y intercept at the vertex</span></a>
<a class="sourceLine" id="cb604-10" title="10">      <span class="dt">Float_t</span>   fMeanCharge; <span class="co">//Mean charge deposition of all hits</span></a>
<a class="sourceLine" id="cb604-11" title="11">      <span class="dt">Float_t</span>   fXfirst;     <span class="co">//X coordinate of the first point</span></a>
<a class="sourceLine" id="cb604-12" title="12">      <span class="dt">Float_t</span>   fXlast;      <span class="co">//X coordinate of the last point</span></a>
<a class="sourceLine" id="cb604-13" title="13">      <span class="dt">Float_t</span>   fYfirst;     <span class="co">//Y coordinate of the first point</span></a>
<a class="sourceLine" id="cb604-14" title="14">      <span class="dt">Float_t</span>   fYlast;      <span class="co">//Y coordinate of the last point</span></a>
<a class="sourceLine" id="cb604-15" title="15">      <span class="dt">Float_t</span>   fZfirst;     <span class="co">//Z coordinate of the first point</span></a>
<a class="sourceLine" id="cb604-16" title="16">      <span class="dt">Float_t</span>   fZlast;      <span class="co">//Z coordinate of the last point</span></a>
<a class="sourceLine" id="cb604-17" title="17">      <span class="dt">Float_t</span>   fCharge;     <span class="co">//Charge of this track</span></a>
<a class="sourceLine" id="cb604-18" title="18">      <span class="dt">Float_t</span>   fVertex[<span class="dv">3</span>];  <span class="co">//Track vertex position</span></a>
<a class="sourceLine" id="cb604-19" title="19">      <span class="dt">Int_t</span>     fNpoint;     <span class="co">//Number of points for this track</span></a>
<a class="sourceLine" id="cb604-20" title="20">      <span class="dt">Short_t</span>   fValid;      <span class="co">//Validity criterion</span></a>
<a class="sourceLine" id="cb604-21" title="21"></a>
<a class="sourceLine" id="cb604-22" title="22">      <span class="co">// method definitions ...</span></a>
<a class="sourceLine" id="cb604-23" title="23">      ClassDef(Track,<span class="dv">1</span>)          <span class="co">//A track segment</span></a>
<a class="sourceLine" id="cb604-24" title="24">};</a></code></pre></div>
<h3 id="writing-the-tree-2"><span class="header-section-number">12.17.4</span> Writing the Tree</h3>
<p>We create a simple tree with two branches both holding <code>Event</code> objects. One is split and the other is not. We also create a pointer to an <code>Event</code> object (<code>event</code>).</p>
<div class="sourceCode" id="cb605"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb605-1" title="1"><span class="dt">void</span> tree4w() {</a>
<a class="sourceLine" id="cb605-2" title="2">   <span class="co">// check to see if the event class is in the dictionary</span></a>
<a class="sourceLine" id="cb605-3" title="3">   <span class="co">// if it is not load the definition in libEvent.so</span></a>
<a class="sourceLine" id="cb605-4" title="4">   <span class="cf">if</span> (!TClassTable::GetDict(<span class="st">"Event"</span>)) {</a>
<a class="sourceLine" id="cb605-5" title="5">      gSystem-&gt;Load(<span class="st">"$ROOTSYS/test/libEvent.so"</span>);</a>
<a class="sourceLine" id="cb605-6" title="6">   }</a>
<a class="sourceLine" id="cb605-7" title="7">   <span class="co">// create a Tree file tree4.root</span></a>
<a class="sourceLine" id="cb605-8" title="8">   TFile f(<span class="st">"tree4.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb605-9" title="9">   <span class="co">// create a ROOT Tree</span></a>
<a class="sourceLine" id="cb605-10" title="10">   TTree t4(<span class="st">"t4"</span>,<span class="st">"A Tree with Events"</span>);</a>
<a class="sourceLine" id="cb605-11" title="11">   <span class="co">// create a pointer to an Event object</span></a>
<a class="sourceLine" id="cb605-12" title="12">   Event *event = <span class="kw">new</span> Event();</a>
<a class="sourceLine" id="cb605-13" title="13">   <span class="co">// create two branches, split one</span></a>
<a class="sourceLine" id="cb605-14" title="14">   t4.Branch(<span class="st">"event_branch"</span>, <span class="st">"Event"</span>, &amp;event,<span class="dv">16000</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb605-15" title="15">   t4.Branch(<span class="st">"event_not_split"</span>, <span class="st">"Event"</span>, &amp;event,<span class="dv">16000</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb605-16" title="16"></a>
<a class="sourceLine" id="cb605-17" title="17">   <span class="co">// a local variable for the event type</span></a>
<a class="sourceLine" id="cb605-18" title="18">   <span class="dt">char</span> etype[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb605-19" title="19"></a>
<a class="sourceLine" id="cb605-20" title="20">   <span class="co">// fill the tree</span></a>
<a class="sourceLine" id="cb605-21" title="21">   <span class="cf">for</span> (<span class="dt">Int_t</span> ev = <span class="dv">0</span>; ev &lt;<span class="dv">100</span>; ev++) {</a>
<a class="sourceLine" id="cb605-22" title="22">      <span class="dt">Float_t</span> sigmat, sigmas;</a>
<a class="sourceLine" id="cb605-23" title="23">      gRandom-&gt;Rannor(sigmat,sigmas);</a>
<a class="sourceLine" id="cb605-24" title="24">      <span class="dt">Int_t</span> ntrack   = <span class="dt">Int_t</span>(<span class="dv">600</span> + <span class="dv">600</span> *sigmat/<span class="fl">120.</span>);</a>
<a class="sourceLine" id="cb605-25" title="25">      <span class="dt">Float_t</span> random = gRandom-&gt;Rndm(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb605-26" title="26">      sprintf(etype,<span class="st">"type</span><span class="sc">%d</span><span class="st">"</span>,ev%<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb605-27" title="27">      event-&gt;SetType(etype);</a>
<a class="sourceLine" id="cb605-28" title="28">      event-&gt;SetHeader(ev, <span class="dv">200</span>, <span class="dv">960312</span>, random);</a>
<a class="sourceLine" id="cb605-29" title="29">      event-&gt;SetNseg(<span class="dt">Int_t</span>(<span class="dv">10</span>*ntrack+<span class="dv">20</span>*sigmas));</a>
<a class="sourceLine" id="cb605-30" title="30">      event-&gt;SetNvertex(<span class="dt">Int_t</span>(<span class="dv">1</span>+<span class="dv">20</span>*gRandom-&gt;Rndm()));</a>
<a class="sourceLine" id="cb605-31" title="31">      event-&gt;SetFlag(<span class="dt">UInt_t</span>(random+<span class="fl">0.5</span>));</a>
<a class="sourceLine" id="cb605-32" title="32">      event-&gt;SetTemperature(random+<span class="fl">20.</span>);</a>
<a class="sourceLine" id="cb605-33" title="33">      <span class="cf">for</span>(<span class="dt">UChar_t</span> m = <span class="dv">0</span>; m &lt; <span class="dv">10</span>; m++) {</a>
<a class="sourceLine" id="cb605-34" title="34">         event-&gt;SetMeasure(m, <span class="dt">Int_t</span>(gRandom-&gt;Gaus(m,m+<span class="dv">1</span>)));</a>
<a class="sourceLine" id="cb605-35" title="35">      }</a>
<a class="sourceLine" id="cb605-36" title="36">                                                  <span class="co">// continued...</span></a>
<a class="sourceLine" id="cb605-37" title="37">      <span class="co">// fill the matrix</span></a>
<a class="sourceLine" id="cb605-38" title="38">      <span class="cf">for</span>(<span class="dt">UChar_t</span> i0 = <span class="dv">0</span>; i0 &lt; <span class="dv">4</span>; i0++) {</a>
<a class="sourceLine" id="cb605-39" title="39">         <span class="cf">for</span>(<span class="dt">UChar_t</span> i1 = <span class="dv">0</span>; i1 &lt; <span class="dv">4</span>; i1++) {</a>
<a class="sourceLine" id="cb605-40" title="40">            event-&gt;SetMatrix(i0,i1,gRandom-&gt;Gaus(i0*i1,<span class="dv">1</span>));</a>
<a class="sourceLine" id="cb605-41" title="41">         }</a>
<a class="sourceLine" id="cb605-42" title="42">      }</a>
<a class="sourceLine" id="cb605-43" title="43">      <span class="co">// create and fill the Track objects</span></a>
<a class="sourceLine" id="cb605-44" title="44">      <span class="cf">for</span> (<span class="dt">Int_t</span> t = <span class="dv">0</span>; t &lt; ntrack; t++) event-&gt;AddTrack(random);</a>
<a class="sourceLine" id="cb605-45" title="45">      t4.Fill();      <span class="co">// Fill the tree</span></a>
<a class="sourceLine" id="cb605-46" title="46">      event-&gt;Clear(); <span class="co">// Clear before reloading event</span></a>
<a class="sourceLine" id="cb605-47" title="47">   }</a>
<a class="sourceLine" id="cb605-48" title="48">   f.Write();            <span class="co">// Write the file header</span></a>
<a class="sourceLine" id="cb605-49" title="49">   t4.Print();           <span class="co">// Print the tree contents</span></a>
<a class="sourceLine" id="cb605-50" title="50">}</a></code></pre></div>
<h3 id="reading-the-tree-1"><span class="header-section-number">12.17.5</span> Reading the Tree</h3>
<p>First, we check if the shared library with the class definitions is 
loaded. If not we load it. Then we read two branches, one for the number
 of tracks and one for the entire event. We check the number of tracks 
first, and if it meets our condition, we read the entire event. We show 
the fist entry that meets the condition.</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb606-1" title="1"><span class="dt">void</span> tree4r() {</a>
<a class="sourceLine" id="cb606-2" title="2">   <span class="co">// check if the event class is in the dictionary</span></a>
<a class="sourceLine" id="cb606-3" title="3">   <span class="co">// if it is not load the definition in libEvent.so</span></a>
<a class="sourceLine" id="cb606-4" title="4">   <span class="cf">if</span> (!TClassTable::GetDict(<span class="st">"Event"</span>)) {</a>
<a class="sourceLine" id="cb606-5" title="5">      gSystem-&gt;Load(<span class="st">"$ROOTSYS/test/libEvent.so"</span>);</a>
<a class="sourceLine" id="cb606-6" title="6">   }</a>
<a class="sourceLine" id="cb606-7" title="7">   <span class="co">// read the tree generated with tree4w</span></a>
<a class="sourceLine" id="cb606-8" title="8"></a>
<a class="sourceLine" id="cb606-9" title="9">   <span class="co">// note that we use "new" to create the TFile and TTree objects, because we</span></a>
<a class="sourceLine" id="cb606-10" title="10">   <span class="co">// want to keep these objects alive when we leave this function.</span></a>
<a class="sourceLine" id="cb606-11" title="11">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"tree4.root"</span>);</a>
<a class="sourceLine" id="cb606-12" title="12">   TTree *t4 = (TTree*)f-&gt;Get(<span class="st">"t4"</span>);</a>
<a class="sourceLine" id="cb606-13" title="13"></a>
<a class="sourceLine" id="cb606-14" title="14">   <span class="co">// create a pointer to an event object for reading the branch values.</span></a>
<a class="sourceLine" id="cb606-15" title="15">   Event *event = <span class="kw">new</span> Event();</a>
<a class="sourceLine" id="cb606-16" title="16">   <span class="co">// get two branches and set the branch address</span></a>
<a class="sourceLine" id="cb606-17" title="17">   TBranch *bntrack = t4-&gt;GetBranch(<span class="st">"fNtrack"</span>);</a>
<a class="sourceLine" id="cb606-18" title="18">   TBranch *branch  = t4-&gt;GetBranch(<span class="st">"event_split"</span>);</a>
<a class="sourceLine" id="cb606-19" title="19">   branch-&gt;SetAddress(&amp;event);</a>
<a class="sourceLine" id="cb606-20" title="20"></a>
<a class="sourceLine" id="cb606-21" title="21">   <span class="dt">Int_t</span> nevent = t4-&gt;GetEntries();</a>
<a class="sourceLine" id="cb606-22" title="22">   <span class="dt">Int_t</span> nselected = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb606-23" title="23">   <span class="dt">Int_t</span> nb = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb606-24" title="24">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;nevent; i++) {</a>
<a class="sourceLine" id="cb606-25" title="25">      <span class="co">//read branch "fNtrack"only</span></a>
<a class="sourceLine" id="cb606-26" title="26">      bntrack-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb606-27" title="27"></a>
<a class="sourceLine" id="cb606-28" title="28">      <span class="co">// reject events with more than 587 tracks</span></a>
<a class="sourceLine" id="cb606-29" title="29">      <span class="cf">if</span> (event-&gt;GetNtrack() &gt; <span class="dv">587</span>)<span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb606-30" title="30"></a>
<a class="sourceLine" id="cb606-31" title="31">      <span class="co">// read complete accepted event in memory</span></a>
<a class="sourceLine" id="cb606-32" title="32">      nb += t4-&gt;GetEntry(i);</a>
<a class="sourceLine" id="cb606-33" title="33">      nselected++;</a>
<a class="sourceLine" id="cb606-34" title="34"></a>
<a class="sourceLine" id="cb606-35" title="35">     <span class="co">// print the first accepted event</span></a>
<a class="sourceLine" id="cb606-36" title="36">     <span class="cf">if</span> (nselected == <span class="dv">1</span>) t4-&gt;Show();</a>
<a class="sourceLine" id="cb606-37" title="37">     <span class="co">// clear tracks array</span></a>
<a class="sourceLine" id="cb606-38" title="38">     event-&gt;Clear();</a>
<a class="sourceLine" id="cb606-39" title="39">   }</a>
<a class="sourceLine" id="cb606-40" title="40"></a>
<a class="sourceLine" id="cb606-41" title="41">   <span class="cf">if</span> (gROOT-&gt;IsBatch()) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb606-42" title="42">   <span class="kw">new</span> TBrowser();</a>
<a class="sourceLine" id="cb606-43" title="43">   t4-&gt;StartViewer();</a>
<a class="sourceLine" id="cb606-44" title="44">}</a></code></pre></div>
<p>Now, let’s see how the tree looks like in the tree viewer.</p>
<figure>
<img src="ROOTUsersGuide_files/03000103.png" alt="The tree viewer with tree4 example"><figcaption>The tree viewer with tree4 example</figcaption>
</figure>
<p>You can see the two branches in the tree in the left panel: the event
 branch is split and hence expands when clicked on. The other branch 
event not split is not expandable and we can not browse the data 
members.</p>
<p>The <strong><code>TClonesArray</code></strong> of tracks <code>fTracks</code> is also split because we set the split level to 2. The output on the command line is the result of <code>tree4-&gt;Show()</code>. It shows the first entry with more than 587 tracks:</p>
<div class="sourceCode" id="cb607"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb607-1" title="1">======&gt; EVENT:<span class="dv">26</span></a>
<a class="sourceLine" id="cb607-2" title="2"> event_split     =</a>
<a class="sourceLine" id="cb607-3" title="3"> fUniqueID       = <span class="dv">0</span></a>
<a class="sourceLine" id="cb607-4" title="4"> fBits           = <span class="dv">50331648</span></a>
<a class="sourceLine" id="cb607-5" title="5"> fType[<span class="dv">20</span>]       = <span class="dv">116</span> <span class="dv">121</span> <span class="dv">112</span> <span class="dv">101</span> <span class="dv">49</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb607-6" title="6"> fNtrack         = <span class="dv">585</span></a>
<a class="sourceLine" id="cb607-7" title="7"> fNseg           = <span class="dv">5834</span></a>
<a class="sourceLine" id="cb607-8" title="8"> fNvertex        = <span class="dv">17</span></a>
<a class="sourceLine" id="cb607-9" title="9"> fFlag           = <span class="dv">0</span></a>
<a class="sourceLine" id="cb607-10" title="10"> fTemperature    = <span class="fl">20.044315</span></a>
<a class="sourceLine" id="cb607-11" title="11"> fEvtHdr.fEvtNum = <span class="dv">26</span></a>
<a class="sourceLine" id="cb607-12" title="12"> fEvtHdr.fRun    = <span class="dv">200</span></a>
<a class="sourceLine" id="cb607-13" title="13"> fEvtHdr.fDate   = <span class="dv">960312</span></a>
<a class="sourceLine" id="cb607-14" title="14"> fTracks         = <span class="dv">585</span></a>
<a class="sourceLine" id="cb607-15" title="15"> fTracks.fUniqueID = <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></a>
<a class="sourceLine" id="cb607-16" title="16">...</a></code></pre></div>
<h2 id="example-5-import-an-ascii-file-into-a-ttree"><span class="header-section-number">12.18</span> Example 5: Import an ASCII File into a TTree</h2>
<p>The method <code>TTree::ReadFile</code> can be used to automatic define the structure of the <strong><code>TTree</code></strong> and read the data from a formatted ascii file.</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb608-1" title="1"><span class="dt">Long64_t</span> TTree::ReadFile(<span class="at">const</span> <span class="dt">char</span> *filename,</a>
<a class="sourceLine" id="cb608-2" title="2">                         <span class="at">const</span> <span class="dt">char</span> *branchDescriptor)</a></code></pre></div>
<p>Creates or simply read branches from the file named whose name is passed in <code>'filename'</code>.</p>
<div class="sourceCode" id="cb609"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb609-1" title="1">{</a>
<a class="sourceLine" id="cb609-2" title="2">   gROOT-&gt;Reset();</a>
<a class="sourceLine" id="cb609-3" title="3">   TFile *f = <span class="kw">new</span> TFile(<span class="st">"basic2.root"</span>,<span class="st">"RECREATE"</span>);</a>
<a class="sourceLine" id="cb609-4" title="4">   TH1F *h1 = <span class="kw">new</span> TH1F(<span class="st">"h1"</span>,<span class="st">"x distribution"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb609-5" title="5">   TTree *T = <span class="kw">new</span> TTree(<span class="st">"ntuple"</span>,<span class="st">"data from ascii file"</span>);</a>
<a class="sourceLine" id="cb609-6" title="6">   <span class="dt">Long64_t</span> nlines = T-&gt;ReadFile(<span class="st">"basic.dat"</span>,<span class="st">"x:y:z"</span>);</a>
<a class="sourceLine" id="cb609-7" title="7">   printf(<span class="st">" found </span><span class="sc">%lld</span><span class="st"> pointsn"</span>,nlines);</a>
<a class="sourceLine" id="cb609-8" title="8">   T-&gt;Draw(<span class="st">"x"</span>,<span class="st">"z&gt;2"</span>);</a>
<a class="sourceLine" id="cb609-9" title="9">   T-&gt;Write();</a>
<a class="sourceLine" id="cb609-10" title="10">}</a></code></pre></div>
<p>If <code>branchDescriptor</code> is set to an empty string (the default), it is assumed that the <strong><code>Tree</code></strong> descriptor is given in the first line of the file with a syntax like: <code>A/D:Table[2]/F:Ntracks/I:astring/C</code>.</p>
<p>Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A <strong><code>TBranch</code></strong> object is created for each variable in the expression. The total number of rows read from the file is returned.</p>
<h2 id="trees-in-analysis"><span class="header-section-number">12.19</span> Trees in Analysis</h2>
<p>The methods <code>TTree::Draw</code>, <code>TTree::MakeClass</code> and <code>TTree::MakeSelector</code> are available for data analysis using trees. The <strong><code>TTree::Draw</code></strong>
 method is a powerful yet simple way to look and draw the trees 
contents. It enables you to plot a variable (a leaf) with just one line 
of code. However, the Draw method falls short once you want to look at 
each entry and design more sophisticated acceptance criteria for your 
analysis. For these cases, you can use <code>TTree::MakeClass</code>. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.</p>
<p>The <code>TTree::MakeSelector</code> is the recommended method for 
ROOT data analysis. It is especially important for large data set in a 
parallel processing configuration where the analysis is distributed over
 several processors and you can specify which entries to send to each 
processor. With <code>MakeClass</code> the user has control over the event loop, with <code>MakeSelector</code>the tree is in control of the event loop.</p>
<h2 id="simple-analysis-using-ttreedraw"><span class="header-section-number">12.20</span> Simple Analysis Using TTree::Draw</h2>
<p>We will use the tree in <code>cernstaff.root</code> that was made by the macro in <code>$ROOTSYS/tutorials/tree/staff.C</code>.</p>
<p>First, open the file and lists its contents.</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb610-1" title="1">root[] TFile f (<span class="st">"cernstaff.root"</span>)</a>
<a class="sourceLine" id="cb610-2" title="2">root[] f.ls()</a>
<a class="sourceLine" id="cb610-3" title="3">TFile**         cernstaff.root</a>
<a class="sourceLine" id="cb610-4" title="4">TFile*         cernstaff.root</a>
<a class="sourceLine" id="cb610-5" title="5">KEY: TTree    T;<span class="dv">1</span>     staff data from ascii file</a></code></pre></div>
<p>We can see the <strong><code>TTree</code></strong>“<code>T</code>” in the file. We will use it to experiment with the <strong><code>TTree::Draw</code></strong> method, so let’s create a pointer to it:</p>
<div class="sourceCode" id="cb611"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb611-1" title="1">root[] TTree *MyTree = T</a></code></pre></div>
<p>Cling allows us to get simply the object by using it. Here we define a pointer to a <strong><code>TTree</code></strong> object and assign it the value of “<code>T</code>”, the <strong><code>TTree</code></strong> in the file. Cling looks for an object named “<code>T</code>”
 in the current ROOT file and returns it (this assumes that “T” has not 
previously been used to declare a variable or function).</p>
<p>In contrast, in compiled code, you can use:</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb612-1" title="1">   TTree *MyTree;f.GetObject(<span class="st">"T"</span>,MyTree);</a></code></pre></div>
<p>To show the different <code>Draw</code> options, we create a canvas with four sub-pads. We will use one sub-pad for each <code>Draw</code> command.</p>
<div class="sourceCode" id="cb613"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb613-1" title="1">root[] TCanvas *myCanvas = <span class="kw">new</span> TCanvas()</a>
<a class="sourceLine" id="cb613-2" title="2">root[] myCanvas-&gt;Divide(<span class="dv">2</span>,<span class="dv">2</span>)</a></code></pre></div>
<p>We activate the first pad with the <code>TCanvas::cd</code> statement:</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb614-1" title="1">root[] myCanvas-&gt;cd(<span class="dv">1</span>)</a></code></pre></div>
<p>We then draw the variable <code>Cost</code>:</p>
<div class="sourceCode" id="cb615"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb615-1" title="1">root[] MyTree-&gt;Draw(<span class="st">"C</span></a></code></pre></div>
<p>As you can see, the last call <code>TTree::Draw</code> has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a <code>TTree::Draw</code>. The style of the histogram is inherited from the <strong><code>TTree</code></strong> attributes and the current style (<strong><em><code>gStyle</code></em></strong>) is ignored. The <strong><code>TTree</code></strong> gets its attributes from the current <strong><code>TStyle</code></strong> at the time it was created. You can call the method <code>TTree::UseCurrentStyle</code> to change to the current style rather than the <strong><code>TTree</code></strong> style. (See <strong><em><code>gStyle</code></em></strong>; see also “Graphics and the Graphical User Interface” )</p>
<p>In the next segment, we activate the second pad and draw a scatter plot variables:</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb616-1" title="1">root[] myCanvas-&gt;cd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb616-2" title="2">root[] MyTree-&gt;Draw(<span class="st">"Cost:Age"</span>)</a></code></pre></div>
<p>This signature still only has one parameter, but it now has two dimensions separated by a colon <code>("x:y")</code>.
 The item to be plotted can be an expression not just a simple variable.
 In general, this parameter is a string that contains up to three 
expressions, one for each dimension, separated by a colon (“<code>e1:e2:e3</code>”). A list of examples follows this introduction.</p>
<h3 id="using-selection-with-ttreedraw"><span class="header-section-number">12.20.1</span> Using Selection with TTree:Draw</h3>
<p>Change the active pad to 3, and add a selection to the list of parameters of the draw command.</p>
<div class="sourceCode" id="cb617"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb617-1" title="1">root[] myCanvas-&gt;cd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb617-2" title="2">root[] MyTree-&gt;Draw(<span class="st">"Cost:Age"</span>,<span class="st">"Nation == "</span>FR<span class="st">""</span>)</a></code></pre></div>
<p>This will draw the <code>Cost</code>vs.&nbsp;<code>Age</code> for the entries where the nation is equal to “<code>FR</code>”. You can use any C++ operator, and some functions defined in <strong><code>TFormula</code></strong>,
 in the selection parameter. The value of the selection is used as a 
weight when filling the histogram. If the expression includes only 
Boolean operations as in the example above, the result is 0 or 1. If the
 result is 0, the histogram is not filled. In general, the expression 
is:</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb618-1" title="1">Selection = <span class="st">"weight *(boolean expression)"</span></a></code></pre></div>
<p>If the Boolean expression evaluates to true, the histogram is filled 
with a weight. If the weight is not explicitly specified it is assumed 
to be 1.</p>
<p>For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2.</p>
<div class="sourceCode" id="cb619"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb619-1" title="1"><span class="st">"x&lt;y &amp;&amp; sqrt(z)&gt;3.2"</span></a></code></pre></div>
<p>On the other hand, this selection will add <code>x+y</code> to the histogram if the square root of z is larger than 3.2.</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb620-1" title="1"><span class="st">"(x+y)*(sqrt(z)&gt;3.2)"</span></a></code></pre></div>
<p>The <code>Draw</code> method has its own parser, and it only looks in
 the current tree for variables. This means that any variable used in 
the selection must be defined in the tree. You cannot use an arbitrary 
global variable in the <code>TTree::Draw</code> method.</p>
<h3 id="using-tcut-objects-in-ttreedraw"><span class="header-section-number">12.20.2</span> Using TCut Objects in TTree::Draw</h3>
<p>The <code>TTree::Draw</code> method also accepts <strong><code>TCutG</code></strong> objects. A <strong><code>TCut</code></strong> is a specialized string object used for <strong><code>TTree</code></strong> selections. A <strong><code>TCut</code></strong> object has a name and a title. It does not have any data members in addition to what it inherits from <strong><code>TNamed</code></strong>. It only adds a set of operators to do logical string concatenation. For example, assume:</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb621-1" title="1">TCut cut1 = <span class="st">"x&lt;1"</span></a>
<a class="sourceLine" id="cb621-2" title="2">TCut cut2 = <span class="st">"y&gt;2"</span></a></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb622-1" title="1">cut1 &amp;&amp; cut<span class="dv">2</span></a>
<a class="sourceLine" id="cb622-2" title="2"><span class="co">//result is the string "(x&lt;1)&amp;&amp;(y&gt;2)"</span></a></code></pre></div>
<p>Operators =, +=, +, *, !, &amp;&amp;, || are overloaded, here are some examples:</p>
<div class="sourceCode" id="cb623"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb623-1" title="1">root[] TCut c1 = <span class="st">"x &lt; 1"</span></a>
<a class="sourceLine" id="cb623-2" title="2">root[] TCut c2 = <span class="st">"y &lt; 0"</span></a>
<a class="sourceLine" id="cb623-3" title="3">root[] TCut c3 = c1 &amp;&amp; c<span class="dv">2</span></a>
<a class="sourceLine" id="cb623-4" title="4">root[] MyTree.Draw(<span class="st">"x"</span>, c1)</a>
<a class="sourceLine" id="cb623-5" title="5">root[] MyTree.Draw(<span class="st">"x"</span>, c1 || <span class="st">"x&gt;0"</span>)</a>
<a class="sourceLine" id="cb623-6" title="6">root[] MyTree.Draw(<span class="st">"x"</span>, c1 &amp;&amp; c2)</a>
<a class="sourceLine" id="cb623-7" title="7">root[] MyTree.Draw(<span class="st">"x"</span>, <span class="st">"(x + y)"</span> * (c1 &amp;&amp; c2))</a></code></pre></div>
<h3 id="accessing-the-histogram-in-batch-mode"><span class="header-section-number">12.20.3</span> Accessing the Histogram in Batch Mode</h3>
<p>The <code>TTree::Draw</code> method creates a histogram called <code>htemp</code> and puts it on the active pad. In a batch program, the histogram <code>htemp</code> created by default, is reachable from the current pad.</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb624-1" title="1">   <span class="co">// draw the histogram</span></a>
<a class="sourceLine" id="cb624-2" title="2">   nt-&gt;Draw(<span class="st">"x"</span>, <span class="st">"cuts"</span>);</a>
<a class="sourceLine" id="cb624-3" title="3">   <span class="co">// get the histogram from the current pad</span></a>
<a class="sourceLine" id="cb624-4" title="4">   TH1F *htemp = (TH1F*)gPad-&gt;GetPrimitive(<span class="st">"htemp"</span>);</a>
<a class="sourceLine" id="cb624-5" title="5">   <span class="co">// now we have full use of the histogram</span></a>
<a class="sourceLine" id="cb624-6" title="6">   htemp-&gt;GetEntries();</a></code></pre></div>
<p>If you pipe the result of the <code>TTree::Draw</code> into a histogram, the histogram is also available in the current directory. You can do:</p>
<div class="sourceCode" id="cb625"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb625-1" title="1">   <span class="co">// Draw the histogram and fill hnew with it</span></a>
<a class="sourceLine" id="cb625-2" title="2">   nt-&gt;Draw(<span class="st">"x&gt;&gt;hnew"</span>,<span class="st">"cuts"</span>);</a>
<a class="sourceLine" id="cb625-3" title="3">   <span class="co">// get hnew from the current directory</span></a>
<a class="sourceLine" id="cb625-4" title="4">   TH1F *hnew = (TH1F*)gDirectory-&gt;Get(<span class="st">"hnew"</span>);</a>
<a class="sourceLine" id="cb625-5" title="5">   <span class="co">// or get hnew from the current Pad</span></a>
<a class="sourceLine" id="cb625-6" title="6">   TH1F *hnew = (TH1F*)gPad-&gt;GetPrimitive(<span class="st">"hnew"</span>);</a></code></pre></div>
<h3 id="using-draw-options-in-ttreedraw"><span class="header-section-number">12.20.4</span> Using Draw Options in TTree::Draw</h3>
<p>The next parameter is the draw option for the histogram:</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb626-1" title="1">root[] MyTree-&gt;Draw(<span class="st">"Cost:Age"</span>,<span class="st">"Nation == </span><span class="sc">\"</span><span class="st">FR</span><span class="sc">\"</span><span class="st">"</span>,<span class="st">"surf2"</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/03000104.png" alt="Using draw options in trees"><figcaption>Using draw options in trees</figcaption>
</figure>
<p>The draw options are the same as for <code>TH1::Draw</code>. See “Draw Options” where they are listed. In addition to the draw options defined in <strong><code>TH1</code></strong>, there are three more. The <code>'prof'</code> and <code>'profs'</code> draw a profile histogram (<strong><code>TProfile</code></strong>) rather than a regular 2D histogram (<strong><code>TH2D</code></strong>) from an expression with two variables. If the expression has three variables, a <strong><code>TProfile2D</code></strong> is generated.</p>
<p>The ‘<code>profs</code>’ generates a <strong><code>TProfile</code></strong> with error on the spread. The ‘<code>prof</code>’ option generates a <strong><code>TProfile</code></strong> with error on the mean. The “<code>goff</code>”
 option suppresses generating the graphics. You can combine the draw 
options in a list separated by commas. After typing the lines above, you
 should now have a canvas that looks this.</p>
<h3 id="superimposing-two-histograms"><span class="header-section-number">12.20.5</span> Superimposing Two Histograms</h3>
<p>When superimposing two 2-D histograms inside a script with <code>TTree::Draw</code> and using the “<code>same</code>” option, you will need to update the pad between <code>Draw</code> commands.</p>
<div class="sourceCode" id="cb627"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb627-1" title="1">{</a>
<a class="sourceLine" id="cb627-2" title="2">   <span class="co">// superimpose two 2D scatter plots</span></a>
<a class="sourceLine" id="cb627-3" title="3">   <span class="co">// Create a 2D histogram and fill it with random numbers</span></a>
<a class="sourceLine" id="cb627-4" title="4">   TH2 *h2 = <span class="kw">new</span> TH2D (<span class="st">"h2"</span>,<span class="st">"2D histo"</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">70</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">20000</span>);</a>
<a class="sourceLine" id="cb627-5" title="5">   <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10000</span>; i++)</a>
<a class="sourceLine" id="cb627-6" title="6">      h2-&gt;Fill(gRandom-&gt;Gaus(<span class="dv">40</span>,<span class="dv">10</span>),gRandom-&gt;Gaus(<span class="dv">10000</span>,<span class="dv">3000</span>));</a>
<a class="sourceLine" id="cb627-7" title="7">   <span class="co">// set the color to differentiate it visually</span></a>
<a class="sourceLine" id="cb627-8" title="8">   h2-&gt;SetMarkerColor(kGreen);</a>
<a class="sourceLine" id="cb627-9" title="9">   h2-&gt;Draw();</a>
<a class="sourceLine" id="cb627-10" title="10">   <span class="co">// Open the example file and get the tree</span></a>
<a class="sourceLine" id="cb627-11" title="11">   TFile f(<span class="st">"cernstaff.root"</span>);</a>
<a class="sourceLine" id="cb627-12" title="12">   TTree *myTree = (TTree*)f.Get(<span class="st">"T"</span>);</a>
<a class="sourceLine" id="cb627-13" title="13">   <span class="co">// the update is needed for the next draw command to work properly</span></a>
<a class="sourceLine" id="cb627-14" title="14">   gPad-&gt;Update();</a>
<a class="sourceLine" id="cb627-15" title="15">   myTree-&gt;Draw(<span class="st">"Cost:Age"</span>, <span class="st">""</span>,<span class="st">"same"</span>);</a>
<a class="sourceLine" id="cb627-16" title="16">}</a></code></pre></div>
<p>In this example, <code>h2-&gt;Draw</code> is only adding the object h2 to the pad’s list of primitives. It does not paint the object on the screen. However, <code>TTree::Draw</code> when called with option “<code>same</code>”
 gets the current pad coordinates to build an intermediate histogram 
with the right limits. Since nothing has been painted in the pad yet, 
the pad limits have not been computed. Calling <code>pad-&gt;Update()</code> forces the painting of the pad and allows <code>TTree::Draw</code> to compute the right limits for the intermediate histogram.</p>
<h3 id="setting-the-range-in-ttreedraw"><span class="header-section-number">12.20.6</span> Setting the Range in TTree::Draw</h3>
<p>There are two more optional parameters to the <code>TTree::Draw</code>
 method: one is the number of entries and the second one is the entry to
 start with. For example, this command draws 1000 entries starting with 
entry 100:</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb628-1" title="1">myTree-&gt;Draw(<span class="st">"Cost:Age"</span>, <span class="st">""</span>,<span class="st">""</span>,<span class="dv">1000</span>,<span class="dv">100</span>);</a></code></pre></div>
<h3 id="ttreedraw-examples"><span class="header-section-number">12.20.7</span> TTree::Draw Examples</h3>
<p>The examples below use the <code>Event.root</code> file generated by the <code>$ROOTSYS/test/Event</code> executable and the <code>Event</code>, <code>Track</code>, and <code>EventHeader</code> class definitions are in <code>$ROOTSYS/test/Event.h</code>.
 The commands have been tested on the split-levels 0, 1, and 9. Each 
command is numbered and referenced by the explanations immediately 
following the examples.</p>
<div class="sourceCode" id="cb629"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb629-1" title="1">    <span class="co">// Data members and methods</span></a>
<a class="sourceLine" id="cb629-2" title="2"><span class="dv">1</span>   tree-&gt;Draw(<span class="st">"fNtrack"</span>);</a>
<a class="sourceLine" id="cb629-3" title="3"><span class="dv">2</span>   tree-&gt;Draw(<span class="st">"event.GetNtrack()"</span>);</a>
<a class="sourceLine" id="cb629-4" title="4"><span class="dv">3</span>   tree-&gt;Draw(<span class="st">"GetNtrack()"</span>);</a>
<a class="sourceLine" id="cb629-5" title="5"><span class="dv">4</span>   tree-&gt;Draw(<span class="st">"fH.fXaxis.fXmax"</span>);</a>
<a class="sourceLine" id="cb629-6" title="6"><span class="dv">5</span>   tree-&gt;Draw(<span class="st">"fH.fXaxis.GetXmax()"</span>);</a>
<a class="sourceLine" id="cb629-7" title="7"><span class="dv">6</span>   tree-&gt;Draw(<span class="st">"fH.GetXaxis().fXmax"</span>);</a>
<a class="sourceLine" id="cb629-8" title="8"><span class="dv">7</span>   tree-&gt;Draw(<span class="st">"GetHistogram().GetXaxis().GetXmax()"</span>);</a>
<a class="sourceLine" id="cb629-9" title="9">    <span class="co">// Expressions in the selection parameter</span></a>
<a class="sourceLine" id="cb629-10" title="10"><span class="dv">8</span>   tree-&gt;Draw(<span class="st">"fTracks.fPx"</span>,<span class="st">"fEvtHdr.fEvtNum%10 == 0"</span>);</a>
<a class="sourceLine" id="cb629-11" title="11"><span class="dv">9</span>   tree-&gt;Draw(<span class="st">"fPx"</span>,<span class="st">"fEvtHdr.fEvtNum%10 == 0"</span>);</a>
<a class="sourceLine" id="cb629-12" title="12">    <span class="co">// Two dimensional arrays defined as:</span></a>
<a class="sourceLine" id="cb629-13" title="13">    <span class="co">//   Float_t fMatrix[4][4] in Event class</span></a>
<a class="sourceLine" id="cb629-14" title="14"><span class="dv">10</span>  tree-&gt;Draw(<span class="st">"fMatrix"</span>);</a>
<a class="sourceLine" id="cb629-15" title="15"><span class="dv">11</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][ ]"</span>);</a>
<a class="sourceLine" id="cb629-16" title="16"><span class="dv">12</span>  tree-&gt;Draw(<span class="st">"fMatrix[2][2]"</span>);</a>
<a class="sourceLine" id="cb629-17" title="17"><span class="dv">13</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][0]"</span>);</a>
<a class="sourceLine" id="cb629-18" title="18"><span class="dv">14</span>  tree-&gt;Draw(<span class="st">"fMatrix[1][ ]"</span>);</a>
<a class="sourceLine" id="cb629-19" title="19">    <span class="co">// using two arrays... Float_t  fVertex[3];  in Track class</span></a>
<a class="sourceLine" id="cb629-20" title="20"><span class="dv">15</span>  tree-&gt;Draw(<span class="st">"fMatrix - fVertex"</span>);</a>
<a class="sourceLine" id="cb629-21" title="21"><span class="dv">16</span>  tree-&gt;Draw(<span class="st">"fMatrix[2][1]  - fVertex[5][1]"</span>);</a>
<a class="sourceLine" id="cb629-22" title="22"><span class="dv">17</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][1]  - fVertex[5][1]"</span>);</a>
<a class="sourceLine" id="cb629-23" title="23"><span class="dv">18</span>  tree-&gt;Draw(<span class="st">"fMatrix[2][ ]  - fVertex[5][ ]"</span>);</a>
<a class="sourceLine" id="cb629-24" title="24"><span class="dv">19</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][2]  - fVertex[ ][1]"</span>);</a>
<a class="sourceLine" id="cb629-25" title="25"><span class="dv">20</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][2]  - fVertex[ ][ ]"</span>);</a>
<a class="sourceLine" id="cb629-26" title="26"><span class="dv">21</span>  tree-&gt;Draw(<span class="st">"fMatrix[ ][ ]  - fVertex[ ][ ]"</span>);</a>
<a class="sourceLine" id="cb629-27" title="27">    <span class="co">// variable length arrays</span></a>
<a class="sourceLine" id="cb629-28" title="28"><span class="dv">22</span>  tree-&gt;Draw(<span class="st">"fClosestDistance"</span>);</a>
<a class="sourceLine" id="cb629-29" title="29"><span class="dv">23</span>  tree-&gt;Draw(<span class="st">"fClosestDistance[fNvertex/2]"</span>);</a>
<a class="sourceLine" id="cb629-30" title="30">    <span class="co">// mathematical expressions</span></a>
<a class="sourceLine" id="cb629-31" title="31"><span class="dv">24</span>  tree-&gt;Draw(<span class="st">"sqrt(fPx*fPx + fPy*fPy + fPz*fPz))"</span>);</a>
<a class="sourceLine" id="cb629-32" title="32">    <span class="co">// external function call</span></a>
<a class="sourceLine" id="cb629-33" title="33"><span class="dv">25</span>  tree-&gt;Draw(<span class="st">"TMath::BreitWigner(fPx,3,2)"</span>);</a>
<a class="sourceLine" id="cb629-34" title="34">    <span class="co">// strings</span></a>
<a class="sourceLine" id="cb629-35" title="35"><span class="dv">26</span>  tree-&gt;Draw(<span class="st">"fEvtHdr.fEvtNum"</span>,<span class="st">"fType=="</span>type1<span class="st">" "</span>);</a>
<a class="sourceLine" id="cb629-36" title="36"><span class="dv">27</span>  tree-&gt;Draw(<span class="st">"fEvtHdr.fEvtNum"</span>,<span class="st">"strstr(fType,"</span><span class="dv">1</span><span class="st">" "</span>);</a>
<a class="sourceLine" id="cb629-37" title="37">    <span class="co">// Where fPoints is defined in the track class:</span></a>
<a class="sourceLine" id="cb629-38" title="38">    <span class="co">//        Int_t  fNpoint;</span></a>
<a class="sourceLine" id="cb629-39" title="39">    <span class="co">//        Int_t *fPoints; [fNpoint]</span></a>
<a class="sourceLine" id="cb629-40" title="40"><span class="dv">28</span>  tree-&gt;Draw(<span class="st">"fTracks.fPoints"</span>);</a>
<a class="sourceLine" id="cb629-41" title="41"><span class="dv">29</span>  tree-&gt;Draw(<span class="st">"fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"</span>);</a>
<a class="sourceLine" id="cb629-42" title="42"><span class="dv">30</span>  tree-&gt;Draw(<span class="st">"fTracks.fPoints[2][]- fTracks.fPoints[][55]"</span>);</a>
<a class="sourceLine" id="cb629-43" title="43"><span class="dv">31</span>  tree-&gt;Draw(<span class="st">"fTracks.fPoints[][] - fTracks.fVertex[][]"</span>);</a>
<a class="sourceLine" id="cb629-44" title="44">    <span class="co">// selections</span></a>
<a class="sourceLine" id="cb629-45" title="45"><span class="dv">32</span>  tree-&gt;Draw(<span class="st">"fValid&amp;0x1"</span>,<span class="st">"(fNvertex&gt;10) &amp;&amp; (fNseg&lt;=6000)"</span>);</a>
<a class="sourceLine" id="cb629-46" title="46"><span class="dv">33</span>  tree-&gt;Draw(<span class="st">"fPx"</span>,<span class="st">"(fBx&gt;.4) || (fBy&lt;=-.4)"</span>);</a>
<a class="sourceLine" id="cb629-47" title="47"><span class="dv">34</span>  tree-&gt;Draw(<span class="st">"fPx"</span>,<span class="st">"fBx*fBx*(fBx&gt;.4) + fBy*fBy*(fBy&lt;=-.4)"</span>);</a>
<a class="sourceLine" id="cb629-48" title="48"><span class="dv">35</span>  tree-&gt;Draw(<span class="st">"fVertex"</span>,<span class="st">"fVertex&gt;10"</span>);</a>
<a class="sourceLine" id="cb629-49" title="49"><span class="dv">36</span>  tree-&gt;Draw(<span class="st">"fPx[600]"</span>);</a>
<a class="sourceLine" id="cb629-50" title="50"><span class="dv">37</span>  tree-&gt;Draw(<span class="st">"fPx[600]"</span>,<span class="st">"fNtrack&gt;600"</span>);</a>
<a class="sourceLine" id="cb629-51" title="51">    <span class="co">// alphanumeric bin histogram</span></a>
<a class="sourceLine" id="cb629-52" title="52">    <span class="co">// where Nation is a char* indended to be used as a string</span></a>
<a class="sourceLine" id="cb629-53" title="53"><span class="dv">38</span>  tree-&gt;Draw(<span class="st">"Nation"</span>);</a>
<a class="sourceLine" id="cb629-54" title="54">    <span class="co">// where MyByte is a char* intended to be used as a byte</span></a>
<a class="sourceLine" id="cb629-55" title="55"><span class="dv">39</span>  tree-&gt;Draw(<span class="st">"MyByte + 0"</span>);</a>
<a class="sourceLine" id="cb629-56" title="56">    <span class="co">// where fTriggerBits is a data member of TTrack of type TBits</span></a>
<a class="sourceLine" id="cb629-57" title="57"><span class="dv">40</span>  tree-&gt;Draw(<span class="st">"fTracks.fTriggerBits"</span>);</a>
<a class="sourceLine" id="cb629-58" title="58">    <span class="co">// using alternate values</span></a>
<a class="sourceLine" id="cb629-59" title="59"><span class="dv">41</span>  tree-&gt;Draw(<span class="st">"fMatrix-Alt$(fClosestDistance,0)"</span>);</a>
<a class="sourceLine" id="cb629-60" title="60">    <span class="co">// using meta information about the formula</span></a>
<a class="sourceLine" id="cb629-61" title="61"><span class="dv">42</span>  tree-&gt;Draw(<span class="st">"fMatrix:Iteration$"</span>)</a>
<a class="sourceLine" id="cb629-62" title="62"><span class="dv">43</span> T-&gt;Draw(<span class="st">"fLastTrack.GetPx():fLastTrack.fPx"</span>);</a>
<a class="sourceLine" id="cb629-63" title="63"><span class="dv">44</span> T-&gt;Scan(<span class="st">"((Track*)(fLastTrack@.GetObject())).GetPx()"</span>,<span class="st">""</span>,<span class="st">""</span>);</a>
<a class="sourceLine" id="cb629-64" title="64"><span class="dv">45</span> tree-&gt;Draw(<span class="st">"This-&gt;GetReadEntry()"</span>);</a>
<a class="sourceLine" id="cb629-65" title="65"><span class="dv">46</span>  tree-&gt;Draw(<span class="st">"mybr.mystring"</span>);</a>
<a class="sourceLine" id="cb629-66" title="66"><span class="dv">47</span>  tree-&gt;Draw(<span class="st">"myTimeStamp"</span>);</a></code></pre></div>
<h4 id="explanations"><span class="header-section-number">12.20.7.1</span> Explanations:</h4>
<ol type="1">
<li><strong><code>tree-&gt;Draw("fNtrack");</code></strong></li>
</ol>
<p>It fills the histogram with the number of tracks for each entry. <code>fNtrack</code> is a member of event.</p>
<ol start="2" type="1">
<li><strong><code>tree-&gt;Draw("event.GetNtrack()");</code></strong></li>
</ol>
<p>Same as case 1, but use the method of event to get the number of 
tracks. When using a method, you can include parameters for the method 
as long as the parameters are literals.</p>
<ol start="3" type="1">
<li><strong><code>tree-&gt;Draw("GetNtrack()");</code></strong></li>
</ol>
<p>Same as case 2, the object of the method is not specified. The command uses the first instance of the <code>GetNtrack</code> method found in the objects stored in the tree. We recommend using this shortcut only if the method name is unique.</p>
<ol start="4" type="1">
<li><strong><code>tree-&gt;Draw("fH.fXaxis.fXmax");</code></strong></li>
</ol>
<p>Draw the data member of a data member. In the tree, each entry has a 
histogram. This command draws the maximum value of the X-axis for each 
histogram.</p>
<ol start="5" type="1">
<li><strong><code>tree-&gt;Draw("fH.fXaxis.GetXmax()");</code></strong></li>
</ol>
<p>Same as case 4, but use the method of a data member.</p>
<ol start="6" type="1">
<li><strong><code>tree-&gt;Draw("fH.GetXaxis().fXmax");</code></strong></li>
</ol>
<p>The same as case 4: a data member of a data member retrieved by a method.</p>
<ol start="7" type="1">
<li><strong><code>tree-&gt;Draw("GetHistogram().GetXaxis().GetXmax()");</code></strong></li>
</ol>
<p>Same as case 4, but using methods.</p>
<ol start="8" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fPx","fEvtHdr.fEvtNum%10 == 0");</code></strong></li>
</ol>
<p>Use data members in the expression and in the selection parameter to plot <code>fPx</code> or all tracks in every 10th entry. Since <code>fTracks</code> is a <strong><code>TClonesArray</code></strong> of <code>Tracks</code>, there will be d values of <code>fPx</code> for each entry.</p>
<ol start="9" type="1">
<li><strong><code>tree-&gt;Draw("fPx","fEvtHdr.fEvtNum%10 == 0");</code></strong></li>
</ol>
<p>Same as case 8, use the name of the data member directly.</p>
<ol start="10" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix");</code></strong></li>
</ol>
<p>When the index of the array is left out or when empty brackets are used <code>[]</code>, all values of the array are selected. Draw all values of <code>fMatrix</code> for each entry in the tree. If <code>fMatrix</code> is defined as: <code>Float_t fMatrix[4][4]</code>, all 16 values are used for each entry.</p>
<ol start="11" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[ ][ ]");</code></strong></li>
</ol>
<p>The same as case 10, all values of <code>fMatrix</code> are drawn for each entry.</p>
<ol start="12" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[2][2]");</code></strong></li>
</ol>
<p>The single element at <code>fMatrix[2][2]</code> is drawn for each entry.</p>
<ol start="13" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[][0]");</code></strong></li>
</ol>
<p>Four elements of <code>fMatrix</code> are used: <code>fMatrix[1][0]</code>, <code>fMatrix[2][0]</code>, <code>fMatrix[3][0]</code>, <code>fMatrix[4][0]</code>.</p>
<ol start="14" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[1][ ]");</code></strong></li>
</ol>
<p>Four elements of <code>fMatrix</code> are used: <code>fMatrix[1][0]</code>, <code>fMatrix[1][2]</code>, <code>fMatrix[1][3]</code>, <code>fMatrix[1][4]</code>.</p>
<ol start="15" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix - fVertex");</code></strong></li>
</ol>
<p>With two arrays and unspecified element numbers, the number of 
selected values is the minimum of the first dimension times the minimum 
of the second dimension. In this case <code>fVertex</code> is also a two dimensional array since it is a data member of the tracks array. If <code>fVertex</code> is defined in the track class as: <code>Float_t *fVertex[3]</code>, it has <code>fNtracks</code> x 3 elements. <code>fMatrix</code> has 4 x 4 elements. This case, draws 4 (the smaller of <code>fNtrack</code> and 4) times 3 (the smaller of 4 and 3), meaning 12 elements per entry. The selected values for each entry are:</p>
<p><code>fMatrix[0][0] - fVertex[0][0]</code></p>
<p><code>fMatrix[0][1] - fVertex[0][1]</code></p>
<p><code>fMatrix[0][2] - fVertex[0][2]</code></p>
<p><code>fMatrix[1][0] - fVertex[1][0]</code></p>
<p><code>fMatrix[1][1] - fVertex[1][1]</code></p>
<p><code>fMatrix[1][2] - fVertex[1][2]</code></p>
<p><code>fMatrix[2][0] - fVertex[2][0]</code></p>
<p><code>fMatrix[2][1] - fVertex[2][1]</code></p>
<p><code>fMatrix[2][2] - fVertex[2][2]</code></p>
<p><code>fMatrix[3][0] - fVertex[3][0]</code></p>
<p><code>fMatrix[3][1] - fVertex[3][1]</code></p>
<p><code>fMatrix[3][2] - fVertex[3][2]</code></p>
<ol start="16" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[2][1] - fVertex[5][1]");</code></strong></li>
</ol>
<p>This command selects one value per entry.</p>
<ol start="17" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[ ][1] - fVertex[5][1]");</code></strong></li>
</ol>
<p>The first dimension of the array is taken by the <code>fMatrix</code>.</p>
<p><code>fMatrix[0][1] - fVertex[5][1]</code></p>
<p><code>fMatrix[1][1] - fVertex[5][1]</code></p>
<p><code>fMatrix[2][1] - fVertex[5][1]</code></p>
<p><code>fMatrix[3][1] - fVertex[5][1]</code></p>
<ol start="18" type="1">
<li><strong><code>tree-&gt;Draw("("fMatrix[2][ ] - fVertex[5][ ]");</code></strong></li>
</ol>
<p>The first dimension minimum is 2, and the second dimension minimum is 3 (from <code>fVertex</code>). Three values are selected from each entry:</p>
<p><code>fMatrix[2][0] - fVertex[5][0]</code></p>
<p><code>fMatrix[2][1] - fVertex[5][1]</code></p>
<p><code>fMatrix[2][2] - fVertex[5][2]</code></p>
<ol start="19" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[ ][2] - fVertex[ ][1]")</code></strong></li>
</ol>
<p>This is similar to case 18. Four values are selected from each entry:</p>
<p><code>fMatrix[0][2] - fVertex[0][1]</code></p>
<p><code>fMatrix[1][2] - fVertex[1][1]</code></p>
<p><code>fMatrix[2][2] - fVertex[2][1]</code></p>
<p><code>fMatrix[3][2] - fVertex[3][1]</code></p>
<ol start="20" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[ ][2] - fVertex[ ][ ]")</code></strong></li>
</ol>
<p>This is similar to case 19. Twelve values are selected (4x3) from each entry:</p>
<p><code>fMatrix[0][2] - fVertex[0][0]</code></p>
<p><code>fMatrix[0][2] - fVertex[0][1]</code></p>
<p><code>fMatrix[0][2] - fVertex[0][2]</code></p>
<p><code>fMatrix[1][2] - fVertex[1][0]</code></p>
<p><code>fMatrix[1][2] - fVertex[1][1]</code></p>
<p><code>fMatrix[1][2] - fVertex[1][2]</code></p>
<p><code>fMatrix[2][2] - fVertex[2][0]</code></p>
<p><code>fMatrix[2][2] - fVertex[2][1]</code></p>
<p><code>fMatrix[2][2] - fVertex[2][2]</code></p>
<p><code>fMatrix[3][2] - fVertex[3][0]</code></p>
<p><code>fMatrix[3][2] - fVertex[3][1]</code></p>
<p><code>fMatrix[3][2] - fVertex[3][2]</code></p>
<ol start="21" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix[ ][ ] - fVertex[ ][ ]")</code></strong></li>
</ol>
<p>This is the same as case 15. The first dimension minimum is 4 (from <code>fMatrix</code>), and the second dimension minimum is 3 (from <code>fVertex</code>). Twelve values are selected from each entry.</p>
<ol start="22" type="1">
<li><strong><code>tree-&gt;Draw("fClosestDistance")</code></strong></li>
</ol>
<p>This event data member <code>fClosestDistance</code> is a variable length array:</p>
<p><code>Float_t  *fClosestDistance;   //[fNvertex]</code></p>
<p>This command selects all elements, but the number per entry depends on the number of vertices of that entry.</p>
<ol start="23" type="1">
<li><strong><code>tree-&gt;Draw("fClosestDistance[fNvertex/2]")</code></strong></li>
</ol>
<p>With this command the element at <code>fNvertex/2</code> of the <code>fClosestDistance</code>array is selected. Only one per entry is selected.</p>
<ol start="24" type="1">
<li><strong><code>tree-&gt;Draw("sqrt(fPx*fPx + fPy*fPy + fPz*fPz)")</code></strong></li>
</ol>
<p>This command shows the use of a mathematical expression. It draws the square root of the sum of the product.</p>
<ol start="25" type="1">
<li><strong><code>tree-&gt;Draw("TMath::BreitWigner(fPx,3,2)")</code></strong></li>
</ol>
<p>The formula can contains call to a function that takes numerical 
arguments and returns a numerical value. The function needs to be 
declared to the dictionary and need to be available from the global 
namespace. In particular, global functions and public static member 
functions can be called.</p>
<ol start="26" type="1">
<li><strong><code>tree-&gt;Draw("fEvtHdr.fEvtNum","fType=="type1" ")</code></strong></li>
</ol>
<p>You can compare strings, using the symbols == and !=, in the first two parameters of the <code>Draw</code> command (<code>TTreeFormula</code>). In this case, the event number for ‘type1’ events is plotted.</p>
<ol start="27" type="1">
<li><strong><code>tree-&gt;Draw("fEvtHdr.fEvtNum","strstr(fType,"1") ")</code></strong></li>
</ol>
<p>To compare strings, you can also use <code>strstr</code>. In this case, events having a ‘1’ in <code>fType</code> are selected.</p>
<ol start="28" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fPoints")</code></strong></li>
</ol>
<p>If <code>fPoints</code> is a data member of the <code>Track</code> class declared as:</p>
<p><code>Int_t  fNpoint;</code></p>
<p><code>Int_t *fPoints; [fNpoint]</code></p>
<p>The size of the array <code>fPoints</code> varies with each track of each event. This command draws all the value in the <code>fPoints</code> arrays.</p>
<ol start="29" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fPoints - fTracks.fPoints[][fAvgPoints]");</code></strong></li>
</ol>
<p><code>When fAvgPoints</code> is a data member of the <code>Event</code> class, this example selects:</p>
<p><code>fTracks[0].fPoints[0] - fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[0].fPoints[1] - fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[0].fPoints[2] - fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[0].fPoints[3] - fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[0].fPoints[4] - fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>...</code></p>
<p><code>fTracks[0].fPoints[max0]- fTracks[0].fPoint[fAvgPoints]</code></p>
<p><code>...</code></p>
<p><code>fTracks[1].fPoints[0] - fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[1].fPoints[1] - fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[1].fPoints[2] - fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[1].fPoints[3] - fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[1].fPoints[4] - fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>...</code></p>
<p><code>fTracks[1].fPoints[max1]- fTracks[1].fPoint[fAvgPoints]</code></p>
<p><code>...</code></p>
<p><code>fTracks[fNtrack-1].fPoints[0] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[fNtrack-1].fPoints[1] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[fNtrack-1].fPoints[2] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[fNtrack-1].fPoints[3] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p><code>fTracks[fNtrack-1].fPoints[4] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p><code>...</code></p>
<p><code>fTracks[fNtrack-1].fPoints[maxn] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></p>
<p>Where<code>max0</code>, <code>max1</code>, <code>... max n</code>, is the size of the<code>fPoints</code>array for the respective track<code>.</code></p>
<ol start="30" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fPoints[2][]- fTracks.fPoints[][55]")</code></strong></li>
</ol>
<p>For each event, this expression is selected:</p>
<p><code>fTracks[2].fPoints[0] - fTracks[0].fPoints[55]</code></p>
<p><code>fTracks[2].fPoints[1] - fTracks[1].fPoints[55]</code></p>
<p><code>fTracks[2].fPoints[2] - fTracks[2].fPoints[55]</code></p>
<p><code>fTracks[2].fPoints[3] - fTracks[3].fPoints[55]</code></p>
<p><code>...</code></p>
<p><code>fTracks[2].fPoints[max] - fTracks[max].fPoints[55]</code></p>
<p>where max is the minimum of <code>fNtrack</code> and <code>fTracks[2].fNpoint</code>.</p>
<ol start="31" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fPoints[][] - fTracks.fVertex[][]")</code></strong></li>
</ol>
<p>For each event and each track, this expression is selected. It is the difference between <code>fPoints</code> and of <code>fVertex</code>. The number of elements used for each track is the minimum of <code>fNpoint</code> and 3 (the size of the <code>fVertex</code> array).</p>
<p><code>fTracks[0].fPoints[0] - fTracks[0].fVertex[0]</code></p>
<p><code>fTracks[0].fPoints[1] - fTracks[0].fVertex[1]</code></p>
<p><code>fTracks[0].fPoints[2] - fTracks[0].fVertex[2]</code></p>
<p><code>// with fTracks[1].fNpoint==7</code></p>
<p><code>fTracks[1].fPoints[0] - fTracks[1].fVertex[0]</code></p>
<p><code>fTracks[1].fPoints[1] - fTracks[1].fVertex[1]</code></p>
<p><code>fTracks[1].fPoints[2] - fTracks[1].fVertex[2]</code></p>
<p><code>// with fTracks[1].fNpoint==5</code></p>
<p><code>fTracks[2].fPoints[0] - fTracks[2].fVertex[0]</code></p>
<p><code>fTracks[2].fPoints[1] - fTracks[2].fVertex[1]</code></p>
<p><code>// with fTracks[2].fNpoint==2</code></p>
<p><code>fTracks[3].fPoints[0] - fTracks[3].fVertex[0]</code></p>
<p><code>// with fTracks[3].fNpoint==1</code></p>
<p><code>fTracks[4].fPoints[0] - fTracks[4].fVertex[0]</code></p>
<p><code>fTracks[4].fPoints[1] - fTracks[4].fVertex[1]</code></p>
<p><code>fTracks[4].fPoints[2] - fTracks[4].fVertex[2]</code></p>
<p><code>// with fTracks[4].fNpoint==3</code></p>
<ol start="32" type="1">
<li><strong><code>tree-&gt;Draw("fValid&amp;0x1","(fNvertex&gt;10) &amp;&amp; (fNseg&lt;=6000)")</code></strong></li>
</ol>
<p>You can use bit patterns (<code>&amp;,|,&lt;&lt;</code>) or Boolean operation.</p>
<ol start="33" type="1">
<li><p><strong><code>tree-&gt;Draw("fPx","(fBx&gt;.4) || (fBy&lt;=-.4)");</code></strong></p></li>
<li><p><strong><code>tree-&gt;Draw("fPx","fBx*fBx*(fBx&gt;.4) + fBy*fBy*(fBy&lt;=-.4)");</code></strong></p></li>
</ol>
<p>The selection argument is used as a weight. The expression returns a 
multiplier and in case of a Boolean the multiplier is either 0 (for 
false) or 1 (for true). The first command draws <code>fPx</code> for the range between with conditions on <code>fBx</code> and <code>fBy</code>, the second command draws <code>fPx</code> for the same conditions, but adds a weight using the result of the second expression.</p>
<ol start="35" type="1">
<li><strong><code>tree-&gt;Draw("fVertex","fVertex&gt;10")</code></strong></li>
</ol>
<p>When using arrays in the selection and the expression, the selection is applied to each element of the array.</p>
<p><code>if (fVertex[0]&gt;10) fVertex[0]</code></p>
<p><code>if (fVertex[1]&gt;10) fVertex[1]</code></p>
<p><code>if (fVertex[2]&gt;10) fVertex[2]</code></p>
<ol start="36" type="1">
<li><p><strong><code>tree-&gt;Draw("fPx[600]")</code></strong></p></li>
<li><p><strong><code>tree-&gt;Draw("fPx[600]","fNtrack &gt; 600")</code></strong></p></li>
</ol>
<p>When using a specific element for a variable length array the entries
 with fewer elements are ignored. Thus these two commands are 
equivalent.</p>
<ol start="38" type="1">
<li><strong><code>tree-&gt;Draw("Nation")</code></strong></li>
</ol>
<p><code>Nation</code> is a <code>char*</code> branch. When drawing a <code>char*</code> it will plot an alphanumeric histogram, of the different value of the string <code>Nation</code>. The axis will have the <code>Nation</code> values. See “Histograms”.</p>
<ol start="39" type="1">
<li><strong><code>tree-&gt;Draw("MyChar +0")</code></strong></li>
</ol>
<p>If you want to plot a char* variable as a byte rather than a string, you can use the syntax above.</p>
<ol start="40" type="1">
<li><strong><code>tree-&gt;Draw("fTracks.fTriggerBits")</code></strong></li>
</ol>
<p><code>fTriggerBits</code> is a data member of <strong><code>TTrack</code></strong> of type <strong><code>TBits</code></strong>. Objects of class <strong><code>TBits</code></strong> can be drawn directly. This command will create a 1D histogram from 0 to <code>nbits</code> which is filled for each non-null bit-number.</p>
<ol start="41" type="1">
<li><strong><code>tree-&gt;Draw("fMatrix-Alt$(fClosestDistance,0)")</code></strong></li>
</ol>
<p><code>Alt$(primary,alternate)</code> returns the value of “<code>primary</code>” if it is available for the current iteration; otherwise return the value of “<code>alternate</code>”. Assuming that <code>fClosestDistance</code> is a smaller array than <code>fMatrix</code>. This example will draw <code>fMatrix[i]+fClosestDistance[i]</code> for <code>i</code> less than the size of <code>fClosestDistance</code>, and will draw <code>fMatrix[i]+0</code> for the other value of <code>i</code>.</p>
<ol start="42" type="1">
<li><strong><code>tree-&gt;Draw("fClosestDistance:Iteration$")</code></strong></li>
</ol>
<p>This example draws a 2D plot with, for all entries, <code>fClosestDistance[i]:i</code> for each value of <code>i</code> between 0 and the size of <code>fClosestDistance</code>. <code>Iterations$</code> is one of four special variables giving some indications of the state of the loops implied by the formula:</p>
<p><code>Entry$    :</code> return the current entry number (<code>TTree::GetReadEntry()</code>)</p>
<p><code>Entries$  :</code> return the total number of entries (<code>TTree::GetEntries()</code>)</p>
<p><code>Length$   :</code> return the total number of element of this formula for this entry</p>
<p><code>Iteration$:</code> return the current iteration over this formula for this entry (i.e.&nbsp;varies from 0 to <code>Length$</code>).</p>
<ol start="43" type="1">
<li><strong><code>tree-&gt;Draw("fLastTrack.GetPx():fLastTrack.fPx");</code></strong></li>
</ol>
<p><strong><code>TRef</code></strong> and <strong><code>TRefArray</code></strong> are automatically deferenced and this shows the value of the <code>fPx</code> of the track referenced by <code>fLastTrack</code>. To access the <strong><code>TRef</code></strong> object itself use the ‘<code>@</code>’ notation (see next example). This auto dereferencing can be extended (via an implementation of <strong><code>TVirtualRefProxy</code></strong>) to any reference type.</p>
<ol start="44" type="1">
<li><strong><code>tree-&gt;Scan("((Track*)(fLastTrack@.GetObject())).GetPx()","","");</code></strong></li>
</ol>
<p>Will cast the return value of <code>GetObject()</code> (which happens to be <strong><code>TObject*</code></strong> in this case) before requesting the <code>GetPx()</code> member functions.</p>
<ol start="45" type="1">
<li><strong><code>tree-&gt;Draw("This-&gt;GetReadEntry()");</code></strong></li>
</ol>
<p>You can refer to the tree (or chain) containing the data by using the string ‘<code>This</code>’. You can also call any <strong><code>TTree</code></strong> methods. Next example will display the name of the first ‘<code>user info</code>’ object:</p>
<p><code>tree-&gt;Draw("This-&gt;GetUserInfo()-&gt;At(0)-&gt;GetName()");</code></p>
<ol start="46" type="1">
<li><strong><code>tree-&gt;Draw("mybr.mystring");</code></strong></li>
</ol>
<p><strong><code>TString</code></strong> and <code>std::string</code> 
object are plotted directly. The example 45 draws the same results - 
i.e.&nbsp;an histogram whose labels are the string value of ‘<code>mystring</code>’:</p>
<p><code>tree-&gt;Draw("mybr.mystring.c_str()");</code></p>
<p>or</p>
<p><code>tree-&gt;Draw("mybr.mytstring.Data()");</code></p>
<ol start="47" type="1">
<li><strong><code>tree-&gt;Draw("myTimeStamp");</code></strong></li>
</ol>
<p>You can plot plot objects of any class which has either <code>AsDouble</code> or <code>AsString</code> (<code>AsDouble</code> has priority). For such a class (for example <strong><code>TTimeStamp</code></strong>), the line 46 will plot the same as:</p>
<p><code>tree-&gt;Draw("myTimeStamp.AsDouble");</code></p>
<p><code>AsString</code> can be returning either a <code>char*</code>, or a <strong><code>TString</code></strong> or an <code>std::string</code>.</p>
<h3 id="multiple-variables-visualisation"><span class="header-section-number">12.20.8</span> Multiple variables visualisation</h3>
<p>This section presents the visualization technique available in ROOT to represent multiple variables (&gt;4) data sets.</p>
<h4 id="spider-radar-plots"><span class="header-section-number">12.20.8.1</span> Spider (Radar) Plots</h4>
<p>Spider plots (sometimes called “web-plots” or “radar plots”) are used
 to compare series of data points (events). They use the human ability 
to spot un-symmetry.</p>
<figure>
<img src="ROOTUsersGuide_files/spider1.png" alt="Example of spider plot."><figcaption>Example of spider plot.</figcaption>
</figure>
<p>Variables are represented on individual axes displayed along a 
circle. For each variable the minimum value sits on the circle’s center,
 and the maximum on the circle’s radius. Spider plots are not suitable 
for an accurate graph reading since, by their nature, it can be 
difficult to read out very detailed values, but they give quickly a 
global view of an event in order to compare it with the others. In ROOT 
the spider plot facility is accessed from the tree viewer GUI. The 
variables to be visualized are selected in the tree viewer and can be 
scanned using the spider plot button.</p>
<figure>
<img src="ROOTUsersGuide_files/spider2.png" alt="The tree viewer Graphical User Interface and the Spider Plot Editor."><figcaption>The tree viewer Graphical User Interface and the Spider Plot Editor.</figcaption>
</figure>
<p>The spider plot graphics editor provides two tabs to interact with 
the spider plots’ output: the tab “Style” defining the spider layout and
 the tab “Browse” to navigate in the tree.</p>
<h4 id="parallel-coordinates-plots"><span class="header-section-number">12.20.8.2</span> Parallel Coordinates Plots</h4>
<p></p>
<p>The Parallel Coordinates Plots are a common way of studying and 
visualizing multiple variables data sets. They were proposed by in 
A.Inselberg in 1981 as a new way to represent multi-dimensional 
information. In traditional Cartesian coordinates, axes are mutually 
perpendicular. In Parallel coordinates, all axes are parallel which 
allows representing data in much more than three dimensions. To show a 
set of points in Parallel Coordinates, a set of parallel lines is drawn,
 typically vertical and equally spaced. A point in n-dimensional space 
is represented as a polyline with vertices on the parallel axes. The 
position of the vertex on the i-th axis corresponds to the i-th 
coordinate of the point. The three following figures show some very 
simple examples:</p>
<figure>
<img src="ROOTUsersGuide_files/para1.png" alt="The Parallel Coordinates representation of the six dimensional point (-5,3,4,2,0,1)."><figcaption>The Parallel Coordinates representation of the six dimensional point <code>(-5,3,4,2,0,1)</code>.</figcaption>
</figure>
<figure>
<img src="ROOTUsersGuide_files/para2.png" alt="The line y = -3x+20 and a circle in Parallel Coordinates."><figcaption>The line <code>y = -3x+20</code> and a circle in Parallel Coordinates.</figcaption>
</figure>
<p>The Parallel Coordinates technique is good at: spotting irregular 
events, seeing the data trend, finding correlations and clusters. Its 
main weakness is the cluttering of the output. Because each “point” in 
the multidimensional space is represented as a line, the output is very 
quickly opaque and therefore it is difficult to see the data clusters. 
Most of the work done about Parallel Coordinates is to find techniques 
to reduce the output’s cluttering. The Parallel Coordinates plots in 
ROOT have been implemented as a new plotting option “PARA” in the <code>TTree::Draw()method</code>. To demonstrate how the Parallel Coordinates works in ROOT we will use the tree produced by the following “pseudo C++” code:</p>
<div class="sourceCode" id="cb630"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb630-1" title="1"><span class="dt">void</span> parallel_example() {</a>
<a class="sourceLine" id="cb630-2" title="2">   TNtuple *nt = <span class="kw">new</span> TNtuple(<span class="st">"nt"</span>,<span class="st">"Demo ntuple"</span>,<span class="st">"x:y:z:u:v:w:a:b:c"</span>);</a>
<a class="sourceLine" id="cb630-3" title="3">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">3000</span>; i++) {</a>
<a class="sourceLine" id="cb630-4" title="4">      nt-&gt;Fill(   rnd,   rnd,   rnd,    rnd,    rnd,    rnd, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-5" title="5">      nt-&gt;Fill(   s1x,   s1y,   s1z,    s2x,    s2y,    s2z, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-6" title="6">      nt-&gt;Fill(   rnd,   rnd,   rnd,    rnd,    rnd,    rnd, rnd, s3y, rnd );</a>
<a class="sourceLine" id="cb630-7" title="7">      nt-&gt;Fill( s2x-<span class="dv">1</span>, s2y-<span class="dv">1</span>,   s2z, s1x+<span class="fl">.5</span>, s1y+<span class="fl">.5</span>, s1z+<span class="fl">.5</span>, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-8" title="8">      nt-&gt;Fill(   rnd,   rnd,   rnd,    rnd,    rnd,    rnd, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-9" title="9">      nt-&gt;Fill( s1x+<span class="dv">1</span>, s1y+<span class="dv">1</span>, s1z+<span class="dv">1</span>,  s3x-<span class="dv">2</span>,  s3y-<span class="dv">2</span>,  s3z-<span class="dv">2</span>, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-10" title="10">      nt-&gt;Fill(   rnd,   rnd,   rnd,    rnd,    rnd,    rnd, s3x, rnd, s3z );</a>
<a class="sourceLine" id="cb630-11" title="11">      nt-&gt;Fill(   rnd,   rnd,   rnd,    rnd,    rnd,    rnd, rnd, rnd, rnd );</a>
<a class="sourceLine" id="cb630-12" title="12">   }</a></code></pre></div>
<p>The data set generated has:</p>
<ul>
<li>9 variables: x, y, z, u, v, w, a, b, c.</li>
<li>3000*8 = 24000 events.</li>
<li>3 sets of random points distributed on spheres: s1, s2, s3</li>
<li>Random values (noise): rnd</li>
<li>The variables a,b,c are almost completely random. The variables a 
and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere”
 s3.</li>
</ul>
<p>The command used to produce the Parallel Coordinates plot is:</p>
<div class="sourceCode" id="cb631"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb631-1" title="1">   nt-&gt;Draw(<span class="st">"x:a:y:b:z:u:c:v:w"</span>,<span class="st">""</span>,<span class="st">"PARA"</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/para3.png" alt="Cluttered output produced when all the tree events are plotted."><figcaption>Cluttered output produced when all the tree events are plotted.</figcaption>
</figure>
<p>If the 24000 events are plotted as solid lines and no special 
techniques are used to clarify the picture, the result is the previous 
picture which is very cluttered and useless. To improve the readability 
of the Parallel Coordinates output and to explore interactively the data
 set, many techniques are available. We have implemented a few in ROOT. 
First of all, in order to show better where the clusters on the various 
axes are, a 1D histogram is associated to each axis. These histograms 
(one per axis) are filled according to the number of lines passing 
through the bins.</p>
<figure>
<img src="ROOTUsersGuide_files/para4.png" alt="The histogram’s axis can be represented with colors or as bar charts."><figcaption>The histogram’s axis can be represented with colors or as bar charts.</figcaption>
</figure>
<p>These histograms can be represented which colors (get from a palette 
according to the bin contents) or as bar charts. Both representations 
can be cumulated on the same plot. This technique allows seeing clearly 
where the clusters are on an individual axis but it does not give any 
hints about the correlations between the axes.</p>
<p>Avery simple technique allows to make the clusters appearing: Instead
 of painting solid lines we paint dotted lines. The cluttering of each 
individual line is reduced and the clusters show clearly as we can see 
on the next figure. The spacing between the dots is a parameter which 
can be adjusted in order to get the best results.</p>
<figure>
<img src="ROOTUsersGuide_files/para5.png" alt="Using dotted lines is a very simple method to reduce the cluttering."><figcaption>Using dotted lines is a very simple method to reduce the cluttering.</figcaption>
</figure>
<p>Interactivity is a very important aspect of the Parallel Coordinates 
plots. To really explore the data set it is essential to act directly 
with the events and the axes. For instance, changing the axes order may 
show clusters which were not visible in a different order. On the next 
figure the axes order has been changed interactively. We can see that 
many more clusters appear and all the “random spheres” we put in the 
data set are now clearly visible. Having moved the variables <code>u,v,w</code> after the variables <code>x,y,z</code> the correlation between these two sets of variables is clear also.</p>
<figure>
<img src="ROOTUsersGuide_files/para6.png" alt="Axis order is very important to show clusters."><figcaption>Axis order is very important to show clusters.</figcaption>
</figure>
<p>To pursue further data sets exploration we have implemented the 
possibility to define selections interactively. A selection is a set of 
ranges combined together. Within a selection, ranges along the same axis
 are combined with logical OR, and ranges on different axes with logical
 AND. A selection is displayed on top of the complete data set using its
 own color. Only the events fulfilling the selection criteria (ranges) 
are displayed. Ranges are defined interactively using cursors, like on 
the first axis on the figure. Several selections can be defined at the 
same time, each selection having its own color.</p>
<figure>
<img src="ROOTUsersGuide_files/para7.png" alt="Selections are set of ranges which can be defined interactively."><figcaption>Selections are set of ranges which can be defined interactively.</figcaption>
</figure>
<p>Several selections can been defined. Each cluster is now clearly 
visible and the zone with crossing clusters is now understandable 
whereas, without any selection or with only a single one, it was not 
easy to understand.</p>
<figure>
<img src="ROOTUsersGuide_files/para8.png" alt="Several selections can be defined each of them having its own color."><figcaption>Several selections can be defined each of them having its own color.</figcaption>
</figure>
<p>Interactive selections on Parallel Coordinates are a powerful tool 
because they can be defined graphically on many variables (graphical 
cuts in ROOT can be defined on two variables only) which allow a very 
accurate events filtering. Selections allow making precise events 
choices: a single outlying event is clearly visible when the lines are 
displayed as “solid” therefore it is easy to make cuts in order to 
eliminate one single event from a selection. Such selection (to filter 
one single event) on a scatter plot would be much more difficult.</p>
<figure>
<img src="ROOTUsersGuide_files/para9.png" alt="Selections allow to easily filter one single event."><figcaption>Selections allow to easily filter one single event.</figcaption>
</figure>
<p>Once a selection has been defined, it is possible to use it to generate a <code>TEntryList</code>
 which is applied on the tree and used at drawing time. In our example 
the selection we defined allows to select exactly the two correlated 
“random spheres”.</p>
<figure>
<img src="ROOTUsersGuide_files/para10.png" alt="Output of nt-&gt;Draw(“x:y:z”) and nt-&gt;Draw(“u:v:w”) after applying the selection."><figcaption>Output of <code>nt-&gt;Draw(“x:y:z”)</code> and <code>nt-&gt;Draw(“u:v:w”)</code> after applying the selection.</figcaption>
</figure>
<p>Another technique has been implemented in order to show clusters when
 the picture is cluttered. A weight is assigned to each event. The 
weight value is computed as: <span class="math display">\[
weight = \sum_{i=1}^{n} b_i
\]</span></p>
<p>Where:</p>
<ul>
<li>bi is the content of bin crossed by the event on the i-th axis.</li>
<li>n is the number of axis.</li>
</ul>
<p>The events having the bigger weights are those belonging to clusters.
 It is possible to paint only the events having a weight above a given 
value and the clusters appear. The next example “weight cut” applied on 
the right plot is 50. Only the events with a weight greater than 50 are 
displayed.</p>
<figure>
<img src="ROOTUsersGuide_files/para11.png" alt="Applying a “weight cut” makes the clusters visible."><figcaption>Applying a “weight cut” makes the clusters visible.</figcaption>
</figure>
<p>In case only a few events are displayed, drawing them as smooth curves instead of straight lines helps to differentiate them.</p>
<figure>
<img src="ROOTUsersGuide_files/para12.png" alt="Zoom on a Parallel Coordinates plot detail: curves differentiate better events."><figcaption>Zoom on a Parallel Coordinates plot detail: curves differentiate better events.</figcaption>
</figure>
<p>Interactivity and therefore the Graphical User Interface are very 
important to manipulate the Parallel Coordinates plots. The ROOT 
framework allows to easily implement the direct interactions on the 
graphical area and the graphical editor facility provides dedicated GUI.</p>
<figure>
<img src="ROOTUsersGuide_files/para13.png" alt="Parallel Coordinates graphical editors."><figcaption>Parallel Coordinates graphical editors.</figcaption>
</figure>
<p>Transparency is very useful with parallel coordinates plots. It allows to show clearly the clusters. </p>
<figure>
<img src="ROOTUsersGuide_files/para14.png" alt="Parallel Coordinates with transparency."><figcaption>Parallel Coordinates with transparency.</figcaption>
</figure>
<h4 id="box-candle-plots"><span class="header-section-number">12.20.8.3</span> Box (Candle) Plots</h4>
<p>  </p>
<p>A Box Plot (also known as a “box-and whisker” plot or “candle stick” 
plot) is a convenient way to describe graphically a data distribution 
(D) with only the five numbers. It was invented in 1977 by John Tukey. 
The five numbers are:</p>
<ol type="1">
<li>The minimum value of the distribution D (Min).</li>
<li>The lower quartile (Q1): 25% of the data points in D are less than Q1.</li>
<li>The median (M): 50% of the data points in D are less than M.</li>
<li>The upper quartile (Q3): 75% of the data points in D are less than Q3.</li>
<li>The maximum value of the distribution D (Max).</li>
</ol>
<figure>
<img src="ROOTUsersGuide_files/bp1.png" alt="A box plot describes a distribution with only five numbers."><figcaption>A box plot describes a distribution with only five numbers.</figcaption>
</figure>
<p>In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().</p>
<div class="sourceCode" id="cb632"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb632-1" title="1">  tree-&gt;Draw(“px:cos(py):sin(pz)”,””,”candle”);</a></code></pre></div>
<h3 id="using-ttreescan"><span class="header-section-number">12.20.9</span> Using TTree::Scan</h3>
<p></p>
<p><code>TTree::Scan</code> can be used to print the content of the tree’s entries optional passing a selection.</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb633-1" title="1">root[] MyTree-&gt;Scan();</a></code></pre></div>
<p>will print the first 8 variables of the tree.</p>
<div class="sourceCode" id="cb634"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb634-1" title="1">root[] MyTree-&gt;Scan(<span class="st">"*"</span>);</a></code></pre></div>
<p>will print all the variable of the tree.</p>
<p>Specific variables of the tree can be explicit selected by list them in column separated list:</p>
<div class="sourceCode" id="cb635"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb635-1" title="1">root[] MyTree-&gt;Scan(<span class="st">"var1:var2:var3"</span>);</a></code></pre></div>
<p>will print the values of <code>var1</code>, <code>var2</code> and <code>var3</code>. A selection can be applied in the second argument:</p>
<div class="sourceCode" id="cb636"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb636-1" title="1">root[] MyTree-&gt;Scan(<span class="st">"var1:var2:var3"</span>,<span class="st">"var1==0"</span>);</a></code></pre></div>
<p>will print the values of <code>var1</code>, <code>var2</code> and <code>var3</code> for the entries where var1 is exactly 0.</p>
<p><code>TTree::Scan</code> returns the number of entries passing the selection. By default 50 rows are shown before <code>TTree::Scan</code>
 pauses and ask you to press the Enter key to see the next 50 rows. You 
can change the default number of rows to be shown before &lt;CR&gt; via <code>mytree-&gt;SetScanfield(maxrows)</code> where maxrows is 50 by default. If maxrows is set to 0 all rows of the <strong><code>Tree</code></strong> are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:</p>
<div class="sourceCode" id="cb637"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb637-1" title="1">root[] tree-&gt;SetScanField(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb637-2" title="2">root[] tree-&gt;Scan(<span class="st">"*"</span>); &gt;tree.log</a></code></pre></div>
<p>will create a file <code>tree.log</code>.</p>
<p>Arrays (within an entry) are printed in their linear forms. If 
several arrays with multiple dimensions are printed together, they will 
NOT be synchronized. For example, with a tree containing <code>arr1[4][2]</code>and <code>arr2[2][3]</code>,</p>
<div class="sourceCode" id="cb638"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb638-1" title="1">root[] MyTree(<span class="st">"arr1:arr2"</span>);</a></code></pre></div>
<p>will results in a printing similar to:</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb639-1" title="1">************************************************</a>
<a class="sourceLine" id="cb639-2" title="2">*    Row   * Instance *      arr1 *      arr2 *</a>
<a class="sourceLine" id="cb639-3" title="3">***********************************************</a>
<a class="sourceLine" id="cb639-4" title="4">*        x *        <span class="dv">0</span> * arr1[<span class="dv">0</span>][<span class="dv">0</span>]* arr2[<span class="dv">0</span>][<span class="dv">0</span>]*</a>
<a class="sourceLine" id="cb639-5" title="5">*        x *        <span class="dv">1</span> * arr1[<span class="dv">0</span>][<span class="dv">1</span>]* arr2[<span class="dv">0</span>][<span class="dv">1</span>]*</a>
<a class="sourceLine" id="cb639-6" title="6">*        x *        <span class="dv">2</span> * arr1[<span class="dv">1</span>][<span class="dv">0</span>]* arr2[<span class="dv">0</span>][<span class="dv">2</span>]*</a>
<a class="sourceLine" id="cb639-7" title="7">*        x *        <span class="dv">3</span> * arr1[<span class="dv">1</span>][<span class="dv">1</span>]* arr2[<span class="dv">1</span>][<span class="dv">0</span>]*</a>
<a class="sourceLine" id="cb639-8" title="8">*        x *        <span class="dv">4</span> * arr1[<span class="dv">2</span>][<span class="dv">0</span>]* arr2[<span class="dv">1</span>][<span class="dv">1</span>]*</a>
<a class="sourceLine" id="cb639-9" title="9">*        x *        <span class="dv">5</span> * arr1[<span class="dv">2</span>][<span class="dv">1</span>]* arr2[<span class="dv">1</span>][<span class="dv">2</span>]*</a>
<a class="sourceLine" id="cb639-10" title="10">*        x *        <span class="dv">6</span> * arr1[<span class="dv">3</span>][<span class="dv">0</span>]*           *</a>
<a class="sourceLine" id="cb639-11" title="11">*        x *        <span class="dv">7</span> * arr1[<span class="dv">3</span>][<span class="dv">1</span>]*           *</a></code></pre></div>
<p>However, if there is a selection criterium which is an array, then 
all the formulas will be synchronized with the selection criterium (see <strong><code>TTree::Draw</code> for more information).</strong></p>
<p>The third parameter of <code>TTree::Scan</code> can be use to specific the layout of the table:</p>
<ul>
<li><p><code>lenmax=dd</code> - where ‘dd’ is the maximum number of 
elements per array that should be printed. If ‘dd’ is 0, all elements 
are printed (this is the default).</p></li>
<li><p><code>colsize=ss</code> - where ‘ss’ will be used as the default 
size for all the column. If this options is not specified, the default 
column size is 9.</p></li>
<li><p><code>precision=pp</code> - where ‘pp’ will be used as the default ‘precision’ for the printing format.</p></li>
<li><p><code>col=xxx</code> - where ‘<code>xxx</code>’ is colon (:) delimited list of printing format for each column if no format is specified for a column, the default is used.</p></li>
</ul>
<p>For example:</p>
<div class="sourceCode" id="cb640"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb640-1" title="1">   tree-&gt;Scan(<span class="st">"a:b:c"</span>,<span class="st">""</span>,<span class="st">"colsize=30 precision=3 col=::20.10"</span>);</a></code></pre></div>
<p>will print 3 columns, the first 2 columns will be 30 characters long,
 the third columns will be 20 characters long. The printf format for the
 columns (assuming they are numbers) will be respectively: <code>%30.3g</code> <code>%30.3g</code> <code>%20.10g</code>.</p>
<h3 id="teventlist-and-tentrylist"><span class="header-section-number">12.20.10</span> TEventList and TEntryList</h3>
<p> </p>
<p>The <code>TTree::Draw</code>method can also be used to build a list of the entries. When the first argument is preceded by <code>"&gt;&gt;"</code>
 ROOT knows that this command is not intended to draw anything, but to 
save the entries in a list with the name given by the first argument. As
 a result, a <strong><code>TEventList</code></strong> or a <strong><code>TEntryList</code></strong> object is created in the current directory. For example, to create a <strong><code>TEventList</code></strong> of all entries with more than 600 tracks, do:</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb641-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Event.root"</span>);</a>
<a class="sourceLine" id="cb641-2" title="2">root[] T-&gt;Draw(<span class="st">"&gt;&gt; myList"</span>,<span class="st">"fNtrack &gt; 600"</span>);</a></code></pre></div>
<p>To create a <strong><code>TEntryList</code></strong>, use the option “<code>entrylist</code>”.</p>
<div class="sourceCode" id="cb642"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb642-1" title="1">root[] T-&gt;Draw(<span class="st">"&gt;&gt;myList"</span>, <span class="st">"fNtrack&gt;600"</span>, <span class="st">"entrylist"</span>);</a></code></pre></div>
<p>This list contains the entry number of all entries with more than 600 tracks. To see the entry numbers use the <code>Print("all")</code> command.</p>
<div class="sourceCode" id="cb643"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb643-1" title="1">root[] myList-&gt;Print(<span class="st">"all"</span>);</a></code></pre></div>
<p>When using the “<code>&gt;&gt;</code>” whatever was in the list is overwritten. The list can be grown by using the “<code>&gt;&gt;+</code>” syntax. For example to add the entries, with exactly 600 tracks:</p>
<div class="sourceCode" id="cb644"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb644-1" title="1">root[] T-&gt;Draw(<span class="st">"&gt;&gt;+ myList"</span>,<span class="st">"fNtrack == 600"</span>, <span class="st">"entrylist"</span>);</a></code></pre></div>
<p>If the <code>Draw</code> command generates duplicate entries, they are not added to the list.</p>
<div class="sourceCode" id="cb645"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb645-1" title="1">root[] T-&gt;Draw(<span class="st">"&gt;&gt;+ myList"</span>,<span class="st">" fNtrack &gt; 610"</span>, <span class="st">"entrylist"</span>);</a></code></pre></div>
<p>This command does not add any new entries to the list because all 
entries with more than 610 tracks have already been found by the 
previous command for entries with more than 600 tracks.</p>
<h4 id="main-differences-between-teventlist-and-tentrylist"><span class="header-section-number">12.20.10.1</span> Main Differences between TEventList and TEntryList</h4>
<p>The functionality is essentially the same: both are used to store entry numbers. <strong><code>TEntryList</code></strong>, however, uses considerably less memory for storage, and is optimized for both very high and very low selectivity of cuts (see <strong><code>TEntryListBlock</code></strong> class description for the details of internal storage). Unlike the <strong><code>TEventList</code></strong>, <strong><code>TEntryList</code></strong> makes a distinction between indices from a <strong><code>TChain</code></strong> and from a <strong><code>TTree</code></strong>. While a <strong><code>TEntryList</code></strong> for a <strong><code>TTree</code></strong> can be seen as just a list of numbers, a <strong><code>TEntryList</code></strong> for a <strong><code>TChain</code></strong> is a collection of <strong><code>TEntryList</code></strong>(s) for the <strong><code>TTree</code></strong>(s) that constitute this <strong><code>TChain</code></strong>. Such “sub-lists” can be extracted by calling the function</p>
<div class="sourceCode" id="cb646"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb646-1" title="1">TEntryList::GetEntryList(<span class="at">const</span> <span class="dt">char</span> *treename, <span class="at">const</span> <span class="dt">char</span> *filename)</a></code></pre></div>
<p>and then be used to construct a new <strong><code>TEntryList</code></strong> for a new <strong><code>TChain</code></strong>, or processed independently as normal <strong><code>TEntryList</code></strong>(s) for <strong><code>TTree</code></strong>(s). This modularity makes <strong><code>TEntryList</code></strong> much better suited for PROOF processing than the <strong><code>TEventList</code></strong>.</p>
<h4 id="using-an-event-list"><span class="header-section-number">12.20.10.2</span> Using an Event List</h4>
<p>A <strong><code>TEventList</code></strong> or a <strong><code>TEntryList</code></strong> can be used to limit the <strong><code>TTree</code></strong> to the events in the list. The methods <code>SetEventList</code> and <code>SetEntryList</code> tell the tree to use the list and hence limit all subsequent calls to <code>Draw</code>, <code>Scan</code>, <code>Process</code>, <code>Query</code>, <code>Principal</code> and <code>CopyTree</code> methods to the entries in the list. In general, it affects the <code>GetEntryNumber</code> method and all functions using it for looping over the tree entries. The <code>GetEntry</code> and <code>GetEntries</code> methods are not affected. Note, that in the <code>SetEventList</code> method, the <strong><code>TEventList</code></strong> argument is internally transformed into a <strong><code>TEntryList</code></strong>, and this operation, in case of a <strong><code>TChain</code></strong>,
 requires loading of all the tree headers. In this example, we create a 
list with all entries with more than 600 tracks and then set it so that 
the tree will use this list. To reset the <strong><code>TTree</code></strong> to use all events use <code>SetEventList(0)</code> or <code>SetEntryList(0)</code>.</p>
<ol type="1">
<li>Let’s look at an example. First, open the file and draw the <code>fNtrack</code>.</li>
</ol>
<div class="sourceCode" id="cb647"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb647-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Event.root"</span>);</a>
<a class="sourceLine" id="cb647-2" title="2">root[] TTree *T = (TTree*)f-&gt;Get(<span class="st">"T"</span>);</a>
<a class="sourceLine" id="cb647-3" title="3">root[] T-&gt;Draw(<span class="st">"fNtrack"</span>);</a></code></pre></div>
<ol start="2" type="1">
<li>Now, put the entries with over 600 tracks into a <strong><code>TEntryList</code></strong> called <code>myList</code>. We get the list from the current directory and assign it to a variable list.</li>
</ol>
<div class="sourceCode" id="cb648"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb648-1" title="1">root[] T-&gt;Draw(<span class="st">"&gt;&gt;myList"</span>,<span class="st">"fNtrack &gt; 600"</span>,<span class="st">"entrylist"</span>);</a>
<a class="sourceLine" id="cb648-2" title="2">root[] TEntryList *list=(TEntryList*)gDirectory-&gt;Get(<span class="st">"myList"</span>);</a></code></pre></div>
<ol start="3" type="1">
<li>Instruct the tree <strong><code>T</code></strong> to use the new list and draw it again. Note that this is exactly the same <code>Draw</code> command. The list limits the entries.</li>
</ol>
<div class="sourceCode" id="cb649"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb649-1" title="1">root[] T-&gt;SetEntryList(list);</a>
<a class="sourceLine" id="cb649-2" title="2">root[] T-&gt;Draw(<span class="st">"fNtrack"</span>);</a></code></pre></div>
<p>You should now see a canvas similar to this one.</p>
<p><img src="ROOTUsersGuide_files/03000105.png"></p>
<h4 id="operations-on-tentrylists"><span class="header-section-number">12.20.10.3</span> Operations on TEntryLists</h4>
<p>If you have entry lists that were created using different cuts, you 
can combine the lists to get a new list, with entries passing at least 
one of the cuts. Example:</p>
<div class="sourceCode" id="cb650"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb650-1" title="1">root[] T-&gt;Draw(<span class="st">"&gt;&gt;list1"</span>,<span class="st">"fNtrack&gt;600"</span>,<span class="st">"entrylist"</span>);</a>
<a class="sourceLine" id="cb650-2" title="2">root[] TEntryList *list1 = (TEntryList*)gDirectory-&gt;Get(<span class="st">"list1"</span>);</a>
<a class="sourceLine" id="cb650-3" title="3">root[] T-&gt;Draw(<span class="st">"&gt;&gt;list2"</span>,<span class="st">"fNtrack&lt;590"</span>,<span class="st">"entrylist"</span>);</a>
<a class="sourceLine" id="cb650-4" title="4">root[] TEntryList *list2 = (TEntryList*)gDirectory-&gt;Get(<span class="st">"list2"</span>);</a>
<a class="sourceLine" id="cb650-5" title="5">root[] list1-&gt;Add(list2);</a></code></pre></div>
<p><code>list1</code> now contains entries with more than 600 or less than 590 tracks. Check this by calling:</p>
<div class="sourceCode" id="cb651"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb651-1" title="1">root[] T-&gt;SetEntryList(list1);</a>
<a class="sourceLine" id="cb651-2" title="2">root[] T-&gt;Draw(<span class="st">"fNtrack"</span>);</a></code></pre></div>
<p>You can also subtract <strong><code>TEntryList</code></strong> from 
each other, so that the first list contains only the entries, passing 
the selection of the first list and not present in the second list.</p>
<p>To add some individual entries, use <code>TEntryList::Enter()</code> function. To remove the entries you don’t like, use <code>TEntryList::Remove()</code>. To see if the entry is in the list, use <strong><code>TEntryList::Contains()</code></strong>. Remember, that all operation in a <strong><code>TEntryList</code></strong> for a <strong><code>TChain</code></strong> are on the <strong><code>TTree</code></strong> level. This is illustrated by the following example:</p>
<div class="sourceCode" id="cb652"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb652-1" title="1">root[] TEntryList *list1 = <span class="kw">new</span> TEntryList(<span class="st">"list1"</span>,<span class="st">"list1"</span>);</a>
<a class="sourceLine" id="cb652-2" title="2">root[] list1-&gt;SetTree(<span class="st">"tree1"</span>,<span class="st">"file1"</span>)</a>
<a class="sourceLine" id="cb652-3" title="3">root[] list1-&gt;Enter(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb652-4" title="4">root[] list1-&gt;Enter(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb652-5" title="5">root[] TEntryList *list2 = <span class="kw">new</span> TEntryList(<span class="st">"list2"</span>, <span class="st">"list2"</span>);</a>
<a class="sourceLine" id="cb652-6" title="6">root[] list2-&gt;SetTree(<span class="st">"tree2"</span>, <span class="st">"file2"</span>);</a>
<a class="sourceLine" id="cb652-7" title="7">root[] list2-&gt;Enter(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb652-8" title="8">root[] list2-&gt;Enter(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb652-9" title="9">root[] list1-&gt;Add(list2);</a>
<a class="sourceLine" id="cb652-10" title="10">root[] list1-&gt;Print(<span class="st">"all"</span>)</a>
<a class="sourceLine" id="cb652-11" title="11">tree1 file<span class="dv">1</span></a>
<a class="sourceLine" id="cb652-12" title="12"><span class="dv">0</span></a>
<a class="sourceLine" id="cb652-13" title="13"><span class="dv">2</span></a>
<a class="sourceLine" id="cb652-14" title="14">tree2 file<span class="dv">2</span></a>
<a class="sourceLine" id="cb652-15" title="15"><span class="dv">0</span></a>
<a class="sourceLine" id="cb652-16" title="16"><span class="dv">3</span></a></code></pre></div>
<p>The result is a <strong><code>TEntryList</code></strong> for a <strong><code>TChain</code></strong> of <code>tree1</code> and <code>tree2</code>. If the second list was for the same <strong><code>TTree</code></strong> in the same file as the first list, the result would be as follows:</p>
<div class="sourceCode" id="cb653"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb653-1" title="1">root[] TEntryList *list2_2 = <span class="kw">new</span> TEntryList(<span class="st">"list2_2"</span>, <span class="st">"list2_2"</span>);</a>
<a class="sourceLine" id="cb653-2" title="2">root[] list2_2-&gt;SetTree(<span class="st">"tree2"</span>, <span class="st">"file2"</span>);</a>
<a class="sourceLine" id="cb653-3" title="3">root[] list2_2-&gt;Enter(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb653-4" title="4">root[] list2_2-&gt;Enter(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb653-5" title="5">root[] list2-&gt;Add(list2_2);</a>
<a class="sourceLine" id="cb653-6" title="6">root[] list2-&gt;Print(<span class="st">"all"</span>)</a>
<a class="sourceLine" id="cb653-7" title="7">tree2 file<span class="dv">2</span></a>
<a class="sourceLine" id="cb653-8" title="8"><span class="dv">0</span></a>
<a class="sourceLine" id="cb653-9" title="9"><span class="dv">1</span></a>
<a class="sourceLine" id="cb653-10" title="10"><span class="dv">2</span></a>
<a class="sourceLine" id="cb653-11" title="11"><span class="dv">3</span></a></code></pre></div>
<h4 id="tentrylistfromfile"><span class="header-section-number">12.20.10.4</span> TEntryListFromFile</h4>
<p>This is a special kind of <strong><code>TEntryList</code></strong>, used only when processing <strong><code>TChain</code></strong> objects (see the method <code>TChain::SetEntryListFile()</code>).
 It is used in the case, when the entry lists, corresponding to the 
trees of this chain, are stored in separate files. It allows to load the
 entry lists in memory one by one, keeping only the list for the 
currently processed tree loaded.</p>
<p>For more details on entry lists, see <strong><code>TEntryList</code></strong>, <strong><code>TEntryListBlock</code></strong> and <strong><code>TEntryListFromFile</code></strong> class descriptions, functions <strong><code>TChain</code></strong><code>::SetEntryList()</code>, <code>TChain::SetEntryListFile()</code>, and the macro <code>$ROOTSYS/test/stressEntryList.C</code>.</p>
<h3 id="filling-a-histogram"><span class="header-section-number">12.20.11</span> Filling a Histogram</h3>
<p>The <code>TTree::Draw</code> method can also be used to fill a specific histogram. The syntax is:</p>
<div class="sourceCode" id="cb654"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb654-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Event.root"</span>)</a>
<a class="sourceLine" id="cb654-2" title="2">root[] T-&gt;Draw(<span class="st">"fNtrack &gt;&gt; myHisto"</span>)</a>
<a class="sourceLine" id="cb654-3" title="3">root[] myHisto-&gt;Print()</a>
<a class="sourceLine" id="cb654-4" title="4">TH1.Print Name= myHisto, Entries= <span class="dv">100</span>, Total sum= <span class="dv">100</span></a></code></pre></div>
<p>As we can see, this created a <strong><code>TH1</code></strong>, called <code>myHisto</code>. If you want to append more entries to the histogram, you can use this syntax:</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb655-1" title="1">root[] T-&gt;Draw(<span class="st">"fNtrack &gt;&gt;+ myHisto"</span>)</a></code></pre></div>
<p>If you do not create a histogram ahead of time, ROOT will create one 
at the time of the Draw command (as is the case above). If you would 
like to draw the variable into a specific histogram where you, for 
example, set the range and bin number, you can define the histogram 
ahead of time and use it in the Draw command. The histogram has to be in
 the same directory as the tree.</p>
<div class="sourceCode" id="cb656"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb656-1" title="1">root[] TH1 *h1 = <span class="kw">new</span> TH1(<span class="st">"h1"</span>,<span class="st">"h1"</span>,<span class="dv">50</span>,<span class="fl">0.</span>,<span class="fl">150.</span>);</a>
<a class="sourceLine" id="cb656-2" title="2">root[] T-&gt;Draw(<span class="st">"fNtrack&gt;&gt; h1"</span>);</a></code></pre></div>
<p>When you project a <strong><code>TTree</code></strong> into a histogram, the histogram inherits the <strong><code>TTree</code></strong>
 attributes and not the current style attributes. This allows you to 
project two Trees with different attributes into the same picture. You 
can call the method <code>TTree::UseCurrentStyle</code> to change the histogram to use the current style <strong><em><code>gStyle</code></em></strong>. See "Graphics and the Graphical User Interface.</p>
<p>The binning of the newly created histogram can be specified in two ways. You can set a default in the <code>.rootrc</code> and/or you can add the binning information in the <code>TTree::Draw</code> command.</p>
<p>To set number of bins default for the 1-D, 2-D, 3-D histograms can be specified in the <code>.rootrc</code> file via the environment variables, e.g.:</p>
<pre><code># default binnings   Hist.Binning.1D.x: 100

Hist.Binning.2D.x: 40
Hist.Binning.2D.y: 40
Hist.Binning.2D.Prof: 100

Hist.Binning.3D.x: 20
Hist.Binning.3D.y: 20
Hist.Binning.3D.z: 20
Hist.Binning.3D.Profx: 100
Hist.Binning.3D.Profy: 100</code></pre>
<p>To set the number of bins for a specific histogram when using <code>TTree::Draw,</code> add up to nine numbers following the histogram name. The numbers meaning is:</p>
<p>1 bins in x-direction</p>
<p>2 lower limit in x-direction</p>
<p>3 upper limit in x-direction</p>
<p>4-6 same for y-direction</p>
<p>7-9 same for z-direction</p>
<p>When a bin number is specified, the value becomes the default. Any of the numbers can be skipped. For example:</p>
<div class="sourceCode" id="cb658"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb658-1" title="1">   tree.Draw(<span class="st">"sqrt(x)&gt;&gt;hsqrt(500,10,20)"</span>;</a>
<a class="sourceLine" id="cb658-2" title="2">   <span class="co">// plot sqrt(x) between 10 and 20 using 500 bins</span></a>
<a class="sourceLine" id="cb658-3" title="3">   tree.Draw(<span class="st">"sqrt(x):sin(y)&gt;&gt;hsqrt(100,10,,50,.1,.5)"</span>;</a>
<a class="sourceLine" id="cb658-4" title="4">   <span class="co">// plot sqrt(x) against sin(y) 100 bins in x-direction;</span></a>
<a class="sourceLine" id="cb658-5" title="5">   <span class="co">// lower limit on x-axis is 10; no upper limit</span></a>
<a class="sourceLine" id="cb658-6" title="6">   <span class="co">// 50 bins in y-direction; lower limit on y-axis is .1;</span></a>
<a class="sourceLine" id="cb658-7" title="7">   <span class="co">// upper limit is .5</span></a></code></pre></div>
<p>When the name is followed by binning information, appending the histogram with a “+”, will not reset <code>hsqrt</code>, but will continue to fill it.</p>
<div class="sourceCode" id="cb659"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb659-1" title="1">   tree.Draw(<span class="st">"sqrt(x)&gt;&gt;+hsqrt"</span>,<span class="st">"y&gt;0"</span>);</a></code></pre></div>
<p>This works for 1-D, 2-D and 3-D histograms.</p>
<h4 id="projecting-a-histogram"><span class="header-section-number">12.20.11.1</span> Projecting a Histogram</h4>
<p>If you would like to fill a histogram, but not draw it you can use the <code>TTree::Project()</code> method.</p>
<div class="sourceCode" id="cb660"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb660-1" title="1">root[] T-&gt;Project(<span class="st">"quietHisto"</span>,<span class="st">"fNtrack"</span>)</a></code></pre></div>
<h4 id="making-a-profile-histogram"><span class="header-section-number">12.20.11.2</span> Making a Profile Histogram</h4>
<p></p>
<p>In case of a two dimensional expression, you can generate a <strong><code>TProfile</code></strong> histogram instead of a two dimensional histogram by specifying the <code>'prof'</code> or ’<code>profs'</code> option. The <code>prof</code> option is automatically selected when the output is redirected into a <strong><code>TProfile</code></strong>. For example <code>y:x&gt;&gt;pf</code> where <code>pf</code>is an existing <strong><code>TProfile</code></strong> histogram.</p>
<h4 id="tree-information"><span class="header-section-number">12.20.11.3</span> Tree Information</h4>
<p>Once we have drawn a tree, we can get information about the tree. 
These are the methods used to get information from a drawn tree <strong><code>TTree</code></strong>:</p>
<ul>
<li><p><code>GetSelectedRows</code>: Returns the number of entries 
accepted by the selection expression. In case where no selection was 
specified, it returns the number of entries processed.</p></li>
<li><p><code>GetV1</code>: Returns a pointer to the float array of the first variable.</p></li>
<li><p><code>GetV2</code>: Returns a pointer to the float array of second variable</p></li>
<li><p><code>GetV3</code>: Returns a pointer to the float array of third variable.</p></li>
<li><p><code>GetW</code>: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression.</p></li>
</ul>
<p>To read the drawn values of <code>fNtrack</code> into an array, and loop through the entries follow the lines below. First, open the file and draw the <code>fNtrack</code> variable:</p>
<div class="sourceCode" id="cb661"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb661-1" title="1">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Event.root"</span>)</a>
<a class="sourceLine" id="cb661-2" title="2">root[] T-&gt;Draw(<span class="st">"fNtrack"</span>)</a></code></pre></div>
<p>Then declare a pointer to a float and use the GetV1 method to 
retrieve the first dimension of the tree. In this example we only drew 
one dimension (<code>fNtrack</code>) if we had drawn two, we could use GetV2 to get the second one.</p>
<div class="sourceCode" id="cb662"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb662-1" title="1">root[] <span class="dt">Float_t</span> *a</a>
<a class="sourceLine" id="cb662-2" title="2">root[] a = T-&gt;GetV1()</a></code></pre></div>
<p>Loop through the first 10 entries and print the values of <code>fNtrack</code>:</p>
<div class="sourceCode" id="cb663"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb663-1" title="1">root[] <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++)</a>
<a class="sourceLine" id="cb663-2" title="2">root[] cout &lt;&lt; a[i] &lt;&lt; <span class="st">" "</span> &lt;&lt; endl   <span class="co">// need an endl to see the values</span></a>
<a class="sourceLine" id="cb663-3" title="3"><span class="dv">594</span> <span class="dv">597</span> <span class="dv">606</span> <span class="dv">595</span> <span class="dv">604</span> <span class="dv">610</span> <span class="dv">604</span> <span class="dv">602</span> <span class="dv">603</span> <span class="dv">596</span></a></code></pre></div>
<p>By default, <code>TTree::Draw</code> creates these arrays with <code>fEstimate</code> words where <code>fEstimate</code> can be set via <code>TTree::SetEstimate</code>. If you have more entries than <code>fEstimate</code> only the first <code>fEstimate</code> selected entries will be stored in the arrays. The arrays are used as buffers. When <code>fEstimate</code>
 entries have been processed, ROOT scans the buffers to compute the 
minimum and maximum of each coordinate and creates the corresponding 
histograms. You can use these lines to read all entries into these 
arrays:</p>
<div class="sourceCode" id="cb664"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb664-1" title="1">root[] <span class="dt">Int_t</span> nestimate = (<span class="dt">Int_t</span>)T-&gt;GetEntries();</a>
<a class="sourceLine" id="cb664-2" title="2">root[] T-&gt;SetEstimate(nestimate);</a></code></pre></div>
<p>Obviously, this will not work if the number of entries is very large.
 This technique is useful in several cases, for example if you want to 
draw a graph connecting all the <code>x</code>, <code>y(or z)</code> 
points. Note that you may have a tree (or chain) with 1 billion entries,
 but only a few may survive the cuts and will fit without problems in 
these arrays.</p>
<h2 id="using-ttreemakeclass"><span class="header-section-number">12.21</span> Using TTree::MakeClass</h2>
<p></p>
<p>The <code>TTree::Draw</code> method is convenient and easy to use; however it falls short if you need to do some programming with the variable.</p>
<p>For example, for plotting the masses of all oppositely changed pairs 
of tracks, you would need to write a program that loops over all events,
 finds all pairs of tracks, and calculates the required quantities. We 
have shown how to retrieve the data arrays from the branches of the tree
 in the previous section, and you could just write that program from 
scratch. Since this is a very common task, ROOT provides a utility that 
generates a skeleton class designed to loop over the entries of the 
tree.</p>
<p>This is the <code>TTree::MakeClass</code> method. We will now go through the steps of using <code>MakeClass</code> with a simplified example. The methods used here obviously work for complex event loop calculations.</p>
<p>These are our assumptions: we would like to do selective plotting and
 loop through each entry of the tree and tracks. We chose a simple 
example: we want to plot <code>fPx</code> of the first 100 tracks of each entry. We have a ROOT tree with a branch for each data member in the “<code>Event</code>” object. To build this file and tree follow the instructions on how to build the examples in <code>$ROOTSYS/test</code>. Execute <code>Event</code> and instruct it to split the object with this command (from the UNIX command line).</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb665-1" title="1">&gt; <span class="er">$</span>ROOTSYS/test/Event <span class="dv">400</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span></a></code></pre></div>
<p>This creates an <code>Event.root</code> file with 400 events, compressed, split, and filled.</p>
<p>See <code>$ROOTSYS/test/MainEvent.cxx</code> for more info.</p>
<p>The person who designed the tree makes a shared library available to 
you, which defines the classes needed. In this case, the classes are 
Event, <code>EventHeader</code>, and Track and they are defined in the shared library <code>libEvent.so</code>. The designer also gives you the <code>Event.h</code> file to see the definition of the classes. You can locate <code>Event.h</code> in <code>$ROOTSYS/test</code>, and if you have not yet built <code>libEvent.so</code>,
 please see the instructions of how to build it (typing make in 
$ROOTSYS/test is enough). If you have already built it, you can now use 
it again.</p>
<h3 id="creating-a-class-with-makeclass"><span class="header-section-number">12.21.1</span> Creating a Class with MakeClass</h3>
<p>First, we load the shared library and open <code>Event.root</code>.</p>
<div class="sourceCode" id="cb666"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb666-1" title="1">root[] .L libEvent.so</a>
<a class="sourceLine" id="cb666-2" title="2">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Event.root"</span>);</a>
<a class="sourceLine" id="cb666-3" title="3">root[] f-&gt;ls();</a>
<a class="sourceLine" id="cb666-4" title="4">TFile**         Event.root      TTree benchmark ROOT file</a>
<a class="sourceLine" id="cb666-5" title="5">TFile*         Event.root      TTree benchmark ROOT file</a>
<a class="sourceLine" id="cb666-6" title="6">KEY: TH1F     htime;<span class="dv">1</span> Real-Time to write versus time</a>
<a class="sourceLine" id="cb666-7" title="7">KEY: TTree    T;<span class="dv">1</span>     An example of a ROOT tree</a></code></pre></div>
<p>We can see there is a tree “<code>T</code>”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.</p>
<div class="sourceCode" id="cb667"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb667-1" title="1">root[] T-&gt;Print();</a></code></pre></div>
<p>From the output of print we can see that the tree has one branch for each data member of <code>Event</code>, <code>Track</code>, and <code>EventHeader</code>. Now we can use <code>TTree::MakeClass</code> on our tree “<code>T</code>”. <code>MakeClass</code>
 takes one parameter, a string containing the name of the class to be 
made. In the command below, the name of our class will be “<code>MyClass</code>”.</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb668-1" title="1">root[] T-&gt;MakeClass(<span class="st">"MyClass"</span>)</a>
<a class="sourceLine" id="cb668-2" title="2">Files: MyClass.h <span class="kw">and</span> MyClass.C generated from Tree: T</a></code></pre></div>
<p>Cling informs us that it has created two files. <code>MyClass.</code>h contains the class definition and <code>MyClass.C</code> contains the <code>MyClass::Loop()</code> method. <code>MyClass</code> has more methods than just <code>Loop()</code>. The other methods are a constructor, a destructor, <code>GetEntry()</code>, <code>LoadTree()</code>, <code>Notify()</code>, <code>Cut()</code> and <code>Show()</code>.
 The implementations of these methods are in the .h file. This division 
of methods was done intentionally. The .C file is kept as short as 
possible, and contains only code that is intended for you to customize. 
The .h file contains all the other methods. It is clear that you want to
 be as independent as possible of the header file (i.e.&nbsp;<code>MyClass.h</code>) generated by <code>MakeClass</code>. The solution is to implement a derived class, for example <code>MyRealClass</code> deriving from <code>MyClass</code> such that a change in your <code>Tree</code>or regeneration of <code>MyClass.h</code> does not force you to change <code>MyRealClass.h</code>. You can imagine deriving several classes from <code>MyClass.h</code>, each with a specific algorithm. To understand both files, let’s start with <code>MyClass.h</code> and the class declaration:</p>
<h3 id="myclass.h"><span class="header-section-number">12.21.2</span> MyClass.h</h3>
<div class="sourceCode" id="cb669"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb669-1" title="1"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb669-2" title="2">   <span class="kw">public</span> :</a>
<a class="sourceLine" id="cb669-3" title="3">      <span class="co">// Pointer to the analyzed TTree or TChain</span></a>
<a class="sourceLine" id="cb669-4" title="4">      TTree          *fChain;</a>
<a class="sourceLine" id="cb669-5" title="5">      <span class="co">// Current Tree number in a TChain</span></a>
<a class="sourceLine" id="cb669-6" title="6">      <span class="dt">Int_t</span>           fCurrent;</a>
<a class="sourceLine" id="cb669-7" title="7">      <span class="co">// Declaration of leaves types</span></a>
<a class="sourceLine" id="cb669-8" title="8">      <span class="dt">UInt_t</span>          fUniqueID;</a>
<a class="sourceLine" id="cb669-9" title="9">      <span class="dt">UInt_t</span>          fBits;</a>
<a class="sourceLine" id="cb669-10" title="10">      <span class="dt">Char_t</span>          fType[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb669-11" title="11">      <span class="dt">Int_t</span>           fNtrack;</a>
<a class="sourceLine" id="cb669-12" title="12">      <span class="dt">Int_t</span>           fNseg;</a>
<a class="sourceLine" id="cb669-13" title="13">      <span class="dt">Int_t</span>           fNvertex;</a>
<a class="sourceLine" id="cb669-14" title="14">      <span class="dt">UInt_t</span>          fFlag;</a>
<a class="sourceLine" id="cb669-15" title="15">      <span class="dt">Float_t</span>         fTemperature;</a>
<a class="sourceLine" id="cb669-16" title="16">      <span class="dt">Int_t</span>           fEvtHdr_fEvtNum;</a>
<a class="sourceLine" id="cb669-17" title="17">      <span class="co">// List of branches</span></a>
<a class="sourceLine" id="cb669-18" title="18">      TBranch        *b_fUniqueID;</a>
<a class="sourceLine" id="cb669-19" title="19">      TBranch        *b_fBits;</a>
<a class="sourceLine" id="cb669-20" title="20">      TBranch        *b_fType;</a>
<a class="sourceLine" id="cb669-21" title="21">      TBranch        *b_fNtrack;</a>
<a class="sourceLine" id="cb669-22" title="22">      TBranch        *b_fNseg;</a>
<a class="sourceLine" id="cb669-23" title="23">      TBranch        *b_fNvertex;</a>
<a class="sourceLine" id="cb669-24" title="24">      TBranch        *b_fFlag;</a>
<a class="sourceLine" id="cb669-25" title="25">      TBranch        *b_fTemperature;</a>
<a class="sourceLine" id="cb669-26" title="26">      TBranch        *b_fEvtHdr_fEvtNum;</a>
<a class="sourceLine" id="cb669-27" title="27">...</a>
<a class="sourceLine" id="cb669-28" title="28">             MyClass(TTree *tree=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb669-29" title="29">            ~MyClass();</a>
<a class="sourceLine" id="cb669-30" title="30">      <span class="dt">Int_t</span>  Cut(<span class="dt">Int_t</span> entry);</a>
<a class="sourceLine" id="cb669-31" title="31">      <span class="dt">Int_t</span>  GetEntry(<span class="dt">Int_t</span> entry);</a>
<a class="sourceLine" id="cb669-32" title="32">      <span class="dt">Int_t</span>  LoadTree(<span class="dt">Int_t</span> entry);</a>
<a class="sourceLine" id="cb669-33" title="33">      <span class="dt">void</span>   Init(TTree *tree);</a>
<a class="sourceLine" id="cb669-34" title="34">      <span class="dt">void</span>   Loop();</a>
<a class="sourceLine" id="cb669-35" title="35">      <span class="dt">Bool_t</span> Notify();</a>
<a class="sourceLine" id="cb669-36" title="36">      <span class="dt">void</span>   Show(<span class="dt">Int_t</span> entry = -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb669-37" title="37">};</a></code></pre></div>
<p>We can see data members in the generated class. The first data member is <code>fChain</code>. Once this class is instantiated, <code>fChain</code> will point to the original tree or chain this class was made from. In our case, this is “T” in “<code>Event.root</code>”. If the class is instantiated with a tree as a parameter to the constructor, <code>fChain</code> will point to the tree named in the parameter. Next is <code>fCurrent</code>,
 which is also a pointer to the current tree/chain. Its role is only 
relevant when we have multiple trees chained together in a <strong><code>TChain</code></strong>. The class definition shows us that this tree has one branch and one leaf per data member. The methods of <code>MyClass</code> are:</p>
<ul>
<li><p><code>MyClass(TTree *tree=0) -</code> this constructor has an optional tree for a parameter. If you pass a tree, <code>MyClass</code> will use it rather than the tree from which it was created.</p></li>
<li><p><code>void  Init(TTree *tree) -</code> it is called by the 
constructor to initialize the tree for reading. It associates each 
branch with the corresponding leaf data member.</p></li>
<li><p><code>~MyClass() -</code>the destructor, nothing special.</p></li>
<li><p><code>Int_t GetEntry(Int_t entry) -</code> it loads the class with the entry specified. Once you have executed <code>GetEntry</code>, the leaf data members in <code>MyClass</code> are set to the values of the entry. For example, <code>GetEntry(12)</code> loads the 13th event into the event data member of <code>MyClass</code> (note that the first entry is 0). <code>GetEntry</code>
 returns the number of bytes read from the file. In case the same entry 
is read twice, ROOT does not have to do any I/O. In this case <code>GetEntry</code> returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.</p></li>
<li><p><code>Int_t LoadTree(Int_t entry)</code> and <code>void  Notify()</code> - these two methods are related to chains. <code>LoadTree</code> will load the tree containing the specified entry from a chain of trees. Notify is called by <code>LoadTree</code> to adjust the branch addresses.</p></li>
<li><p><code>void Loop()</code> - it is the skeleton method that loops 
through each entry of the tree. This is interesting to us, because we 
will need to customize it for our analysis.</p></li>
</ul>
<h3 id="myclass.c"><span class="header-section-number">12.21.3</span> MyClass.C</h3>
<p><code>MyClass::Loop</code> consists of a for-loop calling <code>GetEntry</code>
 for each entry. In the template, the numbers of bytes are added up, but
 it does nothing else. If we were to execute it now, there would be no 
output.</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb670-1" title="1"><span class="dt">void</span> MyClass::Loop() {</a>
<a class="sourceLine" id="cb670-2" title="2">   <span class="cf">if</span> (fChain == <span class="dv">0</span>) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb670-3" title="3"></a>
<a class="sourceLine" id="cb670-4" title="4">   <span class="dt">Int_t</span> nentries = <span class="dt">Int_t</span>(fChain-&gt;GetEntries());</a>
<a class="sourceLine" id="cb670-5" title="5">   <span class="dt">Int_t</span> nbytes = <span class="dv">0</span>, nb = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb670-6" title="6">   <span class="cf">for</span> (<span class="dt">Int_t</span> jentry=<span class="dv">0</span>; jentry&lt;nentries;jentry++) {</a>
<a class="sourceLine" id="cb670-7" title="7">      <span class="dt">Int_t</span> ientry = LoadTree(jentry);</a>
<a class="sourceLine" id="cb670-8" title="8">      <span class="co">// in case of a TChain   , ientry is the entry number in the</span></a>
<a class="sourceLine" id="cb670-9" title="9">      <span class="co">// current file</span></a>
<a class="sourceLine" id="cb670-10" title="10">      nb = fChain-&gt;GetEntry(jentry);   nbytes += nb;</a>
<a class="sourceLine" id="cb670-11" title="11">      <span class="co">// if (Cut(ientry) &lt; 0) continue;</span></a>
<a class="sourceLine" id="cb670-12" title="12">   }</a>
<a class="sourceLine" id="cb670-13" title="13">}</a></code></pre></div>
<p>At the beginning of the file are instructions about reading selected 
branches. They are not reprinted here, but please read them from your 
own file</p>
<h3 id="modifying-myclassloop"><span class="header-section-number">12.21.4</span> Modifying MyClass::Loop</h3>
<p>Let us continue with the goal of going through the first 100 tracks of each entry and plot <code>Px</code>. To do this we change the Loop method.</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb671-1" title="1">...</a>
<a class="sourceLine" id="cb671-2" title="2">   <span class="cf">if</span> (fChain == <span class="dv">0</span>) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb671-3" title="3">   <span class="dt">Int_t</span> nentries = <span class="dt">Int_t</span>(fChain-&gt;GetEntries());</a>
<a class="sourceLine" id="cb671-4" title="4">   TH1F *myHisto  = <span class="kw">new</span> TH1F(<span class="st">"myHisto"</span>,<span class="st">"fPx"</span>, <span class="dv">100</span>, -<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb671-5" title="5">   TH1F *smallHisto = <span class="kw">new</span> TH1F(<span class="st">"small"</span>,<span class="st">"fPx"</span>, <span class="dv">100</span>, -<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb671-6" title="6">...</a></code></pre></div>
<p>In the for-loop, we need to add another for-loop to go over all the 
tracks. In the outer for-loop, we get the entry and the number of 
tracks. In the inner for-loop, we fill the large histogram (<code>myHisto</code>) with all tracks and the small histogram (<code>smallHisto</code>) with the track if it is in the first 100.</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb672-1" title="1">...</a>
<a class="sourceLine" id="cb672-2" title="2">   <span class="cf">for</span> (<span class="dt">Int_t</span> jentry=<span class="dv">0</span>; jentry&lt;nentries;jentry++) {</a>
<a class="sourceLine" id="cb672-3" title="3">      GetEntry(jentry);</a>
<a class="sourceLine" id="cb672-4" title="4">      <span class="cf">for</span> (<span class="dt">Int_t</span> j = <span class="dv">0</span>; j &lt; <span class="dv">100</span>; j++) {</a>
<a class="sourceLine" id="cb672-5" title="5">         myHisto-&gt;Fill(fTracks_fPx[j]);</a>
<a class="sourceLine" id="cb672-6" title="6">         <span class="cf">if</span> (j &lt; <span class="dv">100</span>) {</a>
<a class="sourceLine" id="cb672-7" title="7">            smallHisto-&gt;Fill(fTracks_fPx[j]);</a>
<a class="sourceLine" id="cb672-8" title="8">         }</a>
<a class="sourceLine" id="cb672-9" title="9">      }</a>
<a class="sourceLine" id="cb672-10" title="10">   }</a>
<a class="sourceLine" id="cb672-11" title="11">...</a></code></pre></div>
<p>Outside of the for-loop, we draw both histograms on the same canvas.</p>
<div class="sourceCode" id="cb673"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb673-1" title="1">...</a>
<a class="sourceLine" id="cb673-2" title="2">   myHisto-&gt;Draw();</a>
<a class="sourceLine" id="cb673-3" title="3">   smallHisto-&gt;Draw(<span class="st">"Same"</span>);</a>
<a class="sourceLine" id="cb673-4" title="4">...</a></code></pre></div>
<p>Save these changes to <code>MyClass.C</code> and start a fresh root session. We will now load <code>MyClass</code> and experiment with its methods.</p>
<h3 id="loading-myclass"><span class="header-section-number">12.21.5</span> Loading MyClass</h3>
<p>The first step is to load the library and the class file. Then we can instantiate a <code>MyClass</code> object.</p>
<div class="sourceCode" id="cb674"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb674-1" title="1">root[] .L libEvent.so</a>
<a class="sourceLine" id="cb674-2" title="2">root[] .L MyClass.C</a>
<a class="sourceLine" id="cb674-3" title="3">root[] MyClass m</a></code></pre></div>
<p>Now we can get a specific entry and populate the event leaf. In the 
code snipped below, we get entry 0, and print the number of tracks 
(594). Then we get entry 1 and print the number of tracks (597).</p>
<div class="sourceCode" id="cb675"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb675-1" title="1">root[] m.GetEntry(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb675-2" title="2">(<span class="dt">int</span>)<span class="dv">57503</span></a>
<a class="sourceLine" id="cb675-3" title="3">root[] m.fNtrack()</a>
<a class="sourceLine" id="cb675-4" title="4">(<span class="dt">Int_t</span>)<span class="dv">594</span></a>
<a class="sourceLine" id="cb675-5" title="5">root[] m.GetEntry(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb675-6" title="6">(<span class="dt">int</span>)<span class="dv">48045</span></a>
<a class="sourceLine" id="cb675-7" title="7">root[] m.fNtrack()</a>
<a class="sourceLine" id="cb675-8" title="8">(<span class="dt">Int_t</span>)<span class="dv">597</span></a></code></pre></div>
<p>Now we can call the <code>Loop</code> method, which will build and display the two histograms.</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb676-1" title="1">root[] m.Loop()</a></code></pre></div>
<p>You should now see a canvas that looks like this.</p>
<p><img src="ROOTUsersGuide_files/03000106.png"></p>
<p>To conclude the discussion on <code>MakeClass</code> let us lists the steps that got us here.</p>
<ul>
<li><p>Call <code>TTree::MakeClass</code>, which automatically creates a class to loop over the tree.</p></li>
<li><p>Modify the <code>MyClass::Loop()</code> method in <code>MyClass.C</code> to fit your task.</p></li>
<li><p>Load and instantiate <code>MyClass</code>, and run <code>MyClass::Loop()</code>.</p></li>
</ul>
<h2 id="using-ttreemakeselector"><span class="header-section-number">12.22</span> Using TTree::MakeSelector</h2>
<p></p>
<p>With a <strong><code>TTree</code></strong> we can make a selector and
 use it to process a limited set of entries. This is especially 
important in a parallel processing configuration where the analysis is 
distributed over several processors and we can specify which entries to 
send to each processor. The <code>TTree::Process</code> method is used to specify the selector and the entries. Before we can use <strong><code>TTree::Process</code></strong> we need to make a selector. We can call the <code>TTree::MakeSelector</code> method. It creates two files similar to <code>TTree::MakeClass</code>.</p>
<p>In the resulting files is a class that is a descendent of <strong><code>TSelector</code></strong> and implements the following methods:</p>
<ul>
<li><p><code>TSelector::Begin()</code> <code>-</code> this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.</p></li>
<li><p><code>TSelector::Notify()</code> <code>-</code> it is called at the first entry of a new tree in a chain.</p></li>
<li><p><code>TSelector::Process()</code> <code>-</code> it is called to 
process an event. It is the user’s responsibility to read the 
corresponding entry in memory (may be just a partial read). Once the 
entry is in memory one can apply a selection and if the event is 
selected histograms can be filled. Processing stops when this function 
returns <code>kFALSE</code>. It combines the methods <strong><code>TSelector::ProcessCut()</code> and <code>TSelector</code></strong><code>::ProcessFill()</code>
 in one, avoiding the necessity to maintain the state in the class to 
communicate between these two functions. It reduces the information that
 needs to be shared between them and promotes a more granular data 
access by reading branches as they are needed.</p></li>
<li><p><code>TSelector::Terminate() -</code> it is called at the end of a loop on a <strong><code>TTree</code></strong>. This is a convenient place to draw and fit your histograms.</p></li>
<li><p><code>TSelector::Version()</code> <code>-</code> this function provides backward compatibility for old versions and support for the future upgrades.</p></li>
<li><p>The <strong><code>TSelector</code></strong>, unlike the resulting class from <code>MakeClass</code>, separates the processing into a <code>ProcessCut()</code> and <code>ProcessFill()</code>, so we can limit reading of branches to the ones we need.</p></li>
<li><p>When a selector is used with a <strong><code>TChain</code></strong> in methods <code>Process()</code>, <code>ProcessFill()</code>, <code>ProcessCut()</code>, you must use the pointer to the current <strong><code>TTree</code></strong> to call the method <code>GetEntry(entry)</code>. The parameter <code>entry</code> is always the local entry number in the current tree. Assuming that <code>fChain</code> is the pointer to the <strong><code>TChain</code></strong> being processed, use</p></li>
</ul>
<div class="sourceCode" id="cb677"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb677-1" title="1">   fChain-&gt;GetTree()-&gt;GetEntry(entry);</a></code></pre></div>
<p>To create a selector call:</p>
<div class="sourceCode" id="cb678"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb678-1" title="1">root[] T-&gt;MakeSelector(<span class="st">"MySelector"</span>);</a></code></pre></div>
<p>Where <code>T</code> is the <strong><code>TTree</code></strong> and <code>MySelector</code> is the name of created class and the name of the <code>.h</code> and <code>.C</code> files. The resulting <strong><code>TSelector</code></strong> is the argument to <strong><code>TTree::Process</code></strong>. The argument can be the file name or a pointer to the selector object.</p>
<div class="sourceCode" id="cb679"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb679-1" title="1">root[] T-&gt;Process(<span class="st">"MySelector.C"</span>,<span class="st">""</span>,<span class="dv">1000</span>,<span class="dv">100</span>);</a></code></pre></div>
<p>This call will interpret the class defined in <code>MySelector.C</code> and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use <code>ACLiC</code>.</p>
<div class="sourceCode" id="cb680"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb680-1" title="1">root[] T-&gt;Process(<span class="st">"MySelector.C++"</span>,<span class="st">""</span>,<span class="dv">1000</span>,<span class="dv">100</span>);</a></code></pre></div>
<p>When appending a “++”, the class will be compiled and dynamically loaded.</p>
<div class="sourceCode" id="cb681"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb681-1" title="1">root[] T-&gt;Process(<span class="st">"MySelector.C+"</span>,<span class="st">""</span>,<span class="dv">1000</span>,<span class="dv">100</span>);</a></code></pre></div>
<p>When appending a “+”, the class will also be compiled and dynamically
 loaded. When it is called again, it recompiles only if the macro (<code>MySelector.C</code>)
 has changed since it was compiled last. If not, it loads the existing 
library. The next example shows how to create a selector with a pointer:</p>
<div class="sourceCode" id="cb682"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb682-1" title="1">MySelector *selector = (MySelector *)TSelector::GetSelector(<span class="st">"MySelector.C+"</span>);</a>
<a class="sourceLine" id="cb682-2" title="2">T-&gt;Process(selector);</a></code></pre></div>
<p><code>Using this form, you can do things like:</code></p>
<div class="sourceCode" id="cb683"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb683-1" title="1">   selector-&gt;public_attribute1 = init_value;</a>
<a class="sourceLine" id="cb683-2" title="2">   <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;limit; i++) {</a>
<a class="sourceLine" id="cb683-3" title="3">      T-&gt;Process(selector);</a>
<a class="sourceLine" id="cb683-4" title="4">      selector-&gt;public_attribute1 =</a>
<a class="sourceLine" id="cb683-5" title="5">         function(selector-&gt;public_attribute2);</a>
<a class="sourceLine" id="cb683-6" title="6">   }</a></code></pre></div>
<p><code>TTree::Process()</code> is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.</p>
<h3 id="performance-benchmarks"><span class="header-section-number">12.22.1</span> Performance Benchmarks</h3>
<p></p>
<p>The program <code>$ROOTSYS/test/bench.cxx</code> compares the I/O performance of STL vectors to the ROOT native <strong><code>TClonesArray</code></strong><code>s</code> collection class. It creates trees with and without compression for the following cases: <code>vector&lt;THit&gt;</code>, <code>vector&lt;THit*&gt;</code>, <code>TClonesArray(</code><strong><code>TObjHit</code></strong><code>)</code> not split <code>TClonesArray(</code><strong><code>TObjHit</code></strong><code>)</code> split.</p>
<p>The next graphs show the two columns on the right which represent the split and non-split <strong><code>TClonesArray</code></strong>, are significantly lower than the vectors. The most significant difference is in reading a file without compression.</p>
<p>The file size with compression, write times with and without 
compression and the read times with and without compression all favor 
the <strong><code>TClonesArray</code></strong>.</p>
<h2 id="impact-of-compression-on-io"><span class="header-section-number">12.23</span> Impact of Compression on I/O</h2>
<p>This benchmark illustrates the pros and cons of the compression 
option. We recommend using compression when the time spent in I/O is 
small compared to the total processing time. In this case, if the I/O 
operation is increased by a factor of 5 it is still a small percentage 
of the total time and it may very well save a factor of 10 on disk 
space. On the other hand if the time spend on I/O is large, compression 
may slow down the program’s performance. The standard test program <code>$ROOTSYS/test/Event</code> was used in various configurations with 400 events. The data file contains a <strong><code>TTree</code></strong>. The program was invoked with:</p>
<div class="sourceCode" id="cb684"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb684-1" title="1">Event <span class="dv">400</span> comp split</a></code></pre></div>
<ul>
<li>comp = 0 means: no compression at all.</li>
<li>comp = 1 means: compress everything if split = 0.</li>
<li>comp = 1 means: compress only the tree branches with integers if split = 1.</li>
<li>comp = 2 means: compress everything if split=1.</li>
<li>split = 0 : the full event is serialized into one single buffer.</li>
<li>split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a <strong><code>TClonesArray</code></strong>) has the data members of the Track class also split into individual buffers.</li>
</ul>
<p>These tests were run on Pentium III CPU with 650 MHz.</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 10%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 19%">
<col style="width: 19%">
</colgroup>
<tbody>
<tr class="odd">
<td>Event Parameters</td>
<td>File Size</td>
<td>Total Time to Write (MB/sec)</td>
<td>Effective Time to Write (MB/sec)</td>
<td>Total Time to Read All (MB/sec)</td>
<td>Total Time to Read Sample (MB/sec)</td>
</tr>
<tr class="even">
<td><p>Comp = 0</p>
<p>Split = 1</p></td>
<td>19.75 MB</td>
<td>6.84 s.(2.8 MB/s)</td>
<td>3.56 s.(5.4 MB/s)</td>
<td>0.79s.(24.2 MB/s)</td>
<td>0.79 s.(24.2 MB/s)</td>
</tr>
<tr class="odd">
<td><p>Comp = 1</p>
<p>Split = 1</p></td>
<td>17.73 MB</td>
<td>6.44 s.(3.0 MB/s)</td>
<td>4.02 s.(4.8 MB/s)</td>
<td>0.90 s.(21.3 MB/s)</td>
<td>0.90 s.(21.3 MB/s)</td>
</tr>
<tr class="even">
<td><p>Comp = 2</p>
<p>Split = 1</p></td>
<td>13.78 MB</td>
<td>11.34s.(1.7 MB/s)</td>
<td>9.51 s.(2.0 MB/s)</td>
<td>2.17 s.(8.8 MB/s)</td>
<td>2.17 s.(8.8 MB/s)</td>
</tr>
</tbody>
</table>
<p>The <strong>Total Time</strong> is the real time in seconds to run the program. <strong>Effective time</strong> is the real time minus the time spent in non I/O operations (essentially the random number generator). The program <code>Event</code>
 generates in average 600 tracks per event. Each track has 17 data 
members. The read benchmark runs in the interactive version of ROOT. The
 ‘Total Time to Read All’ is the real time reported by the execution of 
the script <code>&amp;ROOTSYS/test/eventa</code>.</p>
<p>We did not correct this time for the overhead coming from the interpreter itself. The <strong>Total time to read sample</strong> is the execution time of the script <code>$ROOTSYS/test/eventb</code>.
 This script loops on all events. For each event, the branch containing 
the number of tracks is read. In case the number of tracks is less than 
585, the full event is read in memory. This test is obviously not 
possible in non-split mode. In non-split mode, the full event must be 
read in memory. The times reported in the table correspond to complete 
I/O operations necessary to deal with <strong>machine independent binary files</strong>. On <strong>Linux</strong>,
 this also includes byte-swapping operations. The ROOT file allows for 
direct access to any event in the file and direct access to any part of 
an event when split=1.</p>
<p>Note also that the uncompressed file generated with split=0 is 48.7 
Mbytes and only 47.17 Mbytes for the option split=1. The difference in 
size is due to the object identification mechanism overhead when the 
event is written to a single buffer. This overhead does not exist in 
split mode because the branch buffers are optimized for homogeneous data
 types. You can run the test programs on your architecture. The program <code>Event</code> will report the write performance. You can measure the read performance by executing the scripts <code>eventa</code> and <code>eventb</code>. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).</p>
<h2 id="chains"><span class="header-section-number">12.24</span> Chains</h2>
<p></p>
<p>A <strong><code>TChain</code></strong> object is a list of ROOT files containing the same tree. As an example, assume we have three files called <code>file1.root, file2.root, file3.root</code>. Each file contains one tree called “<code>T</code>”. We can create a chain with the following statements:</p>
<div class="sourceCode" id="cb685"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb685-1" title="1">   TChain chain(<span class="st">"T"</span>);   <span class="co">// name of the tree is the argument</span></a>
<a class="sourceLine" id="cb685-2" title="2">   chain.Add(<span class="st">"file1.root"</span>);</a>
<a class="sourceLine" id="cb685-3" title="3">   chain.Add(<span class="st">"file2.root"</span>);</a>
<a class="sourceLine" id="cb685-4" title="4">   chain.Add(<span class="st">"file3.root"</span>);</a></code></pre></div>
<p>The name of the <strong><code>TChain</code></strong> will be the same as the name of the tree; in this case it will be <code>"T". Note that two</code>objects
 can have the same name as long as they are not histograms in the same 
directory, because there, the histogram names are used to build a hash 
table. The class <strong><code>TChain</code></strong> is derived from the class <strong><code>TTree</code></strong>. For example, to generate a histogram corresponding to the attribute “<code>x</code>” in tree “<code>T</code>” by processing sequentially the three files of this chain, we can use the <code>TChain::Draw</code> method.</p>
<div class="sourceCode" id="cb686"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb686-1" title="1">   chain.Draw(<span class="st">"x"</span>);</a></code></pre></div>
<p>When using a <strong><code>TChain</code></strong>, the branch address(es) must be set with:</p>
<div class="sourceCode" id="cb687"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb687-1" title="1">   chain.SetBranchAdress(branchname,...)  <span class="co">// use this for TChain</span></a></code></pre></div>
<p>rather than:</p>
<div class="sourceCode" id="cb688"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb688-1" title="1">   branch-&gt;SetAddress(...);  <span class="co">// this will not work</span></a></code></pre></div>
<p>The second form returns the pointer to the branch of the current <strong><code>TTree</code></strong> in the chain, typically the first one. The information is lost when the next <strong><code>TTree</code></strong>
 is loaded. The following statements illustrate how to set the address 
of the object to be read and how to loop on all events of all files of 
the chain.</p>
<div class="sourceCode" id="cb689"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb689-1" title="1">{</a>
<a class="sourceLine" id="cb689-2" title="2">   TChain chain(<span class="st">"T"</span>); <span class="co">// create the chain with tree "T"</span></a>
<a class="sourceLine" id="cb689-3" title="3">   chain.Add(<span class="st">"file1.root"</span>); <span class="co">// add the files</span></a>
<a class="sourceLine" id="cb689-4" title="4">   chain.Add(<span class="st">"file2.root"</span>);</a>
<a class="sourceLine" id="cb689-5" title="5">   chain.Add(<span class="st">"file3.root"</span>);</a>
<a class="sourceLine" id="cb689-6" title="6">   TH1F *hnseg = <span class="kw">new</span> TH1F(<span class="st">"hnseg"</span>,</a>
<a class="sourceLine" id="cb689-7" title="7">                          <span class="st">"Number of segments for selected tracks"</span>,</a>
<a class="sourceLine" id="cb689-8" title="8">                          <span class="dv">5000</span>,<span class="dv">0</span>,<span class="dv">5000</span>);</a>
<a class="sourceLine" id="cb689-9" title="9">   <span class="co">// create an object before setting the branch address</span></a>
<a class="sourceLine" id="cb689-10" title="10">   Event *event = <span class="kw">new</span> Event();</a>
<a class="sourceLine" id="cb689-11" title="11">   <span class="co">// Specify the address where to read the event object</span></a>
<a class="sourceLine" id="cb689-12" title="12">   chain.SetBranchAddress(<span class="st">"event"</span>, &amp;event);</a>
<a class="sourceLine" id="cb689-13" title="13"></a>
<a class="sourceLine" id="cb689-14" title="14">   <span class="co">// Start main loop on all events In case you want to read only a few</span></a>
<a class="sourceLine" id="cb689-15" title="15">   <span class="co">// branches, use TChain::SetBranchStatus to activate a branch.</span></a>
<a class="sourceLine" id="cb689-16" title="16">   <span class="dt">Int_t</span> nevent = chain.GetEntries();</a>
<a class="sourceLine" id="cb689-17" title="17">   <span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>;i&lt;nevent;i++) {</a>
<a class="sourceLine" id="cb689-18" title="18">      <span class="co">// read complete accepted event in memory</span></a>
<a class="sourceLine" id="cb689-19" title="19">      chain.GetEvent(i);</a>
<a class="sourceLine" id="cb689-20" title="20">      <span class="co">// Fill histogram with number of segments</span></a>
<a class="sourceLine" id="cb689-21" title="21">      hnseg-&gt;Fill(event-&gt;GetNseg());</a>
<a class="sourceLine" id="cb689-22" title="22">   }</a>
<a class="sourceLine" id="cb689-23" title="23">   <span class="co">// Draw the histogram</span></a>
<a class="sourceLine" id="cb689-24" title="24">   hnseg-&gt;Draw();</a>
<a class="sourceLine" id="cb689-25" title="25">}</a></code></pre></div>
<h3 id="tchainaddfriend"><span class="header-section-number">12.24.1</span> TChain::AddFriend</h3>
<p></p>
<p><code>A</code><strong><code>TChain</code></strong> has a list of friends similar to a tree (see <code>TTree::AddFriend)</code>. You can add a friend to a chain with the <code>TChain::AddFriend</code> method. With <code>TChain::GetListOfFriends</code> you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.</p>
<div class="sourceCode" id="cb690"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb690-1" title="1">   TChain ch(<span class="st">"t"</span>);    <span class="co">// a chain with 20 trees from 20 files</span></a>
<a class="sourceLine" id="cb690-2" title="2">   TChain ch1(<span class="st">"t1"</span>);</a>
<a class="sourceLine" id="cb690-3" title="3">   TChain ch2(<span class="st">"t2"</span>);</a>
<a class="sourceLine" id="cb690-4" title="4">   TChain ch3(<span class="st">"t3"</span>);</a></code></pre></div>
<p>Now we can add the friends to the first chain.</p>
<div class="sourceCode" id="cb691"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb691-1" title="1">   ch.AddFriend(<span class="st">"t1"</span>);</a>
<a class="sourceLine" id="cb691-2" title="2">   ch.AddFriend(<span class="st">"t2"</span>);</a>
<a class="sourceLine" id="cb691-3" title="3">   ch.AddFriend(<span class="st">"t3"</span>);</a></code></pre></div>
<p>The parameter is the name of friend chain (the name of a chain is 
always the name of the tree from which it was created). The original 
chain has access to all variables in its friends. We can use the <code>TChain::Draw</code> method as if the values in the friends were in the original chain. To specify the chain to use in the <code>Draw</code> method, use:</p>
<div class="sourceCode" id="cb692"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb692-1" title="1">&lt;chainname&gt;.&lt;branchname&gt;.&lt;varname&gt;</a></code></pre></div>
<p>If the variable name is enough to identify uniquely the variable, you
 can leave out the chain and/or branch name. For example, this generates
 a 3-d scatter plot of variable “<code>var</code>” in the <code>TChain ch</code> versus variable <code>v1 in</code><strong><code>TChain t1</code> versus variable <code>v2</code> in <code>TChain</code></strong><code>t2</code>.</p>
<div class="sourceCode" id="cb693"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb693-1" title="1">   ch.Draw(<span class="st">"var:t1.v1:t2.v2"</span>);</a></code></pre></div>
<p>When a <code>TChain::Draw</code> is executed, an automatic call to <code>TTree::AddFriend</code>connects the trees in the chain. When a chain is deleted, its friend elements are also deleted.</p>
<p><img src="ROOTUsersGuide_files/02000108.jpg"></p>
<p>The number of entries in the friend must be equal or greater to the 
number of entries of the original chain. If the friend has fewer entries
 a warning is given and the resulting histogram will have missing 
entries. For additional information see <code>TTree::AddFriends()</code>. A full example of a tree and friends is in Example #3 <code>($ROOTSYS/tutorials/tree/tree3.C</code>) in the Trees section above.</p>
<h1 id="math-libraries-in-root"><span class="header-section-number">13</span> Math Libraries in ROOT</h1>
<p>The aim of Math libraries in ROOT is to provide and to support a 
coherent set of mathematical and statistical functions. The latest 
developments have been concentrated in providing first versions of the <code>MathCore</code> and <code>MathMore</code> libraries, included in ROOT v5.08. Other recent developments include the new version of <code>MINUIT</code>,
 which has been re-designed and re-implemented in the C++ language. It 
is integrated in ROOT. In addition, an optimized package for describing 
small matrices and vector with fixed sizes and their operation has been 
developed (<code>SMatrix</code>). The structure is shown in the following picture.</p>
<figure>
<img src="ROOTUsersGuide_files/02000109.jpg" alt="Math libraries and packages"><figcaption>Math libraries and packages</figcaption>
</figure>
<h2 id="mathcore-library"><span class="header-section-number">13.1</span> MathCore Library</h2>
<p><code>MathCore</code> provides a collection of functions and C++ 
classes for numerical computing. This library includes only the basic 
mathematical functions and algorithms and not all the functionality 
required by the physics community. A more advanced mathematical 
functionality is provided by the <code>MathMore</code> library. The current set of included classes, which are provided in the <code>ROOT::Math</code> namespace are:</p>
<ul>
<li><p>Basic special functions like the gamma, beta and error function.</p></li>
<li><p>Mathematical functions used in statistics, such as the 
probability density functions and the cumulative distributions functions
 (lower and upper integral of the pdf’s).</p></li>
<li><p>Generic function classes and interfaces for evaluating one-dimensional (<code>ROOT::Math::IBaseFunctiononeDim</code>) and multi-dimensional functions (<code>ROOT::Math::IBaseFunctionMultiDim</code>) and parametric function interfaces for evaluating functions with parameters in one (<code>ROOT::Math::IParametricFunctionOneDim</code>) or multi dimensions (<code>ROOT::Math::IParametricFunctionMultiDim</code>). A set of user convenient wrapper classes, such as <code>ROOT::Math::Functor</code> is provided for wrapping user-classes in the needed interface, required to use the algorithms of the <code>ROOT</code> Mathematical libraries.</p></li>
<li>Numerical algorithms interfaces and in same cases default implementations for:
<ul>
<li>numerical integration;</li>
<li>numerical differentiation;</li>
<li>one dimensional root-finding;</li>
<li>one-dimensional minimization;</li>
<li>multi-dimensional minimization (only the <code>ROOT::Math::Minimizer</code> interface)</li>
</ul></li>
<li><p>Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace <code>ROOT::Fit</code>. They are describing separately in the Fitting chapter.</p></li>
</ul>
<p>The sets described above is independent of ROOT libraries and can be built as a set of standalone classes. In addition <code>MathCore</code> provides the following classes (depending on ROOT <em>libCore</em> library):</p>
<ul>
<li><code>TMath</code>: namespace with mathematical functions and basic function algorithms.</li>
<li><code>TComplex</code>: class for complex numbers.</li>
<li>Random classes: the base class <code>TRandom</code> and the derived classes <code>TRandom1</code>, <code>TRandom2</code> and <code>TRandom3</code>, implementing the pseudo-random number generators.</li>
</ul>
<p>A detailed description for all <code>MathCore</code> classes is available in the Doxygen <a href="https://root.cern/root/htmldoc/guides/users-guide/online%20reference%20documentation">online reference documentation</a>.</p>
<h2 id="mathmore-library"><span class="header-section-number">13.2</span> MathMore Library</h2>
<p>The <code>MathMore</code> library provides an advanced collection of 
functions and C++ classes for numerical computing. This is an extension 
of the functionality provided by the <code>MathCore</code> library. The <code>MathMore</code> library is implemented wrapping in C++ the GNU Scientific Library (GSL). The current set, provided in the <code>ROOT::Math</code> namespace include:</p>
<ul>
<li><p>Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. )</p></li>
<li><p>Additional mathematical functions used in statistics such as 
probability density functions, cumulative distributions functions and 
their inverse which are not in <code>MathCore</code> but present in the <code>GSL</code> library.</p></li>
<li><p>Numerical algorithms for one dimensional functions based on implementation of the GNU Scientific Library (GSL):</p></li>
<li><p>Numerical integration classes implementing the interface <strong><code>ROOT::Math::Integrator</code></strong> which is based on the Adaptive integration algorithms of QUADPACK</p></li>
<li><p>Numerical differentiation via <strong><code>ROOT::Math::GSLDerivator</code></strong></p></li>
<li><p>Root finder implementing the <strong><code>ROOT::Math::RootFinder</code></strong> interface, using different solver algorithms from GSL</p></li>
<li><p>one-dimensional Minimization implementing the interface<strong><code>ROOT::Math::IMinimizer1D</code></strong></p></li>
<li><p>Interpolation via <strong><code>ROOT::Math::Interpolation</code></strong>. All the GSL interpolation types are supported</p></li>
<li><p>Function approximation based on Chebyshev polynomials via the class <strong><code>ROOT::Math::Chebyshev</code></strong></p></li>
<li><p>Random number generators and distributions based on GSL using the <code>ROOT::Math::Random&lt;Engine_type&gt;</code> class.</p></li>
<li><p>Polynomial evaluation and root solvers</p></li>
</ul>
<p>The mathematical functions are implemented as a set of free functions in the namespace <strong><code>ROOT::Math</code></strong>. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension <a href="https://root.cern/root/htmldoc/guides/users-guide/proposal%20document">proposal document</a>).The <code>MathMore</code> library is implemented wrapping in C++ the GNU Scientific Library ( <gsl>). Building <code>MathMore</code> requires a version of GSL larger or equal 1.8. The source code of <code>MathMore</code> is distributed under the GNU General Public License.</gsl></p>
<p><code>MathMore</code> (and its ROOT Cling dictionary) can be built 
within ROOT whenever a GSL library is found in the system. The GSL 
library and header file location can be specified in the ROOT configure 
script, by doing:</p>
<pre><code>./configure --with-gsl-incdir=... --with-gsl-libdir=...</code></pre>
<p><code>MathMore</code> can be built also a stand-alone library 
(without requiring ROOT) downloding the tar file from the Web at this 
link. In this case the library will not contain the dictionary 
information and therefore cannot be used interactively</p>
<p>More information on the classes and functions present in <code>MathMore</code> is available in the <a href="https://root.cern/root/htmldoc/guides/users-guide/online%20reference%20documentation">online reference documentation</a>.</p>
<h2 id="tmath"><span class="header-section-number">13.3</span> TMath</h2>
<p>In the namespace, <strong><code>TMath</code></strong>, a collection of free functions is provided for the following functionality:</p>
<ul>
<li><p>numerical constants (like <code>pi</code>, <code>e</code>, <code>h</code>, etc.);</p></li>
<li><p>trigonometric and elementary mathematical functions;</p></li>
<li><p>functions to work with arrays and collections (e.g.&nbsp;functions to find <code>min</code> and <code>max</code> of arrays);</p></li>
<li><p>statistic functions to work on array of data (e.g.&nbsp;mean and <code>RMS</code> of arrays);</p></li>
<li><p>algorithms for binary search/hashing sorting;</p></li>
<li><p>special mathematical functions like <code>Bessel</code>, <code>Erf</code>, <code>Gamma</code>, etc.;</p></li>
<li><p>statistical functions, like common probability and cumulative (quantile) distributions</p></li>
<li><p>geometrical functions.</p></li>
</ul>
<p>For more details, see the reference documentation of <strong><code>TMath</code></strong> at <a href="http://root.cern.ch/root/htmldoc/TMath.html" class="uri">http://root.cern.ch/root/htmldoc/TMath.html</a>.</p>
<h3 id="numerical-constants"><span class="header-section-number">13.3.1</span> Numerical Constants</h3>
<p><code>TMath</code> offers a wide range of constants in the form of 
inline functions. Notice that they are not defined as C/C++ preprocessor
 macros. This set of functions includes one or more definitions for the 
following constants:</p>
<ul>
<li>Pi.</li>
<li>Base of natural logarithm.</li>
<li>Velocity of light.</li>
<li>Gravitational constant (G).</li>
<li>Standard acceleration of gravity (g).</li>
<li>Standard acceleration of Gravity.</li>
<li>Plank’s contant.</li>
<li>Boltzmann’s and Steffan-Boltzmann’s constants.</li>
<li>Avogadro’s number.</li>
<li>Universal gas constant.</li>
<li>Molecular weight of dry air.</li>
<li>Dry air gas constant.</li>
<li>Euler-Mascheroni Constant.</li>
<li>Elementary charge.</li>
</ul>
<h3 id="elementary-functions"><span class="header-section-number">13.3.2</span> Elementary Functions</h3>
<p>A set of miscellaneous elementary mathematical functions is provided 
along with a set of basic trigonometrical functions. Some of this 
functions refer to basic mathematical functions like the square root, 
the power to a number of the calculus of a logarithm, while others are 
used for number treatment, like rounding.</p>
<p>Although there are some functions that are not in the standard C math library (like <code>Factorial</code>),
 most of the functionality offered here is just a wrapper of the first 
ones. Nevertheless, some of the them also offer some security checks or a
 better precision, like the trigonometrical functions <code>ASin(x)</code>, <code>ACos(x)</code> or <code>ATan(x)</code>.</p>
<div class="sourceCode" id="cb695"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb695-1" title="1"> <span class="co">// Generate a vector with 10 random numbers</span></a>
<a class="sourceLine" id="cb695-2" title="2"> vector&lt;<span class="dt">double</span>&gt; v(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb695-3" title="3"> <span class="bu">std::</span>generate(v.begin(), v.end(), rand);</a>
<a class="sourceLine" id="cb695-4" title="4"></a>
<a class="sourceLine" id="cb695-5" title="5"> <span class="co">// Find the minimum value of the vector (iterator version)</span></a>
<a class="sourceLine" id="cb695-6" title="6"> vector&lt;<span class="dt">double</span>&gt;::iterator it;</a>
<a class="sourceLine" id="cb695-7" title="7"> it = TMath::LocMin(v.begin(), v.end());</a>
<a class="sourceLine" id="cb695-8" title="8"> <span class="bu">std::</span>cout &lt;&lt; *it &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb695-9" title="9"></a>
<a class="sourceLine" id="cb695-10" title="10"> <span class="co">// The same with the old-style version</span></a>
<a class="sourceLine" id="cb695-11" title="11"> <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb695-12" title="12"> i = TMath::LocMin(<span class="dv">10</span>, &amp;v[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb695-13" title="13"> <span class="bu">std::</span>cout &lt;&lt; v[i] &lt;&lt; <span class="bu">std::</span>endl;</a></code></pre></div>
<p>Another example of these functions can be found in $ROOTSYS/tutorials/permute.C.</p>
<h3 id="statistic-functions-operating-on-arrays."><span class="header-section-number">13.3.3</span> Statistic Functions Operating on Arrays.</h3>
<p>This set of functions processes arrays to calculate:</p>
<ul>
<li>Mean.</li>
<li>Median.</li>
<li>Geometrical mean.</li>
<li>Sample Standard Deviation (<em>RMS</em>).</li>
<li>The kth smallest element.</li>
</ul>
<p>These functions, as the array algorithms, have two different 
interfaces. An old-style one where the size of the array is passed as a 
first argument followed by a pointer to the array itself and a modern 
C++-like interface that receives two iterators to it.</p>
<div class="sourceCode" id="cb696"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb696-1" title="1"> <span class="co">// Size of the array</span></a>
<a class="sourceLine" id="cb696-2" title="2"> <span class="at">const</span> <span class="dt">int</span> n = <span class="dv">100</span>;</a>
<a class="sourceLine" id="cb696-3" title="3"></a>
<a class="sourceLine" id="cb696-4" title="4"> <span class="co">// Vector v with random values</span></a>
<a class="sourceLine" id="cb696-5" title="5"> vector&lt;<span class="dt">double</span>&gt; v(n);</a>
<a class="sourceLine" id="cb696-6" title="6"> <span class="bu">std::</span>generate(v.begin(), v.end(), rand);</a>
<a class="sourceLine" id="cb696-7" title="7"></a>
<a class="sourceLine" id="cb696-8" title="8"> <span class="co">// Weight vector w</span></a>
<a class="sourceLine" id="cb696-9" title="9"> vector&lt;<span class="dt">double</span>&gt; w(n);</a>
<a class="sourceLine" id="cb696-10" title="10"> <span class="bu">std::</span>fill(w.begin(), w.end, <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb696-11" title="11"></a>
<a class="sourceLine" id="cb696-12" title="12"> <span class="dt">double</span> mean;</a>
<a class="sourceLine" id="cb696-13" title="13"></a>
<a class="sourceLine" id="cb696-14" title="14"> <span class="co">// Calculate the mean of the vector</span></a>
<a class="sourceLine" id="cb696-15" title="15"> <span class="co">// with iterators</span></a>
<a class="sourceLine" id="cb696-16" title="16"> mean = TMath::Mean(v.begin(), v.end());</a>
<a class="sourceLine" id="cb696-17" title="17"></a>
<a class="sourceLine" id="cb696-18" title="18"> <span class="co">// old-style</span></a>
<a class="sourceLine" id="cb696-19" title="19"> mean = TMath::Mean(n, &amp;v[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb696-20" title="20"></a>
<a class="sourceLine" id="cb696-21" title="21"> <span class="co">// Calculate the mean with a weight vector</span></a>
<a class="sourceLine" id="cb696-22" title="22"> <span class="co">// with iterators</span></a>
<a class="sourceLine" id="cb696-23" title="23"> mean = TMath::Mean(v.begin(), v.end(), w.begin());</a>
<a class="sourceLine" id="cb696-24" title="24"></a>
<a class="sourceLine" id="cb696-25" title="25"> <span class="co">// old-style</span></a>
<a class="sourceLine" id="cb696-26" title="26"> mean = TMath::Mean(n, &amp;v[<span class="dv">0</span>], &amp;w[<span class="dv">0</span>]);</a></code></pre></div>
<h3 id="special-and-statistical-functions."><span class="header-section-number">13.3.4</span> Special and Statistical Functions.</h3>
<p><code>TMath</code> also provides special functions like Bessel, Error
 functions, Gamma or similar plus statistical mathematical functions, 
including probability density functions, cumulative distribution and 
their inverse.</p>
<p>The majority of the special functions and the statistical distributions are provided also as free functions in the <code>ROOT::Math</code> namespace. See one of the next paragraph for the complete description of the functions provided in <code>ROOT::Math</code>. The user is encourage to use those versions of the algorithms rather than the ones in TMath.</p>
<p>Functions not present in <code>ROOT::Math</code> and provided only by <code>TMath</code> are:</p>
<ul>
<li>Special functions:
<ul>
<li>DiLogarithm</li>
<li>Struve</li>
</ul></li>
<li>Statistical functions:
<ul>
<li>KolmogorovProb</li>
<li>Voigt function</li>
<li>LaplaceDist</li>
<li>Vavilov</li>
</ul></li>
</ul>
<p>The example tutorial <code>GammaFun.C</code> and <code>mathBeta.C</code> in <code>$ROOTSYS/tutorials</code> shows an example of use of the <code>ROOT::Math</code> special functions</p>
<h2 id="random-numbers"><span class="header-section-number">13.4</span> Random Numbers</h2>
<p>In ROOT pseudo-random numbers can be generated using the <strong><code>TRandom</code></strong> classes. 4 different types exist: <strong><code>TRandom</code></strong>, <strong><code>TRandom1</code></strong>, <strong><code>TRandom2</code></strong> and <strong><code>TRandom3</code></strong>. All they implement a different type of random generators. <strong><code>TRandom</code></strong>
 is the base class used by others. It implements methods for generating 
random numbers according to pre-defined distributions, such as Gaussian 
or Poisson.</p>
<h3 id="trandom"><span class="header-section-number">13.4.1</span> TRandom</h3>
<p>Pseudo-random numbers are generated using a linear congruential random generator. The multipliers used are the same of the BSD <code>rand()</code> random generator. Its sequence is:</p>
<p><span class="math inline">\(x_{n+1} = (ax_n + c) mod m\)</span> with <span class="math inline">\(a =1103515245\)</span>, <span class="math inline">\(c = 12345\)</span> and <span class="math inline">\(m =2^{31}\)</span>.</p>
<p>This type of generator uses a state of only a 32 bit integer and it has a very short period, 2<sup>31</sup>,about 10<sup>9</sup>,
 which can be exhausted in just few seconds. The quality of this 
generator is therefore BAD and it is strongly recommended to NOT use for
 any statistical study.</p>
<h3 id="trandom1"><span class="header-section-number">13.4.2</span> TRandom1</h3>
<p>This random number generator is based on the Ranlux engine, developed
 by M. Lüsher and implemented in Fortran by F. James. This engine has 
mathematically proven random proprieties and a long period of about 10<sup>171</sup>. Various luxury levels are provided <code>(1,2,3,4)</code>
 and can be specified by the user in the constructor. Higher the level, 
better random properties are obtained at a price of longer CPU time for 
generating a random number. The level 3 is the default, where any 
theoretical possible correlation has very small chance of being 
detected. This generator uses a state of 24 32-bits words. Its main 
disadvantage is that is much slower than the others (see timing table). 
For more information on the generator see the following article:</p>
<ul>
<li>F. James, “RANLUX: A Fortran implementation of the high quality 
pseudo-random number generator of Lüscher”, Computer Physics 
Communication, 79 (1994) 111.</li>
</ul>
<h3 id="trandom2"><span class="header-section-number">13.4.3</span> TRandom2</h3>
<p>This generator is based on the maximally equi-distributed combined 
Tausworthe generator by L’Ecuyer. It uses only 3 32-bits words for the 
state and it has a period of about 10<sup>26</sup>. It is fast and given
 its small states, it is recommended for applications, which require a 
very small random number size. For more information on the generator see
 the following article:</p>
<ul>
<li>P. L’Ecuyer, “Maximally Equi-distributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203-213.</li>
</ul>
<h3 id="trandom3"><span class="header-section-number">13.4.4</span> TRandom3</h3>
<p>This is based on the Mersenne and Twister pseudo-random number 
generator, developed in 1997 by Makoto Matsumoto and Takuji Nishimura. 
The newer implementation is used, referred in the literature as MT19937.
 It is a very fast and very high quality generator with a very long 
period of 10<sup>6000</sup>. The disadvantage of this generator is that 
it uses a state of 624 words. For more information on the generator see 
the following article:</p>
<ul>
<li>M. M. Matsumoto and T. Nishimura, “Mersenne twister: A 
623-dimensionally equi-distributed uniform pseudorandom number 
generator”, ACM Trans. on Modeling and Computer Simulations, 8, 1, 
(1998), 3-20.</li>
</ul>
<p><strong><code>TRandom3</code></strong> is the recommended random number generator, and it is used by default in ROOT using the global <strong><em><code>gRandom</code></em></strong> object (see chapter gRandom).</p>
<h3 id="seeding-the-generators"><span class="header-section-number">13.4.5</span> Seeding the Generators</h3>
<p>The seeds for the generators can be set in the constructor or by using the <code>SetSeed</code> method. When no value is given the generator default seed is used, like 4357 for <strong><code>TRandom3</code></strong>.
 In this case identical sequence will be generated every time the 
application is run. When the 0 value is used as seed, then a unique seed
 is generated using a <strong><code>TUUID</code></strong>, for <strong><code>TRandom1</code></strong>, <strong><code>TRandom2</code></strong> and <strong><code>TRandom3</code></strong>. For <strong><code>TRandom</code></strong>
 the seed is generated using only the machine clock, which has a 
resolution of about 1 sec.&nbsp;Therefore identical sequences will be 
generated if the elapsed time is less than a second.</p>
<h3 id="examples-of-using-the-generators"><span class="header-section-number">13.4.6</span> Examples of Using the Generators</h3>
<p>The method <code>Rndm()</code> is used for generating a pseudo-random number distributed between 0 and 1 as shown in the following example:</p>
<div class="sourceCode" id="cb697"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb697-1" title="1">   <span class="co">// use default seed</span></a>
<a class="sourceLine" id="cb697-2" title="2">   <span class="co">// (same random numbers will be generated each time)</span></a>
<a class="sourceLine" id="cb697-3" title="3">   TRandom3 r; <span class="co">// generate a number in interval ]0,1] (0 is excluded)</span></a>
<a class="sourceLine" id="cb697-4" title="4">   r.Rndm();</a>
<a class="sourceLine" id="cb697-5" title="5">   <span class="dt">double</span> x[<span class="dv">100</span>];</a>
<a class="sourceLine" id="cb697-6" title="6">   r.RndmArray(<span class="dv">100</span>,x); <span class="co">// generate an array of random numbers in ]0,1]</span></a>
<a class="sourceLine" id="cb697-7" title="7">   TRandom3 rdm(<span class="dv">111</span>);      <span class="co">// construct with a user-defined seed</span></a>
<a class="sourceLine" id="cb697-8" title="8">   <span class="co">// use 0: a unique seed will be automatically generated using TUUID</span></a>
<a class="sourceLine" id="cb697-9" title="9">   TRandom1 r1(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb697-10" title="10">   TRandom2 r2(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb697-11" title="11">   TRandom3 r3(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb697-12" title="12">   <span class="co">// seed generated using machine clock (different every second)</span></a>
<a class="sourceLine" id="cb697-13" title="13">   TRandom r0(<span class="dv">0</span>);</a></code></pre></div>
<h3 id="random-number-distributions"><span class="header-section-number">13.4.7</span> Random Number Distributions</h3>
<p>The <strong><code>TRandom</code></strong> base class provides 
functions, which can be used by all the other derived classes for 
generating random variates according to predefined distributions. In the
 simplest cases, like in the case of the exponential distribution, the 
non-uniform random number is obtained by applying appropriate 
transformations. In the more complicated cases, random variates are 
obtained using acceptance-rejection methods, which require several 
random numbers.</p>
<div class="sourceCode" id="cb698"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb698-1" title="1">TRandom3 r;</a>
<a class="sourceLine" id="cb698-2" title="2">   <span class="co">// generate a gaussian distributed number with:</span></a>
<a class="sourceLine" id="cb698-3" title="3">   <span class="co">// mu=0, sigma=1 (default values)</span></a>
<a class="sourceLine" id="cb698-4" title="4">   <span class="dt">double</span> x1 = r.Gaus();</a>
<a class="sourceLine" id="cb698-5" title="5">   <span class="dt">double</span> x2 = r.Gaus(<span class="dv">10</span>,<span class="dv">3</span>);    <span class="co">// use mu = 10, sigma = 3;</span></a></code></pre></div>
<p>The following table shows the various distributions that can be generated using methods of the <strong><code>TRandom</code></strong> classes. More information is available in the reference documentation for <strong><code>TRandom</code></strong>.
 In addition, random numbers distributed according to a user defined 
function, in a limited interval, or to a user defined histogram, can be 
generated in a very efficient way using <strong><code>TF1::</code></strong>GetRandom() or <strong><code>TH1::</code></strong>GetRandom().</p>
<table>
<colgroup>
<col style="width: 57%">
<col style="width: 42%">
</colgroup>
<tbody>
<tr class="odd">
<td>Distributions</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>Double_t Uniform(Double_t x1,Double_t x2 )</code></td>
<td>Uniform random numbers between <code>x1,x2</code></td>
</tr>
<tr class="odd">
<td><code>Double_t Gaus(Double_t mu,Double_t sigma )</code></td>
<td><p>Gaussian random numbers.</p>
<p>Default values: <code>mu=0</code>, <code>sigma=1</code></p></td>
</tr>
<tr class="even">
<td><code>Double_t Exp(Double_t tau)</code></td>
<td>Exponential random numbers with mean tau.</td>
</tr>
<tr class="odd">
<td><code>Double_t Landau(Double_t mean,Double_t s igma)</code></td>
<td><p>Landau distributed random numbers.</p>
<p>Default values: <code>mean=0</code>, <code>sigma=1</code></p></td>
</tr>
<tr class="even">
<td><p><code>Double_t BreitWigner(Double_t mean,</code></p>
<p><code>Double_t gamma)</code></p></td>
<td><p>Breit-Wigner distributed random numbers.</p>
<p>Default values <code>mean=0</code>, <code>gamma=1</code></p></td>
</tr>
<tr class="odd">
<td><p><code>Int_t Poisson(Double_t mean)</code></p>
<p><code>Double_t PoissonD(Double_t mean)</code></p></td>
<td>Poisson random numbers</td>
</tr>
<tr class="even">
<td><code>Int_t  Binomial(Int_t ntot,Double_t prob )</code></td>
<td>Binomial Random numbers</td>
</tr>
<tr class="odd">
<td><code>Circle(Double_t &amp;x,Double_t &amp;y,Double_t r)</code></td>
<td><p>Generate a random 2D point <code>(x,y)</code> in</p>
<p>a circle of radius <code>r</code></p></td>
</tr>
<tr class="even">
<td><p><code>Sphere(Double_t &amp;x,Double_t &amp;y,</code></p>
<p><code>Double_t &amp;z,Double_t r)</code></p></td>
<td><p>Generate a random 3D point <code>(x,y,z)</code> in</p>
<p>a sphere of radius <code>r</code></p></td>
</tr>
<tr class="odd">
<td><code>Rannor(Double_t &amp;a,Double_t &amp;b)</code></td>
<td><p>Generate a pair of Gaussian random</p>
<p>numbers with <code>mu=0</code> and <code>sigma=1</code></p></td>
</tr>
</tbody>
</table>
<h3 id="unuran"><span class="header-section-number">13.4.8</span> UNURAN</h3>
<p>An interface to a new package, UNU.RAN, (Universal Non Uniform Random
 number generator for generating non-uniform pseudo-random numbers) was 
introduced in ROOT v5.16.</p>
<p>UNU.RAN is an ANSI C library licensed under GPL. It contains 
universal (also called automatic or black-box) algorithms that can 
generate random numbers from large classes of continuous (in one or 
multi-dimensions), discrete distributions, empirical distributions (like
 histograms) and also from practically all standard distributions. An 
extensive online documentation is available at the UNU.RAN Web Site <a href="http://statmath.wu-wien.ac.at/unuran/" class="uri">http://statmath.wu-wien.ac.at/unuran/</a></p>
<p>The ROOT class <strong><code>TUnuran</code></strong> is used to interface the UNURAN package. It can be used as following:</p>
<ul>
<li>With the UNU.RAN native, string API for pre-defined distributions (see UNU.RAN documentation for the allowed string values at <a href="http://statistik.wu-wien.ac.at/unuran/doc/unuran.html" class="uri">http://statistik.wu-wien.ac.at/unuran/doc/unuran.html</a> ):</li>
</ul>
<div class="sourceCode" id="cb699"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb699-1" title="1">   TUnuran unr;</a>
<a class="sourceLine" id="cb699-2" title="2">   <span class="co">// initialize unuran to generate normal random numbers using</span></a>
<a class="sourceLine" id="cb699-3" title="3">   <span class="co">// a "arou" method</span></a>
<a class="sourceLine" id="cb699-4" title="4">   unr.Init(<span class="st">"normal()"</span>,<span class="st">"method=arou"</span>);</a>
<a class="sourceLine" id="cb699-5" title="5">   ...</a>
<a class="sourceLine" id="cb699-6" title="6">   <span class="co">// sample distributions N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb699-7" title="7">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;N; ++i)</a>
<a class="sourceLine" id="cb699-8" title="8">      <span class="dt">double</span> x = unr.Sample();</a></code></pre></div>
<ul>
<li>For continuous 1D distribution object via the class <strong><code>TUnuranContDist</code></strong> that can be created for example from a <strong><code>TF1</code></strong> function providing the pdf (probability density function) . The user can optionally provide additional information via <code>TUnuranContDist::SetDomain(min,max)</code> like the <code>domain()</code> for generating numbers in a restricted region.</li>
</ul>
<div class="sourceCode" id="cb700"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb700-1" title="1">   <span class="co">// 1D case: create a distribution from two TF1 object</span></a>
<a class="sourceLine" id="cb700-2" title="2">   <span class="co">// pointers pdfFunc</span></a>
<a class="sourceLine" id="cb700-3" title="3">   TUnuranContDist  dist( pdfFunc);</a>
<a class="sourceLine" id="cb700-4" title="4">   <span class="co">// initialize unuran passing the distribution and a string</span></a>
<a class="sourceLine" id="cb700-5" title="5">   <span class="co">// defining the method</span></a>
<a class="sourceLine" id="cb700-6" title="6">   unr.Init(dist, <span class="st">"method=hinv"</span>);</a>
<a class="sourceLine" id="cb700-7" title="7">   <span class="co">// sample distribution  N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb700-8" title="8">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i)</a>
<a class="sourceLine" id="cb700-9" title="9">      <span class="dt">double</span> x = unr.Sample();</a></code></pre></div>
<ul>
<li>For multi-dimensional distribution via the class <strong><code>TUnuranMultiContDist</code></strong>, which can be created from a the multi-dimensional pdf.</li>
</ul>
<div class="sourceCode" id="cb701"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb701-1" title="1">   <span class="co">// Multi- dimensional case from a TF1 (TF2 or TF3) objects</span></a>
<a class="sourceLine" id="cb701-2" title="2">   TUnuranMultiContDist  dist( pdfFuncMulti);</a>
<a class="sourceLine" id="cb701-3" title="3">   <span class="co">// the recommended method for multi-dimensional function is "hitro"</span></a>
<a class="sourceLine" id="cb701-4" title="4">   unr.Init(dist,<span class="st">"method=hitro"</span>);</a>
<a class="sourceLine" id="cb701-5" title="5">   <span class="co">// sample distribution  N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb701-6" title="6">   <span class="dt">double</span> x[NDIM];</a>
<a class="sourceLine" id="cb701-7" title="7">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;N; ++i)</a>
<a class="sourceLine" id="cb701-8" title="8">      unr.SampleMulti(x);</a></code></pre></div>
<ul>
<li>For discrete distribution via the class <strong><code>TUnuranDiscrDist</code></strong>, which can be initialized from a <strong><code>TF1</code></strong> or from a vector of probabilities.</li>
</ul>
<div class="sourceCode" id="cb702"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb702-1" title="1">   <span class="co">// Create distribution from a vector of probabilities</span></a>
<a class="sourceLine" id="cb702-2" title="2">   <span class="dt">double</span> pv[NSize] = {<span class="fl">0.1</span>,<span class="fl">0.2</span>,...};</a>
<a class="sourceLine" id="cb702-3" title="3">   TUnuranDiscrDist dist(pv,pv+NSize);</a>
<a class="sourceLine" id="cb702-4" title="4">   <span class="co">// the recommended method for discrete distribution is</span></a>
<a class="sourceLine" id="cb702-5" title="5">   unr.Init(dist, <span class="st">"method=dgt"</span>);</a>
<a class="sourceLine" id="cb702-6" title="6">   <span class="co">// sample N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb702-7" title="7">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i)</a>
<a class="sourceLine" id="cb702-8" title="8">      <span class="dt">int</span> k = unr.SampleDiscr();</a></code></pre></div>
<ul>
<li>For empirical distribution via the class <strong><code>TUnuranEmpDist</code></strong>.
 In this case one can generate random numbers from a set of un-bin or 
bin data. In the first case the parent distribution is estimated by 
UNU.RAN using a gaussian kernel smoothing algorithm. The <strong><code>TUnuranEmpDist</code></strong> distribution class can be created from a vector of data or from <strong><code>TH1</code></strong> (using the bins or from its buffer for un-binned data).</li>
</ul>
<div class="sourceCode" id="cb703"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb703-1" title="1">   <span class="co">// Create distribution from a set of data</span></a>
<a class="sourceLine" id="cb703-2" title="2">   <span class="co">// vdata is an std::vector containing the data</span></a>
<a class="sourceLine" id="cb703-3" title="3">   TUnuranEmpDist  dist(vdata.begin(),vdata.end());</a>
<a class="sourceLine" id="cb703-4" title="4">   unr.Init(dist);</a>
<a class="sourceLine" id="cb703-5" title="5">   <span class="co">// sample N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb703-6" title="6">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;N; ++i)</a>
<a class="sourceLine" id="cb703-7" title="7">      <span class="dt">double</span> x = unr.Sample();</a></code></pre></div>
<ul>
<li>For some predefined distributions, like <code>Poisson</code> and <code>Binomial</code>, one can use directly a function in the <strong><code>TUnuran</code></strong> class. This is more convenient in passing distribution parameters than using directly the string interface.</li>
</ul>
<div class="sourceCode" id="cb704"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb704-1" title="1">   TUnuran unr;</a>
<a class="sourceLine" id="cb704-2" title="2">   <span class="co">// Initialize unuran to generate normal random numbers from the</span></a>
<a class="sourceLine" id="cb704-3" title="3">   <span class="co">// Poisson distribution with parameter mu</span></a>
<a class="sourceLine" id="cb704-4" title="4">   unr.InitPoisson(mu);</a>
<a class="sourceLine" id="cb704-5" title="5">   ...</a>
<a class="sourceLine" id="cb704-6" title="6">   <span class="co">// Sample distributions N times (generate N random numbers)</span></a>
<a class="sourceLine" id="cb704-7" title="7">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;N; ++i)</a>
<a class="sourceLine" id="cb704-8" title="8">      <span class="dt">int</span> k = unr.SampleDiscr();</a></code></pre></div>
<p>Functionality is also provided via the C++ classes for using a 
different random number generator by passing a TRandom pointer when 
constructing the <strong><code>TUnuran</code></strong> class (by default the ROOT <strong><em><code>gRandom</code></em></strong> is passed to UNURAN).</p>
<h3 id="performances-of-random-numbers"><span class="header-section-number">13.4.9</span> Performances of Random Numbers</h3>
<p>Here are the CPU times obtained using the four random classes on an <code>lxplus</code> machine with an Intel 64 bit architecture and compiled using gcc 3.4:</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 18%">
<col style="width: 19%">
<col style="width: 19%">
<col style="width: 19%">
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td><strong><code>TRandom</code></strong> (ns/call)</td>
<td><strong><code>TRandom1</code></strong> (ns/call)</td>
<td><strong><code>TRandom2</code></strong> (ns/call)</td>
<td><strong><code>TRandom3</code></strong> (ns/call)</td>
</tr>
<tr class="even">
<td><code>Rndm()</code></td>
<td><ul>
<li></li>
</ul></td>
<td><ul>
<li></li>
</ul></td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td><code>Gaus()</code></td>
<td>31</td>
<td>161</td>
<td>35</td>
<td>42</td>
</tr>
<tr class="even">
<td><code>Rannor()</code></td>
<td>116</td>
<td>216</td>
<td>126</td>
<td>130</td>
</tr>
<tr class="odd">
<td><code>Poisson(m-10)</code></td>
<td>147</td>
<td>1161</td>
<td>162</td>
<td>239</td>
</tr>
<tr class="even">
<td><code>Poisson(m=10)</code> <code>UNURAN</code></td>
<td>80</td>
<td>294</td>
<td>89</td>
<td>99</td>
</tr>
</tbody>
</table>
<h2 id="mathematical-functions"><span class="header-section-number">13.5</span> Mathematical Functions</h2>
<p>The mathematical functions are present in both <code>MathCore</code> and <code>MathMore</code> libraries. All mathematical functions are implemented as free functions in the namespace <strong><code>ROOT::Math</code></strong>. The most used functions are in the <code>MathCore</code> library while the others are in the <code>MathMore</code> library. The functions in <code>MathMore</code>
 are all using the implementation of the GNU Scientific Library (GSL). 
The naming of the special functions is the same defined in the C++ <a href="https://root.cern/root/htmldoc/guides/users-guide/Technical%20Report%20on%20Standard%20Library%20extensions">Technical Report on Standard Library extensions</a>. The special functions are defined in the header file <code>Math/SpecFunc.h</code>.</p>
<h3 id="special-functions-in-mathcore"><span class="header-section-number">13.5.1</span> Special Functions in MathCore</h3>
<ul>
<li><p><code>ROOT::Math::beta(double x,double y) -</code>evaluates the beta function: <span class="math display">\[B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}\]</span></p></li>
<li><p><code>double ROOT::Math::erf(double x)</code> - evaluates the error function encountered in integrating the normal distribution: <span class="math display">\[erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\]</span></p></li>
<li><p><code>double ROOT::Math::erfc(double x)</code> - evaluates the complementary error function: <span class="math display">\[erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt\]</span></p></li>
<li><p><code>double ROOT::Math::tgamma(double x)</code> - calculates the gamma function: <span class="math display">\[\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt\]</span></p></li>
</ul>
<h3 id="special-functions-in-mathmore"><span class="header-section-number">13.5.2</span> Special Functions in MathMore</h3>
<ul>
<li><p><code>double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -</code>computes the associated Legendre polynomials (with <code>m&gt;=0</code>, <code>l&gt;=m</code> and <code>|x|&lt;1)</code>: <span class="math display">\[P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)\]</span></p></li>
<li><p><code>double ROOT::Math::comp_ellint_1(double k)</code> - calculates the complete elliptic integral of the first kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>: <span class="math display">\[
K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}
\]</span></p></li>
<li><p><code>double ROOT::Math::comp_ellint_2(double k)</code> - calculates the complete elliptic integral of the second kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>): <span class="math display">\[
E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta
\]</span></p></li>
<li><p><code>double ROOT::Math::comp_ellint_3(double n,double k)</code> - calculates the complete elliptic integral of the third kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>): <span class="math display">\[
\Pi (n, k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{(1 - n \sin^2{\theta})\sqrt{1 - k^2 \sin^2{\theta}}}
\]</span></p></li>
<li><p><code>double ROOT::Math::conf_hyperg(double a,double b,double z)</code> - calculates the confluent hyper-geometric functions of the first kind: <span class="math display">\[
 _{1}F_{1}(a;b;z) = \frac{\Gamma(b)}{\Gamma(a)} \sum_{n=0}^{\infty} \frac{\Gamma(a+n)}{\Gamma(b+n)} \frac{z^n}{n!}
\]</span></p></li>
<li><p><code>double ROOT::Math::conf_hypergU(double a,double b,double z)</code>
 - calculates the confluent hyper-geometric functions of the second 
kind, known also as Kummer function of the second type. It is related to
 the confluent hyper-geometric function of the first kind: <span class="math display">\[

U(a,b,z) = \frac{ \pi}{ \sin{\pi b } } \left[ \frac{ _{1}F_{1}(a,b,z) } 
{\Gamma(a-b+1) } - \frac{ z^{1-b} { _{1}F_{1}}(a-b+1,2-b,z)}{\Gamma(a)} 
\right]
\]</span></p></li>
<li><p><code>double ROOT::Math::cyl_bessel_i(double nu,double x)</code> - calculates the modified Bessel function of the first kind, also called regular modified (cylindrical) Bessel function: <span class="math display">\[
I_{\nu} (x) = i^{-\nu} J_{\nu}(ix) = \sum_{k=0}^{\infty} \frac{(\frac{1}{2}x)^{\nu + 2k}}{k! \Gamma(\nu + k + 1)}
\]</span></p></li>
<li><p><code>double ROOT::Math::cyl_bessel_j(double nu,double x)</code> - calculates the (cylindrical) Bessel function of the first kind, also called regular (cylindrical) Bessel function: <span class="math display">\[
J_{\nu} (x) = \sum_{k=0}^{\infty} \frac{(-1)^k(\frac{1}{2}x)^{\nu + 2k}}{k! \Gamma(\nu + k + 1)}
\]</span></p></li>
<li><p><code>double ROOT::Math::cyl_bessel_k(double nu,double x)</code> - calculates the modified Bessel function of the second kind, also called irregular modified (cylindrical) Bessel function for <span class="math inline">\(x &gt; 0\)</span>, <span class="math inline">\(v &gt; 0\)</span>: <span class="math display">\[

K_{\nu} (x) = \frac{\pi}{2} i^{\nu + 1} (J_{\nu} (ix) + iN(ix)) = 
\left\{ \begin{array}{cl} \frac{\pi}{2} \frac{I_{-\nu}(x) - 
I_{\nu}(x)}{\sin{\nu \pi}} &amp; \mbox{for non-integral $\nu$} \\ 
\frac{\pi}{2} \lim{\mu \to \nu} \frac{I_{-\mu}(x) - I_{\mu}(x)}{\sin{\mu
 \pi}} &amp; \mbox{for integral $\nu$} \end{array} \right.
\]</span></p></li>
<li><p><code>double ROOT::Math::cyl_neumann(double nu,double x)</code> -
 calculates the (cylindrical) Bessel function of the second kind, also 
called irregular (cylindrical) Bessel function or (cylindrical) Neumann 
function: <span class="math display">\[
N_{\nu} (x) = Y_{\nu} (x) = \left\{ \begin{array}{cl} \frac{J_{\nu} 
\cos{\nu \pi}-J_{-\nu}(x)}{\sin{\nu \pi}} &amp; \mbox{for non-integral 
$\nu$} \\ \lim{\mu \to \nu} \frac{J_{\mu} \cos{\mu 
\pi}-J_{-\mu}(x)}{\sin{\mu \pi}} &amp; \mbox{for integral $\nu$} 
\end{array} \right.
\]</span></p></li>
<li><p><code>double ROOT::Math::ellint_1(double k,double phi)</code> - calculates incomplete elliptic integral of the first kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>): <span class="math display">\[
K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}
\]</span></p></li>
<li><p><code>double ROOT::Math::ellint_2(double k,double phi)</code> - calculates the complete elliptic integral of the second kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>): <span class="math display">\[
E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta
\]</span></p></li>
<li><p><code>double ROOT::Math::ellint_3(double n,double k,double phi)</code> - calculates the complete elliptic integral of the third kind (with <span class="math inline">\(0 \le k^2 \le 1\)</span>): <span class="math display">\[
\Pi (n, k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{(1 - n \sin^2{\theta})\sqrt{1 - k^2 \sin^2{\theta}}}
\]</span></p></li>
<li><p><code>double ROOT::Math::expint(double x)</code> - calculates the exponential integral: <span class="math display">\[
Ei(x) = - \int_{-x}^{\infty} \frac{e^{-t}}{t} dt
\]</span></p></li>
<li><p><code>double ROOT::Math::hyperg(double a,double b,double c,double x)</code> - calculates Gauss’ hyper-geometric function: <span class="math display">\[

_{2}F_{1}(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a) \Gamma(b)} 
\sum_{n=0}^{\infty} \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)} 
\frac{x^n}{n!}
\]</span></p></li>
<li><p><code>double ROOT::Math::legendre(unsigned l,double x)</code> - calculates the Legendre polynomials for <span class="math inline">\(l \ge 0\)</span>, <span class="math inline">\(|x| \le 1\)</span> in the Rodrigues representation: <span class="math display">\[
P_{l}(x) = \frac{1}{2^l l!} \frac{d^l}{dx^l} (x^2 - 1)^l
\]</span></p></li>
<li><p><code>double ROOT::Math::riemann_zeta(double x)</code> - calculates the Riemann zeta function: <span class="math display">\[

\zeta (x) = \left\{ \begin{array}{cl} \sum_{k=1}^{\infty}k^{-x} &amp; 
\mbox{for $x &gt; 1$} \\ 2^x \pi^{x-1} \sin{(\frac{1}{2}\pi x)} 
\Gamma(1-x) \zeta (1-x) &amp; \mbox{for $x &lt; 1$} \end{array} \right.
\]</span></p></li>
<li><p><code>double ROOT::Math::sph_bessel(unsigned n,double x)</code> - calculates the spherical Bessel functions of the first kind (also called regular spherical Bessel functions): <span class="math display">\[
j_{n}(x) = \sqrt{\frac{\pi}{2x}} J_{n+1/2}(x)
\]</span></p></li>
<li><p><code>double ROOT::Math::sph_neumann(unsigned n,double x)</code> -
 calculates the spherical Bessel functions of the second kind (also 
called irregular spherical Bessel functions or spherical Neumann 
functions): <span class="math display">\[
n_n(x) = y_n(x) = \sqrt{\frac{\pi}{2x}} N_{n+1/2}(x)
\]</span></p></li>
</ul>
<h3 id="probability-density-functions-pdf"><span class="header-section-number">13.5.3</span> Probability Density Functions (PDF)</h3>
<p>Probability density functions of various distributions. All the 
functions, apart from the discrete ones, have the extra location 
parameter <code>x0</code>, which by default is zero. For example, in the case of a gaussian <code>pdf</code>, <code>x0</code> is the <code>mean</code>, <code>mu</code>, of the distribution. All the probability density functions are defined in the header file <code>Math/DistFunc.h</code> and are part of the <code>MathCore</code> libraries. The definition of these functions is documented in the <a href="https://root.cern/root/htmldoc/guides/users-guide/reference%20doc%20for%20statistical%20functions">reference doc for statistical functions</a>:</p>
<div class="sourceCode" id="cb705"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb705-1" title="1"><span class="dt">double</span> ROOT::Math::beta_pdf(<span class="dt">double</span> x,<span class="dt">double</span> a, <span class="dt">double</span> b);</a>
<a class="sourceLine" id="cb705-2" title="2"><span class="dt">double</span> ROOT::Math::binomial_pdf(<span class="dt">unsigned</span> <span class="dt">int</span> k,<span class="dt">double</span> p,<span class="dt">unsigned</span> <span class="dt">int</span> n);</a>
<a class="sourceLine" id="cb705-3" title="3"><span class="dt">double</span> ROOT::Math::breitwigner_pdf(<span class="dt">double</span> x,<span class="dt">double</span> gamma,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-4" title="4"><span class="dt">double</span> ROOT::Math::cauchy_pdf(<span class="dt">double</span> x,<span class="dt">double</span> b=<span class="dv">1</span>,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-5" title="5"><span class="dt">double</span> ROOT::Math::chisquared_pdf(<span class="dt">double</span> x,<span class="dt">double</span> r,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-6" title="6"><span class="dt">double</span> ROOT::Math::exponential_pdf(<span class="dt">double</span> x,<span class="dt">double</span> lambda,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-7" title="7"><span class="dt">double</span> ROOT::Math::fdistribution_pdf(<span class="dt">double</span> x,<span class="dt">double</span> n,<span class="dt">double</span> m,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-8" title="8"><span class="dt">double</span> ROOT::Math::gamma_pdf(<span class="dt">double</span> x,<span class="dt">double</span> alpha,<span class="dt">double</span> theta,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-9" title="9"><span class="dt">double</span> ROOT::Math::gaussian_pdf(<span class="dt">double</span> x,<span class="dt">double</span> sigma,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-10" title="10"><span class="dt">double</span> ROOT::Math::landau_pdf(<span class="dt">double</span> x,<span class="dt">double</span> s,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-11" title="11"><span class="dt">double</span> ROOT::Math::lognormal_pdf(<span class="dt">double</span> x,<span class="dt">double</span> m,<span class="dt">double</span> s,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-12" title="12"><span class="dt">double</span> ROOT::Math::normal_pdf(<span class="dt">double</span> x,<span class="dt">double</span> sigma,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-13" title="13"><span class="dt">double</span> ROOT::Math::poisson_pdf(<span class="dt">unsigned</span> <span class="dt">int</span> n,<span class="dt">double</span> mu);</a>
<a class="sourceLine" id="cb705-14" title="14"><span class="dt">double</span> ROOT::Math::tdistribution_pdf(<span class="dt">double</span> x,<span class="dt">double</span> r,<span class="dt">double</span> x0=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb705-15" title="15"><span class="dt">double</span> ROOT::Math::uniform_pdf(<span class="dt">double</span> x,<span class="dt">double</span> a,<span class="dt">double</span> b,<span class="dt">double</span> x0=<span class="dv">0</span>);</a></code></pre></div>
<h3 id="cumulative-distribution-functions-cdf"><span class="header-section-number">13.5.4</span> Cumulative Distribution Functions (CDF)</h3>
<p>For all the probability density functions, we have the corresponding 
cumulative distribution functions and their complements. The functions 
with extension <code>_cdf</code> calculate the lower tail integral of the probability density function:</p>
<p><span class="math display">\[
D(x) = \int_{-\infty}^{x} p(x') dx'
\]</span></p>
<p>while those with the <code>cdf_c</code> extension calculate the upper
 tail of the probability density function, so-called in statistics the 
survival function. For example, the function:</p>
<div class="sourceCode" id="cb706"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb706-1" title="1"><span class="dt">double</span> ROOT::Math::gaussian_cdf(<span class="dt">double</span> x,<span class="dt">double</span> sigma,<span class="dt">double</span> x0=<span class="dv">0</span>);</a></code></pre></div>
<p>evaluates the lower tail of the Gaussian distribution: <span class="math display">\[
D(x) = \int_{-\infty}^{x} {\frac{1}{\sqrt{2 \pi \sigma^2}}} e^{-(x'-x_0)^2 / 2\sigma^2} dx'
\]</span></p>
<p>while the function:</p>
<div class="sourceCode" id="cb707"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb707-1" title="1"><span class="dt">double</span> ROOT::Math::gaussian_cdf_c(<span class="dt">double</span> x, <span class="dt">double</span> sigma, <span class="dt">double</span> x0=<span class="dv">0</span>);</a></code></pre></div>
<p>evaluates the upper tail of the Gaussian distribution: <span class="math display">\[
D(x) = \int_{x}^{+\infty} {\frac{1}{\sqrt{2 \pi \sigma^2}}} e^{-(x'-x_0)^2 / 2\sigma^2} dx'
\]</span></p>
<p>The cumulative distributions functions are defined in the header file <code>Math/ProbFunc.h</code>. The majority of the CDF’s are present in the <code>MathCore</code>, apart from the <code>chisquared</code>, <code>fdistribution</code>, <code>gamma</code> and <code>tdistribution</code>, which are in the <code>MathMore</code> library.</p>
<h4 id="inverse-of-the-cumulative-distribution-functionsquantiles"><span class="header-section-number">13.5.4.1</span> Inverse of the Cumulative Distribution Functions(Quantiles)</h4>
<p>For almost all the cumulative distribution functions (<code>_cdf</code>) and their complements (<code>_cdf_c</code>)
 present in the library, we provide the inverse functions. The inverse 
of the cumulative distribution function is called in statistics quantile
 function. The functions with the extension <code>_quantile</code> 
calculate the inverse of the cumulative distribution function (lower 
tail integral of the probability density function), while those with the
 <em><code>quantile_c</code></em> extension calculate the inverse of the
 complement of the cumulative distribution (upper tail integral). All 
the inverse distributions are in the MathMore library and are defined in
 the header file <code>Math/ProbFuncInv.h</code>.</p>
<p>The following picture illustrates the available statistical functions
 (PDF, CDF and quantiles) in the case of the normal distribution.</p>
<figure>
<img src="ROOTUsersGuide_files/03000128.png" alt="PDF, CDF and quantiles in the case of the normal distribution"><figcaption>PDF, CDF and quantiles in the case of the normal distribution</figcaption>
</figure>
<h2 id="numerical-algorithms"><span class="header-section-number">13.6</span> Numerical Algorithms</h2>
<p>ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:</p>
<ul>
<li>Evaluation of function derivatives.</li>
<li>Evaluation of integrals.</li>
<li>Finding the roots of a function</li>
<li>Finding the minimum/maximum of a function</li>
</ul>
<p>In order to use these algorithm the user needs to provide a function.
 ROOT provides a common way of specifying them via some interfaces</p>
<h2 id="rootmath-function-interfaces"><span class="header-section-number">13.7</span> ROOT::Math Function interfaces</h2>
<p>To get a consistency in the mathematical methods within ROOT, there 
exists a set of interfaces to define the basic behaviour of a 
mathematical function. In order to use the classes presented in this 
chapter, the mathematical functions defined by the user must inherit 
from any of the classes seen in the figure:</p>
<figure>
<img src="ROOTUsersGuide_files/function-hierarchy.png" alt="ROOT::Math Function interface structure"><figcaption>ROOT::Math Function interface structure</figcaption>
</figure>
<h3 id="one-dimensional-function-interfaces"><span class="header-section-number">13.7.1</span> One-dimensional Function Interfaces</h3>
<p>These interfaces are used for numerical algorithms operating only on 
one-dimensional functions and cannot be applied to multi-dimensional 
functions. For this case the users needs to define a function object 
which evaluates in one dimension, and the object will have to derivate 
from the following:</p>
<ul>
<li><code>ROOT::Math::IBaseFunctionOneDim</code>: This class is the most
 basic function. Provides a method to evaluate the function given a 
value (simple double) by implementing <code>double operator() (const double )</code>. The user class defined only needs to reimplement the pure abstract method <code>double DoEval(double x)</code>, that will do the work of evaluating the function at point x.</li>
</ul>
<p>Example on how to create a class that represents a mathematical function. The user only has to override two methods from <code>IBaseFunctionOneDim</code>:</p>
<div class="sourceCode" id="cb708"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb708-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb708-2" title="2"></a>
<a class="sourceLine" id="cb708-3" title="3"><span class="kw">class</span> MyFunction: <span class="kw">public</span> ROOT::Math::IBaseFunctionOneDim</a>
<a class="sourceLine" id="cb708-4" title="4">{</a>
<a class="sourceLine" id="cb708-5" title="5">   <span class="dt">double</span> DoEval(<span class="dt">double</span> x) <span class="at">const</span></a>
<a class="sourceLine" id="cb708-6" title="6">   {</a>
<a class="sourceLine" id="cb708-7" title="7">      <span class="cf">return</span> x*x;</a>
<a class="sourceLine" id="cb708-8" title="8">   }</a>
<a class="sourceLine" id="cb708-9" title="9"></a>
<a class="sourceLine" id="cb708-10" title="10">   ROOT::Math::IBaseFunctionOneDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb708-11" title="11">   {</a>
<a class="sourceLine" id="cb708-12" title="12">      <span class="cf">return</span> <span class="kw">new</span> MyFunction();</a>
<a class="sourceLine" id="cb708-13" title="13">   }</a>
<a class="sourceLine" id="cb708-14" title="14">};</a></code></pre></div>
<ul>
<li><p><code>ROOT::Math::IGradientFunctionOneDim</code>: Some of the 
numerical algorithm will need to calculate the derivatives of the 
function. In these cases, the user will have to provide the necessary 
code for this to happen. The interface defined in <code>IGradientFunctionOneDim</code> introduced the method <code>double Derivative(double x)</code> that will return the derivative of the function at the point <code>x</code>. The class inherit by the user will have to implement the abstract method <code>double DoDerivative(double x)</code>, leaving the rest of the class untouched.</p>
<p>Example for implementing a gradient one-dimensional function:</p></li>
</ul>
<div class="sourceCode" id="cb709"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb709-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb709-2" title="2"></a>
<a class="sourceLine" id="cb709-3" title="3"><span class="kw">class</span> MyGradientFunction: <span class="kw">public</span> ROOT::Math::IGradientFunctionOneDim</a>
<a class="sourceLine" id="cb709-4" title="4">{</a>
<a class="sourceLine" id="cb709-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb709-6" title="6">   <span class="dt">double</span> DoEval(<span class="dt">double</span> x) <span class="at">const</span></a>
<a class="sourceLine" id="cb709-7" title="7">   {</a>
<a class="sourceLine" id="cb709-8" title="8">      <span class="cf">return</span> sin(x);</a>
<a class="sourceLine" id="cb709-9" title="9">   }</a>
<a class="sourceLine" id="cb709-10" title="10"></a>
<a class="sourceLine" id="cb709-11" title="11">   ROOT::Math::IBaseFunctionOneDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb709-12" title="12">   {</a>
<a class="sourceLine" id="cb709-13" title="13">      <span class="cf">return</span> <span class="kw">new</span> MyGradientFunction();</a>
<a class="sourceLine" id="cb709-14" title="14">   }</a>
<a class="sourceLine" id="cb709-15" title="15"></a>
<a class="sourceLine" id="cb709-16" title="16">   <span class="dt">double</span> DoDerivative(<span class="dt">double</span> x) <span class="at">const</span></a>
<a class="sourceLine" id="cb709-17" title="17">   {</a>
<a class="sourceLine" id="cb709-18" title="18">      <span class="cf">return</span> -cos(x);</a>
<a class="sourceLine" id="cb709-19" title="19">   }</a>
<a class="sourceLine" id="cb709-20" title="20"></a>
<a class="sourceLine" id="cb709-21" title="21">};</a></code></pre></div>
<h3 id="multi-dimensional-function-interfaces"><span class="header-section-number">13.7.2</span> Multi-dimensional Function Interfaces</h3>
<p>The most generic case of a multidimensional function has similar 
approach. Some examples will be shown next. It is important to notice, 
that one dimensional functions can be also implemented through the 
interfaces that will be presented here. Nevertheless, the user needs to 
implement those following the indications of the previous chapter, for 
algorithm working exclusivly on one-dimensional functions. For 
algorithms working on both one-dimensional and multi-dimensional 
functions they should instead use this interface.</p>
<ul>
<li><p><code>ROOT::Math::IBaseFunctionMultiDim</code>: This interface provides the <code>double operator() (const double*)</code>
 that takes an array of doubles with all the values for the different 
dimensions. In this case, the user has to provide the functionality for 
two different functions: <code>double DoEval(const double*)</code> and <code>unsigned int NDim()</code>.
 The first ones evaluates the function given the array that represents 
the multiple variables. The second returns the number of dimensions of 
the function.</p>
<p>Example of implementing a basic multi-dimensional function:</p></li>
</ul>
<div class="sourceCode" id="cb710"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb710-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb710-2" title="2"></a>
<a class="sourceLine" id="cb710-3" title="3"><span class="kw">class</span> MyFunction: <span class="kw">public</span> ROOT::Math::IBaseFunctionMultiDim</a>
<a class="sourceLine" id="cb710-4" title="4">{</a>
<a class="sourceLine" id="cb710-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb710-6" title="6">   <span class="dt">double</span> DoEval(<span class="at">const</span> <span class="dt">double</span>* x) <span class="at">const</span></a>
<a class="sourceLine" id="cb710-7" title="7">   {</a>
<a class="sourceLine" id="cb710-8" title="8">      <span class="cf">return</span> x[<span class="dv">0</span>] + sin(x[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb710-9" title="9">   }</a>
<a class="sourceLine" id="cb710-10" title="10"></a>
<a class="sourceLine" id="cb710-11" title="11">   <span class="dt">unsigned</span> <span class="dt">int</span> NDim() <span class="at">const</span></a>
<a class="sourceLine" id="cb710-12" title="12">   {</a>
<a class="sourceLine" id="cb710-13" title="13">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb710-14" title="14">   }</a>
<a class="sourceLine" id="cb710-15" title="15"></a>
<a class="sourceLine" id="cb710-16" title="16">   ROOT::Math::IBaseFunctionMultiDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb710-17" title="17">   {</a>
<a class="sourceLine" id="cb710-18" title="18">      <span class="cf">return</span> <span class="kw">new</span> MyFunction();</a>
<a class="sourceLine" id="cb710-19" title="19">   }</a>
<a class="sourceLine" id="cb710-20" title="20"></a>
<a class="sourceLine" id="cb710-21" title="21">};</a></code></pre></div>
<ul>
<li><code>ROOT::Math::IGradientFunctionMultiDim</code>: This interface offers the same functionality as the base function plus the calculation of the derivative. It only adds the <code>double Derivative(double* x, uint ivar)</code>
 method for the user to implement. This method must implement the 
derivative of the function with respect to the variable indicated with 
the second parameter.</li>
</ul>
<p>Example of implementing a multi-dimensional gradient function</p>
<div class="sourceCode" id="cb711"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb711-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb711-2" title="2"></a>
<a class="sourceLine" id="cb711-3" title="3"><span class="kw">class</span> MyGradientFunction: <span class="kw">public</span> ROOT::Math::IGradientFunctionMultiDim</a>
<a class="sourceLine" id="cb711-4" title="4">{</a>
<a class="sourceLine" id="cb711-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb711-6" title="6">   <span class="dt">double</span> DoEval(<span class="at">const</span> <span class="dt">double</span>* x) <span class="at">const</span></a>
<a class="sourceLine" id="cb711-7" title="7">   {</a>
<a class="sourceLine" id="cb711-8" title="8">      <span class="cf">return</span> x[<span class="dv">0</span>] + sin(x[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb711-9" title="9">   }</a>
<a class="sourceLine" id="cb711-10" title="10"></a>
<a class="sourceLine" id="cb711-11" title="11">   <span class="dt">unsigned</span> <span class="dt">int</span> NDim() <span class="at">const</span></a>
<a class="sourceLine" id="cb711-12" title="12">   {</a>
<a class="sourceLine" id="cb711-13" title="13">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb711-14" title="14">   }</a>
<a class="sourceLine" id="cb711-15" title="15"></a>
<a class="sourceLine" id="cb711-16" title="16">   ROOT::Math::IGradientFunctionMultiDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb711-17" title="17">   {</a>
<a class="sourceLine" id="cb711-18" title="18">      <span class="cf">return</span> <span class="kw">new</span> MyGradientFunction();</a>
<a class="sourceLine" id="cb711-19" title="19">   }</a>
<a class="sourceLine" id="cb711-20" title="20"></a>
<a class="sourceLine" id="cb711-21" title="21">   <span class="dt">double</span> DoDerivative(<span class="at">const</span> <span class="dt">double</span>* x, <span class="dt">unsigned</span> <span class="dt">int</span> ipar) <span class="at">const</span></a>
<a class="sourceLine" id="cb711-22" title="22">   {</a>
<a class="sourceLine" id="cb711-23" title="23">      <span class="cf">if</span> ( ipar == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb711-24" title="24">         <span class="cf">return</span> sin(x[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb711-25" title="25">      <span class="cf">else</span></a>
<a class="sourceLine" id="cb711-26" title="26">         <span class="cf">return</span> x[<span class="dv">0</span>] + x[<span class="dv">1</span>] * cos(x[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb711-27" title="27">   }</a>
<a class="sourceLine" id="cb711-28" title="28"></a>
<a class="sourceLine" id="cb711-29" title="29">};</a></code></pre></div>
<h3 id="parametric-function-interfaces"><span class="header-section-number">13.7.3</span> Parametric Function Interfaces</h3>
<p>These interfaces, for evaluating multi-dimensional functions are used
 for fitting. These interfaces are defined in the header file <code>Math/IParamFunction.h</code>. See also the documentation of the <code>ROOT::Fit</code> classes in the Fitting chapter for more information.</p>
<ul>
<li><strong><code>ROOT::Math::IParametricFunctionMultiDim</code></strong>:
 Describes a multi dimensional parametric function. Similarly to the one
 dimensional version, the user needs to provide the method <code>void SetParameters(double* p)</code> as well as the getter methods <code>const double * Parameters()</code> and <code>uint NPar()</code>. Example of creating a parametric function:</li>
</ul>
<div class="sourceCode" id="cb712"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb712-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb712-2" title="2"><span class="pp">#include </span><span class="im">"Math/IParamFunction.h"</span></a>
<a class="sourceLine" id="cb712-3" title="3"></a>
<a class="sourceLine" id="cb712-4" title="4"><span class="kw">class</span> MyParametricFunction: <span class="kw">public</span> ROOT::Math::IParametricFunctionMultiDim</a>
<a class="sourceLine" id="cb712-5" title="5">{</a>
<a class="sourceLine" id="cb712-6" title="6"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb712-7" title="7">   <span class="at">const</span> <span class="dt">double</span>* pars;</a>
<a class="sourceLine" id="cb712-8" title="8"></a>
<a class="sourceLine" id="cb712-9" title="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb712-10" title="10">   <span class="dt">double</span> DoEvalPar(<span class="at">const</span> <span class="dt">double</span>* x, <span class="at">const</span> <span class="dt">double</span>* p) <span class="at">const</span></a>
<a class="sourceLine" id="cb712-11" title="11">   {</a>
<a class="sourceLine" id="cb712-12" title="12">      <span class="cf">return</span> p[<span class="dv">0</span>] * x[<span class="dv">0</span>] + sin(x[<span class="dv">1</span>]) + p[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb712-13" title="13">   }</a>
<a class="sourceLine" id="cb712-14" title="14"></a>
<a class="sourceLine" id="cb712-15" title="15">   <span class="dt">unsigned</span> <span class="dt">int</span> NDim() <span class="at">const</span></a>
<a class="sourceLine" id="cb712-16" title="16">   {</a>
<a class="sourceLine" id="cb712-17" title="17">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb712-18" title="18">   }</a>
<a class="sourceLine" id="cb712-19" title="19"></a>
<a class="sourceLine" id="cb712-20" title="20">   ROOT::Math::IParametricFunctionMultiDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb712-21" title="21">   {</a>
<a class="sourceLine" id="cb712-22" title="22">      <span class="cf">return</span> <span class="kw">new</span> MyParametricFunction();</a>
<a class="sourceLine" id="cb712-23" title="23">   }</a>
<a class="sourceLine" id="cb712-24" title="24"></a>
<a class="sourceLine" id="cb712-25" title="25">   <span class="at">const</span> <span class="dt">double</span>* Parameters() <span class="at">const</span></a>
<a class="sourceLine" id="cb712-26" title="26">   {</a>
<a class="sourceLine" id="cb712-27" title="27">      <span class="cf">return</span> pars;</a>
<a class="sourceLine" id="cb712-28" title="28">   }</a>
<a class="sourceLine" id="cb712-29" title="29"></a>
<a class="sourceLine" id="cb712-30" title="30">   <span class="dt">void</span> SetParameters(<span class="at">const</span> <span class="dt">double</span>* p)</a>
<a class="sourceLine" id="cb712-31" title="31">   {</a>
<a class="sourceLine" id="cb712-32" title="32">      pars = p;</a>
<a class="sourceLine" id="cb712-33" title="33">   }</a>
<a class="sourceLine" id="cb712-34" title="34"></a>
<a class="sourceLine" id="cb712-35" title="35">   <span class="dt">unsigned</span> <span class="dt">int</span> NPar() <span class="at">const</span></a>
<a class="sourceLine" id="cb712-36" title="36">   {</a>
<a class="sourceLine" id="cb712-37" title="37">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb712-38" title="38">   }</a>
<a class="sourceLine" id="cb712-39" title="39">};</a></code></pre></div>
<ul>
<li><strong><code>ROOT::Math::IParametricGradFunctionMultiDim</code></strong>:
 Provides an interface for parametric gradient multi-dimensional 
functions. In addition to function evaluation it provides the gradient 
with respect to the parameters, via the method <code>ParameterGradient()</code>.
 This interface is only used in case of some dedicated fitting 
algorithms, when is required or more efficient to provide derivatives 
with respect to the parameters. Here is an example:</li>
</ul>
<div class="sourceCode" id="cb713"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb713-1" title="1"><span class="pp">#include </span><span class="im">"Math/IFunction.h"</span></a>
<a class="sourceLine" id="cb713-2" title="2"><span class="pp">#include </span><span class="im">"Math/IParamFunction.h"</span></a>
<a class="sourceLine" id="cb713-3" title="3"></a>
<a class="sourceLine" id="cb713-4" title="4"><span class="kw">class</span> MyParametricGradFunction:</a>
<a class="sourceLine" id="cb713-5" title="5">          <span class="kw">public</span> ROOT::Math::IParametricGradFunctionMultiDim</a>
<a class="sourceLine" id="cb713-6" title="6">{</a>
<a class="sourceLine" id="cb713-7" title="7"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb713-8" title="8">   <span class="at">const</span> <span class="dt">double</span>* pars;</a>
<a class="sourceLine" id="cb713-9" title="9"></a>
<a class="sourceLine" id="cb713-10" title="10"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb713-11" title="11">   <span class="dt">double</span> DoEvalPar(<span class="at">const</span> <span class="dt">double</span>* x, <span class="at">const</span> <span class="dt">double</span>* p) <span class="at">const</span></a>
<a class="sourceLine" id="cb713-12" title="12">   {</a>
<a class="sourceLine" id="cb713-13" title="13">      <span class="cf">return</span> p[<span class="dv">0</span>] * x[<span class="dv">0</span>] + sin(x[<span class="dv">1</span>]) + p[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb713-14" title="14">   }</a>
<a class="sourceLine" id="cb713-15" title="15"></a>
<a class="sourceLine" id="cb713-16" title="16">   <span class="dt">unsigned</span> <span class="dt">int</span> NDim() <span class="at">const</span></a>
<a class="sourceLine" id="cb713-17" title="17">   {</a>
<a class="sourceLine" id="cb713-18" title="18">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb713-19" title="19">   }</a>
<a class="sourceLine" id="cb713-20" title="20"></a>
<a class="sourceLine" id="cb713-21" title="21">   ROOT::Math::IParametricGradFunctionMultiDim* Clone() <span class="at">const</span></a>
<a class="sourceLine" id="cb713-22" title="22">   {</a>
<a class="sourceLine" id="cb713-23" title="23">      <span class="cf">return</span> <span class="kw">new</span> MyParametricGradFunction();</a>
<a class="sourceLine" id="cb713-24" title="24">   }</a>
<a class="sourceLine" id="cb713-25" title="25"></a>
<a class="sourceLine" id="cb713-26" title="26">   <span class="at">const</span> <span class="dt">double</span>* Parameters() <span class="at">const</span></a>
<a class="sourceLine" id="cb713-27" title="27">   {</a>
<a class="sourceLine" id="cb713-28" title="28">      <span class="cf">return</span> pars;</a>
<a class="sourceLine" id="cb713-29" title="29">   }</a>
<a class="sourceLine" id="cb713-30" title="30"></a>
<a class="sourceLine" id="cb713-31" title="31">   <span class="dt">void</span> SetParameters(<span class="at">const</span> <span class="dt">double</span>* p)</a>
<a class="sourceLine" id="cb713-32" title="32">   {</a>
<a class="sourceLine" id="cb713-33" title="33">      pars = p;</a>
<a class="sourceLine" id="cb713-34" title="34">   }</a>
<a class="sourceLine" id="cb713-35" title="35"></a>
<a class="sourceLine" id="cb713-36" title="36">   <span class="dt">unsigned</span> <span class="dt">int</span> NPar() <span class="at">const</span></a>
<a class="sourceLine" id="cb713-37" title="37">   {</a>
<a class="sourceLine" id="cb713-38" title="38">      <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb713-39" title="39">   }</a>
<a class="sourceLine" id="cb713-40" title="40"></a>
<a class="sourceLine" id="cb713-41" title="41">   <span class="dt">double</span> DoParameterDerivative(<span class="at">const</span> <span class="dt">double</span>* x, <span class="at">const</span> <span class="dt">double</span>* p,</a>
<a class="sourceLine" id="cb713-42" title="42">                                <span class="dt">unsigned</span> <span class="dt">int</span> ipar) <span class="at">const</span></a>
<a class="sourceLine" id="cb713-43" title="43">   {</a>
<a class="sourceLine" id="cb713-44" title="44">      <span class="cf">if</span> ( ipar == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb713-45" title="45">         <span class="cf">return</span> sin(x[<span class="dv">1</span>]) + p[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb713-46" title="46">      <span class="cf">else</span></a>
<a class="sourceLine" id="cb713-47" title="47">         <span class="cf">return</span> p[<span class="dv">0</span>] * x[<span class="dv">0</span>] + x[<span class="dv">1</span>] * cos(x[<span class="dv">1</span>]) + p[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb713-48" title="48">   }</a>
<a class="sourceLine" id="cb713-49" title="49">};</a></code></pre></div>
<h3 id="wrapper-functions"><span class="header-section-number">13.7.4</span> Wrapper Functions</h3>
<p>To facilitate the user to insert their own type of function in the 
needed function interface, helper classes, wrapping the user interface 
in the <code>ROOT::Math</code> function interfaces are provided. this 
will avoid the user to re-implement dedicated function classes, 
following the code example shown in the previous paragraphs.</p>
<p>There is one possible wrapper for every interface explained in the 
previous section. The following table indicates the wrapper for the most
 basic ones:</p>
<table>
<thead>
<tr class="header">
<th><strong>Interface</strong></th>
<th><strong>Function Wrapper</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROOT::Math::IBaseFunctionOneDim</code></td>
<td><code>ROOT::Math::Functor1D</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::IGradientFunctionOneDim</code></td>
<td><code>ROOT::Math::GradFunctor1D</code></td>
</tr>
<tr class="odd">
<td><code>ROOT::Math::IBaseFunctionMultiDim</code></td>
<td><code>ROOT::Math::Functor</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::IGradientFunctionMultiDim</code></td>
<td><code>ROOT::Math::GradFunctor</code></td>
</tr>
</tbody>
</table>
<p>Thee functor wrapper are defined in the header file <code>Math/Functor.h</code>.</p>
<h4 id="wrapping-one-dimensional-functions"><span class="header-section-number">13.7.4.1</span> Wrapping One Dimensional Functions</h4>
<p>The <code>ROOT::Math::Functor1D</code> is used to wrap one-dimensional functions It can wrap all the following types: * A free C function of type <code>double ()(double )</code>. * Any C++ callable object implementation <code>double operator()( double )</code>. * A class member function with the correct signature like <code>double Foo::Eval(double )</code>. In this case one pass the object pointer and a pointer to the member function <code>(&amp;Foo::Eval)</code>.</p>
<p>Example:</p>
<div class="sourceCode" id="cb714"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb714-1" title="1"><span class="pp">#include </span><span class="im">"Math/Functor.h"</span></a>
<a class="sourceLine" id="cb714-2" title="2"></a>
<a class="sourceLine" id="cb714-3" title="3"><span class="kw">class</span> MyFunction1D {</a>
<a class="sourceLine" id="cb714-4" title="4"></a>
<a class="sourceLine" id="cb714-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb714-6" title="6"></a>
<a class="sourceLine" id="cb714-7" title="7">   <span class="dt">double</span> <span class="kw">operator</span>()(<span class="dt">double</span> x) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb714-8" title="8">      <span class="cf">return</span> x*x;</a>
<a class="sourceLine" id="cb714-9" title="9">   }</a>
<a class="sourceLine" id="cb714-10" title="10"></a>
<a class="sourceLine" id="cb714-11" title="11">   <span class="dt">double</span> Eval(<span class="dt">double</span> x) <span class="at">const</span> { <span class="cf">return</span> x+x; }</a>
<a class="sourceLine" id="cb714-12" title="12">};</a>
<a class="sourceLine" id="cb714-13" title="13"></a>
<a class="sourceLine" id="cb714-14" title="14"><span class="dt">double</span> freeFunction1D(<span class="dt">double</span>  x ) {</a>
<a class="sourceLine" id="cb714-15" title="15">   <span class="cf">return</span> <span class="dv">2</span>*x;</a>
<a class="sourceLine" id="cb714-16" title="16">}</a>
<a class="sourceLine" id="cb714-17" title="17"></a>
<a class="sourceLine" id="cb714-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb714-19" title="19">{</a>
<a class="sourceLine" id="cb714-20" title="20">   <span class="co">// wrapping a free function</span></a>
<a class="sourceLine" id="cb714-21" title="21">   ROOT::Math::Functor1D  f1(&amp;freeFunction1D);</a>
<a class="sourceLine" id="cb714-22" title="22"></a>
<a class="sourceLine" id="cb714-23" title="23">   MyFunction1D myf1;</a>
<a class="sourceLine" id="cb714-24" title="24"></a>
<a class="sourceLine" id="cb714-25" title="25">   <span class="co">// wrapping a function object implementing operator()</span></a>
<a class="sourceLine" id="cb714-26" title="26">   ROOT::Math::Functor1D  f2(myf1);</a>
<a class="sourceLine" id="cb714-27" title="27"></a>
<a class="sourceLine" id="cb714-28" title="28">   <span class="co">// wrapping a class member function</span></a>
<a class="sourceLine" id="cb714-29" title="29">   ROOT::Math::Functor1D f3(&amp;myf1,&amp;MyFunction1D::Eval);</a>
<a class="sourceLine" id="cb714-30" title="30"></a>
<a class="sourceLine" id="cb714-31" title="31">   cout &lt;&lt; f1(<span class="dv">2</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb714-32" title="32">   cout &lt;&lt; f2(<span class="dv">2</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb714-33" title="33">   cout &lt;&lt; f3(<span class="dv">2</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb714-34" title="34"></a>
<a class="sourceLine" id="cb714-35" title="35">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb714-36" title="36">}</a></code></pre></div>
<h4 id="wrapping-one-dimensional-gradient-functions"><span class="header-section-number">13.7.4.2</span> Wrapping One Dimensional Gradient Functions</h4>
<p>The <code>ROOT::Math::GradFunctor1D</code> class is used to wrap 
one-dimensional gradient functions. It can be constructed in three 
different ways: * Any object implementing both <code>double operator()( double)</code> for the function evaluation and <code>double Derivative(double)</code> for the function derivative. * Any object implementing any member function like <code>Foo::XXX(double )</code> for the function evaluation and any other member function like <code>Foo::YYY(double )</code> for the derivative. * Any two function objects implementing <code>double operator()( double )</code>
 . One object provides the function evaluation, the other the 
derivative. One or both function object can be a free C function of type
 <code>double ()(double )</code>.</p>
<h4 id="wrapping-multi-dimensional-functions"><span class="header-section-number">13.7.4.3</span> Wrapping Multi-dimensional Functions</h4>
<p>The class <code>ROOT::Math::Functor</code> is used to wrap in a very 
simple and convenient way multi-dimensional function objects. It can 
wrap all the following types: * Any C++ callable object implementing <code>double operator()( const double * )</code>. * A free C function of type <code>double ()(const double * )</code>. * A member function with the correct signature like <code>Foo::Eval(const double * )</code>. In this case one pass the object pointer and a pointer to the member function <code>(&amp;Foo::Eval)</code>.</p>
<p>The function dimension is required when constructing the functor.</p>
<p>Example of using <code>Functor</code>:</p>
<div class="sourceCode" id="cb715"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb715-1" title="1"><span class="pp">#include </span><span class="im">"Math/Functor.h"</span></a>
<a class="sourceLine" id="cb715-2" title="2"></a>
<a class="sourceLine" id="cb715-3" title="3"><span class="kw">class</span> MyFunction {</a>
<a class="sourceLine" id="cb715-4" title="4"></a>
<a class="sourceLine" id="cb715-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb715-6" title="6">   <span class="dt">double</span> <span class="kw">operator</span>()(<span class="at">const</span> <span class="dt">double</span> *x) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb715-7" title="7">      <span class="cf">return</span> x[<span class="dv">0</span>]+x[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb715-8" title="8">   }</a>
<a class="sourceLine" id="cb715-9" title="9"></a>
<a class="sourceLine" id="cb715-10" title="10">   <span class="dt">double</span> Eval(<span class="at">const</span> <span class="dt">double</span> * x) <span class="at">const</span> { <span class="cf">return</span> x[<span class="dv">0</span>]+x[<span class="dv">1</span>]; }</a>
<a class="sourceLine" id="cb715-11" title="11">};</a>
<a class="sourceLine" id="cb715-12" title="12"></a>
<a class="sourceLine" id="cb715-13" title="13"><span class="dt">double</span> freeFunction(<span class="at">const</span> <span class="dt">double</span> * x )</a>
<a class="sourceLine" id="cb715-14" title="14">{</a>
<a class="sourceLine" id="cb715-15" title="15">   <span class="cf">return</span> x[<span class="dv">0</span>]+x[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb715-16" title="16">}</a>
<a class="sourceLine" id="cb715-17" title="17"></a>
<a class="sourceLine" id="cb715-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb715-19" title="19">{</a>
<a class="sourceLine" id="cb715-20" title="20">   <span class="co">// test directly calling the function object</span></a>
<a class="sourceLine" id="cb715-21" title="21">   MyFunction myf;</a>
<a class="sourceLine" id="cb715-22" title="22"></a>
<a class="sourceLine" id="cb715-23" title="23">   <span class="co">// test from a free function pointer</span></a>
<a class="sourceLine" id="cb715-24" title="24">   ROOT::Math::Functor f1(&amp;freeFunction,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb715-25" title="25"></a>
<a class="sourceLine" id="cb715-26" title="26">   <span class="co">// test from function object</span></a>
<a class="sourceLine" id="cb715-27" title="27">   ROOT::Math::Functor f2(myf,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb715-28" title="28"></a>
<a class="sourceLine" id="cb715-29" title="29">   <span class="co">// test from a member function</span></a>
<a class="sourceLine" id="cb715-30" title="30">   ROOT::Math::Functor f3(&amp;myf,&amp;MyFunction::Eval,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb715-31" title="31"></a>
<a class="sourceLine" id="cb715-32" title="32">   <span class="dt">double</span> x[] = {<span class="dv">1</span>,<span class="dv">2</span>};</a>
<a class="sourceLine" id="cb715-33" title="33"></a>
<a class="sourceLine" id="cb715-34" title="34">   cout &lt;&lt; f1(x) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb715-35" title="35">   cout &lt;&lt; f2(x) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb715-36" title="36">   cout &lt;&lt; f3(x) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb715-37" title="37"></a>
<a class="sourceLine" id="cb715-38" title="38">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb715-39" title="39">}</a></code></pre></div>
<h4 id="wrapping-multi-dimensional-gradient-functions"><span class="header-section-number">13.7.4.4</span> Wrapping Multi-dimensional Gradient Functions</h4>
<p>The class <code>ROOT::Math::GradFunctor</code> is used to wrap in a 
very C++ callable object to make gradient functions. It can be 
constructed in three different way: * From an object implementing both <code>double operator()( const double * )</code> for the function evaluation and <code>double Derivative(const double *, int icoord)</code> for the partial derivatives. * From an object implementing any member function like <code>Foo::XXX(const double *)</code> for the function evaluation and any member function like <code>Foo::XXX(const double *, int icoord)</code> for the partial derivatives. * From an function object implementing <code>double operator()( const double * )</code> for the function evaluation and another function object implementing <code>double operator() (const double *, int icoord)</code> for the partial derivatives.</p>
<p>The function dimension is required when constructing the functor.</p>
<h4 id="special-case-wrapping-tf1-objects-in-parametric-function-interfaces"><span class="header-section-number">13.7.4.5</span> Special case: Wrapping TF1 objects in Parametric Function interfaces</h4>
<p>In many cases, the user works with the <code>TF1</code> class. The 
mathematical library in ROOT provides some solutions to wrap these into 
the interfaces needed by other methods. If the desired interface to wrap
 is one-dimensional, the class to use is <code>ROOT::Math::WrappedTF1</code>. The default constructor takes a <code>TF1</code> reference as an argument, that will be wrapped with the interfaces of a <code>ROOT::Math::IParametricGradFunctionOneDim</code>. Example:</p>
<div class="sourceCode" id="cb716"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb716-1" title="1"><span class="pp">#include </span><span class="im">"TF1.h"</span></a>
<a class="sourceLine" id="cb716-2" title="2"><span class="pp">#include </span><span class="im">"Math/WrappedTF1.h"</span></a>
<a class="sourceLine" id="cb716-3" title="3"></a>
<a class="sourceLine" id="cb716-4" title="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb716-5" title="5">{</a>
<a class="sourceLine" id="cb716-6" title="6"></a>
<a class="sourceLine" id="cb716-7" title="7">   TF1 f(<span class="st">"Sin Function"</span>, <span class="st">"sin(x)+y"</span>,<span class="dv">0</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb716-8" title="8"></a>
<a class="sourceLine" id="cb716-9" title="9">   ROOT::Math::WrappedTF1 wf1(f);</a>
<a class="sourceLine" id="cb716-10" title="10"></a>
<a class="sourceLine" id="cb716-11" title="11">   cout &lt;&lt; f(<span class="dv">1</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb716-12" title="12">   cout &lt;&lt; wf1(<span class="dv">1</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb716-13" title="13"></a>
<a class="sourceLine" id="cb716-14" title="14">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb716-15" title="15">}</a></code></pre></div>
<p>For a TF1 defining a multidimensional function or in case we need to 
wrap in a multi-dimensional function interface, the class to use is <code>ROOT::Math::WrappedMultiTF1</code>. Following the usual procedure, setting the <code>TF1</code> though the constructor, will wrap it into a <code>ROOT::Math::IParametricGradFunctionMultiDim</code>. Example:</p>
<div class="sourceCode" id="cb717"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb717-1" title="1"><span class="pp">#include </span><span class="im">"TF1.h"</span></a>
<a class="sourceLine" id="cb717-2" title="2"><span class="pp">#include </span><span class="im">"Math/WrappedMultiTF1.h"</span></a>
<a class="sourceLine" id="cb717-3" title="3"></a>
<a class="sourceLine" id="cb717-4" title="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb717-5" title="5">{</a>
<a class="sourceLine" id="cb717-6" title="6"></a>
<a class="sourceLine" id="cb717-7" title="7">   TF2 f(<span class="st">"Sin Function"</span>, <span class="st">"sin(x) + y"</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb717-8" title="8"></a>
<a class="sourceLine" id="cb717-9" title="9">   ROOT::Math::WrappedMultiTF1 wf1(f);</a>
<a class="sourceLine" id="cb717-10" title="10"></a>
<a class="sourceLine" id="cb717-11" title="11">   <span class="dt">double</span> x[] = {<span class="dv">1</span>,<span class="dv">2</span>};</a>
<a class="sourceLine" id="cb717-12" title="12"></a>
<a class="sourceLine" id="cb717-13" title="13">   cout &lt;&lt; f(x) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb717-14" title="14">   cout &lt;&lt; wf1(x) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb717-15" title="15"></a>
<a class="sourceLine" id="cb717-16" title="16">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb717-17" title="17">}</a></code></pre></div>
<h2 id="numerical-integration"><span class="header-section-number">13.8</span> Numerical Integration</h2>
<p>The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. <code>ROOT::Math::VirtualIntegrator</code> defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in <code>ROOT::Math::VirtualIntegratorOneDim</code> and <code>ROOT::Math::VirtualIntegratorMultiDim</code>.
 These interfaces define the integrator functionality with abstract 
methods to set the function, to compute the integral or to set the 
integration tolerance. These methods must be implemented in the concrete
 classes existing for the different integration algorithms. The user 
cannot create directly these virtual integrator interfaces. He needs to 
create the <code>ROOT::Math::IntegratorOneDim</code> class for integrating one-dimensional functions and <code>ROOT::Math::IntegratorMultiDim</code> for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize <code>ROOT::Math::IntegratorOneDim</code> or <code>ROOT::Math::IntegratorMultiDim</code>
 with any of the concrete integration classes without dealing with them 
directly. These two classes provide the same interface as in <code>VirtualIntegratorOneDim</code> and <code>VirtualIntegratorMultiDim</code>, but with the possibility to choose in the constructor, which method will be used to perform the integration.</p>
<p>The method to set the function to be integrated, must be of the function interface type described before. <code>ROOT::Math::IBaseFunctionOneDimFunction</code> is used for <code>ROOT::Math::IBaseFunctionMultiDim</code> and The only difference between the <code>ROOT::Math::IntegratorOneDim</code> and <code>ROOT::Math::IntegratorMultiDim</code> resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one.</p>
<figure>
<img src="ROOTUsersGuide_files/Integration.png" alt="ROOT::Math Numerical Integrator classes"><figcaption>ROOT::Math Numerical Integrator classes</figcaption>
</figure>
<p>The rest of the classes shown above in the diagram are the 
specialized classes provided. Each one implements a different method 
that will be explained in detail. It is important to notice that the two
 grayed classes (the one which name starts by GSL) are part of the <em>MathMore</em> library. We will later show in more detail the differences between the implementations.</p>
<h3 id="integration-of-one-dimensional-functions"><span class="header-section-number">13.8.1</span> Integration of One-dimensional Functions</h3>
<h4 id="using-rootmathintegratoronedim"><span class="header-section-number">13.8.1.1</span> Using <code>ROOT::Math::IntegratorOneDim</code></h4>
<p>Here is a code example on how to use the <code>ROOT::Math::IntegratorOneDim</code> class (note that the class is defined in the header file <code>Math/Integrator.h</code>).
 In this example we create different instance of the class using some of
 the available algorithms in ROOT. If no algorithm is specified, the 
default one is used. The default Integrator together with other 
integration options such as relative and absolute tolerance, can be 
specified using the static method of the <code>ROOT::Math::IntegratorOneDimOptions</code></p>
<div class="sourceCode" id="cb718"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb718-1" title="1"><span class="pp">#include </span><span class="im">"Math/Integrator.h"</span></a>
<a class="sourceLine" id="cb718-2" title="2"></a>
<a class="sourceLine" id="cb718-3" title="3"><span class="at">const</span> <span class="dt">double</span> ERRORLIMIT = <span class="fl">1E-3</span>;</a>
<a class="sourceLine" id="cb718-4" title="4"></a>
<a class="sourceLine" id="cb718-5" title="5"><span class="dt">double</span> f(<span class="dt">double</span> x) {</a>
<a class="sourceLine" id="cb718-6" title="6">   <span class="cf">return</span> x;</a>
<a class="sourceLine" id="cb718-7" title="7">}</a>
<a class="sourceLine" id="cb718-8" title="8"></a>
<a class="sourceLine" id="cb718-9" title="9"><span class="dt">double</span> f2(<span class="at">const</span> <span class="dt">double</span> * x) {</a>
<a class="sourceLine" id="cb718-10" title="10">   <span class="cf">return</span> x[<span class="dv">0</span>] + x[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb718-11" title="11">}</a>
<a class="sourceLine" id="cb718-12" title="12"></a>
<a class="sourceLine" id="cb718-13" title="13"></a>
<a class="sourceLine" id="cb718-14" title="14"><span class="dt">int</span> testIntegration1D() {</a>
<a class="sourceLine" id="cb718-15" title="15"></a>
<a class="sourceLine" id="cb718-16" title="16">   <span class="at">const</span> <span class="dt">double</span> RESULT = <span class="fl">0.5</span>;</a>
<a class="sourceLine" id="cb718-17" title="17">   <span class="dt">int</span> status = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb718-18" title="18"></a>
<a class="sourceLine" id="cb718-19" title="19">   <span class="co">// set default tolerances for all integrators</span></a>
<a class="sourceLine" id="cb718-20" title="20">   ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(<span class="fl">1.E-6</span>);</a>
<a class="sourceLine" id="cb718-21" title="21">   ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(<span class="fl">1.E-6</span>);</a>
<a class="sourceLine" id="cb718-22" title="22"></a>
<a class="sourceLine" id="cb718-23" title="23">   ROOT::Math::Functor1D wf(&amp;f);</a>
<a class="sourceLine" id="cb718-24" title="24">   ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);</a>
<a class="sourceLine" id="cb718-25" title="25">   ig.SetFunction(wf);</a>
<a class="sourceLine" id="cb718-26" title="26">   <span class="dt">double</span> val = ig.Integral(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb718-27" title="27">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb718-28" title="28">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb718-29" title="29"></a>
<a class="sourceLine" id="cb718-30" title="30">   ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);</a>
<a class="sourceLine" id="cb718-31" title="31">   ig2.SetFunction(wf);</a>
<a class="sourceLine" id="cb718-32" title="32">   val = ig2.Integral(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb718-33" title="33">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb718-34" title="34">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb718-35" title="35"></a>
<a class="sourceLine" id="cb718-36" title="36">   ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);</a>
<a class="sourceLine" id="cb718-37" title="37">   val = ig3.Integral(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb718-38" title="38">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb718-39" title="39">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb718-40" title="40"></a>
<a class="sourceLine" id="cb718-41" title="41">   ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);</a>
<a class="sourceLine" id="cb718-42" title="42">   ig4.SetFunction(wf);</a>
<a class="sourceLine" id="cb718-43" title="43">   val = ig4.Integral(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb718-44" title="44">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb718-45" title="45">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb718-46" title="46"></a>
<a class="sourceLine" id="cb718-47" title="47">   ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kLEGENDRE);</a>
<a class="sourceLine" id="cb718-48" title="48">   ig4.SetFunction(wf);</a>
<a class="sourceLine" id="cb718-49" title="49">   val = ig4.Integral(<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb718-50" title="50">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb718-51" title="51">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb718-52" title="52"></a>
<a class="sourceLine" id="cb718-53" title="53">   <span class="cf">return</span> status;</a>
<a class="sourceLine" id="cb718-54" title="54">}</a></code></pre></div>
<h3 id="one-dimensional-integration-algorithms"><span class="header-section-number">13.8.2</span> One-dimensional Integration Algorithms</h3>
<p>Here we provide a brief description of the different integration 
algorithms, which are also implemented as separate classes. The 
algorithms can be instantiated using the following enumeration values:</p>
<table>
<colgroup>
<col style="width: 53%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Enumeration name</strong></th>
<th><strong>Integrator class</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROOT::Math::IntegratorOneDim::kGAUSS</code></td>
<td><code>ROOT::Math::GaussianIntegrator</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::IntegratorOneDim::kLEGENDRE</code></td>
<td><code>ROOT::Math:::GausLegendreIntegrator</code></td>
</tr>
<tr class="odd">
<td><code>ROOT::Math::Integration::kNONADAPTIVE</code></td>
<td><code>ROOT::Math:::GSLIntegrator</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::Integration::kADAPTIVE</code></td>
<td><code>ROOT::Math:::GSLIntegrator</code></td>
</tr>
<tr class="odd">
<td><code>ROOT::Math::Integration::kADAPTIVESINGULAR</code></td>
<td><code>ROOT::Math:::GSLIntegrator</code></td>
</tr>
</tbody>
</table>
<h4 id="rootmathgaussintegrator"><span class="header-section-number">13.8.2.1</span> ROOT::Math:::GaussIntegrator</h4>
<p>It uses the most basic Gaussian integration algorithm, it uses the 
8-point and the 16-point Gaussian quadrature approximations. It is 
derived from the <code>DGAUSS</code> routine of the <em>CERNLIB</em> by S. Kolbig. This class Here is an example of using directly the <code>GaussIntegrator</code> class</p>
<div class="sourceCode" id="cb719"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb719-1" title="1"><span class="pp">#include </span><span class="im">"TF1.h"</span></a>
<a class="sourceLine" id="cb719-2" title="2"><span class="pp">#include </span><span class="im">"Math/WrappedTF1.h"</span></a>
<a class="sourceLine" id="cb719-3" title="3"><span class="pp">#include </span><span class="im">"Math/GaussIntegrator.h"</span></a>
<a class="sourceLine" id="cb719-4" title="4"></a>
<a class="sourceLine" id="cb719-5" title="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb719-6" title="6">{</a>
<a class="sourceLine" id="cb719-7" title="7">   TF1 f(<span class="st">"Sin Function"</span>, <span class="st">"sin(x)"</span>, <span class="dv">0</span>, TMath::Pi());</a>
<a class="sourceLine" id="cb719-8" title="8">   ROOT::Math::WrappedTF1 wf1(f);</a>
<a class="sourceLine" id="cb719-9" title="9"></a>
<a class="sourceLine" id="cb719-10" title="10">   ROOT::Math::GaussIntegrator ig;</a>
<a class="sourceLine" id="cb719-11" title="11"></a>
<a class="sourceLine" id="cb719-12" title="12">   ig.SetFunction(wf1, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb719-13" title="13">   ig.SetRelTolerance(<span class="fl">0.001</span>);</a>
<a class="sourceLine" id="cb719-14" title="14"></a>
<a class="sourceLine" id="cb719-15" title="15">   cout &lt;&lt; ig.Integral(<span class="dv">0</span>, TMath::PiOver2()) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb719-16" title="16"></a>
<a class="sourceLine" id="cb719-17" title="17">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb719-18" title="18">}</a></code></pre></div>
<h4 id="rootmathgausslegendreintegrator"><span class="header-section-number">13.8.2.2</span> ROOT::Math::GaussLegendreIntegrator</h4>
<p>This class implementes the Gauss-Legendre quadrature formulas. This 
sort of numerical methods requieres that the user specifies the number 
of intermediate function points used in the calculation of the integral.
 It will automatically determine the coordinates and weights of such 
points before performing the integration. We can use the example above, 
but replacing the creation of a <code>ROOT::Math::GaussIntegrator</code> object with <code>ROOT::Math::GaussLegendreIntegrator</code>.</p>
<h4 id="rootmathgslintegrator"><span class="header-section-number">13.8.2.3</span> ROOT::Math::GSLIntegrator</h4>
<p>This is a wrapper for the <em>QUADPACK</em> integrator implemented in
 the GSL library. It supports several integration methods that can be 
chosen in construction time. The default type is adaptive integration 
with singularity applying a Gauss-Kronrod 21-point integration rule. For
 a detail description of the GSL methods visit the GSL user guide This 
class implements the best algorithms for numerical integration for one 
dimensional functions. We encourage the use it as the main option, 
bearing in mind that it uses code from the GSL library, wich is provided
 in the <em>MathMore</em> library of ROOT.</p>
<p>The interface to use is the same as above. We have now the 
possibility to specify a different integration algorithm in the 
constructor of the <code>ROOT::Math::GSLIntegrator</code> class.</p>
<div class="sourceCode" id="cb720"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb720-1" title="1"><span class="co">// create the adaptive integrator with the 51 point rule</span></a>
<a class="sourceLine" id="cb720-2" title="2">ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);</a>
<a class="sourceLine" id="cb720-3" title="3">ig.SetRelTolerance(<span class="fl">1.E-6</span>);  <span class="co">// set relative tolerance</span></a>
<a class="sourceLine" id="cb720-4" title="4">ig.SetAbsTolerance(<span class="fl">1.E-6</span>);   <span class="co">// set absoulte tolerance</span></a></code></pre></div>
<p>The algorithm is controlled by the given absolute and relative 
tolerance. The iterations are continued until the following condition is
 satisfied <span class="math display">\[
absErr &lt;= max ( epsAbs, epsRel * Integral)
\]</span> Where <em>absErr</em> is an estimate of the absolute error (it can be retrieved with <code>GSLIntegrator::Error()</code>) and <em>Integral</em> is the estimate of the function integral (it can be obtained with <code>GSLIntegrator::Result()</code>)</p>
<p>The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the <code>GSL</code> users documentation. * <code>ROOT::Math::Integration::kNONADAPTIVE</code> : based on <code>gsl_integration_qng</code>.
 It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson
 abscissae to sample the integrand at a maximum of 87 points. It is 
provided for fast integration of smooth functions. * <code>ROOT::Math::Integration::kADAPTIVE</code>: based on <code>gsl_integration_qag</code>.
 It is an adaptiva Gauss-Kronrod integration algorithm, the integration 
region is divided into subintervals, and on each iteration the 
subinterval with the largest estimated error is bisected. It is possible
 to specify the integration rule as an extra enumeration parameter. The 
possible rules are * <code>Integration::kGAUSS15</code> : 15 points Gauss-Konrod rule (value = 1) * <code>Integration::kGAUSS21</code> : 21 points Gauss-Konrod rule (value = 2) * <code>Integration::kGAUSS31</code> : 31 points Gauss-Konrod rule (value = 3) * <code>Integration::kGAUSS41</code> : 41 points Gauss-Konrod rule (value = 4) * <code>Integration::kGAUSS51</code> : 51 points Gauss-Konrod rule (value = 5) * <code>Integration::kGAUSS61</code>
 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give 
better accuracy for smooth functions, while lower-order rules save time 
when the function contains local difficulties, such as discontinuities. 
If no integration rule is passed, the 31 points rule is used as default.</p>
<ul>
<li><code>ROOT::Math::Integration::kADAPTIVESINGULAR</code>: based on <code>gsl_integration_qags</code>.
 It is an integration type which can be used in the case of the presence
 of singularities.It uses the Gauss-Kronrod 21-point integration rule. 
This is the default algorithm</li>
</ul>
<p>Note that when using the common <code>ROOT::Math::IntegratorOneDIm</code> class the enumeration type defining the algorithm must be defined in the namespace <code>ROOT::Math::IntegrationOneDim</code>
 (to distinguish from the multi-dimensional case) and the rule 
enumeration (or its corresponding integer) can be passed in the 
constructor of the <code>ROOT::Math::IntegratorOneDIm</code>.</p>
<h3 id="multi-dimensional-integration"><span class="header-section-number">13.8.3</span> Multi-dimensional Integration</h3>
<p>The multi-dimensional integration algorithm should be applied to 
functions with dimension larger than one. Adaptive multi-dimensional 
integration works for low function dimension, while MC integration can 
be applied to higher dimensions.</p>
<h4 id="using-rootmathintegratormultidim"><span class="header-section-number">13.8.3.1</span> Using <code>ROOT::Math::IntegratorMultiDim</code></h4>
<p>Here is a code example on how to use the <code>ROOT::Math::IntegratorOneDim</code> class (note that the class is defined in the header file <code>Math/Integrator.h</code>). In this example we create different instance of the class using some of the available algorithms in ROOT.</p>
<div class="sourceCode" id="cb721"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb721-1" title="1"><span class="pp">#include </span><span class="im">"Math/IntegratorMultiDim.h"</span></a>
<a class="sourceLine" id="cb721-2" title="2"><span class="pp">#include </span><span class="im">"Math/Functor.h"</span></a>
<a class="sourceLine" id="cb721-3" title="3"></a>
<a class="sourceLine" id="cb721-4" title="4"></a>
<a class="sourceLine" id="cb721-5" title="5"><span class="dt">double</span> f2(<span class="at">const</span> <span class="dt">double</span> * x) {</a>
<a class="sourceLine" id="cb721-6" title="6">   <span class="cf">return</span> x[<span class="dv">0</span>] + x[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb721-7" title="7">}</a>
<a class="sourceLine" id="cb721-8" title="8"></a>
<a class="sourceLine" id="cb721-9" title="9"><span class="dt">int</span> testIntegrationMultiDim() {</a>
<a class="sourceLine" id="cb721-10" title="10"></a>
<a class="sourceLine" id="cb721-11" title="11">   <span class="at">const</span> <span class="dt">double</span> RESULT = <span class="fl">1.0</span>;</a>
<a class="sourceLine" id="cb721-12" title="12">   <span class="at">const</span> <span class="dt">double</span> ERRORLIMIT = <span class="fl">1E-3</span>;</a>
<a class="sourceLine" id="cb721-13" title="13">   <span class="dt">int</span> status = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb721-14" title="14"></a>
<a class="sourceLine" id="cb721-15" title="15">   ROOT::Math::Functor wf(&amp;f2,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb721-16" title="16">   <span class="dt">double</span> a[<span class="dv">2</span>] = {<span class="dv">0</span>,<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb721-17" title="17">   <span class="dt">double</span> b[<span class="dv">2</span>] = {<span class="dv">1</span>,<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb721-18" title="18"></a>
<a class="sourceLine" id="cb721-19" title="19">   ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);</a>
<a class="sourceLine" id="cb721-20" title="20">   ig.SetFunction(wf);</a>
<a class="sourceLine" id="cb721-21" title="21">   <span class="dt">double</span> val = ig.Integral(a,b);</a>
<a class="sourceLine" id="cb721-22" title="22">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb721-23" title="23">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb721-24" title="24"></a>
<a class="sourceLine" id="cb721-25" title="25">   ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);</a>
<a class="sourceLine" id="cb721-26" title="26">   ig2.SetFunction(wf);</a>
<a class="sourceLine" id="cb721-27" title="27">   val = ig2.Integral(a,b);</a>
<a class="sourceLine" id="cb721-28" title="28">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb721-29" title="29">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb721-30" title="30"></a>
<a class="sourceLine" id="cb721-31" title="31">   ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);</a>
<a class="sourceLine" id="cb721-32" title="32">   val = ig3.Integral(a,b);</a>
<a class="sourceLine" id="cb721-33" title="33">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb721-34" title="34">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb721-35" title="35"></a>
<a class="sourceLine" id="cb721-36" title="36">   ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);</a>
<a class="sourceLine" id="cb721-37" title="37">   val = ig4.Integral(a,b);</a>
<a class="sourceLine" id="cb721-38" title="38">   <span class="bu">std::</span>cout &lt;&lt; <span class="st">"integral result is "</span> &lt;&lt; val &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb721-39" title="39">   status += <span class="bu">std::</span>fabs(val-RESULT) &gt; ERRORLIMIT;</a>
<a class="sourceLine" id="cb721-40" title="40"></a>
<a class="sourceLine" id="cb721-41" title="41">   <span class="cf">return</span> status;</a>
<a class="sourceLine" id="cb721-42" title="42">}</a></code></pre></div>
<h4 id="multi-dimensions-integration-algorithms"><span class="header-section-number">13.8.3.2</span> Multi-dimensions Integration Algorithms</h4>
<p>Here is the types, that can be specified as enumeration and the corresponding classes</p>
<table>
<colgroup>
<col style="width: 53%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Enumeration name</strong></th>
<th><strong>Integrator class</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROOT::Math::IntegratorMultiDim::kADAPTIVE</code></td>
<td><code>ROOT::Math::AdaptiveIntegratorMultiDim</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::IntegratorMultiDim::kVEGAS</code></td>
<td><code>ROOT::Math:::GSLMCIntegrator</code></td>
</tr>
<tr class="odd">
<td><code>ROOT::Math::IntegratorMultiDim::kMISER</code></td>
<td><code>ROOT::Math:::GSLMCIntegrator</code></td>
</tr>
<tr class="even">
<td><code>ROOT::Math::IntegratorMultiDim::kPLAIN</code></td>
<td><code>ROOT::Math:::GSLMCIntegrator</code></td>
</tr>
</tbody>
</table>
<p>The control parameters for the integration algorithms can be specified using the <code>ROOT::Math::IntegratorMultiDimOptions</code>
 class. Static methods are provided to change the default values. It is 
possible to print the list of default control parameters using the <code>ROOT::Math::IntegratorMultiDimOptions::Print</code> function. Example:</p>
<div class="sourceCode" id="cb722"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb722-1" title="1">ROOT::Math::IntegratorMultiDimOptions opt;</a>
<a class="sourceLine" id="cb722-2" title="2">opt.Print();</a>
<a class="sourceLine" id="cb722-3" title="3">          Integrator Type :        ADAPTIVE</a>
<a class="sourceLine" id="cb722-4" title="4">       Absolute tolerance :           <span class="fl">1e-09</span></a>
<a class="sourceLine" id="cb722-5" title="5">       Relative tolerance :           <span class="fl">1e-09</span></a>
<a class="sourceLine" id="cb722-6" title="6">           Workspace size :          <span class="dv">100000</span></a>
<a class="sourceLine" id="cb722-7" title="7">     (max) function calls :          <span class="dv">100000</span></a></code></pre></div>
<p>Depending on the algorithm, some of the control parameters might have no effect.</p>
<h4 id="rootmathadaptiveintegratormultidim"><span class="header-section-number">13.8.3.3</span> <code>ROOT::Math::AdaptiveIntegratorMultiDim</code></h4>
<p>This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper <em>Genz,
 A.A. Malik, An adaptive algorithm for numerical integration over an 
N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 
295-302</em>. It is part of the <em>MathCore</em> library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.</p>
<h4 id="rootmathgslmcintegrator"><span class="header-section-number">13.8.3.4</span> <code>ROOT::Math::GSLMCIntegrator</code></h4>
<p>It is a class for performing numerical integration of a 
multidimensional function. It uses the numerical integration algorithms 
of GSL, which reimplements the algorithms used in the QUADPACK, a 
numerical integration package written in Fortran. Plain MC, MISER and 
VEGAS integration algorithms are supported for integration over finite 
(hypercubic) ranges. For a detail description of the GSL methods visit 
the GSL users guide. Specific configuration options (documented in the 
GSL user guide) for the <code>ROOT::Math::GSLMCIntegration</code> can be set directly in the class, or when using it via the <code>ROOT::Math::IntegratorMultiDim</code> interface, can be defined using the <code>ROOT::Math::IntegratorMultiDimOptions</code>.</p>
<h2 id="function-derivation"><span class="header-section-number">13.9</span> Function Derivation</h2>
<p>There are in ROOT only two classes to perform numerical derivation. 
One of them is in the MathCore library while the other is in the 
MathMore wrapping an integration function from the GSL library. * 
RichardsonDerivator: Implements the Richardson method for numerical 
integration. It can calculate up to the third derivative of a function. *
 GSLDerivator of <em>MathMore</em> based on GSL.</p>
<h2 id="numerical-minimization"><span class="header-section-number">13.10</span> Numerical Minimization</h2>
<p>The algorithms provided by ROOT for numerical integration are 
implemented following the hierarchy shown in the next image. The left 
branch of classes are used for one dimensional minimization, while the 
right one is used for multidimensional minimization. In the case of 
multidimensional minimization we have also the classes <code>TMinuitMinimizer</code> implemented using <code>TMinuit</code>, <code>TFumiliMinimizer</code> implemented using <code>TFumili</code> for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and <code>Minuit2</code> (or the old version<code>Minuit</code>) for multi dimensional minimization.</p>
<figure>
<img src="ROOTUsersGuide_files/Minimization.png" alt="Numerical Minimization classes"><figcaption>Numerical Minimization classes</figcaption>
</figure>
<h3 id="one-dimensional-minimization"><span class="header-section-number">13.10.1</span> One-Dimensional Minimization</h3>
<p>These algorithms are for finding the minimum of a one-dimensional 
minimization function. The function to minimize must be given to the 
class implementing the algorithm as a <code>ROOT::Math::IBaseFunctionOneDim</code> object. The algorithms supported are only bracketing algorithm which do not use derivatives information.</p>
<p>Two classes exist. One in the <em>MathCore</em> library implementing the Brent method (not using the derivatives) and one in the <em>MathMore</em> library implementing several different methods, using in some case the derivatives.</p>
<h4 id="rootmathbrentminimizer1d"><span class="header-section-number">13.10.1.1</span> <code>ROOT::Math::BrentMinimizer1D</code></h4>
<p>This class implements the Brent method to minimize one-dimensional 
function. An interval containing the function minimum must be provided. 
Here is an example where we define the function to minimize as a <em>lambda</em> function (requires C++11). The function to minimize must be given to the class implementing the algorithm as a <code>ROOT::Math::IBaseFunctionOneDim</code> object.</p>
<div class="sourceCode" id="cb723"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb723-1" title="1">  ROOT::Math::Functor1D func( [](<span class="dt">double</span> x){ <span class="cf">return</span> <span class="dv">1</span> + -<span class="dv">4</span>*x + <span class="dv">1</span>*x*x; } );</a>
<a class="sourceLine" id="cb723-2" title="2"></a>
<a class="sourceLine" id="cb723-3" title="3">   ROOT::Math::BrentMinimizer1D bm;</a>
<a class="sourceLine" id="cb723-4" title="4">   bm.SetFunction(func, -<span class="dv">10</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb723-5" title="5">   bm.Minimize(<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb723-6" title="6">   cout &lt;&lt; <span class="st">"Minimum: f("</span> &lt;&lt; bm.XMinimum() &lt;&lt; <span class="st">") = "</span> &lt;&lt;bm.FValMinimum() &lt;&lt; endl;</a></code></pre></div>
<p>Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the <code>Minimize</code> call, the maximum number of function calls, the relative and absolute tolerance must be provided.</p>
<h4 id="rootmathgslminimizer1d"><span class="header-section-number">13.10.1.2</span> <code>ROOT::Math::GSLMInimizer1D</code></h4>
<p>This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are <em>GOLDENSECTION</em>, which is the simplest method but the slowest and <em>BRENT</em>
 (the default one) which combines the golden section with a parabolic 
interpolation. The algorithm can be chosen as a different enumeration in
 the constructor: * <code>ROOT::Math::Minim1D::kBRENT</code> for the Brent algorithm (default) * <code>ROOT::Math::Minim1D::kGOLDENSECTION</code> for the golden section algorithm</p>
<div class="sourceCode" id="cb724"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb724-1" title="1"> <span class="co">// this makes class with the default Brent algorithm</span></a>
<a class="sourceLine" id="cb724-2" title="2"> ROOT::Math::GSLMinimizer1D minBrent;</a>
<a class="sourceLine" id="cb724-3" title="3">  <span class="co">// this make the class with the Golden Section algorithm</span></a>
<a class="sourceLine" id="cb724-4" title="4">   ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);</a></code></pre></div>
<p>The interface to set the function and to minimize is the same as in the case of the <code>BrentMinimizer1D</code>.</p>
<h4 id="using-the-tf1-class"><span class="header-section-number">13.10.1.3</span> Using the TF1 class</h4>
<p>It is possible to perform the one-dimensional 
minimization/maximization of a function by using directly the function 
class in ROOT, <code>TF1</code> of the <em>Hist</em> library. The minmization is implemented in <code>TF1</code> using the BrentMInimizer1D and available with the class member functions * <code>TF1::GetMinimum</code>/<code>TF1::GetMaximum</code> to find the function minimum/maximum value * <code>TF1::GetMinimumX</code>/<code>TF1::GetMaximumX</code> to find the x value corresponding at the function minimum.</p>
<p>The interval to search for the minimum (the default is the <code>TF1</code> range), tolerance and maximum iterations can be provided as optional parameters of the <code>TF1::GetMinimum/Maximum</code> functions.</p>
<h3 id="multi-dimensional-minimization"><span class="header-section-number">13.10.2</span> Multi-Dimensional Minimization</h3>
<p>All the algorithms for multi-dimensional minimization are implementing the <code>ROOT::Math::Minimizer</code>
 interface and they can be used in the same way and one can switch 
between minimizer at run-time. The minimizer concrete class can be in 
different ROOT libraries and they can be instantiate using the ROOT 
plug-in manager. More information on multi-dimensional minimization is 
provided in the Fitting Histogram chapter.</p>
<h2 id="root-finder-algorithms"><span class="header-section-number">13.11</span> ROOT Finder Algorithms</h2>
<p>The function must be given to the class implementing the algorithm as a <code>ROOT::Math::IBaseFunctionOneDim</code> object. Some of the algorithm requires the derivatives of the function. In that case a <code>ROOT::Math::IGradientFunctionOneDim</code> object must be provided.</p>
<h2 id="generic-vectors-for-2-3-and-4-dimensions-genvector"><span class="header-section-number">13.12</span> Generic Vectors for 2, 3 and 4 Dimensions (GenVector)</h2>
<p><code>GenVector</code> is a package intended to represent vectors and
 their operations and transformations, such as rotations and Lorentz 
transformations, in 3 and 4 dimensions. The 3D space is used to describe
 the geometry vectors and points, while the 4D space-time is used for 
physics vectors representing relativistic particles. These 3D and 4D 
vectors are different from vectors of the linear algebra package, which 
describe generic N-dimensional vectors. Similar functionality is 
currently provided by the CLHEP <vector> and <geometry> packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS <a href="https://root.cern/root/htmldoc/guides/users-guide/Common%20Vector%20package">Common Vector package</a>. In contrast to CLHEP or the ROOT physics libraries, <code>GenVector</code>
 provides class templates for modeling the vectors. The user can control
 how the vector is internally represented. This is expressed by a choice
 of coordinate system, which is supplied as a template parameter when 
the vector is constructed. Furthermore, each coordinate system is itself
 a template, so that the user can specify the underlying scalar type.</geometry></vector></p>
<p>The <code>GenVector</code> classes do not inherit from <strong><code>TObject</code></strong>, therefore cannot be used as in the case of the physics vector classes in ROOT collections.</p>
<p>In addition, to optimize performances, no virtual destructors are 
provided. In the following paragraphs, the main characteristics of <code>GenVector</code> are described. A more detailed description of all the <code>GenVector</code> classes is available also at <a href="http://seal.cern.ch/documents/mathlib/GenVector.pdf" class="uri">http://seal.cern.ch/documents/mathlib/GenVector.pdf</a></p>
<h3 id="main-characteristics"><span class="header-section-number">13.12.1</span> Main Characteristics</h3>
<h4 id="optimal-runtime-performances"><span class="header-section-number">13.12.1.1</span> Optimal Runtime Performances</h4>
<p>We try to minimize any overhead in the run-time performance. We have 
deliberately avoided the use of any virtual function and even virtual 
destructors in the classes. In addition, as much as possible functions 
are defined as inline. For this reason, we have chosen to use template 
classes to implement the <code>GenVector</code> concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the <code>GenVector</code> classes polymorphically and developing classes inheriting from them.</p>
<h4 id="points-and-vector-concept"><span class="header-section-number">13.12.1.2</span> Points and Vector Concept</h4>
<p>Mathematically vectors and points are two distinct concepts. They 
have different transformations, as vectors only rotate while points 
rotate and translate. You can add two vectors but not two points and the
 difference between two points is a vector. We then distinguish for the 3
 dimensional case, between points and vectors, modeling them with 
different classes:</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>DisplacementVector2D</code></strong> and <code>ROOT::Math::</code><strong><code>DisplacementVector3D</code></strong> template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;</p></li>
<li><p><code>ROOT::Math::</code><strong><code>PositionVector2D</code></strong> and <code>ROOT::Math::</code><strong><code>PositionVector3D</code></strong> template classes modeling the points in 2 and 3 dimensions.</p></li>
</ul>
<p>For the 4D space-time vectors, we use the same class to model them, <code>ROOT::Math::</code><strong><code>LorentzVector</code></strong>, since we have recognized a limited need for modeling the functionality of a 4D point.</p>
<h4 id="generic-coordinate-system"><span class="header-section-number">13.12.1.3</span> Generic Coordinate System</h4>
<p>The vector classes are based on a generic type of coordinate system, 
expressed as a template parameter of the class. Various classes exist to
 describe the various coordinates systems:</p>
<p>2D coordinate system classes:</p>
<ul>
<li><p><strong><code>ROOT::Math::Cartesian2D</code></strong>, based on (<code>x,y</code>);</p></li>
<li><p><strong><code>ROOT::Math::Polar2D</code></strong>, based on (<code>r,phi</code>);</p></li>
</ul>
<p>3D coordinate system classes:</p>
<ul>
<li><p><strong><code>ROOT::Math::Cartesian3D</code></strong>, based on (<code>x,y,z</code>);</p></li>
<li><p><strong><code>ROOT::Math::Polar3D</code></strong>, based on (<code>r,theta,phi</code>);</p></li>
<li><p><strong><code>ROOT::Math::Cylindrical3D</code></strong>, based on (<code>rho,z,phi</code>)</p></li>
<li><p><strong><code>ROOT::Math::CylindricalEta3D</code></strong>, based on (<code>rho,eta,phi</code>), where <code>eta</code> is the pseudo-rapidity;</p></li>
</ul>
<p>4D coordinate system classes:</p>
<ul>
<li><p><strong><code>ROOT::Math::PxPyPzE4D</code></strong>, based on based on (<code>px,py,pz,E</code>);</p></li>
<li><p><strong><code>ROOT::Math::PxPyPzM4D</code></strong>, based on based on (<code>px,py,pz,M</code>);</p></li>
<li><p><strong><code>ROOT::Math::PtEtaPhiE4D</code></strong>, based on based on (<code>pt,eta,phi,E</code>);</p></li>
<li><p><strong><code>ROOT::Math::PtEtaPhiM4D</code></strong>, based on based on (<code>pt,eta,phi,M</code>);</p></li>
</ul>
<p>Users can define the vectors according to the coordinate type, which 
is the most efficient for their use. Transformations between the various
 coordinate systems are available through copy constructors or the 
assignment (=) operator. For maximum flexibility and minimize memory 
allocation, the coordinate system classes are templated on the scalar 
type. To avoid exposing templated parameter to the users, typedefs are 
defined for all types of vectors based on doubles. See in the examples 
for all the possible types of vector classes, which can be constructed 
by users with the available coordinate system types.</p>
<h4 id="coordinate-system-tag"><span class="header-section-number">13.12.1.4</span> Coordinate System Tag</h4>
<p>The 2D and 3D points and vector classes can be associated to a tag 
defining the coordinate system. This can be used to distinguish between 
vectors of different coordinate systems like global or local vectors. 
The coordinate system tag is a template parameter of the <strong><code>ROOT::Math::</code></strong><code>DisplacementVector3D</code> and <code>ROOT::Math::PositionVector3D</code> (and also for 2D classes). A default tag exists for users who do not need this functionality, <code>ROOT::Math::DefaultCoordinateSystemTag</code>.</p>
<h4 id="transformations"><span class="header-section-number">13.12.1.5</span> Transformations</h4>
<p>The transformations are modeled using simple (non-template) classes, 
using double as the scalar type to avoid too large numerical errors. The
 transformations are grouped in rotations (in 3 dimensions), Lorentz 
transformations and Poincare transformations, which are translation<code>/</code>rotation
 combinations. Each group has several members which may model physically
 equivalent transformations but with different internal representations.
 Transformation classes can operate on all type of vectors by using the 
operator <code>()</code>or the operator <code>*</code> and the transformations can be combined via the operator <code>*</code>. The available transformations are:</p>
<ul>
<li><p>3D rotation classes</p></li>
<li><p>rotation described by a 3x3 matrix (<strong><code>ROOT::Math::Rotation3D</code></strong>)</p></li>
<li><p>rotation described by Euler angles (<strong><code>ROOT::Math::EulerAngles</code></strong>)</p></li>
<li><p>rotation described by a direction axis and an angle (<strong><code>ROOT::Math::AxisAngle</code></strong>)</p></li>
<li><p>rotation described by a quaternion (<strong><code>ROOT::Math::Quaternion</code></strong>)</p></li>
<li><p>optimized rotation around <code>x</code> (<strong><code>ROOT::Math::RotationX</code></strong>), <code>y</code> (<strong><code>ROOT::Math::RotationY</code></strong>) and <code>z</code> (<strong><code>ROOT::Math::RotationZ</code></strong>) and described by just one angle.</p></li>
<li><p>3D transformation: we describe the transformations defined as a 
composition between a rotation and a translation using the class <strong><code>ROOT::Math::Transform3D</code></strong>.
 It is important to note that transformations act differently on vectors
 and points. The vectors only rotate, therefore when applying a 
transformation (rotation + translation) on a vector, only the rotation 
operates while the translation has no effect. The <strong><code>Transform3D</code></strong> class interface is similar to the one used in the CLHEP Geometry package (class <hepgeom::transform3d>).</hepgeom::transform3d></p></li>
<li><p>Lorentz rotation:</p></li>
<li><p>generic Lorentz rotation described by a <code>4x4</code> matrix containing a 3D rotation part and a boost part (class <strong><code>ROOT::Math::LorentzRotation</code></strong>)</p></li>
<li><p>a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class <strong><code>ROOT::Math::Boost</code></strong>)</p></li>
<li><p>boost along the axis:<code>x</code>(<strong><code>ROOT::Math::BoostX</code></strong>), <code>y</code>(<strong><code>ROOT::Math::BoostY</code></strong>) and <code>z</code>(<strong><code>ROOT::Math::BoostZ</code></strong>).</p></li>
</ul>
<h4 id="minimal-vector-classes-interface"><span class="header-section-number">13.12.1.6</span> Minimal Vector Classes Interface</h4>
<p>We have tried to keep the interface to a minimal level by:</p>
<ul>
<li><p>Avoiding methods that provide the same functionality but use different names (like <code>getX()</code> and <code>x()</code>).</p></li>
<li><p>Minimizing the number of setter methods, avoiding methods, which 
can be ambiguous and can set the vector classes in an inconsistent 
state. We provide only methods which set all the coordinates at the same
 time or set only the coordinates on which the vector is based, for 
example <code>SetX()</code> for a Cartesian vector. We then enforce the 
use of transformations as rotations or translations (additions) for 
modifying the vector contents.</p></li>
<li><p>The majority of the functionality, which is present in the CLHEP 
package, involving operations on two vectors, is moved in separated 
helper functions (see <code>ROOT::Math::VectorUtil</code>). This has the
 advantage that the basic interface will remain more stable with time 
while additional functions can be added easily.</p></li>
</ul>
<h4 id="naming-convention"><span class="header-section-number">13.12.1.7</span> Naming Convention</h4>
<p>As part of ROOT, the <code>GenVector</code> package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:</p>
<ul>
<li><p>Every class and function is in the <strong><code>ROOT::Math</code></strong> namespace.</p></li>
<li><p>Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility).</p></li>
</ul>
<h4 id="compatibility-with-clhep-vector-classes"><span class="header-section-number">13.12.1.8</span> Compatibility with CLHEP Vector Classes</h4>
<ul>
<li><p>For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP <code>HepVector</code> or <strong><code>HepLorentzVector</code></strong>, by using a template constructor, which requires only that the classes implement the accessors<code>x()</code>, <code>y()</code>, and <code>z()</code> (and <code>t()</code> for the 4D).</p></li>
<li><p>We provide vector member function with the same naming convention as CLHEP for the most used functions like <code>x()</code>, <code>y()</code> and <code>z()</code>.</p></li>
</ul>
<h4 id="connection-to-linear-algebra-package"><span class="header-section-number">13.12.1.9</span> Connection to Linear Algebra Package</h4>
<p>In some use cases, like in track reconstruction, it is needed to use 
the content of the vector and rotation classes in conjunction with 
linear algebra operations. We prefer to avoid any direct dependency to 
any linear algebra package. However, we provide some hooks to convert to
 and from linear algebra classes. The vector and the transformation 
classes have methods which allow to get and set their data members (like
 <code>SetCoordinates</code> and <code>GetCoordinates</code>) passing 
either a generic iterator or a pointer to a contiguous set of data, like
 a C array. This allows an easy connection with the linear algebra 
package, which in turn, allows creation of matrices using C arrays (like
 the ROOT <strong><code>TMatrix</code></strong> classes) or iterators (<code>SMatrix</code> classes). Multiplication between linear algebra matrices and <code>GenVector</code> vectors is possible by using the template free functions <code>ROOT::Math::VectorUtil::Mult</code>. This function works for any linear algebra matrix, which implements the operator (<code>i,j</code>) and with first matrix element at <code>i=j=0</code>.</p>
<h3 id="example-3d-vector-classes"><span class="header-section-number">13.12.2</span> Example: 3D Vector Classes</h3>
<p>To avoid exposing template parameter to the users, typedef’s are 
defined for all types of vectors based on double’s and float’s. To use 
them, one must include the header file <code>Math/Vector3D.h</code>. The following typedef’s, defined in the header file <code>Math/Vector3Dfwd.h</code>, are available for the different instantiations of the template class <code>ROOT::Math::</code><strong><code>DisplacementVector3D</code></strong>:</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>XYZVector</code></strong> vector based on <code>x,y,z</code> coordinates (Cartesian) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>XYZVectorF</code></strong> vector based on <code>x,y,z</code> coordinates (Cartesian) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Polar3DVector</code></strong> vector based on <code>r,theta,phi</code> coordinates (polar) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Polar3DVectorF</code></strong> vector based on <code>r,theta,phi</code> coordinates (polar) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoZPhiVector</code></strong> vector based on <code>rho,z,phi</code> coordinates (cylindrical) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoZPhiVectorF</code></strong> vector based on <code>rho,z,phi</code> coordinates (cylindrical) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoEtaPhiVector</code></strong> vector based on <code>rho,eta,phi</code> coordinates (cylindrical using <code>eta</code> instead of <code>z</code>) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoEtaPhiVectorF</code></strong> vector based on <code>rho,eta,phi</code> coordinates (cylindrical using <code>eta</code> instead of <code>z</code>) in float precision</p></li>
</ul>
<h4 id="constructors-and-assignment"><span class="header-section-number">13.12.2.1</span> Constructors and Assignment</h4>
<p>The following declarations are available:</p>
<div class="sourceCode" id="cb725"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb725-1" title="1">XYZVector       v1;             <span class="co">//an empty vector (x=0, y=0, z=0)</span></a>
<a class="sourceLine" id="cb725-2" title="2">XYZVector       v2(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);      <span class="co">//vector with x=1, y=2, z=3;</span></a>
<a class="sourceLine" id="cb725-3" title="3">Polar3DVector   v3(<span class="dv">1</span>,PI/<span class="dv">2</span>,PI);  <span class="co">//vector with r=1, theta=PI/2, phi=PI</span></a>
<a class="sourceLine" id="cb725-4" title="4">RhoEtaPHiVector v4(<span class="dv">1</span>,<span class="dv">2</span>, PI);    <span class="co">//vector with rho=1, eta=2, phi=PI</span></a></code></pre></div>
<p>Note that each vector type is constructed by passing its coordinate representation, so a <code>XYZVector(1,2,3)</code> is different from a <code>Polar3DVector(1,2,3)</code>. In addition, the vector classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code> and <code>z()</code>.
 This can be another 3D vector based on a different coordinate system 
type. It can be even any vector of a different package, like the CLHEP <strong><code>HepThreeVector</code></strong> that implements the required signature.</p>
<div class="sourceCode" id="cb726"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb726-1" title="1">   XYZVector    v1(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb726-2" title="2">   RhoEtaPhiVector    r2(v1);</a>
<a class="sourceLine" id="cb726-3" title="3">   CLHEP::HepThreeVector  q(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb726-4" title="4">   XYZVector    v3(q);</a></code></pre></div>
<h4 id="coordinate-accessors"><span class="header-section-number">13.12.2.2</span> Coordinate Accessors</h4>
<p>All coordinate accessors are available through the class <code>ROOT::Math::</code><strong><code>DisplacementVector3D</code></strong>:</p>
<div class="sourceCode" id="cb727"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb727-1" title="1">   <span class="co">//returns cartesian components for the cartesian vector v1</span></a>
<a class="sourceLine" id="cb727-2" title="2">   v1.X(); v1.Y(); v1.Z();</a>
<a class="sourceLine" id="cb727-3" title="3">   <span class="co">//returns cylindrical components for the cartesian vector v1</span></a>
<a class="sourceLine" id="cb727-4" title="4">   v1.Rho(); v1.Eta(); v1.Phi();</a>
<a class="sourceLine" id="cb727-5" title="5">   <span class="co">//returns cartesian components for the cylindrical vector r2</span></a>
<a class="sourceLine" id="cb727-6" title="6">   r2.X(); r2.Y(); r2.Z()</a></code></pre></div>
<p>In addition, all the 3 coordinates of the vector can be retrieved with the <code>GetCoordinates</code> method:</p>
<div class="sourceCode" id="cb728"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb728-1" title="1">   <span class="dt">double</span> d[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb728-2" title="2">   <span class="co">//fill d array with (x,y,z) components of v1</span></a>
<a class="sourceLine" id="cb728-3" title="3">   v1.GetCoordinates(d);</a>
<a class="sourceLine" id="cb728-4" title="4">   <span class="co">//fill d array with (r,eta,phi) components of r2</span></a>
<a class="sourceLine" id="cb728-5" title="5">   r2.GetCoordinates(d);</a>
<a class="sourceLine" id="cb728-6" title="6">   <span class="bu">std::</span>vector vc(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb728-7" title="7">   <span class="co">//fill std::vector with (x,y,z) components of v1</span></a>
<a class="sourceLine" id="cb728-8" title="8">   v1.GetCoordinates(vc.begin(),vc.end());</a></code></pre></div>
<p>See the reference documentation of <code>ROOT::Math::</code><strong><code>DisplacementVector3D</code></strong> for more details on all the coordinate accessors.</p>
<h4 id="setter-methods"><span class="header-section-number">13.12.2.3</span> Setter Methods</h4>
<p>One can set only all the three coordinates via:</p>
<div class="sourceCode" id="cb729"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb729-1" title="1">   v1.SetCoordinates(c1,c2,c3);  <span class="co">// (x,y,z) for a XYZVector</span></a>
<a class="sourceLine" id="cb729-2" title="2">   r2.SetCoordinates(c1,c2,c3);  <span class="co">// r,theta,phi for a Polar3DVector</span></a>
<a class="sourceLine" id="cb729-3" title="3">   r2.SetXYZ(x,y,z);   <span class="co">// 3 cartesian components for Polar3DVector</span></a></code></pre></div>
<p>Single coordinate setter methods are available for the basic vector coordinates, like <code>SetX()</code> for a <strong><code>XYZVector</code></strong> or <code>SetR()</code> for a polar vector. Attempting to do a <code>SetX()</code> on a polar vector will not compile.</p>
<div class="sourceCode" id="cb730"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb730-1" title="1">   XYZVector v1;</a>
<a class="sourceLine" id="cb730-2" title="2">   v1.SetX(<span class="dv">1</span>);   <span class="co">//OK setting x for a Cartesian vector</span></a>
<a class="sourceLine" id="cb730-3" title="3">   Polar3DVector v2;</a>
<a class="sourceLine" id="cb730-4" title="4">   v2.SetX(<span class="dv">1</span>);   <span class="co">//ERROR: cannot set X for a Polar vector.</span></a>
<a class="sourceLine" id="cb730-5" title="5">   <span class="co">//Method will not compile</span></a>
<a class="sourceLine" id="cb730-6" title="6">   v2.SetR(<span class="dv">1</span>);   <span class="co">//OK setting r for a Polar vector</span></a></code></pre></div>
<p>In addition, there are setter methods from C arrays or iterator</p>
<div class="sourceCode" id="cb731"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb731-1" title="1">   <span class="dt">double</span> d[<span class="dv">3</span>] = {<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>};</a>
<a class="sourceLine" id="cb731-2" title="2">   XYZVector v;</a>
<a class="sourceLine" id="cb731-3" title="3">   <span class="co">// set (x,y,z) components of v using values from d</span></a>
<a class="sourceLine" id="cb731-4" title="4">   v.SetCoordinates(d);</a></code></pre></div>
<p>or, for example, from an <code>std::vector</code> using the iterator</p>
<div class="sourceCode" id="cb732"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb732-1" title="1">   <span class="bu">std::</span>vector w(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb732-2" title="2">   <span class="co">// set (x,y,z) components of v using values from w</span></a>
<a class="sourceLine" id="cb732-3" title="3">   v.SetCoordinates(w.begin(),w.end());</a></code></pre></div>
<h4 id="arithmetic-operations"><span class="header-section-number">13.12.2.4</span> Arithmetic Operations</h4>
<p>The following operations are possible between vector classes, even of different coordinate system types: (<code>v1,v2</code> are any type of <strong><code>ROOT::Math::DisplacementVector3D</code></strong> classes, <code>v3</code> is the same type of <code>v1</code>; <code>a</code> is a scalar value)</p>
<div class="sourceCode" id="cb733"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb733-1" title="1">   v1 += v2;</a>
<a class="sourceLine" id="cb733-2" title="2">   v1 -= v2;</a>
<a class="sourceLine" id="cb733-3" title="3">   v1 = - v2;</a>
<a class="sourceLine" id="cb733-4" title="4">   v1 *= a;</a>
<a class="sourceLine" id="cb733-5" title="5">   v1 /= a;</a>
<a class="sourceLine" id="cb733-6" title="6">   v2 = a * v1;</a>
<a class="sourceLine" id="cb733-7" title="7">   v2 = v1 / a;</a>
<a class="sourceLine" id="cb733-8" title="8">   v2 = v1 * a;</a>
<a class="sourceLine" id="cb733-9" title="9">   v3 = v1 + v2;</a>
<a class="sourceLine" id="cb733-10" title="10">   v3 = v1 - v2;</a></code></pre></div>
<h4 id="comparison"><span class="header-section-number">13.12.2.5</span> Comparison</h4>
<p>For <code>v1</code> and <code>v2</code> of the same type (same coordinate system and same scalar type):</p>
<div class="sourceCode" id="cb734"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb734-1" title="1">   v1 == v2;</a>
<a class="sourceLine" id="cb734-2" title="2">   v1 != v2;</a></code></pre></div>
<h4 id="dot-and-cross-product"><span class="header-section-number">13.12.2.6</span> Dot and Cross Product</h4>
<p>We support the dot and cross products, through the <code>Dot()</code> and <code>Cross()</code> method, with any vector (<code>q</code>) implementing <code>x()</code>, <code>y()</code> and <code>z()</code>.</p>
<div class="sourceCode" id="cb735"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb735-1" title="1">   XYZVector v1(x,y,z);</a>
<a class="sourceLine" id="cb735-2" title="2">   <span class="dt">double</span> s = v1.Dot(q);</a>
<a class="sourceLine" id="cb735-3" title="3">   XYZVector v2 = v1.Cross(q);</a></code></pre></div>
<p>Note that the multiplication between two vectors using the operator <code>*</code> is not supported because it is ambiguous.</p>
<h4 id="other-methods"><span class="header-section-number">13.12.2.7</span> Other Methods</h4>
<div class="sourceCode" id="cb736"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb736-1" title="1">   XYZVector u = v1.Unit(); <span class="co">//return unit vector parallel to v1</span></a></code></pre></div>
<h3 id="example-3d-point-classes"><span class="header-section-number">13.12.3</span> Example: 3D Point Classes</h3>
<p>To use all possible types of 3D points one must include the header file <code>Math/Point3D.h</code>. The following typedef’s defined in the header file <code>Math/Point3Dfwd.h</code>, are available for different instantiations of the template class <strong><code>ROOT::Math</code></strong><code>::</code><strong><code>PositionVector3D</code></strong>:</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>XYZPoint</code></strong> point based on <code>x</code>, <code>y</code>, <code>z</code> coordinates (Cartesian) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>XYZPointF</code></strong> point based on <code>x</code>, <code>y</code>, <code>z</code> coordinates (Cartesian) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Polar3DPoint</code></strong> point based on <code>r</code>, <code>theta</code>, <code>phi</code> coordinates (polar) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Polar3DPointF</code></strong> point based on <code>r</code>, <code>theta</code>, <code>phi</code> coordinates (polar) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoZPhiPoint</code></strong> point based on <code>rho</code>, <code>z</code>, <code>phi</code> coordinates (cylindrical using <code>z</code>) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoZPhiPointF</code></strong> point based on <code>rho</code>, <code>z</code>, <code>phi</code> coordinates (cylindrical using <code>z</code>) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoEtaPhiPoint</code></strong> point based on <code>rho</code>, <code>eta</code>, <code>phi</code> coordinates (cylindrical using eta instead of <code>z</code>) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RhoEtaPhiPointF</code></strong> point based on <code>rho</code>, <code>eta</code>, <code>phi</code> coordinates (cylindrical using eta instead of <code>z</code>) in float precision</p></li>
</ul>
<h4 id="constructors-and-assignment-1"><span class="header-section-number">13.12.3.1</span> Constructors and Assignment</h4>
<p>The following declarations are available:</p>
<div class="sourceCode" id="cb737"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb737-1" title="1">   XYZPoint         p1;             <span class="co">//an empty vector (x=0, y=0, z=0)</span></a>
<a class="sourceLine" id="cb737-2" title="2">   XYZPoint         p2(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);      <span class="co">//</span></a></code></pre></div>
<p>Note that each point type is constructed by passing its coordinate representation, so a <code>XYZPoint(1,2,3)</code> is different from a <code>Polar3DPoint(1,2,3)</code>. In addition the point classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code> and <code>z()</code>.
 This can be another 3D point based on a different coordinate system 
type or even any vector of a different package, like the CLHEP <strong><code>HepThreePoint</code></strong> that implements the required signatures.</p>
<div class="sourceCode" id="cb738"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb738-1" title="1">   XYZPoint             p1(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb738-2" title="2">   RhoEtaPHiPoint       r2(v1);</a>
<a class="sourceLine" id="cb738-3" title="3">   CLHEP::HepThreePoint q(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb738-4" title="4">   XYZPoint             p3(q);</a></code></pre></div>
<h4 id="coordinate-accessors-and-setter-methods"><span class="header-section-number">13.12.3.2</span> Coordinate Accessors and Setter Methods</h4>
<p>For the points classes we have the same getter and setter methods as for the vector classes. See “Example: 3D Vector Classes”.</p>
<h4 id="point-vector-operations"><span class="header-section-number">13.12.3.3</span> Point-Vector Operations</h4>
<p>The following operations are possible between points and vector classes: (<code>p1</code>, <code>p2</code> and <code>p3</code> are instantiations of the <code>ROOT::Math::</code><strong><code>PositionVector3D</code></strong> objects with <code>p1</code> and <code>p3</code> of the same type; <code>v1</code> and <code>v2</code> are <code>ROOT::Math::</code><strong><code>DisplacementVector3D</code></strong> objects).</p>
<div class="sourceCode" id="cb739"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb739-1" title="1">   p1 += v1;</a>
<a class="sourceLine" id="cb739-2" title="2">   p1 -= v1;</a>
<a class="sourceLine" id="cb739-3" title="3">   p3 = p1 + v1;    <span class="co">// p1 and p3 are the same type</span></a>
<a class="sourceLine" id="cb739-4" title="4">   p3 = v1 + p1;    <span class="co">// p3 is based on the same coordinate system as v1</span></a>
<a class="sourceLine" id="cb739-5" title="5">   p3 = p1 - v1;</a>
<a class="sourceLine" id="cb739-6" title="6">   p3 = v1 - p1;</a>
<a class="sourceLine" id="cb739-7" title="7">   v2 = p1 - p2;    <span class="co">// difference between points returns a vector v2</span></a>
<a class="sourceLine" id="cb739-8" title="8">                    <span class="co">// based on the same coordinate system as p1</span></a></code></pre></div>
<p>Note that the addition between two points is <strong>NOT</strong> possible and the difference between points returns a vector.</p>
<h4 id="other-operations"><span class="header-section-number">13.12.3.4</span> Other Operations</h4>
<p>Exactly as for the 3D Vectors, the following operations are allowed:</p>
<ul>
<li><p>comparison of points</p></li>
<li><p>scaling and division of points with a scalar</p></li>
<li><p>dot and cross product with any type of vector</p></li>
</ul>
<h3 id="example-lorentzvector-classes"><span class="header-section-number">13.12.4</span> Example: LorentzVector Classes</h3>
<p>As in the 3D case, typedef’s are defined for user convenience. and can be used by including the header file <code>Math/Vector4D.h</code>. The following typedef’s, defined in the header file <code>Math/Vector4Dfwd.h</code>, are available for the different instantiations of the template class <strong><code>ROOT::Math::LorentzVector</code></strong>:</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>XYZTVector</code></strong> vector based on <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> coordinates (Cartesian) in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>XYZTVectorF</code></strong> vector based on <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> coordinates (Cartesian) in float precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>PtEtaPhiEVector</code></strong> vector based on <code>pt(rho)</code>, <code>eta</code>, <code>phi</code> and <code>E(t)</code> coordinates in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>PtEtaPhiMVector</code></strong> vector based on <code>pt(rho)</code>, <code>eta</code>, <code>phi</code> and <code>M(t)</code> coordinates in double precision</p></li>
<li><p><code>ROOT::Math::</code><strong><code>PxPyPzMVector</code></strong> vector based on <code>px</code>, <code>py</code>, <code>pz</code> and <code>M(mass)</code> coordinates in double precision</p></li>
</ul>
<p>The metric used for all the LorentzVector is (<code>-,-,-,+</code>) .</p>
<h4 id="constructors-and-assignment-2"><span class="header-section-number">13.12.4.1</span> Constructors and Assignment</h4>
<p>The following declarations are available:</p>
<div class="sourceCode" id="cb740"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb740-1" title="1">   <span class="co">// create an empty vector (x=0, y=0, z=0, t=0)</span></a>
<a class="sourceLine" id="cb740-2" title="2">   XYZTVector      v1;</a>
<a class="sourceLine" id="cb740-3" title="3">   <span class="co">// vector with x=1, y=2, z=3, t=4</span></a>
<a class="sourceLine" id="cb740-4" title="4">   XYZTVector      v2(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb740-5" title="5">   <span class="co">// vector with pt=1, eta=2, phi=PI, E=5</span></a>
<a class="sourceLine" id="cb740-6" title="6">   PtEtaPhiEVector v3(<span class="dv">1</span>,<span class="dv">2</span>,PI,<span class="dv">5</span>);</a></code></pre></div>
<p>Note that each type of vector is constructed by passing its coordinate representation, so a <strong><code>XYZTVector</code></strong><code>(1,2,3,4)</code> is different from a <code>PtEtaPhiEVector(1,2,3,4)</code>. In addition, the Vector classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code>.</p>
<p>This can be another <code>ROOT::Math::</code><strong><code>LorentzVector</code></strong> based on a different coordinate system or any vector of a different package, like the CLHEP <strong><code>HepLorentzVector</code></strong> that implements the required signature.</p>
<div class="sourceCode" id="cb741"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb741-1" title="1">   XYZTVector              v1(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb741-2" title="2">   PtEtaPhiEVector         v2(v1);</a>
<a class="sourceLine" id="cb741-3" title="3">   CLHEP::HepLorentzVector q(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb741-4" title="4">   XYZTVector              v3(q);</a></code></pre></div>
<h4 id="coordinate-accessors-1"><span class="header-section-number">13.12.4.2</span> Coordinate Accessors</h4>
<p>All the same coordinate accessors are available through the interface of <code>ROOT::Math::</code><strong><code>LorentzVector</code></strong>. For example:</p>
<div class="sourceCode" id="cb742"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb742-1" title="1">   <span class="co">//returns cartesian components for the cartesian vector v1</span></a>
<a class="sourceLine" id="cb742-2" title="2">   v1.X(); v1.X(); v1.Z(); v1.T();</a>
<a class="sourceLine" id="cb742-3" title="3">   <span class="co">//returns cartesian components for the cylindrical vector v2</span></a>
<a class="sourceLine" id="cb742-4" title="4">   v2.Px(); v2.Py(); v2.Pz(); v2.E();</a>
<a class="sourceLine" id="cb742-5" title="5">   <span class="co">//returns other components for the cartesian vector v1</span></a>
<a class="sourceLine" id="cb742-6" title="6">   v1.Pt(); v1.Eta(); v1.Phi(); v1.M()</a></code></pre></div>
<p>In addition, all 4 vector coordinates can be retrieved with the <code>GetCoordinates</code> method:</p>
<div class="sourceCode" id="cb743"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb743-1" title="1">   <span class="dt">double</span> d[<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb743-2" title="2">   <span class="co">//fill d array with (x,y,z,t) components of v1</span></a>
<a class="sourceLine" id="cb743-3" title="3">   v1.GetCoordinates(d);</a>
<a class="sourceLine" id="cb743-4" title="4">   <span class="co">//fill d array with (pt,eta,phi,e) components of v2</span></a>
<a class="sourceLine" id="cb743-5" title="5">   v2.GetCoordinates(d);</a>
<a class="sourceLine" id="cb743-6" title="6">   <span class="bu">std::</span>vector w(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb743-7" title="7">   <span class="co">//fill std::vector with (x,y,z,t)</span></a>
<a class="sourceLine" id="cb743-8" title="8">   v1.GetCoordinates(w.begin(),w.end());</a>
<a class="sourceLine" id="cb743-9" title="9">   <span class="co">//components of v1</span></a></code></pre></div>
<p>To get information on all the coordinate accessors see the <code>ROOT::Math::</code><strong><code>LorentzVector</code></strong> reference documentation.</p>
<h4 id="setter-methods-1"><span class="header-section-number">13.12.4.3</span> Setter Methods</h4>
<p>One can set only all the three coordinates via:</p>
<div class="sourceCode" id="cb744"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb744-1" title="1">   <span class="co">//sets the (x,y,z,t) for a XYZTVector</span></a>
<a class="sourceLine" id="cb744-2" title="2">   v1.SetCoordinates(c1,c2,c3,c4);</a>
<a class="sourceLine" id="cb744-3" title="3">   <span class="co">//sets pt,eta,phi,e for a PtEtaPhiEVector</span></a>
<a class="sourceLine" id="cb744-4" title="4">   v2.SetCoordinates(c1,c2,c3,c4);</a>
<a class="sourceLine" id="cb744-5" title="5">   <span class="co">//sets cartesian components for PtEtaPhiEVector</span></a>
<a class="sourceLine" id="cb744-6" title="6">   v2.SetXYZ(x,y,z,t);</a></code></pre></div>
<p>Single coordinate setter methods are available for the basic vector coordinates, like <code>SetX()</code> for a <code>XYZTVector</code> or <code>SetPt()</code> for a <strong><code>PtEtaPhiEVector</code></strong>. Attempting to do a <code>SetX()</code> on a non-Cartesian vector will not compile.</p>
<div class="sourceCode" id="cb745"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb745-1" title="1">   XYZTVector      v1;</a>
<a class="sourceLine" id="cb745-2" title="2">   v1.SetX(<span class="dv">1</span>);  <span class="co">//OK setting x for a cartesian vector</span></a>
<a class="sourceLine" id="cb745-3" title="3">   PtEtaPhiEVector v2;</a>
<a class="sourceLine" id="cb745-4" title="4">   v2.SetX(<span class="dv">1</span>);  <span class="co">//ERROR: cannot set X for a non-cartesian</span></a>
<a class="sourceLine" id="cb745-5" title="5">                <span class="co">//vector. Method will not compile.</span></a>
<a class="sourceLine" id="cb745-6" title="6">   v2.SetR(<span class="dv">1</span>)   <span class="co">// OK setting Pt for a  PtEtaPhiEVector vector</span></a></code></pre></div>
<p>In addition, there are setter methods from C arrays or iterators.</p>
<div class="sourceCode" id="cb746"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb746-1" title="1">   <span class="dt">double</span> d[<span class="dv">4</span>] = {<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>,<span class="fl">4.</span>};</a>
<a class="sourceLine" id="cb746-2" title="2">   XYZTVector v;</a>
<a class="sourceLine" id="cb746-3" title="3">   <span class="co">//set (x,y,z,t) components of v using values from d</span></a>
<a class="sourceLine" id="cb746-4" title="4">   v.SetCoordinates(d);</a></code></pre></div>
<p>or for example from an <code>std::vector</code>using the iterators</p>
<div class="sourceCode" id="cb747"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb747-1" title="1">   <span class="bu">std::</span>vector w(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb747-2" title="2">   <span class="co">//set (x,y,z,t) components of v using values from w</span></a>
<a class="sourceLine" id="cb747-3" title="3">   v.SetCoordinates(w.begin(),w.end());</a></code></pre></div>
<h4 id="arithmetic-operations-1"><span class="header-section-number">13.12.4.4</span> Arithmetic Operations</h4>
<p>The following operations are possible between Lorentz vectors classes, even of different coordinate system types: (<code>v</code> and<code>w</code> are two Lorentz vector of the same type, <code>q</code>is a generic Lorentz vector implementing <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code>, and <code>a</code> is a generic scalar type: double, float, int, etc.) .</p>
<div class="sourceCode" id="cb748"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb748-1" title="1">   v += q;</a>
<a class="sourceLine" id="cb748-2" title="2">   v -= q;</a>
<a class="sourceLine" id="cb748-3" title="3">   v  = -q;</a>
<a class="sourceLine" id="cb748-4" title="4">   v *= a;</a>
<a class="sourceLine" id="cb748-5" title="5">   v /= a;</a>
<a class="sourceLine" id="cb748-6" title="6">   w = v + q;</a>
<a class="sourceLine" id="cb748-7" title="7">   w = v - q;</a>
<a class="sourceLine" id="cb748-8" title="8">   w = v * a;</a>
<a class="sourceLine" id="cb748-9" title="9">   w = a * v;</a>
<a class="sourceLine" id="cb748-10" title="10">   w = v / a;</a></code></pre></div>
<h4 id="comparison-1"><span class="header-section-number">13.12.4.5</span> Comparison</h4>
<div class="sourceCode" id="cb749"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb749-1" title="1">   v == w;</a>
<a class="sourceLine" id="cb749-2" title="2">   v != w;</a></code></pre></div>
<h4 id="other-methods-1"><span class="header-section-number">13.12.4.6</span> Other Methods</h4>
<div class="sourceCode" id="cb750"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb750-1" title="1">   a =  v.Dot(q); <span class="co">//dot product in metric(+,+,+,-) of 2 LorentzVectors</span></a>
<a class="sourceLine" id="cb750-2" title="2">   XYZVector s = v.Vect() <span class="co">//return the spatial components (x,y,z)</span></a>
<a class="sourceLine" id="cb750-3" title="3">   v.Beta(); <span class="co">//return beta and gamma value (vector must</span></a>
<a class="sourceLine" id="cb750-4" title="4">   v.Gamma() <span class="co">// be time-like otherwise result is meaningless)</span></a>
<a class="sourceLine" id="cb750-5" title="5">   XYZVector b = v.BoostToCM(); <span class="co">//return boost vector which will bring</span></a>
<a class="sourceLine" id="cb750-6" title="6">                                <span class="co">//the Vector in its mas frame (P=0)</span></a></code></pre></div>
<h3 id="example-vector-transformations"><span class="header-section-number">13.12.5</span> Example: Vector Transformations</h3>
<p>Transformation classes are grouped in rotations (in three 
dimensions), Lorentz transformations and Poincaré transformations, which
 are translation<code>/</code>rotation combinations. Each group has 
several members which may model physically equivalent transformations 
but with different internal representations. All the classes are 
non-template and use double precision as the scalar type. The following 
types of transformation classes are defined:</p>
<p>3D rotations:</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>Rotation3D</code></strong>, rotation described by a 3x3 matrix of doubles</p></li>
<li><p><code>ROOT::Math::</code><strong><code>EulerAngles</code></strong> rotation described by the three Euler angles (<code>phi</code>, <code>theta</code> and <code>psi</code>) following the <a href="https://root.cern/root/htmldoc/guides/users-guide/GoldStein%20definition">GoldStein definition</a>.</p></li>
<li><p><strong><code>ROOT::Math::RotationZYX</code></strong> rotation described by three angles defining a rotation first along the <code>Z</code> axis, then along the rotated <code>Y'</code> axis and then along the rotated <code>X''</code> axis.</p></li>
<li><p><code>ROOT::Math::</code><strong><code>AxisAngle</code></strong>, rotation described by a vector (axis) and an angle</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Quaternion</code></strong>, rotation described by a quaternion (4 numbers)</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RotationX</code></strong>, specialized rotation along the X axis</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RotationY</code></strong>, specialized rotation along the Y axis</p></li>
<li><p><code>ROOT::Math::</code><strong><code>RotationZ</code></strong>, specialized rotation along the Z axis</p></li>
</ul>
<p>3D transformations (rotations + translations)</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>Transform3D</code></strong>, (rotations and then translation) described by a 3x4 matrix (12 double numbers)</p></li>
<li><p><strong><code>ROOT::Math::Translation3D</code></strong> (only translation) described by a 3D Vector</p></li>
</ul>
<p>Lorentz rotations and boosts</p>
<ul>
<li><p><code>ROOT::Math::</code><strong><code>LorentzRotation</code></strong>, 4D rotation (3D rotation plus a boost) described by a 4x4 matrix</p></li>
<li><p><code>ROOT::Math::</code><strong><code>Boost</code></strong>, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetrix matrix (10 numbers)</p></li>
<li><p><code>ROOT::Math::</code><strong><code>BoostX</code></strong>, a boost in the X axis direction</p></li>
<li><p><code>ROOT::Math::</code><strong><code>BoostY</code></strong>, a boost in the Y axis direction</p></li>
<li><p><code>ROOT::Math::</code><strong><code>BoostZ</code></strong>, a boost in the Z axis direction</p></li>
</ul>
<h4 id="constructors"><span class="header-section-number">13.12.5.1</span> Constructors</h4>
<p>All rotations and transformations are default constructible (giving 
the identity transformation). All rotations are constructible taking a 
number of scalar arguments matching the number (and order of 
components).</p>
<div class="sourceCode" id="cb751"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb751-1" title="1">   Rotation3D  rI;                 <span class="co">//a summy rotation (Identity matrix)</span></a>
<a class="sourceLine" id="cb751-2" title="2">   RotationX   rX(PI);             <span class="co">//a RotationX with an angle PI</span></a>
<a class="sourceLine" id="cb751-3" title="3">   EulerAngles rE(phi,theta,psi);  <span class="co">//an Euler rotation with phi,</span></a>
<a class="sourceLine" id="cb751-4" title="4">                                   <span class="co">//theta,psi angles</span></a>
<a class="sourceLine" id="cb751-5" title="5">   XYZVector   u(ux,uy,uz);</a>
<a class="sourceLine" id="cb751-6" title="6">   AxisAngle   rA(u,delta);        <span class="co">//a rotation based on direction u,</span></a>
<a class="sourceLine" id="cb751-7" title="7">                                   <span class="co">//angle delta</span></a></code></pre></div>
<p>In addition, all rotations and transformations (other than the axial rotations) and transformations are constructible from (<code>begin</code>,<code>end</code>) iterators or from pointers behave like iterators.</p>
<div class="sourceCode" id="cb752"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb752-1" title="1">   <span class="dt">double</span>      data[<span class="dv">9</span>];</a>
<a class="sourceLine" id="cb752-2" title="2">   <span class="co">//create a rotation from a rotation matrix</span></a>
<a class="sourceLine" id="cb752-3" title="3">   Rotation3D  r(data,data+<span class="dv">9</span>);</a>
<a class="sourceLine" id="cb752-4" title="4">   <span class="bu">std::</span>vector w(<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb752-5" title="5">   <span class="co">//create Transform3D from std::vector content</span></a>
<a class="sourceLine" id="cb752-6" title="6">   Transform3D t(w.begin(),w.end());</a></code></pre></div>
<p>All rotations, except the axial rotations, are constructible and assigned from any other type of rotation (including the axial):</p>
<div class="sourceCode" id="cb753"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb753-1" title="1">   <span class="co">//create a rotation 3D from a rotation along X axis of angle PI</span></a>
<a class="sourceLine" id="cb753-2" title="2">   Rotation3D  r(ROOT::Math::RotationX(PI));</a>
<a class="sourceLine" id="cb753-3" title="3"></a>
<a class="sourceLine" id="cb753-4" title="4">   <span class="co">//construct an Euler rotation from A Rotation3D</span></a>
<a class="sourceLine" id="cb753-5" title="5">   EulerAngles r2(r);</a>
<a class="sourceLine" id="cb753-6" title="6"></a>
<a class="sourceLine" id="cb753-7" title="7">   <span class="co">//assign an Axis rotation from an Euler Rotation</span></a>
<a class="sourceLine" id="cb753-8" title="8">   AxisAngle   r3; r3 = r2;</a></code></pre></div>
<p><strong><code>Transform3D</code></strong> (rotation + translation) can be constructed from a rotation and a translation vector:</p>
<div class="sourceCode" id="cb754"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb754-1" title="1">   Rotation3D  r;</a>
<a class="sourceLine" id="cb754-2" title="2">   XYZVector   v;</a>
<a class="sourceLine" id="cb754-3" title="3">   Transform3D t1(r,v);   <span class="co">//construct from rotation and then</span></a>
<a class="sourceLine" id="cb754-4" title="4">                          <span class="co">//translation</span></a>
<a class="sourceLine" id="cb754-5" title="5">   Transform3D t2(v,r);   <span class="co">//construct inverse from first translation</span></a>
<a class="sourceLine" id="cb754-6" title="6">                          <span class="co">//then rotation</span></a>
<a class="sourceLine" id="cb754-7" title="7">   Transform3D t3(r);     <span class="co">//construct from only a rotation</span></a>
<a class="sourceLine" id="cb754-8" title="8">                          <span class="co">//(zero translation)</span></a>
<a class="sourceLine" id="cb754-9" title="9">   Transform3D t4(v);     <span class="co">//construct from only translation</span></a>
<a class="sourceLine" id="cb754-10" title="10">                          <span class="co">//(identity rotation)</span></a></code></pre></div>
<h4 id="operations"><span class="header-section-number">13.12.5.2</span> Operations</h4>
<p>All transformations can be applied to vector and points using the operator * or using the operator()</p>
<div class="sourceCode" id="cb755"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb755-1" title="1">   XYZVector  v1(...);</a>
<a class="sourceLine" id="cb755-2" title="2">   Rotation3D r(...);</a>
<a class="sourceLine" id="cb755-3" title="3">   XYZVector  v2 = r*v1;       <span class="co">//rotate vector v1 using r</span></a>
<a class="sourceLine" id="cb755-4" title="4">   v2 = r(v1);                 <span class="co">//equivalent</span></a></code></pre></div>
<p>Transformations can be combined using the operator <code>*</code>. Rotation, translation and <strong><code>Transform3D</code></strong> classes can be all combined with the operator *. The result of a combination of a rotation and a translation will be a <strong><code>Transform3D</code></strong> class. Note that the rotations are not commutative, the order is then important.</p>
<div class="sourceCode" id="cb756"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb756-1" title="1">   Rotation3D  r1(...);</a>
<a class="sourceLine" id="cb756-2" title="2">   Rotation3D  r2(...);</a>
<a class="sourceLine" id="cb756-3" title="3">   Rotation3D  r3 = r2*r1; <span class="co">//a combine rotation r3 by</span></a>
<a class="sourceLine" id="cb756-4" title="4">                           <span class="co">//applying first r1 then r2</span></a></code></pre></div>
<p>We can combine rotations of different types, like <code>Rotation3D</code> with any other type of rotations. The product of two different axial rotations returns a <code>Rotation3D</code>:</p>
<div class="sourceCode" id="cb757"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb757-1" title="1">   RotationX   rx(<span class="fl">1.</span>);</a>
<a class="sourceLine" id="cb757-2" title="2">   RotationY   ry(<span class="fl">2.</span>);</a>
<a class="sourceLine" id="cb757-3" title="3">   Rotation3D  r = ry * rx;       <span class="co">//rotation along X and then Y axis</span></a></code></pre></div>
<p>It is also possible to invert all the transformation or return their inverse:</p>
<div class="sourceCode" id="cb758"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb758-1" title="1">   Rotation3D  r1(...);</a>
<a class="sourceLine" id="cb758-2" title="2">   r1.Invert(); <span class="co">//invert the rotation modifying its content</span></a>
<a class="sourceLine" id="cb758-3" title="3">   Rotation3D  r2 =r1.Inverse(); <span class="co">//return the inverse in a new</span></a>
<a class="sourceLine" id="cb758-4" title="4">                                 <span class="co">//rotation class</span></a></code></pre></div>
<p>We have used rotation as examples, but all these operations can be applied to all the transformation classes.</p>
<h4 id="setgetcomponents-methods"><span class="header-section-number">13.12.5.3</span> Set/GetComponents Methods</h4>
<p>Common methods to all transformations are <code>Get</code> and <code>SetComponents</code>. They can be used to retrieve all the scalar values on which the transformation is based.</p>
<div class="sourceCode" id="cb759"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb759-1" title="1">   RotationX  rx;</a>
<a class="sourceLine" id="cb759-2" title="2">   rx.SetComponents(<span class="fl">1.</span>);      <span class="co">//set agle of the X rotation</span></a>
<a class="sourceLine" id="cb759-3" title="3">   <span class="dt">double</span> d[<span class="dv">9</span>] = {........};</a>
<a class="sourceLine" id="cb759-4" title="4">   Rotation3D r;</a>
<a class="sourceLine" id="cb759-5" title="5">   r.SetComponents(d,d+<span class="dv">9</span>);    <span class="co">//set 9 components of 3D rotation</span></a>
<a class="sourceLine" id="cb759-6" title="6">   <span class="dt">double</span> d[<span class="dv">16</span>];</a>
<a class="sourceLine" id="cb759-7" title="7">   LorentzRotation lr;</a>
<a class="sourceLine" id="cb759-8" title="8">   lr.GetComponents(d,d+<span class="dv">16</span>);  <span class="co">//get 16 components of a LorentzRotation</span></a>
<a class="sourceLine" id="cb759-9" title="9">   TMatrixD(<span class="dv">3</span>,<span class="dv">4</span>) m;</a>
<a class="sourceLine" id="cb759-10" title="10">   Transform3D t;</a>
<a class="sourceLine" id="cb759-11" title="11">   t.GetComponens(m);         <span class="co">//fill 3x4 matrix with components of t</span></a></code></pre></div>
<p>The<code>GetComponents</code> and <code>SetComponents</code> methods can be used with a signature based iterators or by using any foreign matrix which implements the <code>operator(i,j)</code>
 or a different signatures depending on the transformation type. For 
more details on all methods see the reference documentation of any 
specific transformation class.</p>
<h3 id="example-with-external-packages"><span class="header-section-number">13.12.6</span> Example with External Packages</h3>
<h4 id="connection-to-linear-algebra-classes"><span class="header-section-number">13.12.6.1</span> Connection to Linear Algebra Classes</h4>
<p>It is possible to use the vector and rotation classes together with 
the linear algebra classes and to set and get the contents of any 3D or 
4D vector from a linear algebra vector class which implements an 
iterator or something which behaves like an iterator. For example a 
pointer to a C array (double<code>*</code>) behaves like an iterator. It is then assumed that the coordinates, like (<code>x,y,z</code>) will be stored contiguously.</p>
<div class="sourceCode" id="cb760"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb760-1" title="1">   TVectorD   r2(N); <span class="co">//ROOT Linear Algebra Vector containing</span></a>
<a class="sourceLine" id="cb760-2" title="2">                     <span class="co">//many vectors</span></a>
<a class="sourceLine" id="cb760-3" title="3">   XYZVector  v2;</a>
<a class="sourceLine" id="cb760-4" title="4">   <span class="co">//construct vector from x=r[INDEX], y=r[INDEX+1], z=r[INDEX+2]</span></a>
<a class="sourceLine" id="cb760-5" title="5">   v2.SetCoordinates(&amp;r2[INDEX],&amp;r2[index]+<span class="dv">3</span>);</a></code></pre></div>
<p>To fill a linear algebra vector from a 3D or 4D vector, with <code>GetCoordinates()</code> one can get the internal coordinate data.</p>
<div class="sourceCode" id="cb761"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb761-1" title="1">   HepVector      c(<span class="dv">3</span>);        <span class="co">//CLHEP Linear algebra vector</span></a>
<a class="sourceLine" id="cb761-2" title="2">   <span class="co">//fill HepVector c with c[0]=x, c[1]=y, c[2]=z</span></a>
<a class="sourceLine" id="cb761-3" title="3">   v2.GetCoordinates(&amp;c[<span class="dv">0</span>],&amp;c[index]+<span class="dv">3</span>)</a></code></pre></div>
<p>or using <strong><code>TVectorD</code></strong>:</p>
<div class="sourceCode" id="cb762"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb762-1" title="1">   <span class="dt">double</span>   *data[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb762-2" title="2">   v2.GetCoordinates(data,data+<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb762-3" title="3">   TVectorD  r1(<span class="dv">3</span>,data); <span class="co">//create a new Linear Algebra vector</span></a>
<a class="sourceLine" id="cb762-4" title="4">                         <span class="co">//copying the data</span></a></code></pre></div>
<p>In the case of transformations, constructor and method to set<code>/</code>get
 components exist with linear algebra matrices. The requisite is that 
the matrix data are stored, for example in the case of a Lorentz 
rotation, from (<code>0,0</code>) thru (<code>3,3</code>)</p>
<div class="sourceCode" id="cb763"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb763-1" title="1">   TMatrixD(<span class="dv">4</span>,<span class="dv">4</span>)   m;</a>
<a class="sourceLine" id="cb763-2" title="2">   LorentzRotation r(m);       <span class="co">//create Lorentz r</span></a></code></pre></div>
<h4 id="connection-to-other-vector-classes"><span class="header-section-number">13.12.6.2</span> Connection to Other Vector Classes</h4>
<p>The 3D and 4D vectors of the <code>GenVector</code> package can be constructed and assigned from any vector which satisfies the following requisites:</p>
<ul>
<li><p>for 3D vectors implementing the <code>x()</code>, <code>y()</code> and <code>z()</code> methods</p></li>
<li><p>for Lorentz vectors implementing the <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code> methods.</p></li>
</ul>
<div class="sourceCode" id="cb764"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb764-1" title="1">   CLHEP::Hep3Vector hv;</a>
<a class="sourceLine" id="cb764-2" title="2">   XYZVector         v1(hv);      <span class="co">//create  3D vector from</span></a>
<a class="sourceLine" id="cb764-3" title="3">                                  <span class="co">//CLHEP 3D Vector</span></a>
<a class="sourceLine" id="cb764-4" title="4">   HepGeom::Point3D  hp;</a>
<a class="sourceLine" id="cb764-5" title="5">   XYZPoint          p1(hp);      <span class="co">//create a 3D p</span></a></code></pre></div>
<h2 id="linear-algebra-smatrix-package"><span class="header-section-number">13.13</span> Linear Algebra: SMatrix Package</h2>
<p>The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). <code>SMatrix</code>
 is a C++ package, for high performance vector and matrix computations. 
It has been introduced in ROOT v5.08. It is optimized for describing 
small matrices and vectors and It can be used only in problems when the 
size of the matrices is known at compile time, like in the tracking 
reconstruction of physics experiments. It is based on a C++ technique, 
called expression templates, to achieve an high level optimization. The 
C++ templates can be used to implement vector and matrix expressions 
such that these expressions can be transformed at compile time to code 
which is equivalent to hand optimized code in a low-level language like 
FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ 
Report, 1995).</p>
<p>The <code>SMatrix</code> has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the <code>HeraB</code>
 analysis framework. A subset of the original package has been now 
incorporated in the ROOT distribution, with the aim to provide a 
stand-alone and high performance matrix package. The API of the current 
package differs from the original one, in order to be compliant to the 
ROOT coding conventions.</p>
<p><code>SMatrix</code> contains the generic <strong><code>ROOT::Math::SMatrix</code></strong> and <strong><code>ROOT::Math::SVector</code></strong>
 classes for describing matrices and vectors of arbitrary dimensions and
 of arbitrary type. The classes are templated on the scalar type and on 
the size, like number of rows and columns for a matrix . Therefore, the 
matrix/vector dimension has to be known at compile time. An advantage of
 using the dimension as template parameters is that the correctness of 
dimension in the matrix/vector operations can be checked at compile 
time.</p>
<p><code>SMatrix</code> supports, since ROOT v5.10, symmetric matrices using a storage class (<strong><code>ROOT::Math::MatRepSym</code></strong>) which contains only the <code>N*(N+1)/2</code> independent element of a <code>NxN</code>
 symmetric matrix. It is not in the mandate of this package to provide 
complete linear algebra functionality. It provides basic matrix and 
vector functions such as matrix-matrix, matrix-vector, vector-vector 
operations, plus some extra functionality for square matrices, like 
inversion and determinant calculation. The inversion is based on the 
optimized Cramer method for squared matrices of size up to <code>6x6</code>.</p>
<p>The <code>SMatrix</code> package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, <code>libSmatrix</code> is produced with the C++ dictionary information for squared and symmetric matrices and vectors up to dimension 7 and based on <strong><code>Double_t</code></strong>, <strong><code>Float_t</code></strong> and <strong><code>Double32_t</code></strong>.
 The following paragraphs describe the main characteristics of the 
matrix and vector classes. More detailed information about the <code>SMatrix</code> classes API is available in the <a href="https://root.cern/root/htmldoc/guides/users-guide/online%20reference%20documentation">online reference documentation</a>.</p>
<h3 id="example-vector-class-svector"><span class="header-section-number">13.13.1</span> Example: Vector Class (SVector)</h3>
<p>The template class <strong><code>ROOT::Math::SVector</code></strong> represents <code>n</code>-
dimensional vectors for objects of arbitrary type. This class has 2 
template parameters, which define at compile time, its properties: 1) 
type of the contained elements (for example <em>float</em> or <em>double</em>); 2) size of the vector. The use of this dictionary is mandatory if one want to use <code>Smatrix</code> in Cling and with I/O.</p>
<h4 id="creating-a-vector"><span class="header-section-number">13.13.1.1</span> Creating a Vector</h4>
<p>The following constructors are available to create a vector:</p>
<ul>
<li><p>Default constructor for a zero vector (all elements equal to zero).</p></li>
<li><p>Constructor (and assignment) from a vector expression, like <code>v=p*q+w</code>. Due to the expression template technique, no temporary objects are created in this operation.</p></li>
<li><p>Constructor by passing directly the elements. This is possible only for vectors up to size 10.</p></li>
<li><p>Constructor from an iterator copying the data referred by the iterator. It is possible to specify the <em>begin</em> and <em>end</em> of the iterator or the <em>begin</em> and the <em>size</em>. Note that for the Vector the iterator is not generic and must be of type <code>T*</code>, where <code>T</code> is the type of the contained elements.</p></li>
</ul>
<p>In the following example we assume that we are using the namespace <strong><code>ROOT::Math</code></strong></p>
<div class="sourceCode" id="cb765"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb765-1" title="1">   <span class="co">//create an empty vector of size 3 ( v[0]=v[1]=v[2]=0)</span></a>
<a class="sourceLine" id="cb765-2" title="2">   SVector&lt;<span class="dt">double</span>,<span class="dv">3</span>&gt; v;</a>
<a class="sourceLine" id="cb765-3" title="3">   <span class="dt">double</span> d[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};</a>
<a class="sourceLine" id="cb765-4" title="4">   SVector&lt;<span class="dt">double</span>,<span class="dv">3</span>&gt; v(d,<span class="dv">3</span>);  <span class="co">//create a vector from a C array</span></a></code></pre></div>
<h4 id="accessing-and-setting-methods"><span class="header-section-number">13.13.1.2</span> Accessing and Setting Methods</h4>
<p>The single vector elements can be set or retrieved using the <code>operator[i]</code>, <code>operator(i)</code>
 or the iterator interface. Notice that the index starts from zero and 
not from one as in FORTRAN. Also no check is performed on the passed 
index. The full vector elements can be set also by using the SetElements
 function passing a generic iterator.</p>
<div class="sourceCode" id="cb766"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb766-1" title="1">   <span class="dt">double</span> x = m(i);          <span class="co">// return the i-th element</span></a>
<a class="sourceLine" id="cb766-2" title="2">   x = *(m.begin()+i);       <span class="co">// return the i-th element</span></a>
<a class="sourceLine" id="cb766-3" title="3">   v[<span class="dv">0</span>] = <span class="dv">1</span>;                 <span class="co">// set the first element</span></a>
<a class="sourceLine" id="cb766-4" title="4">   v(<span class="dv">1</span>) = <span class="dv">2</span>;                 <span class="co">// set the second element</span></a>
<a class="sourceLine" id="cb766-5" title="5">   *(v.begin()+<span class="dv">3</span>) = <span class="dv">3</span>;       <span class="co">// set the third element</span></a>
<a class="sourceLine" id="cb766-6" title="6">   <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; w(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb766-7" title="7"></a>
<a class="sourceLine" id="cb766-8" title="8">   <span class="co">// set vector elements from a std::vector&lt;double&gt;::iterator</span></a>
<a class="sourceLine" id="cb766-9" title="9">   v.SetElements(w.begin(),w.end());</a></code></pre></div>
<p>In addition there are methods to place a sub-vector in a vector. If 
the size of the sub-vector is larger than the vector size a static 
assert (a compilation error) is produced.</p>
<div class="sourceCode" id="cb767"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb767-1" title="1">   SVector&gt;<span class="dt">double</span>,N&gt;  v;</a>
<a class="sourceLine" id="cb767-2" title="2">   SVector&gt;<span class="dt">double</span>,M&gt;  w;</a>
<a class="sourceLine" id="cb767-3" title="3">   <span class="co">// M &lt;= N otherwise a compilation error is obtained later</span></a>
<a class="sourceLine" id="cb767-4" title="4">   <span class="co">// place a vector of size M starting from</span></a>
<a class="sourceLine" id="cb767-5" title="5">   <span class="co">// element ioff, v[ioff+i]=w[i]</span></a>
<a class="sourceLine" id="cb767-6" title="6">   v.Place_at(w,ioff);</a>
<a class="sourceLine" id="cb767-7" title="7">   <span class="co">// return a sub-vector of size M starting from</span></a>
<a class="sourceLine" id="cb767-8" title="8">   <span class="co">// v[ioff]: w[i]=v[ioff+i]</span></a>
<a class="sourceLine" id="cb767-9" title="9">   w = v.Sub &lt; SVector&gt;<span class="dt">double</span>,M&gt; &gt; (ioff);</a></code></pre></div>
<p>For the vector functions see later in the Matrix and Vector Operators and Functions paragraph.</p>
<h3 id="example-matrix-class-smatrix"><span class="header-section-number">13.13.2</span> Example: Matrix Class (SMatrix)</h3>
<p>The template class <strong><code>ROOT::Math::SMatrix</code></strong> represents a matrix of arbitrary type with <code>nrows</code> <code>x</code> <code>ncol</code> dimension. The class has 4 template parameters, which define at compile time, its properties:</p>
<ul>
<li><p>type of the contained elements, T, for example float or double;</p></li>
<li><p>number of rows;</p></li>
<li><p>number of columns;</p></li>
<li><p>representation type. This is a class describing the underlined 
storage model of the Matrix. Presently exists only two types of this 
class:</p></li>
<li><p><strong><code>ROOT::Math::MatRepStd</code></strong> for a general <code>nrows x ncols</code> matrix. This class is itself a template on the contained type <code>T</code>, the number of rows and the number of columns. Its data member is an array <code>T[nrows*ncols]</code> containing the matrix data. The data are stored in the row-major C convention. For example, for a matrix <code>M</code>, of size <code>3x3</code>, the data <code>{a0,a1,...,a8}</code> are stored in the following order:</p></li>
</ul>
<p><span class="math display">\[
M =
         \left(\begin{array}{ccc}
         a_0 &amp;  a_1  &amp; a_2 \\
         a_3 &amp;  a_4  &amp; a_5 \\
         a_6 &amp;  a_7  &amp; a_8
         \end{array}\right)
\]</span></p>
<ul>
<li><strong><code>ROOT::Math::MatRepSym</code></strong> for a symmetric matrix of size <code>NxN</code>. This class is a template on the contained type and on the symmetric matrix size <code>N</code>. It has as data member an array of type <code>T</code> of size <code>N*(N+1)/2</code>,
 containing the lower diagonal block of the matrix. The order follows 
the lower diagonal block, still in a row-major convention. For example 
for a symmetric <code>3x3</code> matrix the order of the <code>6</code> independent elements <code>{a0,a1,...,a5}</code> is:</li>
</ul>
<p><span class="math display">\[
M =
         \left(\begin{array}{ccc}
         a_0 &amp;  a_1  &amp; a_3 \\
         a_1 &amp;  a_2  &amp; a_4 \\
         a_3 &amp;  a_4  &amp; a_5
         \end{array}\right)
\]</span></p>
<h4 id="creating-a-matrix"><span class="header-section-number">13.13.2.1</span> Creating a Matrix</h4>
<p>The following constructors are available to create a matrix:</p>
<ul>
<li><p>Default constructor for a zero matrix (all elements equal to zero).</p></li>
<li><p>Constructor of an identity matrix.</p></li>
<li><p>Copy constructor (and assignment) for a matrix with the same 
representation, or from a different one when possible, for example from a
 symmetric to a general matrix.</p></li>
<li><p>Constructor (and assignment) from a matrix expression, like <code>D=A*B+C</code>.
 Due to the expression template technique, no temporary objects are 
created in this operation. In the case of an operation like <code>A=A*B+C</code>,
 a temporary object is needed and it is created automatically to store 
the intermediary result in order to preserve the validity of this 
operation.</p></li>
<li><p>Constructor from a generic STL-like iterator copying the data 
referred by the iterator, following its order. It is both possible to 
specify the begin and end of the iterator or the begin and the size. In 
case of a symmetric matrix, it is required only the triangular block and
 the user can specify whether giving a block representing the lower 
(default case) or the upper diagonal part.</p></li>
</ul>
<p>Here are some examples on how to create a matrix. We use typedef’s in
 the following examples to avoid the full C++ names for the matrix 
classes. Notice that for a general matrix the representation has the 
default value, <strong><code>ROOT::Math::MatRepStd</code></strong>, and it is not needed to be specified. Furthermore, for a general square matrix, the number of column may be as well omitted.</p>
<div class="sourceCode" id="cb768"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb768-1" title="1">   <span class="co">// typedef definitions used in the following declarations</span></a>
<a class="sourceLine" id="cb768-2" title="2">   <span class="kw">typedef</span> ROOT::Math::SMatrix&lt;<span class="dt">double</span>,<span class="dv">3</span>&gt;       SMatrix33;</a>
<a class="sourceLine" id="cb768-3" title="3">   <span class="kw">typedef</span> ROOT::Math::SMatrix&lt;<span class="dt">double</span>,<span class="dv">2</span>&gt;       SMatrix22;</a>
<a class="sourceLine" id="cb768-4" title="4">   <span class="kw">typedef</span> ROOT::Math::SMatrix&lt;<span class="dt">double</span>,<span class="dv">3</span>,<span class="dv">3</span>,</a>
<a class="sourceLine" id="cb768-5" title="5">   ROOT::Math::MatRepSym&lt;<span class="dt">double</span>,<span class="dv">3</span>&gt;&gt; SMatrixSym3;</a>
<a class="sourceLine" id="cb768-6" title="6">   <span class="kw">typedef</span> ROOT::Math::SVector&gt;<span class="dt">double</span>,<span class="dv">2</span>&gt;       SVector2;</a>
<a class="sourceLine" id="cb768-7" title="7">   <span class="kw">typedef</span> ROOT::Math::SVector&gt;<span class="dt">double</span>,<span class="dv">3</span>&gt;       SVector3;</a>
<a class="sourceLine" id="cb768-8" title="8">   <span class="kw">typedef</span> ROOT::Math::SVector&gt;<span class="dt">double</span>,<span class="dv">6</span>&gt;       SVector6;</a>
<a class="sourceLine" id="cb768-9" title="9">   SMatrix33   m0;                         <span class="co">// create a zero 3x3 matrix</span></a>
<a class="sourceLine" id="cb768-10" title="10">   <span class="co">// create an 3x3 identity matrix</span></a>
<a class="sourceLine" id="cb768-11" title="11">   SMatrix33   i = ROOT::Math::SMatrixIdentity();</a>
<a class="sourceLine" id="cb768-12" title="12">   <span class="dt">double</span>   a[<span class="dv">9</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>};    <span class="co">// input matrix data</span></a>
<a class="sourceLine" id="cb768-13" title="13">   <span class="co">// create a matrix using the a[] data</span></a>
<a class="sourceLine" id="cb768-14" title="14">   SMatrix33   m(a,<span class="dv">9</span>);             <span class="co">// this will produce the 3x3 matrix</span></a>
<a class="sourceLine" id="cb768-15" title="15">                                   <span class="co">//    (  1    2    3  )</span></a>
<a class="sourceLine" id="cb768-16" title="16">                                   <span class="co">//    (  4    5    6  )</span></a>
<a class="sourceLine" id="cb768-17" title="17">                                   <span class="co">//    (  7    8    9  )</span></a></code></pre></div>
<p>Example to fill a symmetric matrix from an <code>std::vector</code>:</p>
<div class="sourceCode" id="cb769"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb769-1" title="1">   <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; v(<span class="dv">6</span>);</a>
<a class="sourceLine" id="cb769-2" title="2">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;<span class="dv">6</span>; ++i) v[i] = <span class="dt">double</span>(i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb769-3" title="3">   SMatrixSym3  s(v.begin(),v.end())   <span class="co">// this will produce the</span></a>
<a class="sourceLine" id="cb769-4" title="4">                                       <span class="co">// symmetric  matrix</span></a>
<a class="sourceLine" id="cb769-5" title="5">                                       <span class="co">//    (  1    2    4  )</span></a>
<a class="sourceLine" id="cb769-6" title="6">                                       <span class="co">//    (  2    3    5  )</span></a>
<a class="sourceLine" id="cb769-7" title="7">                                       <span class="co">//    (  4    5    6  )</span></a>
<a class="sourceLine" id="cb769-8" title="8">   <span class="co">//create a general matrix from a symmetric matrix (the opposite</span></a>
<a class="sourceLine" id="cb769-9" title="9">   <span class="co">// will not compile)</span></a>
<a class="sourceLine" id="cb769-10" title="10">   SMatrix33    m2 = s;</a></code></pre></div>
<h4 id="accessing-and-setting-methods-1"><span class="header-section-number">13.13.2.2</span> Accessing and Setting Methods</h4>
<p>The matrix elements can be set using the <code>operator()(irow,icol)</code>, where <code>irow</code> and <code>icol</code>
 are the row and column indexes or by using the iterator interface. 
Notice that the indexes start from zero and not from one as in FORTRAN. 
Furthermore, all the matrix elements can be set also by using the 
SetElements function passing a generic iterator. The elements can be 
accessed by the same methods as well as by using the function <code>ROOT::Math::SMatrix::apply</code>. The <code>apply(i)</code>
 has exactly the same behavior for general and symmetric matrices; in 
contrast to the iterator access methods which behave differently (it 
follows the data order).</p>
<div class="sourceCode" id="cb770"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb770-1" title="1">   SMatrix33   m;</a>
<a class="sourceLine" id="cb770-2" title="2">   m(<span class="dv">0</span>,<span class="dv">0</span>) = <span class="dv">1</span>;        <span class="co">// set the element in first row and first column</span></a>
<a class="sourceLine" id="cb770-3" title="3">   *(m.begin()+<span class="dv">1</span>) = <span class="dv">2</span>;      <span class="co">// set the second element (0,1)</span></a>
<a class="sourceLine" id="cb770-4" title="4">   <span class="dt">double</span> d[<span class="dv">9</span>]={<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>};</a>
<a class="sourceLine" id="cb770-5" title="5">   m.SetElements(d,d+<span class="dv">9</span>);    <span class="co">// set the d[] values in m</span></a>
<a class="sourceLine" id="cb770-6" title="6">   <span class="dt">double</span> x = m(<span class="dv">2</span>,<span class="dv">1</span>);       <span class="co">// return the element in 3</span></a>
<a class="sourceLine" id="cb770-7" title="7">   x = m.apply(<span class="dv">7</span>);          <span class="co">// return the 8-th element (row=2,col=1)</span></a>
<a class="sourceLine" id="cb770-8" title="8">   x = *(m.begin()+<span class="dv">7</span>);      <span class="co">// return the 8-th element (row=2,col=1)</span></a>
<a class="sourceLine" id="cb770-9" title="9">   <span class="co">// symmetric matrices</span></a>
<a class="sourceLine" id="cb770-10" title="10">   <span class="co">//(note the difference in behavior between apply and the iterators)</span></a>
<a class="sourceLine" id="cb770-11" title="11">   x = *(m.begin()+<span class="dv">4</span>)       <span class="co">// return the element (row=2,col=1)</span></a>
<a class="sourceLine" id="cb770-12" title="12">   x = m.apply(<span class="dv">7</span>);          <span class="co">// returns again the (row=2,col=1) element</span></a></code></pre></div>
<p>There are methods to place and/or retrieve <strong><code>ROOT::Math::SVector</code></strong> objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another <strong><code>ROOT::Math::SMatrix</code></strong>
 object in a matrix. If the size of the sub-vector or sub-matrix is 
larger than the matrix size a static assert (a compilation error) is 
produced. The non-const methods are:</p>
<div class="sourceCode" id="cb771"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb771-1" title="1">   SMatrix33 m;</a>
<a class="sourceLine" id="cb771-2" title="2">   SVector2  v2(<span class="dv">1</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb771-3" title="3">   <span class="co">// place a vector in the first row from</span></a>
<a class="sourceLine" id="cb771-4" title="4">   <span class="co">// element (0,1) : m(0,1)=v2[0]</span></a>
<a class="sourceLine" id="cb771-5" title="5">   m.Place_in_row(v2,<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb771-6" title="6">   <span class="co">// place the vector in the second column from</span></a>
<a class="sourceLine" id="cb771-7" title="7">   <span class="co">// (0,1) : m(0,1) = v2[0]</span></a>
<a class="sourceLine" id="cb771-8" title="8">   m.Place in_col(v2,<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb771-9" title="9">   SMatrix22 m2;</a>
<a class="sourceLine" id="cb771-10" title="10">   <span class="co">// place m2 in m starting from the</span></a>
<a class="sourceLine" id="cb771-11" title="11">   <span class="co">// element (1,1) : m(1,1) = m2(0,0)</span></a>
<a class="sourceLine" id="cb771-12" title="12">   m.Place_at(m2,<span class="dv">1</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb771-13" title="13">   SVector3 v3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb771-14" title="14">   <span class="co">// set v3 as the diagonal elements</span></a>
<a class="sourceLine" id="cb771-15" title="15">   <span class="co">// of m  : m(i,i) = v3[i] for i=0,1,2</span></a>
<a class="sourceLine" id="cb771-16" title="16">   m.SetDiagonal(v3)</a></code></pre></div>
<p>The const methods retrieving contents (getting slices of a matrix) are:</p>
<div class="sourceCode" id="cb772"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb772-1" title="1">   a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>};</a>
<a class="sourceLine" id="cb772-2" title="2">   SMatrix33       m(a,a+<span class="dv">9</span>);</a>
<a class="sourceLine" id="cb772-3" title="3">   SVector3 irow = m.Row(<span class="dv">0</span>);     <span class="co">// return as vector the first row</span></a>
<a class="sourceLine" id="cb772-4" title="4">   SVector3 jcol = m.Col(<span class="dv">1</span>);     <span class="co">// return as vector the second column</span></a>
<a class="sourceLine" id="cb772-5" title="5"></a>
<a class="sourceLine" id="cb772-6" title="6">   <span class="co">// return a slice of the first row from</span></a>
<a class="sourceLine" id="cb772-7" title="7">   <span class="co">// (0,1): r2[0]= m(0,1); r2[1]=m(0,2)</span></a>
<a class="sourceLine" id="cb772-8" title="8">   SVector2 r2   =  m.SubRow&lt;SVector2&gt; (<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb772-9" title="9">   <span class="co">// return a slice of the second column from</span></a>
<a class="sourceLine" id="cb772-10" title="10">   <span class="co">// (0,1): c2[0] = m(0,1); c2[1] = m(1,1)</span></a>
<a class="sourceLine" id="cb772-11" title="11">   SVector2 c2   =  m.SubCol&lt;SVector2&gt; (<span class="dv">1</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb772-12" title="12"></a>
<a class="sourceLine" id="cb772-13" title="13">   <span class="co">// return a sub-matrix 2x2 with the upper left corner at(1,1)</span></a>
<a class="sourceLine" id="cb772-14" title="14">   SMatrix22 subM = m.Sub&lt;SMatrix22&gt;   (<span class="dv">1</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb772-15" title="15"></a>
<a class="sourceLine" id="cb772-16" title="16">   <span class="co">// return the diagonal element in a SVector</span></a>
<a class="sourceLine" id="cb772-17" title="17">   SVector3  diag = m.Diagonal();</a>
<a class="sourceLine" id="cb772-18" title="18"></a>
<a class="sourceLine" id="cb772-19" title="19">   <span class="co">// return the upper(lower) block of the matrix m</span></a>
<a class="sourceLine" id="cb772-20" title="20">   SVector6 vub = m.UpperBlock();       <span class="co">//  vub = [ 1, 2, 3, 5, 6, 9 ]</span></a>
<a class="sourceLine" id="cb772-21" title="21">   SVector6 vlb = m.LowerBlock();       <span class="co">//  vlb = [ 1, 4, 5, 7, 8, 9 ]</span></a></code></pre></div>
<h4 id="linear-algebra-matrix-functions-inversion-determinant"><span class="header-section-number">13.13.2.3</span> Linear Algebra Matrix Functions (Inversion, Determinant)</h4>
<p>Only limited linear algebra functionality is available for <code>SMatrix</code>. It is possible for squared matrices <code>NxN</code>, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than <code>6x6</code> or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large <code>(N&gt;6)</code>symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large <code>(N&gt;6)</code> general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine <code>dinv</code>.</p>
<div class="sourceCode" id="cb773"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb773-1" title="1">   <span class="co">// Invert a NxN matrix.</span></a>
<a class="sourceLine" id="cb773-2" title="2">   <span class="co">// The inverted matrix replaces the existing one if the</span></a>
<a class="sourceLine" id="cb773-3" title="3">   <span class="co">// result is successful</span></a>
<a class="sourceLine" id="cb773-4" title="4">   <span class="dt">bool</span> ret = m.Invert();               <span class="co">// return the inverse matrix of m.</span></a>
<a class="sourceLine" id="cb773-5" title="5"></a>
<a class="sourceLine" id="cb773-6" title="6">   <span class="co">// If the inversion fails ifail is different than zero  ???</span></a>
<a class="sourceLine" id="cb773-7" title="7">   <span class="dt">int</span> ifail = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb773-8" title="8">   ifail = m.Inverse(ifail);</a>
<a class="sourceLine" id="cb773-9" title="9"></a>
<a class="sourceLine" id="cb773-10" title="10">   <span class="co">// determinant of a square matrix - calculate the determinant</span></a>
<a class="sourceLine" id="cb773-11" title="11">   <span class="co">// modyfing the matrix content and returns it if the calculation</span></a>
<a class="sourceLine" id="cb773-12" title="12">   <span class="co">// was successful</span></a>
<a class="sourceLine" id="cb773-13" title="13">   <span class="dt">double</span> det;</a>
<a class="sourceLine" id="cb773-14" title="14">   <span class="dt">bool</span> ret = m.Det(det);</a>
<a class="sourceLine" id="cb773-15" title="15"></a>
<a class="sourceLine" id="cb773-16" title="16">   <span class="co">// calculate determinant by using a temporary matrix; preserves</span></a>
<a class="sourceLine" id="cb773-17" title="17">   <span class="co">// matrix content</span></a>
<a class="sourceLine" id="cb773-18" title="18">   <span class="dt">bool</span> ret = n.Det2(det);</a></code></pre></div>
<h3 id="example-matrix-and-vector-functions-and-operators"><span class="header-section-number">13.13.3</span> Example: Matrix and Vector Functions and Operators</h3>
<h4 id="matrix-and-vector-operators"><span class="header-section-number">13.13.3.1</span> Matrix and Vector Operators</h4>
<p>The <strong><code>ROOT::Math::SVector</code></strong> and <strong><code>ROOT::Math::SMatrix</code></strong> classes define the following operators described below. The <code>m1</code>, <code>m2</code>, <code>m3</code> are vectors or matrices of the same type (and size) and <code>a</code> is a scalar value:</p>
<div class="sourceCode" id="cb774"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb774-1" title="1">   m1 == m2  <span class="co">// returns whether m1 is equal to m2</span></a>
<a class="sourceLine" id="cb774-2" title="2">             <span class="co">// (element by element comparison)</span></a>
<a class="sourceLine" id="cb774-3" title="3">   m1 != m2  <span class="co">// returns whether m1 is NOT equal to m2</span></a>
<a class="sourceLine" id="cb774-4" title="4">             <span class="co">// (element by element comparison)</span></a>
<a class="sourceLine" id="cb774-5" title="5">   m1 &lt; m2   <span class="co">// returns whether m1 is less than m2</span></a>
<a class="sourceLine" id="cb774-6" title="6">             <span class="co">// (element wise comparison)</span></a>
<a class="sourceLine" id="cb774-7" title="7">   m1 &gt; m2   <span class="co">// returns whether m1 is greater than m2</span></a>
<a class="sourceLine" id="cb774-8" title="8">             <span class="co">// (element wise comparison)</span></a>
<a class="sourceLine" id="cb774-9" title="9"></a>
<a class="sourceLine" id="cb774-10" title="10">   <span class="co">// in the following m1 and m3 can be general and m2 symmetric,</span></a>
<a class="sourceLine" id="cb774-11" title="11">   <span class="co">// but not vice-versa</span></a>
<a class="sourceLine" id="cb774-12" title="12"></a>
<a class="sourceLine" id="cb774-13" title="13">   m1 += m2           <span class="co">// add m2 to m1</span></a>
<a class="sourceLine" id="cb774-14" title="14">   m1 -= m2           <span class="co">// subtract m2 to m1</span></a>
<a class="sourceLine" id="cb774-15" title="15">   m3 = m1 + m2       <span class="co">// addition</span></a>
<a class="sourceLine" id="cb774-16" title="16">   m1 - m2            <span class="co">// subtraction</span></a>
<a class="sourceLine" id="cb774-17" title="17"></a>
<a class="sourceLine" id="cb774-18" title="18">   <span class="co">// Multiplication and division via a scalar value a</span></a>
<a class="sourceLine" id="cb774-19" title="19"></a>
<a class="sourceLine" id="cb774-20" title="20">   m3 = a*m1; m3 = m1*a; m3 = m1/a;</a></code></pre></div>
<p><strong>Vector-Vector multiplication:</strong> The operator <code>*</code>
 defines an element by element multiplication between vectors. For the 
standard vector-vector algebraic multiplication returning a scalar, <code>vTv</code> (dot product), one must use the <strong><code>ROOT::Math::Dot</code> function. In addition, the Cross (only for vector sizes of 3), <code>ROOT::Math::</code></strong><code>Cross</code>, and the Tensor product, <code>ROOT::Math::TensorProd</code>, are defined.</p>
<p><strong>Matrix - Vector multiplication:</strong> The operator <code>*</code> defines the matrix-vector multiplication: <span class="math inline">\(y_i = \sum_j M_{i,j} x_j\)</span>. The operation compiles only if the matrix and the vectors have the right sizes.</p>
<div class="sourceCode" id="cb775"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb775-1" title="1">   <span class="co">//M is a N1xN2 matrix, x is a N2 size vector, y is a N1 size vector</span></a>
<a class="sourceLine" id="cb775-2" title="2">   y = M * x</a></code></pre></div>
<p><strong>Matrix - Matrix multiplication:</strong> The operator <code>*</code> defines the matrix-matrix multiplication: <span class="math inline">\(C_{i,j} = \sum_k A_{i,k} B_{k,j}\)</span>.</p>
<div class="sourceCode" id="cb776"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb776-1" title="1">   <span class="co">// A is a N1xN2 matrix, B is a N2xN3 matrix and C is a N1xN3 matrix</span></a>
<a class="sourceLine" id="cb776-2" title="2">   C = A * B</a></code></pre></div>
<p>The operation compiles only if the matrices have the right size. In the case that <code>A</code> and <code>B</code> are symmetric matrices, <code>C</code> is a general one, since their product is not guaranteed to be symmetric.</p>
<h3 id="matrix-and-vector-functions"><span class="header-section-number">13.13.4</span> Matrix and Vector Functions</h3>
<p>The most used matrix functions are:</p>
<ul>
<li><p><code>ROOT::Math::Transpose(M)</code> returns the transpose matrix <code>MT</code></p></li>
<li><p><code>ROOT::Math::Similarity(v,M)</code> returns the scalar value resulting from the matrix-vector product <code>vTMv</code></p></li>
<li><p><code>ROOT::Math::Similarity(U,M)</code> returns the matrix resulting from the product: <code>U M UT</code>. If <code>M</code> is symmetric, the returned resulting matrix is also symmetric</p></li>
<li><p><code>ROOT::Math::SimilarityT(U,M)</code> returns the matrix resulting from the product: <code>UT M U</code>. If <code>M</code> is symmetric, the returned resulting matrix is also symmetric</p></li>
</ul>
<p>The major vector functions are:</p>
<ul>
<li><p><code>ROOT::Math::Dot(v1,v2)</code> returns the scalar value resulting from the vector dot product</p></li>
<li><p><code>ROOT::Math::Cross(v1,v2)</code> returns the vector cross product for two vectors of size 3. Note that the <code>Cross</code> product is not defined for other vector sizes</p></li>
<li><p><code>ROOT::Math::Unit(v)</code> returns unit vector. One can use also the <code>v.Unit()</code>method.</p></li>
<li><p><code>ROOT::Math::TensorProd(v1,v2)</code> returns a general matrix <code>M</code>of size <code>N1xN2</code> resulting from the tensor product between the vector <code>v1</code> of size <code>N1</code> and <code>v2</code> of size <code>N2</code>:</p></li>
</ul>
<p>For a list of all the available matrix and vector functions see the <code>SMatrix</code> online reference documentation.</p>
<h4 id="matrix-and-vector-io"><span class="header-section-number">13.13.4.1</span> Matrix and Vector I/O</h4>
<p>One can print (or write in an output stream) Vectors and Matrices) using the <code>Print</code> method or the <code>&lt;&lt;</code> operator:</p>
<div class="sourceCode" id="cb777"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb777-1" title="1">   <span class="co">// m is a SMatrix or a SVector object</span></a>
<a class="sourceLine" id="cb777-2" title="2">   m.Print(<span class="bu">std::</span>cout);</a>
<a class="sourceLine" id="cb777-3" title="3">   <span class="bu">std::</span>cout &lt;&lt; m &lt;&lt; <span class="bu">std::</span>endl;</a></code></pre></div>
<p>In the ROOT distribution, the Cling dictionary is generated for <code>SMatrix</code> and <code>SVector</code> for for <strong><code>Double_t</code></strong>, <strong><code>Float_t</code></strong> and <strong><code>Double32_t</code></strong> up to dimension 7. This allows the possibility to store them in a ROOT file.</p>
<h2 id="root-statistics-classes"><span class="header-section-number">13.14</span> ROOT Statistics Classes</h2>
<h3 id="classes-for-computing-limits-and-confidence-levels"><span class="header-section-number">13.14.1</span> Classes for Computing Limits and Confidence Levels</h3>
<p><strong><code>TFeldmanCousins</code></strong> class calculates the <code>CL</code>
 upper/lower limit for a Poisson process using the Feldman-Cousins 
method (as described in PRD V57 #7, p3873-3889). No treatment is 
provided in this method for the uncertainties in the signal or the 
background.</p>
<p><strong><code>TRolke</code></strong> computes confidence intervals 
for the rate of a Poisson process in the presence of background and 
efficiency, using the profile likelihood technique for treating the 
uncertainties in the efficiency and background estimate. The signal is 
always assumed to be Poisson; background may be Poisson, Gaussian, or 
user-supplied; efficiency may be Binomial, Gaussian, or user-supplied. 
See publication at Nucl. Instrum. Meth. A551:493-503,2005.</p>
<p><strong><code>TLimit</code></strong> class computes 95% C.L. limits using the Likelihood ratio semi-Bayesian method ( <cls> method; see e.g.&nbsp;T. Junk, NIM A434, p. 435-443, 1999). It takes signal background and data histograms wrapped in a <code>TLimitDataSource</code>
 as input, and runs a set of Monte Carlo experiments in order to compute
 the limits. If needed, inputs are fluctuated according to systematic.</cls></p>
<h3 id="specialized-classes-for-fitting"><span class="header-section-number">13.14.2</span> Specialized Classes for Fitting</h3>
<p><strong><code>TFractionFitter</code></strong> fits Monte Carlo (MC) 
fractions to data histogram (a la HMCMLL, R. Barlow and C. Beeston, 
Comp. Phys. Comm. 77 (1993) 219-228). It takes into account both data 
and Monte Carlo statistical uncertainties through a likelihood fit using
 Poisson statistics. However, the template (MC) predictions are also 
varied within statistics, leading to additional contributions to the 
overall likelihood. This leads to many more fit parameters (one per bin 
per template), but the minimization with respect to these additional 
parameters is done analytically rather than introducing them as formal 
fit parameters. Some special care needs to be taken in the case of bins 
with zero content.</p>
<p><strong><code>TMultiDimFit</code></strong> implements 
multi-dimensional function parametrization for multi-dimensional data by
 fitting them to multi-dimensional data using polynomial or Chebyshev or
 Legendre polynomial</p>
<p><strong><code>TSpectrum</code></strong> contains advanced spectra 
processing functions for 1- and 2-dimensional background estimation, 
smoothing, deconvolution, peak search and fitting, and orthogonal 
transformations.</p>
<p><strong><code>RooFit</code></strong> is a complete toolkit for 
fitting and data analysis modeling (see the RooFit User Guide at 
ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf)</p>
<p><strong><code>TSplot</code></strong> to disentangle signal from 
background via an extended maximum likelihood fit and with a tool to 
access the quality and validity of the fit producing distributions for 
the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. 
Meth.A 555, 356-369, 2005).</p>
<h3 id="multi-variate-analysis-classes"><span class="header-section-number">13.14.3</span> Multi-variate Analysis Classes</h3>
<p><strong><code>TMultiLayerPerceptron</code></strong> is a Neural Network class (see for more details the chapter “Neural Networks”).</p>
<p><strong><code>TPrincipal</code></strong> provides the Principal Component Analysis.</p>
<p><strong><code>TRobustEstimator</code></strong> is a robust method for minimum covariance determinant estimator (MCD).</p>
<p><strong><code>TMVA</code></strong> is a package for multivariate data analysis (see <a href="https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf" class="uri">https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf</a> the User’s Guide).</p>
<h1 id="linear-algebra-in-root"><span class="header-section-number">14</span> Linear Algebra in ROOT</h1>
<p>The linear algebra package is supposed to give a complete environment
 in ROOT to perform calculations like equation solving and eigenvalue 
decompositions. Most calculations are performed in double precision. For
 backward compatibility, some classes are also provided in single 
precision like <strong><code>TMatrixF</code></strong>, <strong><code>TMatrixFSym</code></strong> and <strong><code>TVectorF</code></strong>.
 Copy constructors exist to transform these into their double precision 
equivalent, thereby allowing easy access to decomposition and eigenvalue
 classes, only available in double precision.</p>
<p>The choice was made not to provide the less frequently used complex 
matrix classes. If necessary, users can always reformulate the 
calculation in 2 parts, a real one and an imaginary part. Although, a 
linear equation involving complex numbers will take about a factor of 8 
more computations, the alternative of introducing a set of complex 
classes in this non-template library would create a major maintenance 
challenge.</p>
<p>Another choice was to fill in both the upper-right corner and the 
bottom-left corner of a symmetric matrix. Although most algorithms use 
only the upper-right corner, implementation of the different matrix 
views was more straightforward this way. When stored only the 
upper-right part is written to file.</p>
<p>For a detailed description of the interface, the user should look at the root reference guide at: <a href="http://root.cern.ch/root/Reference.html" class="uri">http://root.cern.ch/root/Reference.html</a></p>
<h2 id="overview-of-matrix-classes"><span class="header-section-number">14.1</span> Overview of Matrix Classes</h2>
<p>The figure below shows an overview of the classes available in the linear algebra library,<code>libMatrix.so</code>. At the center is the base class <strong><code>TMatrixDBase</code></strong> from which three different matrix classes, <strong><code>TMatrixD</code></strong>, <strong><code>TMatrixDSym</code></strong> and <strong><code>TMatrixDFSparse</code></strong> derive. The user can define customized matrix operations through the classes <strong><code>TElementActionD</code></strong> and <strong><code>TElementsPosActionD</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/0300012D.png" alt="Overview of matrix classes"><figcaption>Overview of matrix classes</figcaption>
</figure>
<p>Reference to different views of the matrix can be created through the
 classes on the right-hand side, see “Matrix Views”. These references 
provide a natural connection to vectors.</p>
<p>Matrix decompositions (used in equation solving and matrix inversion)
 are available through the classes on the left-hand side (see “Matrix 
Decompositions”). They inherit from the <strong><code>TDecompBase</code></strong>
 class. The Eigen Analysis is performed through the classes at the top, 
see “Matrix Eigen Analysis”. In both cases, only some matrix types can 
be analyzed. For instance, <strong><code>TDecompChol</code></strong> will only accept symmetric matrices as defined <strong><code>TMatrixDSym</code></strong>. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:</p>
<div class="sourceCode" id="cb778"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb778-1" title="1">   TMatrixD a(<span class="dv">3</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb778-2" title="2">   TMatrixD b(<span class="dv">5</span>,<span class="dv">6</span>);</a>
<a class="sourceLine" id="cb778-3" title="3">   b = a;</a></code></pre></div>
<p>It required to first resize matrix b to the shape of <code>a</code>.</p>
<div class="sourceCode" id="cb779"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb779-1" title="1">   TMatrixD a(<span class="dv">3</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb779-2" title="2">   TMatrixD b(<span class="dv">5</span>,<span class="dv">6</span>);</a>
<a class="sourceLine" id="cb779-3" title="3">   b.ResizeTo(a);</a>
<a class="sourceLine" id="cb779-4" title="4">   b = a;</a></code></pre></div>
<h2 id="matrix-properties"><span class="header-section-number">14.2</span> Matrix Properties</h2>
<p>A matrix has five properties, which are all set in the constructor:</p>
<ul>
<li><p><code>precision</code> - float or double. In the first case you will use the <strong><code>TMatrixF</code></strong> class family, in the latter case the <strong><code>TMatrixD</code></strong> one;</p></li>
<li><p><code>type</code> - general (<strong><code>TMatrixD</code></strong>), symmetric (<strong><code>TMatrixDSym</code></strong>) or sparse (<strong><code>TMatrixDSparse</code></strong>);</p></li>
<li><p><code>size</code> - number of rows and columns;</p></li>
<li><p><code>index</code> - range start of row and column index. By default these start at zero;</p></li>
<li><p><code>sparse</code> <code>map</code> - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero.</p></li>
</ul>
<h3 id="accessing-properties"><span class="header-section-number">14.2.1</span> Accessing Properties</h3>
<p>The following table shows the methods to access the information about the relevant matrix property:</p>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<tbody>
<tr class="odd">
<td>Method</td>
<td>Descriptions</td>
</tr>
<tr class="even">
<td><code>Int_t GetRowLwb</code> <code>()</code></td>
<td>row lower-bound index</td>
</tr>
<tr class="odd">
<td><code>Int_t GetRowUpb</code> <code>()</code></td>
<td>row upper-bound index</td>
</tr>
<tr class="even">
<td><code>Int_t GetNrows</code> <code>()</code></td>
<td>number of rows</td>
</tr>
<tr class="odd">
<td><code>Int_t GetColLwb</code> <code>()</code></td>
<td>column lower-bound index</td>
</tr>
<tr class="even">
<td><code>Int_t GetColUpb</code> <code>()</code></td>
<td>column upper-bound index</td>
</tr>
<tr class="odd">
<td><code>Int_t GetNcols</code> <code>()</code></td>
<td>number of columns</td>
</tr>
<tr class="even">
<td><code>Int_t GetNoElements</code> <code>()</code></td>
<td>number of elements, for a dense matrix this equals: <code>fNrows x fNcols</code></td>
</tr>
<tr class="odd">
<td><code>Double_t GetTol</code> <code>()</code></td>
<td>tolerance number which is used in decomposition operations</td>
</tr>
<tr class="even">
<td><code>Int_t *GetRowIndexArray</code> <code>()</code></td>
<td>for sparse matrices, access to the row index of <code>fNrows+1</code> entries</td>
</tr>
<tr class="odd">
<td><code>Int_t *GetColIndexArray</code> <code>()</code></td>
<td>for sparse matrices, access to the column index of <code>fNelems</code> entries</td>
</tr>
</tbody>
</table>
<p>The last two methods in this table are specific to the sparse matrix,
 which is implemented according to the Harwell-Boeing format. Here, 
besides the usual shape/size descriptors of the matrix like <code>fNrows</code>, <code>fRowLwb</code>, <code>fNcols</code> and <code>fColLwb</code>, we also store a row index, <code>fRowIndex</code> and column index, <code>fColIndex</code> for the elements unequal zero:</p>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>fRowIndex[0,..,fNrows]:</code></td>
<td>Stores for each row the index range of the elements in the data and column array</td>
</tr>
<tr class="even">
<td><code>fColIndex[0,..,fNelems-1]:</code></td>
<td>Stores the column number for each data element != 0.</td>
</tr>
</tbody>
</table>
<p>The code to print all matrix elements unequal zero would look like:</p>
<div class="sourceCode" id="cb780"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb780-1" title="1">   TMatrixDSparse a;</a>
<a class="sourceLine" id="cb780-2" title="2">   <span class="at">const</span> <span class="dt">Int_t</span> *rIndex = a.GetRowIndexArray();</a>
<a class="sourceLine" id="cb780-3" title="3">   <span class="at">const</span> <span class="dt">Int_t</span> *cIndex = a.GetColIndexArray();</a>
<a class="sourceLine" id="cb780-4" title="4">   <span class="at">const</span> <span class="dt">Double_t</span> *pData = a.GetMatrixArray();</a>
<a class="sourceLine" id="cb780-5" title="5">   <span class="cf">for</span> (<span class="dt">Int_t</span> irow = <span class="dv">0</span>; irow &lt; a.getNrows(); irow++) {</a>
<a class="sourceLine" id="cb780-6" title="6">      <span class="at">const</span> <span class="dt">Int_t</span> sIndex = rIndex[irow];</a>
<a class="sourceLine" id="cb780-7" title="7">      <span class="at">const</span> <span class="dt">Int_t</span> eIndex = rIndex[irow+<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb780-8" title="8">      <span class="cf">for</span> (<span class="dt">Int_t</span> index = sIndex; index &lt; eIndex; index++) {</a>
<a class="sourceLine" id="cb780-9" title="9">         <span class="at">const</span> <span class="dt">Int_t</span> icol = cIndex[index];</a>
<a class="sourceLine" id="cb780-10" title="10">         <span class="at">const</span> <span class="dt">Double_t</span> data = pData[index];</a>
<a class="sourceLine" id="cb780-11" title="11">         printf(<span class="st">"data(</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) = %.4en"</span>,irow+a.GetfRowLwb(),</a>
<a class="sourceLine" id="cb780-12" title="12">         icol+a.GetColLwb(),data);</a>
<a class="sourceLine" id="cb780-13" title="13">      }</a>
<a class="sourceLine" id="cb780-14" title="14">   }</a></code></pre></div>
<h3 id="setting-properties"><span class="header-section-number">14.2.2</span> Setting Properties</h3>
<p>The following table shows the methods to set some of the matrix 
properties. The resizing procedures will maintain the matrix elements 
that overlap with the old shape. The optional last argument <code>nr_zeros</code>
 is only relevant for sparse matrices. If supplied, it sets the number 
of non-zero elements. If it is smaller than the number overlapping with 
the old matrix, only the first (row-wise)<code>nr_zeros</code> are copied to the new matrix.</p>
<table>
<colgroup>
<col style="width: 54%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SetTol</code> <code>(Double_t tol)</code></td>
<td>set the tolerance number</td>
</tr>
<tr class="even">
<td><p><code>ResizeTo</code> <code>(Int_t nrows,Int_t ncols,</code></p>
<p><code>Int_t nr_nonzeros=-1)</code></p></td>
<td>change matrix shape to <code>nrows</code> x <code>ncols</code>. Index will start at zero</td>
</tr>
<tr class="odd">
<td><p><code>ResizeTo(Int_t row_lwb,Int_t row_upb,</code></p>
<p><code>Int_t col_lwb,Int_t col_upb,</code></p>
<p><code>Int_t nr_nonzeros=-1)</code></p></td>
<td><p>change matrix shape to</p>
<p><code>row_lwb:row_upb</code> x <code>col_lwb:col_upb</code></p></td>
</tr>
<tr class="even">
<td><code>SetRowIndexArray</code> <code>(Int_t *data)</code></td>
<td>for sparse matrices, set the row index. The array data should contains at least<code>fNrows+1</code> entries column lower-bound index</td>
</tr>
<tr class="odd">
<td><code>SetColIndexArray</code> <code>(Int_t *data)</code></td>
<td>for sparse matrices, set the column index. The array data should contains at least <code>fNelems</code> entries</td>
</tr>
<tr class="even">
<td><code>SetSparseIndex</code> <code>(Int_t nelems new)</code></td>
<td>allocate memory for a sparse map of <code>nelems_new</code> elements and copy (if exists) at most <code>nelems_new</code> matrix elements over to the new structure</td>
</tr>
<tr class="odd">
<td><code>SetSparseIndex</code> <code>(const TMatrixDBase &amp;a)</code></td>
<td>copy the sparse map from matrix <code>a</code> Note that this can be a dense matrix!</td>
</tr>
<tr class="even">
<td><code>SetSparseIndexAB</code> <code>(const TMatrixDSparse &amp;a,</code> <code>const TMatrixDSparse &amp;b)</code></td>
<td>set the sparse map to the same of the map of matrix <code>a</code> and <code>b</code></td>
</tr>
</tbody>
</table>
<p>The second half of the table is only relevant for sparse matrices. 
These methods define the sparse structure. It should be clear that a 
call to any of these methods has to be followed by a <strong><code>SetMatrixArray</code></strong> (…) which will supply the matrix data, see the next chapter “Creating and Filling a Matrix”.</p>
<h2 id="creating-and-filling-a-matrix"><span class="header-section-number">14.3</span> Creating and Filling a Matrix</h2>
<p>The matrix constructors are listed in the next table. In the simplest
 ones, only the number of rows and columns is given. In a slightly more 
elaborate version, one can define the row and column index range. 
Finally, one can also define the matrix data in the constructor. In 
Matrix Operators and Methods we will encounter more fancy constructors 
that will allow arithmetic operations.</p>
<table>
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p><code>TMatrixD(Int_t nrows,Int_t ncols)</code></p>
<p><code>TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)</code></p>
<p><code>TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= "")</code></p>
<p><code>TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,</code></p>
<p><code>const Double_t *data,Option_t *option="")</code></p></td>
</tr>
<tr class="even">
<td><p><code>TMatrixDSym(Int_t nrows)</code></p>
<p><code>TMatrixDSym(Int_t row_lwb,Int_t row_upb)</code></p>
<p><code>TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option="")</code></p>
<p><code>TMatrixDSym(Int_t row_lwb,Int_t row_upb,const Double_t *data, Option_t *opt="")</code></p></td>
</tr>
<tr class="odd">
<td><p><code>TMatrixDSparse(Int_t nrows,Int_t ncols)</code></p>
<p><code>TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb )</code></p>
<p><code>TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,</code></p>
<p><code>Int_t nr_nonzeros,Int_t *row,Int_t *col,Double_t *data)</code></p></td>
</tr>
</tbody>
</table>
<p>If only the matrix shape is defined in the constructor, matrix data 
has to be supplied and possibly the sparse structure. In “Setting 
Properties” was discussed how to set the sparse structure.</p>
<p>Several methods exist to fill a matrix with data:</p>
<p><code>SetMatrixArray(const Double_t*data,Option_t*option="")</code>, copies the array data. If option<code>="F"</code>, the array fills the matrix column-wise else row-wise. This option is only implemented for <strong><code>TMatrixD</code></strong> and <strong><code>TMatrixDSym</code></strong>. It is expected that the array data contains at least <code>fNelems</code> entries.</p>
<p><code>SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Double_t *data)</code>, is only available for sparse matrices. The three arrays should each contain <code>nr</code> entries with row index, column index and data entry. Only the entries with non-zero data value are inserted!</p>
<p><code>operator()</code>or <code>operator[]</code>, these operators 
provide the easiest way to fill a matrix but are in particular for a 
sparse matrix expensive. If no entry for slot (<code>i,j</code>) is 
found in the sparse index table it will be entered, which involves some 
memory management! Therefore, before invoking this method in a loop it 
is wise to set the index table first through a call to the <code>SetSparseIndex</code> method.</p>
<p><code>SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixDBase &amp;source)</code>, the matrix to be inserted at position <code>(row_lwb,col_lwb)</code> can be both, dense or sparse.</p>
<p><code>Use(...)</code> allows inserting another matrix or data array 
without actually copying the data. Next table shows the different 
flavors for the different matrix types.</p>
<table>
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p><code>Use(TMatrixD &amp;a)</code></p>
<p><code>Use(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,Double_t *d ata)</code></p>
<p><code>Use(Int_t nrows,Int_t ncols,Double_t *data)</code></p></td>
</tr>
<tr class="even">
<td><p><code>Use(TMatrixDSym &amp;a)</code></p>
<p><code>Use(Int_t nrows,Double_t *data)</code></p>
<p><code>Use(Int_t row_lwb,Int_t row_upb,Double_t *data)</code></p></td>
</tr>
<tr class="odd">
<td><p><code>Use(TMatrixDSparse &amp;a)</code></p>
<p><code>Use(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,Int_t nr_no nzeros,</code></p>
<p><code>Int_t *pRowIndex,Int_t *pColIndex,Double_t *pData)</code></p>
<p><code>Use(Int_t nrows,Int_t ncols,Int_t nr_nonzeros,Int_t *pRowIndex,</code></p>
<p><code>Int_t *pColIndex,Double_t *pData)</code></p></td>
</tr>
</tbody>
</table>
<p>Below follow a few examples of creating and filling a matrix. First we create a Hilbert matrix by copying an array.</p>
<div class="sourceCode" id="cb781"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb781-1" title="1">   TMatrixD h(<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb781-2" title="2">   TArrayD data(<span class="dv">25</span>);</a>
<a class="sourceLine" id="cb781-3" title="3">   <span class="cf">for</span> (<span class="dt">Int_t</span> = <span class="dv">0</span>; i &lt; <span class="dv">25</span>; i++) {</a>
<a class="sourceLine" id="cb781-4" title="4">      <span class="at">const</span> <span class="dt">Int_t</span> ir = i/<span class="dv">5</span>;</a>
<a class="sourceLine" id="cb781-5" title="5">      <span class="at">const</span> <span class="dt">Int_t</span> ic = i%<span class="dv">5</span>;</a>
<a class="sourceLine" id="cb781-6" title="6">      data[i] = <span class="fl">1.</span>/(ir+ic);</a>
<a class="sourceLine" id="cb781-7" title="7">   }</a>
<a class="sourceLine" id="cb781-8" title="8">   h.SetMatrixArray(data.GetArray());</a></code></pre></div>
<p>We also could assign the data array to the matrix without actually copying it.</p>
<div class="sourceCode" id="cb782"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb782-1" title="1">   TMatrixD h; h.Use(<span class="dv">5</span>,<span class="dv">5</span>,data.GetArray());</a>
<a class="sourceLine" id="cb782-2" title="2">   h.Invert();</a></code></pre></div>
<p>The array <code>data</code> now contains the inverted matrix. Finally, create a unit matrix in sparse format.</p>
<div class="sourceCode" id="cb783"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb783-1" title="1">   TMatrixDSparse unit1(<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb783-2" title="2">   TArrayI row(<span class="dv">5</span>),col(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb783-3" title="3">   <span class="cf">for</span> (<span class="dt">Int_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++) row[i] = col[i] = i;</a>
<a class="sourceLine" id="cb783-4" title="4">   TArrayD data(<span class="dv">5</span>); data.Reset(<span class="fl">1.</span>);</a>
<a class="sourceLine" id="cb783-5" title="5">   unit1.SetMatrixArray(<span class="dv">5</span>,row.GetArray(),col.GetArray(),data.GetArray());</a>
<a class="sourceLine" id="cb783-6" title="6"></a>
<a class="sourceLine" id="cb783-7" title="7">   TMatrixDSparse unit2(<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb783-8" title="8">   unit2.SetSparseIndex(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb783-9" title="9">   unit2.SetRowIndexArray(row.GetArray());</a>
<a class="sourceLine" id="cb783-10" title="10">   unit2.SetColIndexArray(col.GetArray());</a>
<a class="sourceLine" id="cb783-11" title="11">   unit2.SetMatrixArray(data.GetArray());</a></code></pre></div>
<h2 id="matrix-operators-and-methods"><span class="header-section-number">14.4</span> Matrix Operators and Methods</h2>
<p>It is common to classify matrix/vector operations according to BLAS 
(Basic Linear Algebra Subroutines) levels, see following table:</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 26%">
<col style="width: 21%">
<col style="width: 34%">
</colgroup>
<tbody>
<tr class="odd">
<td>BLAS level</td>
<td>operations</td>
<td>example</td>
<td>floating-point operations</td>
</tr>
<tr class="even">
<td>1</td>
<td>vector-vector</td>
<td><span class="math inline">\(x T y\)</span></td>
<td><span class="math inline">\(n\)</span></td>
</tr>
<tr class="odd">
<td>2</td>
<td>matrix-vector matrix</td>
<td><span class="math inline">\(A x\)</span></td>
<td><span class="math inline">\(n2\)</span></td>
</tr>
<tr class="even">
<td>3</td>
<td>matrix-matrix</td>
<td><span class="math inline">\(A B\)</span></td>
<td><span class="math inline">\(n3\)</span></td>
</tr>
</tbody>
</table>
<p>Most level 1, 2 and 3 BLAS are implemented. However, we will present 
them not according to that classification scheme it is already boring 
enough.</p>
<h3 id="arithmetic-operations-between-matrices"><span class="header-section-number">14.4.1</span> Arithmetic Operations between Matrices</h3>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 44%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>   Description</code></pre></td>
<td><pre><code>          Format</code></pre></td>
<td><pre><code>  Comment</code></pre></td>
</tr>
<tr class="even">
<td><p><code>element</code></p>
<p><code>wise sum</code></p></td>
<td><p><code>C=A+B</code></p>
<p><code>A+=B</code></p>
<p><code>Add</code> <code>(A,alpha,B)</code></p>
<p><code>TMatrixD(A,TMatrixD::kPlus,B)</code></p></td>
<td><p><code>overwrites</code> <span class="math inline">\(A\)</span></p>
<p><span class="math inline">\(A = A+\alpha B\)</span> <code>constructor</code></p></td>
</tr>
<tr class="odd">
<td><code>element wise</code> <code>subtraction</code></td>
<td><p><code>C=A-B</code> <code>A-=B</code></p>
<p><code>TMatrixD(A,TMatrixD::kMinus,B)</code></p></td>
<td><code>overwrites</code> <span class="math inline">\(A\)</span> <code>constructor</code></td>
</tr>
<tr class="even">
<td><code>matrix multiplication</code></td>
<td><p><code>C=A*B</code></p>
<p><code>A*=B</code></p>
<p><code>C.Mult(A,B)</code></p></td>
<td><code>overwrites</code> <span class="math inline">\(A\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixD(A,TMatrixD::kMult,B)</code></td>
<td><code>constructor of</code> <span class="math inline">\(A.B\)</span></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixD(A,</code> <code>TMatrixD::kTransposeMult,B)</code></td>
<td><code>constructor of</code> <span class="math inline">\(A^{T}.B\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixD(A,</code> <code>TMatrixD::kMultTranspose,B)</code></td>
<td><code>constructor of</code> <span class="math inline">\(A.B^{T}\)</span></td>
</tr>
<tr class="even">
<td><p><code>element wise</code> <code>multiplication</code></p>
<p><code>element wise division</code></p></td>
<td><p><code>ElementMult(A,B)</code></p>
<p><code>ElementDiv(A,B)</code></p></td>
<td><p><code>A(i,j)*= B(i,j)</code></p>
<p><code>A(i,j)/= B(i,j)</code></p></td>
</tr>
</tbody>
</table>
<h3 id="arithmetic-operations-between-matrices-and-real-numbers"><span class="header-section-number">14.4.2</span> Arithmetic Operations between Matrices and Real Numbers</h3>
<table style="width:89%;">
<colgroup>
<col style="width: 37%">
<col style="width: 27%">
<col style="width: 23%">
</colgroup>
<tbody>
<tr class="odd">
<td>Description</td>
<td>Format</td>
<td>Comment</td>
</tr>
<tr class="even">
<td>element wise sum</td>
<td><code>C=r+A</code> <code>C=A+r</code> <code>A+=r</code></td>
<td>overwrites <span class="math inline">\(A\)</span></td>
</tr>
<tr class="odd">
<td>element wise subtraction</td>
<td><code>C=r-A</code> <code>C=A-r</code> <code>A-=r</code></td>
<td>overwrites <span class="math inline">\(A\)</span></td>
</tr>
<tr class="even">
<td>matrix multiplication</td>
<td><code>C=r*A</code> <code>C=A*r</code> <code>A*=r</code></td>
<td>overwrites <span class="math inline">\(A\)</span></td>
</tr>
</tbody>
</table>
<h3 id="comparisons-and-boolean-operations"><span class="header-section-number">14.4.3</span> Comparisons and Boolean Operations</h3>
<p>The following table shows element wise comparisons between two matrices:</p>
<table>
<colgroup>
<col style="width: 51%">
<col style="width: 13%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>A == B</code></td>
<td><code>Bool_t</code></td>
<td>equal to</td>
</tr>
<tr class="odd">
<td><p><code>A != B</code></p>
<p><code>A &gt; B</code></p>
<p><code>A &gt;= B</code></p>
<p><code>A &lt; B</code></p>
<p><code>A &lt;= B</code></p></td>
<td><p>matrix</p>
<p>matrix</p>
<p>matrix</p>
<p>matrix</p>
<p>matrix</p></td>
<td><p>Not equal</p>
<p>Greater than</p>
<p>Greater than or equal to</p>
<p>Smaller than</p>
<p>Smaller than or equal to</p></td>
</tr>
<tr class="even">
<td><p><code>AreCompatible(A,B)</code></p>
<p><code>Compare(A,B)</code></p>
<p><code>VerifyMatrixIdentity(A,B,verb, maxDev)</code></p></td>
<td><p><code>Bool_t</code></p>
<p><code>Bool_t</code></p></td>
<td><p>Compare matrix properties</p>
<p>return summary of comparison</p>
<p>Check matrix identity within <code>maxDev</code> tolerance</p></td>
</tr>
</tbody>
</table>
<p>The following table shows element wise comparisons between matrix and real:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 49%">
<col style="width: 13%">
<col style="width: 37%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><p><code>A == r</code></p>
<p>A != r</p>
<p>A &gt; r</p>
<p>A &gt;= r</p>
<p>A &lt; r</p>
<p>A &lt;= r</p></td>
<td><p><code>Bool_t</code></p>
<p><code>Bool_t</code></p>
<p><code>Bool_t</code> <code>Bool_t</code></p>
<p><code>Bool_t</code> <code>Bool_t</code></p></td>
<td><p>equal to</p>
<p>Not equal</p>
<p>Greater than</p>
<p>Greater than or equal to</p>
<div class="line-block">Smaller than</div>
<p>Smaller than or equal to</p></td>
</tr>
<tr class="odd">
<td><code>VerifyMatrixValue(A,r,verb, maxDev)</code></td>
<td><code>Bool_t</code></td>
<td>Compare matrix value with r within <code>maxDev</code> tolerance</td>
</tr>
</tbody>
</table>
<h3 id="matrix-norms"><span class="header-section-number">14.4.4</span> Matrix Norms</h3>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 18%">
<col style="width: 51%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><p><code>A.RowNorm()</code></p>
<p><code>A.NormInf()</code></p>
<p><code>A.ColNorm()</code></p>
<p><code>A.Norm1()</code></p>
<p><code>A.E2Norm()</code></p>
<p><code>A.NonZeros()</code></p>
<p><code>A.Sum()</code></p>
<p><code>A.Min()</code></p>
<p><code>A.Max()</code></p></td>
<td><p><code>Double_t</code></p>
<p><code>Double_t</code></p>
<p><code>Double_t</code></p>
<p><code>Double_t</code></p>
<p><code>Double_t</code></p>
<p><code>Int_t</code></p>
<p><code>Double_t</code></p>
<p><code>Double_t</code></p>
<p><code>Double_t</code></p></td>
<td><p>norm induced by the infinity vector norm, max<em>i</em><span class="math inline">\(\sum_{i}|A_{ij}|\)</span></p>
<p>max<em>i</em><span class="math inline">\(\sum_{i}|A_{ij}|\)</span></p>
<p>norm induced by the 1 vector norm, max<em>j</em><span class="math inline">\(\sum_{i}|A_{ij}|\)</span></p>
<p>max<em>j</em><span class="math inline">\(\sum_{i}|A_{ij}|\)</span></p>
<p>Square of the Euclidean norm,</p>
<p><span class="math inline">\(\sum_{ji}(A_{ij}^{2})\)</span></p>
<p>number of elements unequal zero</p>
<p><span class="math inline">\(\sum_{ji}(A_{ij})\)</span></p>
<p>min<em>ij</em> <span class="math inline">\((A_{ij})\)</span></p>
<p>max<em>ij</em> <span class="math inline">\((A_{ij})\)</span></p></td>
</tr>
<tr class="odd">
<td><p><code>A.NormByColumn</code> <code>(v,"D")</code></p>
<p><code>A.NormByRow</code> <code>(v,"D")</code></p></td>
<td><p><code>TMatrixD</code></p>
<p><code>TMatrixD</code></p></td>
<td><p><span class="math inline">\(A_{ij}/= \nu_i\)</span>, divide each matrix column by vector v. If the second argument is “<code>M</code>”, the column is multiplied.</p>
<p><span class="math inline">\(A_{ij}/= \nu_j\)</span>, divide each matrix row by vector v. If the second argument is “<code>M</code>”, the row is multiplied.</p></td>
</tr>
</tbody>
</table>
<h3 id="miscellaneous-operators"><span class="header-section-number">14.4.5</span> Miscellaneous Operators</h3>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 15%">
<col style="width: 53%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>A.Zero()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = 0\)</span></td>
</tr>
<tr class="odd">
<td><code>A.Abs()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = |A_{ij}|\)</span></td>
</tr>
<tr class="even">
<td><code>A.Sqr()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = A_{ij}^2\)</span></td>
</tr>
<tr class="odd">
<td><code>A.Sqrt()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = \sqrt{(A_{ij})}\)</span></td>
</tr>
<tr class="even">
<td><code>A.UnitMatrix()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = 1\)</span> for <em>i ==j</em> else 0</td>
</tr>
<tr class="odd">
<td><code>A.Randomize</code> <code>(alpha,beta,seed)</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\)</span> a random matrix is generated with elements uniformly distributed between <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span></td>
</tr>
<tr class="even">
<td><code>A.T()</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = A_{ji}\)</span></td>
</tr>
<tr class="odd">
<td><code>A.Transpose(B)</code></td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = B_{ji}\)</span></td>
</tr>
<tr class="even">
<td><code>A.Invert(&amp;det)</code></td>
<td><code>TMatrixX</code></td>
<td>Invert matrix A. If the optional pointer to the <code>Double_t</code> argument <code>det</code> is supplied, the matrix determinant is calculated.</td>
</tr>
<tr class="odd">
<td><code>A.InvertFast(&amp;det)</code></td>
<td><code>TMatrixX</code></td>
<td>like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used</td>
</tr>
<tr class="even">
<td><code>A.Rank1Update(v,alpha)</code></td>
<td><code>TMatrixX</code></td>
<td>Perform with vector v a rank 1 operation on the matrix: <span class="math inline">\(A = A + \alpha.\nu.\nu^T\)</span></td>
</tr>
<tr class="odd">
<td><code>A.RandomizePD</code>(alpha,beta,seed)`</td>
<td><code>TMatrixX</code></td>
<td><span class="math inline">\(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\)</span> a random symmetric positive-definite matrix is generated with elements uniformly distributed between <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span></td>
</tr>
</tbody>
</table>
<p>Output <strong><code>TMatrixX</code></strong> indicates that the returned matrix is of the same type as <code>A</code>, being <strong><code>TMatrixD</code></strong>, <strong><code>TMatrixDSym</code></strong> or <strong><code>TMatrixDSparse</code></strong>. Next table shows miscellaneous operations for <strong><code>TMatrixD</code></strong>.</p>
<table>
<colgroup>
<col style="width: 41%">
<col style="width: 16%">
<col style="width: 42%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>A.Rank1Update(v1,v2,alpha)</code></td>
<td><code>TMatrixD</code></td>
<td>Perform with vector <code>v1</code> and <code>v2</code>, a rank 1 operation on the matrix: <span class="math inline">\(A = A + \alpha.\nu.\nu2^T\)</span></td>
</tr>
</tbody>
</table>
<h2 id="matrix-views"><span class="header-section-number">14.5</span> Matrix Views</h2>
<p>Another way to access matrix elements is through the matrix-view classes, <strong><code>TMatrixDRow</code></strong>, <strong><code>TMatrixDColumn</code></strong>, <strong><code>TMatrixDDiag</code></strong> and <strong><code>TMatrixDSub</code></strong>
 (each has also a const version which is obtained by simply appending 
const to the class name). These classes create a reference to the 
underlying matrix, so no memory management is involved. The next table 
shows how the classes access different parts of the matrix:</p>
<table>
<colgroup>
<col style="width: 44%">
<col style="width: 56%">
</colgroup>
<tbody>
<tr class="odd">
<td>class</td>
<td>view</td>
</tr>
<tr class="even">
<td><code>TMatrixDRow const(X,i)</code> <code>TMatrixDRow(X,i)</code></td>
<td><span class="math display">\[ \left(\begin{array}{ccccc}
x_{00} &amp;     &amp;        &amp;     &amp; x_{0n} \\
       &amp;     &amp;        &amp;     &amp;        \\
x_{i0} &amp; ... &amp; x_{ij} &amp; ... &amp; x_{in} \\
       &amp;     &amp;        &amp;     &amp;        \\
x_{n0} &amp;     &amp;        &amp;     &amp; x_{nn}
\end{array}\right)\]</span></td>
</tr>
<tr class="odd">
<td><code>TMatrixDColumn const(X,j)</code> <code>TMatrixDColumn(X,j)</code></td>
<td><span class="math display">\[ \left(\begin{array}{ccccc}
x_{00} &amp;     &amp; x_{0j} &amp;     &amp; x_{0n} \\
       &amp;     &amp;  ...   &amp;     &amp;        \\
       &amp;     &amp; x_{ij} &amp;     &amp;        \\
       &amp;     &amp;  ...   &amp;     &amp;        \\
x_{n0} &amp;     &amp; x_{nj} &amp;     &amp; x_{nn}
\end{array}\right)\]</span></td>
</tr>
<tr class="even">
<td><code>TMatrixDDiag const(X)</code> <code>TMatrixDDiag(X)</code></td>
<td><span class="math display">\[ \left(\begin{array}{ccccc}
x_{00} &amp;     &amp;        &amp;     &amp; x_{0n} \\
       &amp; ... &amp;        &amp;     &amp;        \\
       &amp;     &amp;   ...  &amp;     &amp;        \\
       &amp;     &amp;        &amp; ... &amp;        \\
x_{n0} &amp;     &amp;        &amp;     &amp; x_{nn}
\end{array}\right)\]</span></td>
</tr>
<tr class="odd">
<td><code>TMatrixDSub const(X,i,l,j,k)</code> <code>TMatrixDSub(X,i,l,j,k)</code></td>
<td><span class="math display">\[ \left(\begin{array}{ccccc}
x_{00} &amp;     &amp;        &amp;     &amp; x_{0n} \\
       &amp;     &amp;        &amp;     &amp;        \\
       &amp;     &amp; x_{ij} &amp; ... &amp; x_{ik} \\
       &amp;     &amp; x_{lj} &amp; ... &amp; x_{lk} \\
x_{n0} &amp;     &amp;        &amp;     &amp; x_{nn}
\end{array}\right)\]</span></td>
</tr>
</tbody>
</table>
<h3 id="view-operators"><span class="header-section-number">14.5.1</span> View Operators</h3>
<p>For the matrix views <strong><code>TMatrixDRow</code></strong>, <strong><code>TMatrixDColumn</code></strong> and <strong><code>TMatrixDDiag</code></strong>, the necessary assignment operators are available to interact with the vector class <strong><code>TVectorD</code></strong>. The sub matrix view <strong><code>TMatrixDSub</code></strong> has links to the matrix classes <strong><code>TMatrixD</code></strong> and <strong><code>TMatrixDSym</code></strong>. The next table summarizes how the access individual matrix elements in the matrix views:</p>
<table>
<colgroup>
<col style="width: 53%">
<col style="width: 46%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Comment</td>
</tr>
<tr class="even">
<td><code>TMatrixDRow(A,i)(j)</code> <code>TMatrixDRow(A,i)[j]</code></td>
<td>element <span class="math inline">\(A_{ij}\)</span></td>
</tr>
<tr class="odd">
<td><code>TMatrixDColumn(A,j)(i)</code> <code>TMatrixDColumn(A,j)[i]</code></td>
<td>element <span class="math inline">\(A_{ij}\)</span></td>
</tr>
<tr class="even">
<td><code>TMatrixDDiag(A(i)</code> <code>TMatrixDDiag(A[i]</code></td>
<td>element <span class="math inline">\(A_{ij}\)</span></td>
</tr>
<tr class="odd">
<td><code>TMatrixDSub(A(i)</code> <code>TMatrixDSub(A,rl,rh,cl,ch)(i,j)</code></td>
<td><p>element <span class="math inline">\(A_{ij}\)</span></p>
<p>element <span class="math inline">\(A_{rl+i,cl+j}\)</span></p></td>
</tr>
</tbody>
</table>
<p>The next two tables show the possible operations with real numbers, and the operations between the matrix views:</p>
<table style="width:99%;">
<colgroup>
<col style="width: 29%">
<col style="width: 44%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr class="odd">
<td>Description</td>
<td><pre><code> Format</code></pre></td>
<td>Comment</td>
</tr>
<tr class="even">
<td>assign real</td>
<td><code>TMatrixDRow(A,i) = r</code></td>
<td>row <span class="math inline">\(i\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixDColumn(A,j) = r</code></td>
<td>column <span class="math inline">\(j\)</span></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDDiag(A) = r</code></td>
<td>matrix diagonal</td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixDSub(A,i,l,j,k) = r</code></td>
<td>sub matrix</td>
</tr>
</tbody>
</table>
<table style="width:99%;">
<colgroup>
<col style="width: 29%">
<col style="width: 44%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr class="odd">
<td>add real</td>
<td><code>TMatrixDRow(A,i) += r</code></td>
<td>row <span class="math inline">\(i\)</span></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDColumn(A,j) += r</code></td>
<td>column <span class="math inline">\(j\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixDDiag(A) += r</code></td>
<td>matrix diagonal</td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDSub(A,i,l,j,k) +=r</code></td>
<td>sub matrix</td>
</tr>
</tbody>
</table>
<table style="width:99%;">
<colgroup>
<col style="width: 29%">
<col style="width: 44%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr class="odd">
<td>multiply with real</td>
<td><code>TMatrixDRow(A,i) *= r</code></td>
<td>row <span class="math inline">\(i\)</span></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDColumn(A,j) *= r</code></td>
<td>column <span class="math inline">\(j\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixDDiag(A) *= r</code></td>
<td>matrix diagonal</td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDSub(A,i,l,j,k) *= r</code></td>
<td>sub matrix</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 34%">
<col style="width: 40%">
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>  Description</code></pre></td>
<td><pre><code>  Format</code></pre></td>
<td><pre><code>   Comment</code></pre></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDRow(A,i1) +=</code> <code>TMatrixDRow const(B,i2)</code></td>
<td>add row <span class="math inline">\(i2\)</span> to row <span class="math inline">\(i1\)</span></td>
</tr>
<tr class="odd">
<td>add matrix slice</td>
<td><code>TMatrixDColumn(A,j1) +=</code> <code>TMatrixDColumn const(A,j2)</code></td>
<td>add column <span class="math inline">\(j2\)</span> to column <span class="math inline">\(j1\)</span></td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDDiag(A) +=</code> <code>TMatrixDDiag const(B)</code></td>
<td>add <span class="math inline">\(B\)</span> diagonal to <span class="math inline">\(A\)</span> diagonal</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 34%">
<col style="width: 40%">
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td><code>TMatrixDRow(A,i1) *=</code> <code>TMatrixDRow const(B,i2)</code></td>
<td>multiply row <span class="math inline">\(i2\)</span> with row <span class="math inline">\(i1\)</span> element wise</td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDColumn(A,j1) *=</code> <code>TMatrixDColumn const(A,j2)</code></td>
<td>multiply column <span class="math inline">\(j2\)</span> with column <span class="math inline">\(j1\)</span> element wise</td>
</tr>
<tr class="odd">
<td>multiply matrix slice</td>
<td><code>TMatrixDDiag(A) *=</code> <code>TMatrixDDiag const(B)</code></td>
<td>multiply <span class="math inline">\(B\)</span> diagonal with <span class="math inline">\(A\)</span> diagonal element wise</td>
</tr>
<tr class="even">
<td></td>
<td><code>TMatrixDSub(A,i1,l1,j1,k1) *=</code> <code>TMatrixDSub(B,i2,l2,j2,k2)</code></td>
<td>multiply sub matrix of <span class="math inline">\(A\)</span> with sub matrix of <span class="math inline">\(B\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TMatrixDSub(A,i,l,j,k) *= B</code></td>
<td>multiply sub matrix of <span class="math inline">\(A\)</span> with matrix of <span class="math inline">\(B\)</span></td>
</tr>
</tbody>
</table>
<p>In the current implementation of the matrix views, the user could 
perform operations on a symmetric matrix that violate the symmetry. No 
checking is done. For instance, the following code violates the 
symmetry.</p>
<div class="sourceCode" id="cb791"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb791-1" title="1">   TMatrixDSym A(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb791-2" title="2">   A.UnitMatrix();</a>
<a class="sourceLine" id="cb791-3" title="3">   TMatrixDRow(A,<span class="dv">1</span>)[<span class="dv">0</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb791-4" title="4">   TMatrixDRow(A,<span class="dv">1</span>)[<span class="dv">2</span>] = <span class="dv">1</span>;</a></code></pre></div>
<h3 id="view-examples"><span class="header-section-number">14.5.2</span> View Examples</h3>
<p>Inserting row <code>i1</code>into row<code>i2</code> of matrix <span class="math inline">\(A\)</span> can easily accomplished through:</p>
<div class="sourceCode" id="cb792"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb792-1" title="1">   TMatrixDRow(A,i1) = TMatrixDRow(A,i2)</a></code></pre></div>
<p>Which more readable than:</p>
<div class="sourceCode" id="cb793"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb793-1" title="1">   <span class="at">const</span> <span class="dt">Int_t</span> ncols = A.GetNcols();</a>
<a class="sourceLine" id="cb793-2" title="2">   <span class="dt">Double_t</span> *start = A.GetMatrixArray();</a>
<a class="sourceLine" id="cb793-3" title="3">   <span class="dt">Double_t</span> *rp1 = start+i*ncols;</a>
<a class="sourceLine" id="cb793-4" title="4">   <span class="at">const</span> <span class="dt">Double_t</span> *rp2 = start+j*ncols;</a>
<a class="sourceLine" id="cb793-5" title="5">   <span class="cf">while</span> (rp1 &lt; start+ncols) *rp1++ = *rp2++;</a></code></pre></div>
<p>Check that the columns of a Haar -matrix of order <code>order</code> are indeed orthogonal:</p>
<div class="sourceCode" id="cb794"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb794-1" title="1">   <span class="at">const</span> TMatrixD haar = THaarMatrixD(order);</a>
<a class="sourceLine" id="cb794-2" title="2">   TVectorD colj(<span class="dv">1</span>&lt;&lt;order);</a>
<a class="sourceLine" id="cb794-3" title="3">   TVectorD coll(<span class="dv">1</span>&lt;&lt;order);</a>
<a class="sourceLine" id="cb794-4" title="4">   <span class="cf">for</span> (<span class="dt">Int_t</span> j = haar.GetColLwb(); j &lt;= haar.GetColUpb(); j++) {</a>
<a class="sourceLine" id="cb794-5" title="5">      colj = TMatrixDColumn_const(haar,j);</a>
<a class="sourceLine" id="cb794-6" title="6">      Assert(TMath::Abs(colj*colj-<span class="fl">1.0</span>) &lt;= <span class="fl">1.0e-15</span>);</a>
<a class="sourceLine" id="cb794-7" title="7"></a>
<a class="sourceLine" id="cb794-8" title="8">      <span class="cf">for</span> (<span class="dt">Int_t</span> l = j+<span class="dv">1</span>; l &lt;= haar.GetColUpb(); l++) {</a>
<a class="sourceLine" id="cb794-9" title="9">         coll = TMatrixDColumn_const(haar,l);</a>
<a class="sourceLine" id="cb794-10" title="10">         Assert(TMath::Abs(colj*coll) &lt;= <span class="fl">1.0e-15</span>);</a>
<a class="sourceLine" id="cb794-11" title="11">      }</a>
<a class="sourceLine" id="cb794-12" title="12">   }</a></code></pre></div>
<p>Multiplying part of a matrix with another part of that matrix (they can overlap)</p>
<div class="sourceCode" id="cb795"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb795-1" title="1">   TMatrixDSub(m,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>) *= m.GetSub(<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">5</span>,<span class="dv">7</span>);</a></code></pre></div>
<h2 id="matrix-decompositions"><span class="header-section-number">14.6</span> Matrix Decompositions</h2>
<p>The linear algebra package offers several classes to assist in matrix
 decompositions. Each of the decomposition methods performs a set of 
matrix transformations to facilitate solving a system of linear 
equations, the formation of inverses as well as the estimation of 
determinants and condition numbers. More specifically the classes <strong><code>TDecompLU</code></strong>, <strong><code>TDecompBK</code></strong>, <strong><code>TDecompChol</code></strong>, <strong><code>TDecompQRH</code></strong> and <strong><code>TDecompSVD</code></strong>
 give a simple and consistent interface to the LU, Bunch-Kaufman, 
Cholesky, QR and SVD decompositions. All of these classes are derived 
from the base class <strong><code>TDecompBase</code></strong> of which the important methods are listed in next table:</p>
<table>
<colgroup>
<col style="width: 58%">
<col style="width: 41%">
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>               Method</code></pre></td>
<td><pre><code>     Action</code></pre></td>
</tr>
<tr class="even">
<td><code>Bool_t Decompose()</code></td>
<td>perform the matrix decomposition</td>
</tr>
<tr class="odd">
<td><code>Double_t Condition()</code></td>
<td>calculate ||<em>A</em>||1 ||<em>A</em>-1||1, see “Condition number”</td>
</tr>
<tr class="even">
<td><code>void Det(Double_t &amp;d1,Double_t &amp;d2)</code></td>
<td>the determinant is <code>d1</code> <span class="math inline">\(2^{d_{2}}\)</span>. Expressing the determinant this way makes under/over-flow very unlikely</td>
</tr>
<tr class="odd">
<td><code>Bool_t Solve(TVectorD &amp;b)</code></td>
<td>solve <code>Ax=b</code>; vector<code>b</code> is supplied through the argument and replaced with solution <code>x</code></td>
</tr>
<tr class="even">
<td><code>TVectorD Solve(const TVectorD &amp;b,Bool_t &amp;ok)</code></td>
<td>solve <code>Ax=b; x</code> is returned</td>
</tr>
<tr class="odd">
<td><code>Bool_t Solve(TMatrixDColumn &amp;b)</code></td>
<td>solve <code>Ax=column(B,j)</code>;<code>column(B,j)</code> is supplied through the argument and replaced with solution <code>x</code></td>
</tr>
<tr class="even">
<td><code>Bool_t TransSolve(TVectorD &amp;b)</code></td>
<td>solve <span class="math inline">\(A^Tx=b;\)</span> vector <code>b</code> is supplied through the argument and replaced with solution <code>x</code></td>
</tr>
<tr class="odd">
<td><code>TVectorD TransSolve(const TVectorD b, Bool_t &amp;ok)</code></td>
<td>solve <span class="math inline">\(A^Tx=b;\)</span> vector <code>x</code> is returned</td>
</tr>
<tr class="even">
<td><code>Bool_t TransSolve(TMatrixDColumn &amp;b)</code></td>
<td>solve <code>ATx=column(B,j); column(B,j)</code> is supplied through the argument and replaced with solution <code>x</code></td>
</tr>
<tr class="odd">
<td><code>Bool_t MultiSolve(TMatrixD &amp;B)</code></td>
<td>solve <span class="math inline">\(A^Tx=b;\)</span>. matrix <code>B</code> is supplied through the argument and replaced with solution <code>X</code></td>
</tr>
<tr class="even">
<td><code>void Invert(TMatrixD &amp;inv)</code></td>
<td>call to <code>MultiSolve</code> with as input argument the unit matrix. Note that for a matrix (<code>m</code> x <code>n</code>) - <span class="math inline">\(A\)</span> with <code>m &gt; n</code>, a pseudo-inverse is calculated</td>
</tr>
<tr class="odd">
<td><code>TMatrixD Invert()</code></td>
<td>call to <code>MultiSolve</code> with as input argument the unit matrix. Note that for a matrix (<code>m</code> x <code>n</code>) - <span class="math inline">\(A\)</span> with <code>m &gt; n</code>, a pseudo-inverse is calculated</td>
</tr>
</tbody>
</table>
<p>Through <strong><code>TDecompSVD</code></strong> and <strong><code>TDecompQRH</code></strong> one can solve systems for a (<code>m</code> x <code>n</code>) - <span class="math inline">\(A\)</span> with <code>m&gt;n</code>.
 However, care has to be taken for methods where the input vector/matrix
 is replaced by the solution. For instance in the method <strong><code>Solve(b)</code></strong>, the input vector should have length m but only the first n entries of the output contain the solution. For the <strong><code>Invert(B)</code></strong> method, the input matrix B should have size (<code>m</code> x <code>n</code>) so that the returned (<code>m</code> x <code>n</code>) pseudo-inverse can fit in it.</p>
<p>The classes store the state of the decomposition process of matrix <span class="math inline">\(A\)</span> in the user-definable part of <strong><code>TObject::fBits</code></strong>, see the next table. This guarantees the correct order of the operations:</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 82%">
</colgroup>
<tbody>
<tr class="odd">
<td><p><code>kMatrixSet</code></p>
<p><code>kDecomposed</code></p>
<p><code>kDetermined</code></p>
<p><code>kCondition</code></p>
<p><code>kSingular</code></p></td>
<td><p><span class="math inline">\(A\)</span> <code>assigned</code></p>
<p><span class="math inline">\(A\)</span> decomposed, bit <code>kMatrixSet</code> must have been set.</p>
<p><code>det</code> <span class="math inline">\(A\)</span> calculated, bit <code>kDecomposed</code> must have been set.</p>
<p>||<em>A</em>||1 ||<em>A</em>-1||1 is calculated bit <code>kDecomposed</code> must have been set.</p>
<p><span class="math inline">\(A\)</span> is singular</p></td>
</tr>
</tbody>
</table>
<p>The state is reset by assigning a new matrix through <code>SetMatrix(TMatrixD &amp;A)</code> for <strong><code>TDecompBK</code></strong> and <strong><code>TDecompChol</code></strong> (actually <code>SetMatrix(</code><strong><code>TMatrixDSym &amp;A)</code></strong> and <code>SetMatrix(</code><strong><code>TMatrixDSparse</code></strong> <code>&amp;A)</code> for <strong><code>TMatrixDSparse</code></strong>).</p>
<p>As the code example below shows, the user does not have to worry 
about the decomposition step before calling a solve method, because the 
decomposition class checks before invoking <code>Solve</code> that the matrix has been decomposed.</p>
<div class="sourceCode" id="cb798"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb798-1" title="1">   TVectorD b = ..;</a>
<a class="sourceLine" id="cb798-2" title="2">   TMatrixD a = ..;</a>
<a class="sourceLine" id="cb798-3" title="3">   .</a>
<a class="sourceLine" id="cb798-4" title="4">   TDecompLU lu(a);</a>
<a class="sourceLine" id="cb798-5" title="5">   <span class="dt">Bool_t</span> ok;</a>
<a class="sourceLine" id="cb798-6" title="6">   lu.Solve(b,ok);</a></code></pre></div>
<p>In the next example, we show again the same decomposition but now 
performed in a loop and all necessary steps are manually invoked. This 
example also demonstrates another very important point concerning memory
 management! Note that the vector, matrix and decomposition class are 
constructed outside the loop since the dimensions of vector/matrix are 
constant. If we would have replaced <code>lu.SetMatrix(a)</code> by <strong><code>TDecompLU</code></strong> <code>lu(a)</code>, we would construct/deconstruct the array elements of <code>lu</code> on the stack<em>.</em></p>
<div class="sourceCode" id="cb799"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb799-1" title="1">   TVectorD b(n);</a>
<a class="sourceLine" id="cb799-2" title="2">   TMatrixD a(n,n);</a>
<a class="sourceLine" id="cb799-3" title="3">   TDecompLU lu(n);</a>
<a class="sourceLine" id="cb799-4" title="4">   <span class="dt">Bool_t</span> ok;</a>
<a class="sourceLine" id="cb799-5" title="5">   <span class="cf">for</span> (....) {</a>
<a class="sourceLine" id="cb799-6" title="6">      b = ..;</a>
<a class="sourceLine" id="cb799-7" title="7">      a = ..;</a>
<a class="sourceLine" id="cb799-8" title="8">      lu.SetMatrix(a);</a>
<a class="sourceLine" id="cb799-9" title="9">      lu.Decompose();</a>
<a class="sourceLine" id="cb799-10" title="10">      lu.Solve(b,ok);</a>
<a class="sourceLine" id="cb799-11" title="11">   }</a></code></pre></div>
<h3 id="tolerances-and-scaling"><span class="header-section-number">14.6.1</span> Tolerances and Scaling</h3>
<p>The tolerance parameter <code>fTol</code> (a member of the base class <strong><code>TDecompBase</code></strong>)
 plays a crucial role in all operations of the decomposition classes. It
 gives the user a tool to monitor and steer the operations its default 
value is <span class="math inline">\(\varepsilon\)</span> where <span class="math inline">\(1+\varepsilon=1\)</span>.</p>
<p>If you do not want to be bothered by the following considerations, 
like in most other linear algebra packages, just set the tolerance with <code>SetTol</code>
 to an arbitrary small number. The tolerance number is used by each 
decomposition method to decide whether the matrix is near singular, 
except of course SVD that can handle singular matrices. This will be 
checked in a different way for any decomposition. For instance in LU, a 
matrix is considered singular in the solving stage when a diagonal 
element of the decomposed matrix is smaller than <code>fTol</code>. Here an important point is raised. The <code>Decompose()</code>
 method is successful as long no zero diagonal element is encountered. 
Therefore, the user could perform decomposition and only after this step
 worry about the tolerance number.</p>
<p>If the matrix is flagged as being singular, operations with the 
decomposition will fail and will return matrices or vectors that are 
invalid. If one would like to monitor the tolerance parameter but not 
have the code stop in case of a number smaller than <code>fTol</code>, one could proceed as follows:</p>
<div class="sourceCode" id="cb800"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb800-1" title="1">   TVectorD b = ..;</a>
<a class="sourceLine" id="cb800-2" title="2">   TMatrixD a = ..;</a>
<a class="sourceLine" id="cb800-3" title="3">   .</a>
<a class="sourceLine" id="cb800-4" title="4">   TDecompLU lu(a);</a>
<a class="sourceLine" id="cb800-5" title="5">   <span class="dt">Bool_t</span> ok;</a>
<a class="sourceLine" id="cb800-6" title="6">   TVectorD x = lu.Solve(b,ok);</a>
<a class="sourceLine" id="cb800-7" title="7">   <span class="dt">Int_t</span> nr = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb800-8" title="8">   <span class="cf">while</span> (!ok) {</a>
<a class="sourceLine" id="cb800-9" title="9">      lu.SetMatrix(a);</a>
<a class="sourceLine" id="cb800-10" title="10">      lu.SetTol(<span class="fl">0.1</span>*lu.GetTol());</a>
<a class="sourceLine" id="cb800-11" title="11">      <span class="cf">if</span> (nr++ &gt; <span class="dv">10</span>) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb800-12" title="12">      x = lu.Solve(b,ok);</a>
<a class="sourceLine" id="cb800-13" title="13">   }</a>
<a class="sourceLine" id="cb800-14" title="14">   <span class="cf">if</span> (x.IsValid())</a>
<a class="sourceLine" id="cb800-15" title="15">   cout &lt;&lt; <span class="st">"solved with tol ="</span> &lt;&lt; lu.GetTol() &lt;&lt; endl;</a>
<a class="sourceLine" id="cb800-16" title="16">   <span class="cf">else</span></a>
<a class="sourceLine" id="cb800-17" title="17">   cout &lt;&lt; <span class="st">"solving failed "</span> &lt;&lt; endl;</a></code></pre></div>
<p>The observant reader will notice that by scaling the complete matrix 
by some small number the decomposition will detect a singular matrix. In
 this case, the user will have to reduce the tolerance number by this 
factor. (For CPU time saving we decided not to make this an automatic 
procedure).</p>
<h3 id="condition-number"><span class="header-section-number">14.6.2</span> Condition number</h3>
<p>The numerical accuracy of the solution <code>x</code> in <code>Ax = b</code> can be accurately estimated by calculating the condition number <code>k</code> of matrix <span class="math inline">\(A\)</span>, which is defined as:</p>
<p><span class="math inline">\(k = ||A||_{1}||A^{-1}||_{1}\)</span> where <span class="math inline">\(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\)</span></p>
<p>A good rule of thumb is that if the matrix condition number is 10n, the accuracy in <code>x</code> is <code>15</code> - <code>n</code> digits for double precision.</p>
<p>Hager devised an iterative method (W.W. Hager, Condition estimators, 
SIAM J. Sci. Stat. Comp., 5 (1984), pp.&nbsp;311-316) to determine <span class="math inline">\(||A^{-1}||_{1}\)</span> without actually having to calculate <span class="math inline">\(A^{-1}\)</span>. It is used when calling <code>Condition()</code>.</p>
<p>A code example below shows the usage of the condition number. The matrix <span class="math inline">\(A\)</span> is a (10x10) <em>Hilbert</em> matrix that is badly conditioned as its determinant shows. We construct a vector <code>b</code> by summing the matrix rows. Therefore, the components of the solution vector <code>x</code> should be exactly 1. Our rule of thumb to the 2.1012 condition number predicts that the solution accuracy should be around</p>
<p><code>15 - 12 = 3</code></p>
<p>digits. Indeed, the largest deviation is 0.00055 in component 6.</p>
<div class="sourceCode" id="cb801"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb801-1" title="1">   TMatrixDSym H = THilbertMatrixDSym(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb801-2" title="2">   TVectorD rowsum(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb801-3" title="3">   <span class="cf">for</span> (<span class="dt">Int_t</span> irow = <span class="dv">0</span>; irow &lt; <span class="dv">10</span>; irow++)</a>
<a class="sourceLine" id="cb801-4" title="4">   <span class="cf">for</span> (<span class="dt">Int_t</span> icol = <span class="dv">0</span>; icol &lt; <span class="dv">10</span>; icol++)</a>
<a class="sourceLine" id="cb801-5" title="5">   rowsum(irow) += H(irow,icol);</a>
<a class="sourceLine" id="cb801-6" title="6">   TDecompLU lu(H);</a>
<a class="sourceLine" id="cb801-7" title="7">   <span class="dt">Bool_t</span> ok;</a>
<a class="sourceLine" id="cb801-8" title="8">   TVectorD x = lu.Solve(rowsum,ok);</a>
<a class="sourceLine" id="cb801-9" title="9">   <span class="dt">Double_t</span> d1,d2;</a>
<a class="sourceLine" id="cb801-10" title="10">   lu.Det(d1,d2);</a>
<a class="sourceLine" id="cb801-11" title="11">   cout &lt;&lt; <span class="st">"cond:"</span> &lt;&lt; lu.Condition() &lt;&lt; endl;</a>
<a class="sourceLine" id="cb801-12" title="12">   cout &lt;&lt; <span class="st">"det :"</span> &lt;&lt; d1*TMath:Power(<span class="fl">2.</span>,d2) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb801-13" title="13">   cout &lt;&lt; <span class="st">"tol :"</span> &lt;&lt; lu.GetTol() &lt;&lt; endl;</a>
<a class="sourceLine" id="cb801-14" title="14">   x.Print();</a>
<a class="sourceLine" id="cb801-15" title="15">   cond:<span class="fl">3.9569e+12</span></a>
<a class="sourceLine" id="cb801-16" title="16">   det :<span class="fl">2.16439e-53</span></a>
<a class="sourceLine" id="cb801-17" title="17">   tol :<span class="fl">2.22045e-16</span></a>
<a class="sourceLine" id="cb801-18" title="18">   Vector <span class="dv">10</span> is as follows</a>
<a class="sourceLine" id="cb801-19" title="19">     |          <span class="dv">1</span>   |</a>
<a class="sourceLine" id="cb801-20" title="20">   ------------------</a>
<a class="sourceLine" id="cb801-21" title="21">   <span class="dv">0</span> |<span class="dv">1</span></a>
<a class="sourceLine" id="cb801-22" title="22">   <span class="dv">1</span> |<span class="dv">1</span></a>
<a class="sourceLine" id="cb801-23" title="23">   <span class="dv">2</span> |<span class="fl">0.999997</span></a>
<a class="sourceLine" id="cb801-24" title="24">   <span class="dv">3</span> |<span class="fl">1.00003</span></a>
<a class="sourceLine" id="cb801-25" title="25">   <span class="dv">4</span> |<span class="fl">0.999878</span></a>
<a class="sourceLine" id="cb801-26" title="26">   <span class="dv">5</span> |<span class="fl">1.00033</span></a>
<a class="sourceLine" id="cb801-27" title="27">   <span class="dv">6</span> |<span class="fl">0.999452</span></a>
<a class="sourceLine" id="cb801-28" title="28">   <span class="dv">7</span> |<span class="fl">1.00053</span></a>
<a class="sourceLine" id="cb801-29" title="29">   <span class="dv">8</span> |<span class="fl">0.999723</span></a>
<a class="sourceLine" id="cb801-30" title="30">   <span class="dv">9</span> |<span class="fl">1.00006</span></a></code></pre></div>
<h3 id="lu"><span class="header-section-number">14.6.3</span> LU</h3>
<p>Decompose an <code>nxn</code> matrix <span class="math inline">\(A\)</span>.</p>
<div class="sourceCode" id="cb802"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb802-1" title="1">   PA = LU</a></code></pre></div>
<p><em>P</em> permutation matrix stored in the index array <code>fIndex</code>: <code>j=fIndex[i]</code> indicates that row j and row<code>i</code>should be swapped. Sign of the permutation, <span class="math inline">\(-1^n\)</span>, where <code>n</code> is the number of interchanges in the permutation, stored in <code>fSign</code>.</p>
<p><em>L</em> is lower triangular matrix, stored in the strict lower triangular part of <code>fLU.</code> The diagonal elements of <em>L</em> are unity and are not stored.</p>
<p><em>U</em> is upper triangular matrix, stored in the diagonal and upper triangular part of <code>fU</code>.</p>
<p>The decomposition fails if a diagonal element of <code>fLU</code> equals 0.</p>
<h3 id="bunch-kaufman"><span class="header-section-number">14.6.4</span> Bunch-Kaufman</h3>
<p>Decompose a real symmetric matrix <span class="math inline">\(A\)</span></p>
<div class="sourceCode" id="cb803"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb803-1" title="1">   A = UDUT</a></code></pre></div>
<p><em>D</em> is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks <em>Dk</em>.</p>
<p><em>U</em> is product of permutation and unit upper triangular matrices:</p>
<p><em>U = Pn-1Un-1· · ·PkUk· · ·</em> where <em>k</em> decreases from <em>n</em> - 1 to 0 in steps of 1 or 2. Permutation matrix <em>Pk</em> is stored in <code>fIpiv</code>. <em>Uk</em> is a unit upper triangular matrix, such that if the diagonal block <em>Dk</em> is of order <em>s</em> (<em>s</em> = 1, 2), then</p>
<p><span class="math display">\[ U_k = \underset{
         \begin{array}{ccc}
         k-s &amp; s &amp; n-k
         \end{array}
         }
         {
         \left(\begin{array}{ccc}
         1 &amp;  v  &amp; 0 \\
         0 &amp;  1  &amp; 0 \\
         0 &amp;  0  &amp; 1
         \end{array}\right)
         }
         \begin{array}{c}
         k-s \\
         s \\
         n-k
         \end{array}
\]</span></p>
<p>If <em>s</em> = 1, <code>Dk</code> overwrites <span class="math inline">\(A\)</span><em>(k, k)</em>, and v overwrites <span class="math inline">\(A\)</span><em>(0: k - 1, k)</em>.</p>
<p>If <em>s</em> = 2, the upper triangle of <code>Dk</code> overwrites <span class="math inline">\(A\)</span><em>(k-1, k-1)</em>, <span class="math inline">\(A\)</span><em>(k-1,k)</em>, and <span class="math inline">\(A\)</span><em>(k, k)</em>, and v overwrites <span class="math inline">\(A\)</span><em>(0 : k - 2, k - 1 : k)</em>.</p>
<h3 id="cholesky"><span class="header-section-number">14.6.5</span> Cholesky</h3>
<p>Decompose a symmetric, positive definite matrix <span class="math inline">\(A\)</span></p>
<div class="sourceCode" id="cb804"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb804-1" title="1">   A = UTU</a></code></pre></div>
<p><em>U</em> is an upper triangular matrix. The decomposition fails if a diagonal element of <code>fU&lt;=0</code>, the matrix is not positive negative.</p>
<h3 id="qrh"><span class="header-section-number">14.6.6</span> QRH</h3>
<p>Decompose a (<em>m</em> x<em>n</em>) - matrix <span class="math inline">\(A\)</span> with <em>m &gt;= n.</em></p>
<div class="sourceCode" id="cb805"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb805-1" title="1">   A = QRH</a></code></pre></div>
<p><em>Q</em> orthogonal (<em>m</em> x <em>n</em>) - matrix, stored in <code>fQ</code>;</p>
<p><em>R</em> upper triangular (<em>n</em> x <em>n</em>) - matrix, stored in <code>fR</code>;</p>
<p><em>H</em> (<em>n</em> x <em>n</em>) - Householder matrix, stored through;</p>
<p><code>fUp</code> n - vector with Householder up’s;</p>
<p><code>fW</code> n - vector with Householder beta’s.</p>
<p>The decomposition fails if in the formation of reflectors a zero appears, i.e.&nbsp;singularity.</p>
<h3 id="svd"><span class="header-section-number">14.6.7</span> SVD</h3>
<p>Decompose a (<em>m</em> x <em>n</em>) - matrix <span class="math inline">\(A\)</span> with <em>m &gt;= n</em>.</p>
<div class="sourceCode" id="cb806"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb806-1" title="1">   A = USVT</a></code></pre></div>
<p><em>U</em> (<em>m</em> x <em>m</em>) orthogonal matrix, stored in <code>fU</code>;</p>
<p><em>S</em> is diagonal matrix containing the singular values. Diagonal stored in vector <code>fSig</code> which is ordered so that <code>fSig[0] &gt;= fSig[1] &gt;= ... &gt;= fSig[n-1]</code>;</p>
<p><em>V</em> (<em>n</em> x <em>n</em>) orthogonal matrix, stored in <code>fV</code>.</p>
<p>The singular value decomposition always exists, so the decomposition will (as long as m &gt;= n) never fail. If <em>m</em> &lt; <em>n</em>, the user should add sufficient zero rows to <span class="math inline">\(A\)</span>, so that <em>m</em> == <em>n</em>. In the <code>SVD</code>, <code>fTol</code> is used to set the threshold on the minimum allowed value of the singular values: <code>min singular = fTol maxi(Sii)</code>.</p>
<h2 id="matrix-eigen-analysis"><span class="header-section-number">14.7</span> Matrix Eigen Analysis</h2>
<p>Classes <strong><code>TMatrixDEigen</code></strong> and <strong><code>TMatrixDSymEigen</code></strong> compute eigenvalues and eigenvectors for general dense and symmetric real matrices, respectively. If matrix <span class="math inline">\(A\)</span> is symmetric, then <span class="math inline">\(A = V.D.V^{T}\)</span>, where the eigenvalue matrix <span class="math inline">\(D\)</span> is diagonal and the eigenvector matrix <span class="math inline">\(V\)</span> is orthogonal. That is, the diagonal values of <span class="math inline">\(D\)</span> are the eigenvalues, and <span class="math inline">\(V.V^{T} = I\)</span>, where <span class="math inline">\(I\)</span> - is the identity matrix. The columns of <span class="math inline">\(V\)</span> represent the eigenvectors in the sense that <span class="math inline">\(A.V = V.D\)</span>. If <span class="math inline">\(A\)</span> is not symmetric, the eigenvalue matrix <span class="math inline">\(D\)</span> is block diagonal with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues, <code>a+i*b</code>, in 2-by-2 blocks, <code>[a,b;-b,a]</code>. That is, if the complex eigenvalues look like:</p>
<p><span class="math display">\[
   \left(\begin{array}{cccccc}
   u+iv &amp;   .  &amp;   .  &amp;   .  &amp;   .  &amp;   .  \\
     .  &amp; u-iv &amp;   .  &amp;   .  &amp;   .  &amp;   .  \\
     .  &amp;   .  &amp; a+ib &amp;   .  &amp;   .  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp; a-ib &amp;   .  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp;   .  &amp;   x  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp;   .  &amp;   .  &amp;   y
   \end{array}\right)
\]</span> then <span class="math inline">\(D\)</span> looks like: <span class="math display">\[
   \left(\begin{array}{cccccc}
     u  &amp;   v  &amp;   .  &amp;   .  &amp;   .  &amp;   .  \\
    -v  &amp;   u  &amp;   .  &amp;   .  &amp;   .  &amp;   .  \\
     .  &amp;   .  &amp;   a  &amp;   b  &amp;   .  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp;  -b  &amp;   a  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp;   .  &amp;   x  &amp;   .  \\
     .  &amp;   .  &amp;   .  &amp;   .  &amp;   .  &amp;   y
   \end{array}\right)
\]</span></p>
<p>This keeps <span class="math inline">\(V\)</span> a real matrix in both symmetric and non-symmetric cases, and <span class="math inline">\(A.V = V.D\)</span>. The matrix <span class="math inline">\(V\)</span> may be badly conditioned, or even singular, so the validity of the equation <span class="math inline">\(A = V.D.V^{-1}\)</span> depends upon the condition number of <span class="math inline">\(V\)</span>. Next table shows the methods of the classes <strong><code>TMatrixDEigen</code></strong> and <strong><code>TMatrixDSymEigen</code></strong> to obtain the eigenvalues and eigenvectors. Obviously, <strong><code>MatrixDSymEigen</code></strong> constructors can only be called with <strong><code>TMatrixDSym</code></strong>:</p>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 15%">
<col style="width: 46%">
</colgroup>
<tbody>
<tr class="odd">
<td>Format</td>
<td>Output</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>eig.GetEigenVectors</code> <code>()</code></td>
<td><code>TMatrixD</code></td>
<td>eigenvectors for both <code>TMatrixDEigen</code> and <code>TMatrixDSymEigen</code></td>
</tr>
<tr class="odd">
<td><code>eig.GetEigenValues</code> <code>()</code></td>
<td><code>TVectorD</code></td>
<td>eigenvalues vector for <code>TMatrixDSymEigen</code></td>
</tr>
<tr class="even">
<td><code>eig.GetEigenValues()</code></td>
<td><code>TMatrixD</code></td>
<td>eigenvalues matrix for <code>TMatrixDEigen</code></td>
</tr>
<tr class="odd">
<td><code>eig.GetEigenValuesRe</code> <code>()</code></td>
<td><code>TVectorD</code></td>
<td>real part of eigenvalues for <code>TMatrixDEigen</code></td>
</tr>
<tr class="even">
<td><code>eig.GetEigenValuesIm</code> <code>()</code></td>
<td><code>TVectorD</code></td>
<td><p>imaginary part of eigenvalues for</p>
<p><code>TMatrixDEigen</code></p></td>
</tr>
</tbody>
</table>
<p>Below, usage of the eigenvalue class is shown in an example where it 
is checked that the square of the singular values of a matrix <span class="math inline">\(c\)</span> are identical to the eigenvalues of <span class="math inline">\(c^{T}\)</span>. <span class="math inline">\(c\)</span>:</p>
<div class="sourceCode" id="cb807"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb807-1" title="1">   <span class="at">const</span> TMatrixD m = THilbertMatrixD(<span class="dv">10</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb807-2" title="2">   TDecompSVD svd(m);</a>
<a class="sourceLine" id="cb807-3" title="3">   TVectorD sig = svd.GetSig(); sig.Sqr();</a>
<a class="sourceLine" id="cb807-4" title="4">   <span class="co">// Symmetric matrix EigenVector algorithm</span></a>
<a class="sourceLine" id="cb807-5" title="5">   TMatrixDSym mtm(TMatrixDBase::kAtA,m);</a>
<a class="sourceLine" id="cb807-6" title="6">   <span class="at">const</span> TMatrixDSymEigen eigen(mtm);</a>
<a class="sourceLine" id="cb807-7" title="7">   <span class="at">const</span> TVectorD eigenVal = eigen.GetEigenValues();</a>
<a class="sourceLine" id="cb807-8" title="8">   <span class="at">const</span> <span class="dt">Bool_t</span> ok = VerifyVectorIdentity(sig,eigenVal,<span class="dv">1</span>,<span class="fl">1.</span>-e-<span class="dv">14</span>);</a></code></pre></div>
<h2 id="speed-comparisons"><span class="header-section-number">14.8</span> Speed Comparisons</h2>
<p>Speed of four matrix operations have been compared between four matrix libraries, <code>GSL</code> <code>CLHEP</code>, <code>ROOT v3.10</code> and <code>ROOT v4.0</code>. Next figure shows the <code>CPU</code> time for these four operations as a function of the matrix size:</p>
<ol type="1">
<li><code>A*B</code> The execution time is measured for the sum of A * 
Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution
 time. <code>CLHEP</code> results are hampered by a poor implementation 
of symmetric matrix multiplications. For instance, for general matrices 
of size 100x100, the time is 0.015 sec.&nbsp;while A * Bsym takes 0.028 
sec and Bsym* A takes 0.059 sec.</li>
</ol>
<p>Both <code>GSL</code> and <code>ROOT v4.0</code> can be setup to use the hardware-optimized multiplication routines of the <code>BLAS</code>
 libraries. It was tested on a G4 PowerPC. The improvement becomes 
clearly visible around sizes of (50x50) were the execution speed 
improvement of the Altivec processor becomes more significant than the 
overhead of filling its pipe.</p>
<ol start="2" type="1">
<li><span class="math inline">\(A^{-1}\)</span> Here, the time is measured for an in-place matrix inversion.</li>
</ol>
<p>Except for <code>ROOT v3.10</code>, the algorithms are all based on an <code>LU</code>factorization followed by forward/back-substitution. <code>ROOT v3.10</code> is using the slower Gaussian elimination method. The numerical accuracy of the <code>CLHEP</code> routine is poor:</p>
<ul>
<li><p>up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating <code>U=H*H-1</code>, where <code>H</code> is a (5x5) Hilbert matrix, results in off-diagonal elements of <span class="math inline">\(10^{-7}\)</span> instead of the <span class="math inline">\(10^{-13}\)</span> using an <code>LU</code>according to <code>Crout</code>.</p></li>
<li><p>scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for <code>sizes&gt;(12x12)</code> fails. In order to gain speed the <code>CLHEP</code> algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible.</p></li>
</ul>
<p><code>GSL</code> uses LU decomposition without the implicit scaling of <code>Crout</code>. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the <code>LU Crout</code> result. In <code>ROOT v4.0</code>, the user can choose between the <code>Invert()</code> and <code>IvertFast()</code> routines, where the latter is using the Cramer algorithm for <code>sizes&lt;7x7</code>. The speed graph shows the result for <code>InvertFast()</code>.</p>
<ol start="3" type="1">
<li><p><code>A*x=b</code> the execution time is measured for solving the linear equation <code>A*x=b</code>.
 The same factorizations are used as in the matrix inversion. However, 
only 1 forward/back-substitution has to be used instead of msize as in 
the inversion of (msize x msize) matrix. As a consequence the same 
differences are observed but less amplified. CLHEP shows the same 
numerical issues as in step the matrix inversion. Since ROOT3.10 has no 
dedicated equation solver, the solution is calculated through <code>x=A-1*b</code>. This will be slower and numerically not as stable.</p></li>
<li><p><span class="math inline">\((A^{T}*A)^{-1}*A^{T}\)</span> timing 
results for calculation of the pseudo inverse of matrix a. The sequence 
of operations measures the impact of several calls to constructors and 
destructors in the <code>C++</code> packages versus a <code>C</code> library like <code>GSL</code>.</p></li>
</ol>
<figure>
<img src="ROOTUsersGuide_files/030001A1.png" alt="Speed comparison between the different matrix packages"><figcaption>Speed comparison between the different matrix packages</figcaption>
</figure>
<h1 id="adding-a-class"><span class="header-section-number">15</span> Adding a Class</h1>
<h2 id="the-role-of-tobject"><span class="header-section-number">15.1</span> The Role of TObject</h2>
<p>The light-weight <strong><code>TObject</code></strong> class provides
 the default behavior and protocol for the objects in the ROOT system. 
Specifically, it is the primary interface to classes providing object 
I/O, error handling, inspection, introspection, and drawing. The 
interface to this service is via abstract classes.</p>
<h3 id="introspection-reflection-and-run-time-type-identification"><span class="header-section-number">15.1.1</span> Introspection, Reflection and Run Time Type Identification</h3>
<p>Introspection, which is also referred to as reflection, or run time 
type identification (RTTI) is the ability of a class to reflect upon 
itself or to "look inside itself. ROOT implements reflection with the <strong><code>TClass</code></strong>
 class. It provides all the information about a class, a full 
description of data members and methods, including the comment field and
 the method parameter types. A class with the <code>ClassDef</code> macro has the ability to obtain a <strong><code>TClass</code></strong> with the <code>IsA</code> method.</p>
<div class="sourceCode" id="cb808"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb808-1" title="1">TClass *cl = obj-&gt;IsA();</a></code></pre></div>
<p>It returns a <strong><code>TClass</code></strong>. In addition, an object can directly get the class name and the base classes by:</p>
<div class="sourceCode" id="cb809"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb809-1" title="1"><span class="at">const</span> <span class="dt">char</span>* name = obj-&gt;ClassName();</a></code></pre></div>
<p>If the class is a descendent of <strong><code>TObject</code></strong>, you can check if an object inherits from a specific class, you can use the <code>InheritsFrom</code> method. This method returns <code>kTrue</code> if the object inherits from the specified class name or <strong><code>TClass</code></strong>.</p>
<div class="sourceCode" id="cb810"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb810-1" title="1"><span class="dt">Bool_t</span> b = obj-&gt;InheritsFrom(<span class="st">"TLine"</span>);</a>
<a class="sourceLine" id="cb810-2" title="2"><span class="dt">Bool_t</span> b = obj-&gt;InheritsFrom(TLine::Class());</a></code></pre></div>
<p>ROOT and <code>Cling</code> rely on reflection and the class dictionary to identify the type of a variable at run time. With <strong><code>TObject</code></strong> inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:</p>
<div class="sourceCode" id="cb811"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb811-1" title="1">obj-&gt;Dump();      <span class="co">// lists all data members and their current values</span></a>
<a class="sourceLine" id="cb811-2" title="2">obj-&gt;Inspect();   <span class="co">// opens a window to browse data members</span></a>
<a class="sourceLine" id="cb811-3" title="3">obj-&gt;DrawClass(); <span class="co">// Draws the class inheritance tree</span></a></code></pre></div>
<p>For an example of <code>obj-&gt;Inspect()</code>, see “Inspecting Objects”.</p>
<h3 id="collections"><span class="header-section-number">15.1.2</span> Collections</h3>
<p>To store an object in a ROOT collection, it must be a descendent of <strong><code>TObject</code></strong>.
 This is convenient if you want to store objects of different classes in
 the same collection and execute the method of the same name on all 
members of the collection. For example, the list of graphics primitives 
are in a ROOT collection called <strong><code>TList</code></strong>. When the canvas is drawn, the <code>Paint</code> method is executed on the entire collection. Each member may be a different class, and if the <code>Paint</code> method is not implemented, <strong><code>TObject::Paint</code></strong> will be executed.</p>
<h3 id="inputoutput-1"><span class="header-section-number">15.1.3</span> Input/Output</h3>
<p>The <code>TObject::Write</code> method is the interface to the ROOT I/O system. It streams the object into a buffer using the <code>Streamer</code> method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.</p>
<h3 id="paintdraw"><span class="header-section-number">15.1.4</span> Paint/Draw</h3>
<p>These graphics methods are defaults; their implementation in <strong><code>TObject</code></strong> does not use the graphics subsystem. The <code>TObject::Draw</code> method is simply a call to <code>AppendPad</code>. The <code>Paint</code> method is empty. The default is provided so that one can call <code>Paint</code> in a collection. The method <code>GetDrawOption</code>
 returns the draw option that was used when the object was drawn on the 
canvas. This is especially relevant with histograms and graphs.</p>
<h3 id="clonedrawclone"><span class="header-section-number">15.1.5</span> Clone/DrawClone</h3>
<p>Two useful methods are <code>Clone</code> and <code>DrawClone</code>. The <code>Clone</code> method takes a snapshot of the object with the <code>Streamer</code> and creates a new object. The <code>DrawClone</code> method does the same thing and in addition draws the clone.</p>
<h3 id="browse"><span class="header-section-number">15.1.6</span> Browse</h3>
<p>This method is called if the object is browse-able and is to be displayed in the object browser. For example the <strong><code>TTree</code></strong> implementation of <code>Browse</code>, calls the Browse method for each branch. The <code>TBranch::Browse</code> method displays the name of each leaf. For the object’s <code>Browse</code> method to be called, the <code>IsFolder()</code> method must be overridden to return true. This does not mean it has to be a folder, it just means that it is browse-able.</p>
<h3 id="saveprimitive"><span class="header-section-number">15.1.7</span> SavePrimitive</h3>
<p>This method is called by a canvas on its list of primitives, when the canvas is saved as a script. The purpose of <code>SavePrimitve</code> is to save a primitive as a C++ statement(s). Most ROOT classes implement the <code>SavePrimitive</code> method. It is recommended that the <code>SavePrimitive</code> is implemented in user defined classes if it is to be drawn on a canvas. Such that the command <code>TCanvas::SaveAs(Canvas.C)</code> will preserve the user-class object in the resulting script.</p>
<h3 id="getobjectinfo"><span class="header-section-number">15.1.8</span> GetObjectInfo</h3>
<p>This method is called when displaying the event status in a canvas. To show the event status window, select the <code>Options</code> menu and the <code>EventStatus</code>
 item. This method returns a string of information about the object at 
position (x, y). Every time the cursor moves, the object under the 
cursor executes the <code>GetObjectInfo</code> method. The string is then shown in the status bar. There is a default implementation in <strong><code>TObject</code></strong>,
 but it is typically overridden for classes that can report 
peculiarities for different cursor positions (for example the bin 
contents in a TH1).</p>
<h3 id="isfolder"><span class="header-section-number">15.1.9</span> IsFolder</h3>
<p>By default an object inheriting from <strong><code>TObject</code></strong> is not brows-able, because <strong><code>TObject::IsFolder()</code></strong> returns <code>kFALSE</code>. To make a class browse-able, the <code>IsFolder</code> method needs to be overridden to return <code>kTRUE</code>. In general, this method returns <code>kTRUE</code> if the object contains browse-able objects (like containers or lists of other objects).</p>
<h3 id="bit-masks-and-unique-id"><span class="header-section-number">15.1.10</span> Bit Masks and Unique ID</h3>
<p>A <strong><code>TObject</code></strong> descendent inherits two data members: <code>fBits</code> and <code>fUniqueID</code>. <code>fBits</code>is
 32-bit data member used with a bit mask to get object information. Bits
 0 - 13 are reserved as global bits, bits 14 - 23 can be used in 
different class hierarchies.</p>
<div class="sourceCode" id="cb812"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb812-1" title="1"><span class="kw">enum</span> EObjBits {</a>
<a class="sourceLine" id="cb812-2" title="2">   kCanDelete     = BIT(<span class="dv">0</span>), <span class="co">// if can be deleted</span></a>
<a class="sourceLine" id="cb812-3" title="3">   kMustCleanup   = BIT(<span class="dv">3</span>), <span class="co">// if destructor must call RecursiveRemove()</span></a>
<a class="sourceLine" id="cb812-4" title="4">   kObjInCanvas   = BIT(<span class="dv">3</span>), <span class="co">// for backward compatibility only</span></a>
<a class="sourceLine" id="cb812-5" title="5">   kIsReferenced  = BIT(<span class="dv">4</span>), <span class="co">// if referenced by TRef or TRefArray</span></a>
<a class="sourceLine" id="cb812-6" title="6">   kHasUUID       = BIT(<span class="dv">5</span>), <span class="co">// if has a TUUID, fUniqueID=UUIDNumber</span></a>
<a class="sourceLine" id="cb812-7" title="7">   kCannotPick    = BIT(<span class="dv">6</span>), <span class="co">// if cannot be picked in a pad</span></a>
<a class="sourceLine" id="cb812-8" title="8">   kNoContextMenu = BIT(<span class="dv">8</span>), <span class="co">// if does not want a context menu</span></a>
<a class="sourceLine" id="cb812-9" title="9">   kInvalidObject = BIT(<span class="dv">13</span>) <span class="co">// object ctor succeeded but the object should not be used</span></a>
<a class="sourceLine" id="cb812-10" title="10">};</a></code></pre></div>
<p>For example, the bits <code>kMustCleanup</code> and <code>kCanDelete</code> are used in <strong><code>TObject</code></strong>.
 See “The kCanDelete Bit” and “The kMustCleanup Bit”. They can be set by
 any object and should not be reused. Make sure not to overlap them in 
any given hierarchy. The bit 13 (<code>kInvalidObject</code>) is set when an object could not be read from a ROOT file. It will check this bit and will skip to the next object on the file.</p>
<p>The <strong><code>TObject</code></strong> constructor initializes the <code>fBits</code> to zero depending if the object is created on the stack or allocated on the heap. When the object is created on the stack, the <code>kCanDelete</code>
 bit is set to false to protect from deleting objects on the stack. The 
high 8 bits are reserved for the system usage; the low 24 bits are user 
settable. <code>fUniqueID</code> is a data member used to give a unique identification number to an object. It is initialized to zero by the <strong><code>TObject</code></strong> constructor. ROOT does not use this data member. The two data members (<code>fBits</code> and <code>fUniqueID</code>) are streamed out when writing an object to disk. If you do not use them, you can save some space and time by specifying:</p>
<div class="sourceCode" id="cb813"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb813-1" title="1">MyClass::Class()-&gt;IgnoreTObjectStreamer();</a></code></pre></div>
<p>This sets a bit in the <strong><code>TClass</code></strong> object. 
If the file is compressed, the savings are minimal since most values are
 zero; however, it saves some space when the file is not compressed. A 
call to<code>IgnoreTObjectStreamer</code> also prevents the creation of two additional branches when splitting the object. If left alone, two branches called <code>fBits</code> and <code>fUniqueID</code> will appear.</p>
<h2 id="motivation"><span class="header-section-number">15.2</span> Motivation</h2>
<p>If you want to integrate and use your classes with ROOT, to enjoy 
features like, extensive RTTI (Run Time Type Information) and ROOT 
object I/O and inspection, you have to add the following line to your 
class header files:</p>
<div class="sourceCode" id="cb814"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb814-1" title="1">ClassDef(ClassName,ClassVersionID);  <span class="co">//The class title</span></a></code></pre></div>
<p>For example in <code>TLine.h</code> we have:</p>
<div class="sourceCode" id="cb815"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb815-1" title="1">ClassDef(TLine,<span class="dv">1</span>);                   <span class="co">//A line segment</span></a></code></pre></div>
<p>The <strong><code>ClassVersionID</code></strong> is used by the ROOT 
I/O system. It is written on the output stream and during reading you 
can check this version ID and take appropriate action depending on the 
value of the ID. See “Streamers”. Every time you change the data members
 of a class, you should increase its <code>ClassVersionID</code> by one. The <code>ClassVersionID</code> should be <code>&gt;=1</code>. Set <code>ClassVersionID=0</code> in case you don’t need object I/O. To be able to generate properly documentation for your classes using <strong><code>THtml</code></strong> you must add the statement:</p>
<div class="sourceCode" id="cb816"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb816-1" title="1">ClassImp(ClassName)</a></code></pre></div>
<p>For example in <code>TLine.cxx</code>:</p>
<div class="sourceCode" id="cb817"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb817-1" title="1">ClassImp(TLine)</a></code></pre></div>
<p>Note that you should provide a default constructor for your classes, 
i.e.&nbsp;a constructor with zero parameters or with one or more 
parameters all with default values in case you want to use object I/O. 
If do not provide such a default constructor, you MUST implement an I/O 
constructor. If not you will get a compile time error. See the “The 
Default Constructor” paragraph in this chapter. The <code>ClassDef</code> and <code>ClassImp</code> macros are defined in the file <code>Rtypes.h</code>. This file is referenced by all ROOT include files, so you will automatically get them if you use a ROOT include file.</p>
<h3 id="template-support"><span class="header-section-number">15.2.1</span> Template Support</h3>
<p>In ROOT version 3.03 and older, ROOT provided special <code>ClassDef</code> and <code>ClassImp</code> macros for classes with two and three template arguments. In ROOT version 3.04 and above, the macros <code>ClassDef</code> and <code>ClassImp</code> can be used directly even for a class template. <code>ClassImp</code> is used to register an implementation file in a class. For class templates, the <code>ClassImp</code> can only be used for a specific class template instance.</p>
<div class="sourceCode" id="cb818"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb818-1" title="1">ClassImp(MyClass1&lt;<span class="dt">double</span>&gt;);</a></code></pre></div>
<p>For multiple template arguments, you will need to use an intermediary <code>typedef</code>:</p>
<div class="sourceCode" id="cb819"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb819-1" title="1"><span class="kw">typedef</span> MyClass2&lt;<span class="dt">int</span>,<span class="dt">float</span>&gt; myc_i_f;</a>
<a class="sourceLine" id="cb819-2" title="2">ClassImp(myc_i_f);</a></code></pre></div>
<p>You can also register an implementation for all instances of a class template by using <code>templateClassImp</code>:</p>
<div class="sourceCode" id="cb820"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb820-1" title="1">templateClassImp(MyClass3);</a></code></pre></div>
<p>Here are examples of a header and a <code>LinkDef</code> file:</p>
<div class="sourceCode" id="cb821"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb821-1" title="1"><span class="co">// in header file MyClass.h</span></a>
<a class="sourceLine" id="cb821-2" title="2"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">class</span> MyClass1 {</a>
<a class="sourceLine" id="cb821-3" title="3"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb821-4" title="4">      T  fA;</a>
<a class="sourceLine" id="cb821-5" title="5">      ...</a>
<a class="sourceLine" id="cb821-6" title="6"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb821-7" title="7">      ...</a>
<a class="sourceLine" id="cb821-8" title="8">      ClassDef(MyClass1,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb821-9" title="9">};</a>
<a class="sourceLine" id="cb821-10" title="10"><span class="kw">template</span> &lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2&gt; <span class="kw">class</span> MyClass2 {</a>
<a class="sourceLine" id="cb821-11" title="11"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb821-12" title="12">      T1  fA;</a>
<a class="sourceLine" id="cb821-13" title="13">      T2  fB;</a>
<a class="sourceLine" id="cb821-14" title="14"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb821-15" title="15">      ...</a>
<a class="sourceLine" id="cb821-16" title="16">      ClassDef(MyClass2,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb821-17" title="17">};</a>
<a class="sourceLine" id="cb821-18" title="18"><span class="kw">template</span> &lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2, <span class="kw">typename</span> T3&gt; <span class="kw">class</span> MyClass3 {</a>
<a class="sourceLine" id="cb821-19" title="19"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb821-20" title="20">      T1  fA;</a>
<a class="sourceLine" id="cb821-21" title="21">      T2  fB;</a>
<a class="sourceLine" id="cb821-22" title="22">      T3  fC;</a>
<a class="sourceLine" id="cb821-23" title="23">      ...</a>
<a class="sourceLine" id="cb821-24" title="24"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb821-25" title="25">      ...</a>
<a class="sourceLine" id="cb821-26" title="26">      ClassDef(MyClass3,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb821-27" title="27">};</a></code></pre></div>
<div class="sourceCode" id="cb822"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb822-1" title="1"><span class="co">// A LinkDef.h file with all the explicit template instances</span></a>
<a class="sourceLine" id="cb822-2" title="2"><span class="co">// that will be needed at link time</span></a>
<a class="sourceLine" id="cb822-3" title="3"><span class="pp">#ifdef __CLING__</span></a>
<a class="sourceLine" id="cb822-4" title="4"></a>
<a class="sourceLine" id="cb822-5" title="5"><span class="pp">#pragma link C++ class MyClass1&lt;float&gt;+;</span></a>
<a class="sourceLine" id="cb822-6" title="6"><span class="pp">#pragma link C++ class MyClass1&lt;double&gt;+;</span></a>
<a class="sourceLine" id="cb822-7" title="7"><span class="pp">#pragma link C++ class MyClass2&lt;float,int&gt;+;</span></a>
<a class="sourceLine" id="cb822-8" title="8"><span class="pp">#pragma link C++ class MyClass2&lt;float,double&gt;+;</span></a>
<a class="sourceLine" id="cb822-9" title="9"><span class="pp">#pragma link C++ class MyClass3&lt;float,int,TObject*&gt;+;</span></a>
<a class="sourceLine" id="cb822-10" title="10"><span class="pp">#pragma link C++ class MyClass3&lt;float,TEvent*,TObject*&gt;+;</span></a>
<a class="sourceLine" id="cb822-11" title="11"></a>
<a class="sourceLine" id="cb822-12" title="12"><span class="pp">#endif</span></a></code></pre></div>
<h2 id="the-default-constructor"><span class="header-section-number">15.3</span> The Default Constructor</h2>
<p>ROOT object I/O requires every class to have either a default 
constructor or an I/O constructor. A default constructor is a 
constructor with zero parameters or with one or more parameters all with
 default values. An I/O constructor is a constructor with exactly one 
parameter which type is a pointer to one of the type marked as an ‘io 
constructor type’. We will come back to this context in a few 
paragraphs. This default or I/O constructor is called whenever an object
 is being read from a ROOT database. Be sure that you do not allocate 
any space for embedded pointer objects in this constructor. This space 
will be lost (memory leak) while reading in the object. For example:</p>
<div class="sourceCode" id="cb823"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb823-1" title="1"><span class="kw">class</span> T49Event : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb823-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb823-3" title="3"><span class="dt">Int_t</span>        fId;</a>
<a class="sourceLine" id="cb823-4" title="4">TCollection *fTracks;</a>
<a class="sourceLine" id="cb823-5" title="5">...</a>
<a class="sourceLine" id="cb823-6" title="6"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb823-7" title="7">   <span class="co">// Error space for TList pointer will be lost</span></a>
<a class="sourceLine" id="cb823-8" title="8">T49Event() { fId = <span class="dv">0</span>; fTrack = <span class="kw">new</span> TList; }</a>
<a class="sourceLine" id="cb823-9" title="9">   <span class="co">// Correct default initialization of pointer</span></a>
<a class="sourceLine" id="cb823-10" title="10">T49Event() { fId = <span class="dv">0</span>; fTrack = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb823-11" title="11">...</a>
<a class="sourceLine" id="cb823-12" title="12">};</a></code></pre></div>
<p>The memory will be lost because during reading of the object the 
pointer will be set to the object it was pointing to at the time the 
object was written. Create the <code>fTrack</code> list when you need it, e.g.&nbsp;when you start filling the list or in a <strong>not-default</strong> constructor.</p>
<div class="sourceCode" id="cb824"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb824-1" title="1">...</a>
<a class="sourceLine" id="cb824-2" title="2"><span class="cf">if</span> (!fTrack) fTrack = <span class="kw">new</span> TList;</a>
<a class="sourceLine" id="cb824-3" title="3">...</a></code></pre></div>
<p>The constructor actually called by the ROOT I/O can be customized by using the rootcling pragma:</p>
<div class="sourceCode" id="cb825"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb825-1" title="1"><span class="pp">#pragma link C++ ioctortype UserClass;</span></a></code></pre></div>
<p>For example, with this pragma and a class named MyClass, the ROOT I/O
 will call the first of the following 3 constructors which exists and is
 public:</p>
<div class="sourceCode" id="cb826"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb826-1" title="1">MyClass(UserClass*);MyClass(TRootIOCtor*);</a>
<a class="sourceLine" id="cb826-2" title="2">MyClass();    <span class="co">// Or a constructor with all its arguments defaulted.</span></a></code></pre></div>
<p>When more than one pragma ioctortype is used, the first seen as priority. For example with:</p>
<div class="sourceCode" id="cb827"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb827-1" title="1"><span class="pp">#pragma link C++ ioctortype UserClass1;</span></a>
<a class="sourceLine" id="cb827-2" title="2"><span class="pp">#pragma link C++ ioctortype UserClass2;</span></a></code></pre></div>
<p>We look for the first existing public constructor in the following order:</p>
<div class="sourceCode" id="cb828"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb828-1" title="1">MyClass(UserClass1*);</a>
<a class="sourceLine" id="cb828-2" title="2">MyClass(UserClass2*);</a>
<a class="sourceLine" id="cb828-3" title="3">MyClass(TRootIOCtor*);</a>
<a class="sourceLine" id="cb828-4" title="4">MyClass();   <span class="co">// Or a constructor with all its arguments defaulted.</span></a></code></pre></div>
<h2 id="rootcling-the-cling-dictionary-generator"><span class="header-section-number">15.4</span> rootcling: The Cling Dictionary Generator</h2>
<p>A way in which dictionaries can be generated is via the <code>rootcling</code> utility. This tool generates takes as input a set of headers and generates in output the dictionary C++ code and a <code>pcm</code>
 file. This latter file is fundamental for the correct functioning of 
the dictionary at runtime. It should be located in the directory where 
the shared library is installed in which the compiled dictionary 
resides.</p>
<p>NOTA BENE: the dictionaries that will be used within the same project
 must have unique names. In other words, compiled object files relative 
to dictionary source files cannot reside in the same library or in two 
libraries loaded by the same application if the original source files 
have the same name. This loose limitation is imposed by the registration
 mechanism ROOT has in place to keep track of dynamically loaded 
libraries.</p>
<p>In the following example, we walk through the steps necessary to 
generate a dictionary, I/O, and inspect member functions. Let’s start 
with a <strong><code>TEvent</code></strong> class, which contains a collection of <strong><code>TTracks</code></strong>.</p>
<p>The <code>TEvent.h</code> header is:</p>
<div class="sourceCode" id="cb829"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb829-1" title="1"><span class="pp">#ifndef __TEvent__</span></a>
<a class="sourceLine" id="cb829-2" title="2"><span class="pp">#define _</span>_TEvent__</a>
<a class="sourceLine" id="cb829-3" title="3"><span class="pp">#include </span><span class="im">"TObject.h"</span></a>
<a class="sourceLine" id="cb829-4" title="4"><span class="pp">#include </span><span class="im">"TCollection.h"</span></a>
<a class="sourceLine" id="cb829-5" title="5"></a>
<a class="sourceLine" id="cb829-6" title="6"><span class="kw">class</span> TTrack;</a>
<a class="sourceLine" id="cb829-7" title="7"></a>
<a class="sourceLine" id="cb829-8" title="8"><span class="kw">class</span> TEvent : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb829-9" title="9">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb829-10" title="10">      <span class="dt">Int_t</span>        fId;          <span class="co">// event sequential id</span></a>
<a class="sourceLine" id="cb829-11" title="11">      <span class="dt">Float_t</span>      fTotalMom;    <span class="co">// total momentum</span></a>
<a class="sourceLine" id="cb829-12" title="12">      TCollection *fTracks;      <span class="co">// collection of tracks</span></a>
<a class="sourceLine" id="cb829-13" title="13">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb829-14" title="14">      TEvent() { fId = <span class="dv">0</span>; fTotalMom = <span class="dv">0</span>; fTracks = <span class="kw">nullptr</span>; }</a>
<a class="sourceLine" id="cb829-15" title="15">      TEvent(<span class="dt">Int_t</span> id);</a>
<a class="sourceLine" id="cb829-16" title="16">      ~TEvent();</a>
<a class="sourceLine" id="cb829-17" title="17">     <span class="dt">void</span>    AddTrack(TTrack *t);</a>
<a class="sourceLine" id="cb829-18" title="18">     <span class="dt">Int_t</span>   GetId() <span class="at">const</span> { <span class="cf">return</span> fId; }</a>
<a class="sourceLine" id="cb829-19" title="19">     <span class="dt">Int_t</span>   GetNoTracks() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb829-20" title="20">     <span class="dt">void</span>    Print(<span class="dt">Option_t</span> *opt=<span class="st">""</span>);</a>
<a class="sourceLine" id="cb829-21" title="21">     <span class="dt">Float_t</span> TotalMomentum();</a>
<a class="sourceLine" id="cb829-22" title="22"></a>
<a class="sourceLine" id="cb829-23" title="23">   ClassDef(TEvent,<span class="dv">1</span>);  <span class="co">//Simple event class</span></a>
<a class="sourceLine" id="cb829-24" title="24">};</a>
<a class="sourceLine" id="cb829-25" title="25"></a>
<a class="sourceLine" id="cb829-26" title="26"><span class="pp">#endif</span></a></code></pre></div>
<p>The things to notice in these header files are:</p>
<ul>
<li><p>The usage of the <code>ClassDef</code> macro</p></li>
<li><p>The default constructors of the <strong><code>TEvent</code></strong> and <strong><code>TTrack</code></strong> classes</p></li>
<li><p>Comments to describe the data members and the comment after the <code>ClassDef</code> macro to describe the class</p></li>
</ul>
<p>These classes are intended for you to create an event object with a 
certain id, and then add tracks to it. The track objects have a pointer 
to their event. This shows that the I/O system correctly handles 
circular references.</p>
<p>The <code>TTrack.h</code> header is:</p>
<div class="sourceCode" id="cb830"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb830-1" title="1"><span class="pp">#ifndef __TTrack__</span></a>
<a class="sourceLine" id="cb830-2" title="2"><span class="pp">#define _</span>_TTrack__</a>
<a class="sourceLine" id="cb830-3" title="3"><span class="pp">#include </span><span class="im">"TObject.h"</span></a>
<a class="sourceLine" id="cb830-4" title="4"></a>
<a class="sourceLine" id="cb830-5" title="5"><span class="kw">class</span> TEvent;</a>
<a class="sourceLine" id="cb830-6" title="6"></a>
<a class="sourceLine" id="cb830-7" title="7"><span class="kw">class</span> TTrack : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb830-8" title="8">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb830-9" title="9">      <span class="dt">Int_t</span>    fId;       <span class="co">//track sequential id</span></a>
<a class="sourceLine" id="cb830-10" title="10">      TEvent  *fEvent;    <span class="co">//event to which track belongs</span></a>
<a class="sourceLine" id="cb830-11" title="11">      <span class="dt">Float_t</span>  fPx;       <span class="co">//x part of track momentum</span></a>
<a class="sourceLine" id="cb830-12" title="12">      <span class="dt">Float_t</span>  fPy;       <span class="co">//y part of track momentum</span></a>
<a class="sourceLine" id="cb830-13" title="13">      <span class="dt">Float_t</span>  fPz;       <span class="co">//z part of track momentum</span></a>
<a class="sourceLine" id="cb830-14" title="14">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb830-15" title="15">      TTrack() { fId = <span class="dv">0</span>; fEvent = <span class="kw">nullptr</span>; fPx = fPy = fPz = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb830-16" title="16">      TTrack(<span class="dt">Int_t</span> id, TEvent *ev, <span class="dt">Float_t</span> px,<span class="dt">Float_t</span> py,<span class="dt">Float_t</span> pz);</a>
<a class="sourceLine" id="cb830-17" title="17">      <span class="dt">Float_t</span>  Momentum() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb830-18" title="18">      TEvent  *GetEvent() <span class="at">const</span> { <span class="cf">return</span> fEvent; }</a>
<a class="sourceLine" id="cb830-19" title="19">      <span class="dt">void</span>     Print(<span class="dt">Option_t</span> *opt=<span class="st">""</span>);</a>
<a class="sourceLine" id="cb830-20" title="20"></a>
<a class="sourceLine" id="cb830-21" title="21">   ClassDef (TTrack,<span class="dv">1</span>);  <span class="co">//Simple track class</span></a>
<a class="sourceLine" id="cb830-22" title="22">};</a>
<a class="sourceLine" id="cb830-23" title="23"></a>
<a class="sourceLine" id="cb830-24" title="24"><span class="pp">#endif</span></a></code></pre></div>
<p>Next is the implementation of these two classes.</p>
<p><code>TEvent.cxx</code>:</p>
<div class="sourceCode" id="cb831"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb831-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream.h&gt;</span></a>
<a class="sourceLine" id="cb831-2" title="2"></a>
<a class="sourceLine" id="cb831-3" title="3"><span class="pp">#include </span><span class="im">"TOrdCollection.h"</span></a>
<a class="sourceLine" id="cb831-4" title="4"><span class="pp">#include </span><span class="im">"TEvent.h"</span></a>
<a class="sourceLine" id="cb831-5" title="5"><span class="pp">#include </span><span class="im">"TTrack.h"</span></a>
<a class="sourceLine" id="cb831-6" title="6"></a>
<a class="sourceLine" id="cb831-7" title="7">ClassImp(TEvent)</a>
<a class="sourceLine" id="cb831-8" title="8"></a>
<a class="sourceLine" id="cb831-9" title="9">...</a></code></pre></div>
<p><code>TTrack.cxx:</code></p>
<div class="sourceCode" id="cb832"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb832-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream.h&gt;</span></a>
<a class="sourceLine" id="cb832-2" title="2"></a>
<a class="sourceLine" id="cb832-3" title="3"><span class="pp">#include </span><span class="im">"TMath.h"</span></a>
<a class="sourceLine" id="cb832-4" title="4"><span class="pp">#include </span><span class="im">"TTrack.h"</span></a>
<a class="sourceLine" id="cb832-5" title="5"><span class="pp">#include </span><span class="im">"TEvent.h"</span></a>
<a class="sourceLine" id="cb832-6" title="6"></a>
<a class="sourceLine" id="cb832-7" title="7">ClassImp(TTrack)</a>
<a class="sourceLine" id="cb832-8" title="8">...</a></code></pre></div>
<p>Now using <code>rootcling</code> we can generate the dictionary file.</p>
<div class="sourceCode" id="cb833"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb833-1" title="1">rootcling eventdict.cxx -c TEvent.h TTrack.h</a></code></pre></div>
<p>Looking in the file <code>eventdict.cxx</code> we can see, the<code>Streamer()</code> and<code>ShowMembers()</code>methods for the two classes. <code>Streamer()</code> is used to stream an object to/from a <strong><code>TBuffer</code></strong> and <code>ShowMembers()</code> is used by the <code>Dump()</code> and <code>Inspect()</code> methods of <strong><code>TObject</code></strong>. Here is the <code>TEvent::Streamer</code> method:</p>
<div class="sourceCode" id="cb834"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb834-1" title="1"><span class="dt">void</span> TEvent::Streamer(TBuffer &amp;R__b)</a>
<a class="sourceLine" id="cb834-2" title="2">{</a>
<a class="sourceLine" id="cb834-3" title="3">   <span class="co">// Stream an object of class TEvent.</span></a>
<a class="sourceLine" id="cb834-4" title="4"></a>
<a class="sourceLine" id="cb834-5" title="5">   <span class="dt">UInt_t</span> R__s, R__c;</a>
<a class="sourceLine" id="cb834-6" title="6">   <span class="cf">if</span> (R__b.IsReading()) {</a>
<a class="sourceLine" id="cb834-7" title="7">      <span class="dt">Version_t</span> R__v = R__b.ReadVersion(&amp;R__s, &amp;R__c); <span class="cf">if</span> (R__v) { }</a>
<a class="sourceLine" id="cb834-8" title="8">      TObject::Streamer(R__b);</a>
<a class="sourceLine" id="cb834-9" title="9">      R__b &gt;&gt; fId;</a>
<a class="sourceLine" id="cb834-10" title="10">      R__b &gt;&gt; fTotalMom;</a>
<a class="sourceLine" id="cb834-11" title="11">      R__b &gt;&gt; fTracks;</a>
<a class="sourceLine" id="cb834-12" title="12">      R__b.CheckByteCount(R__s, R__c, TEvent::IsA());</a>
<a class="sourceLine" id="cb834-13" title="13">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb834-14" title="14">      R__c = R__b.WriteVersion(TEvent::IsA(), kTRUE);</a>
<a class="sourceLine" id="cb834-15" title="15">      TObject::Streamer(R__b);</a>
<a class="sourceLine" id="cb834-16" title="16">      R__b &lt;&lt; fId;</a>
<a class="sourceLine" id="cb834-17" title="17">      R__b &lt;&lt; fTotalMom;</a>
<a class="sourceLine" id="cb834-18" title="18">      R__b &lt;&lt; fTracks;</a>
<a class="sourceLine" id="cb834-19" title="19">      R__b.SetByteCount(R__c, kTRUE);</a>
<a class="sourceLine" id="cb834-20" title="20">   }</a>
<a class="sourceLine" id="cb834-21" title="21">}</a></code></pre></div>
<p>The <strong><code>TBuffer</code></strong> class overloads the <code>operator&lt;&lt;()</code> and <code>operator&gt;&gt;()</code>
 for all basic types and for pointers to objects. These operators write 
and read from the buffer and take care of any needed byte swapping to 
make the buffer machine independent. During writing, the <strong><code>TBuffer</code></strong>
 keeps track of the objects that have been written and multiple 
references to the same object are replaced by an index. In addition, the
 object’s class information is stored. <strong><code>TEvent</code></strong> and <strong><code>TTracks</code></strong> need manual intervention. Cut and paste the generated <code>Streamer()</code> from the <code>eventdict.cxx</code>
 into the class’ source file and modify as needed (e.g.&nbsp;add counter
 for array of basic types) and disable the generation of the <code>Streamer()</code> when using the <code>LinkDef.h</code> file for next execution of <code>rootcling</code>. In case you do not want to read or write this class (no I/O) you can tell <code>rootcling</code> to generate a dummy <code>Streamer()</code>by changing this line in the source file:</p>
<div class="sourceCode" id="cb835"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb835-1" title="1">ClassDef(TEvent,<span class="dv">0</span>);</a></code></pre></div>
<p>If you want to prevent the generation of <code>Streamer()</code>, see the section “Adding a Class with a Shared Library”.</p>
<h3 id="dictionaries-for-stl"><span class="header-section-number">15.4.1</span> Dictionaries for STL</h3>
<p>Usually, headers are passed to rootcling at the command line. To generate a dictionary for a class from the STL, e.g.</p>
<p><strong>std::vector&lt;MyClass&gt;</strong>, you would normally pass the header defining <strong>MyClass</strong> and <strong>std::vector</strong>.
 The latter is a compiler specific header and cannot be passed to 
rootcling directly. Instead, create a little header file that includes 
both headers, and pass that to rootcling.</p>
<p>Often ROOT knows where <strong>MyClass</strong> and the templated class (e.g.&nbsp;vector) are defined, for example because the files got <strong>#included</strong>. Knowing these header files ROOT can automatically generate the dictionary for any template combination (e.g.&nbsp;<strong>vector&lt;myClass&gt;</strong>) when it is needed, by generating files starting with <strong>AutoDict*</strong>. You can toggle this feature on or off at the ROOT prompt by executing <strong>.autodict</strong>.</p>
<h2 id="adding-a-class-with-a-shared-library"><span class="header-section-number">15.5</span> Adding a Class with a Shared Library</h2>
<p> <strong>Step 1:</strong> Define your own class in <code>SClass.h</code> and implement it in <code>SClass.cxx</code>.
 You must provide a default constructor or an I/O constructor for your 
class. See the “The Default Constructor” paragraph in this chapter.</p>
<div class="sourceCode" id="cb836"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb836-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream.h&gt;</span></a>
<a class="sourceLine" id="cb836-2" title="2"><span class="pp">#include </span><span class="im">"TObject.h"</span></a>
<a class="sourceLine" id="cb836-3" title="3"><span class="kw">class</span> SClass : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb836-4" title="4">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb836-5" title="5">      <span class="dt">Float_t</span>   fX;         <span class="co">//x position in centimeters</span></a>
<a class="sourceLine" id="cb836-6" title="6">      <span class="dt">Float_t</span>   fY;         <span class="co">//y position in centimeters</span></a>
<a class="sourceLine" id="cb836-7" title="7">      <span class="dt">Int_t</span>     fTempValue; <span class="co">//! temporary state value</span></a>
<a class="sourceLine" id="cb836-8" title="8">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb836-9" title="9">      SClass()             { fX = fY = -<span class="dv">1</span>; }</a>
<a class="sourceLine" id="cb836-10" title="10">      <span class="dt">void</span> Print() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb836-11" title="11">      <span class="dt">void</span> SetX(<span class="dt">float</span> x) { fX = x; }</a>
<a class="sourceLine" id="cb836-12" title="12">      <span class="dt">void</span> SetY(<span class="dt">float</span> y) { fY = y; }</a>
<a class="sourceLine" id="cb836-13" title="13"></a>
<a class="sourceLine" id="cb836-14" title="14">ClassDef(SClass, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb836-15" title="15">};</a></code></pre></div>
<p><strong>Step 2:</strong> Add a call to the <code>ClassDef</code> macro to at the end of the class definition (in the <code>SClass.h</code> file). <code>ClassDef(SClass,1)</code>. Add a call to the <code>ClassImp</code> macro in the implementation file (<code>SClass.cxx</code>): <code>ClassImp(SClass)</code>.</p>
<div class="sourceCode" id="cb837"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb837-1" title="1"><span class="co">// SClass.cxx:</span></a>
<a class="sourceLine" id="cb837-2" title="2"><span class="pp">#include </span><span class="im">"SClass.h"</span></a>
<a class="sourceLine" id="cb837-3" title="3">ClassImp(SClass);</a>
<a class="sourceLine" id="cb837-4" title="4"><span class="dt">void</span> SClass::Print() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb837-5" title="5">   cout &lt;&lt; <span class="st">"fX = "</span> &lt;&lt; fX &lt;&lt; <span class="st">", fY = "</span> &lt;&lt; fY &lt;&lt; endl;</a>
<a class="sourceLine" id="cb837-6" title="6">}</a></code></pre></div>
<p>You can add a class without using the <code>ClassDef</code> and <code>ClassImp</code>
 macros; however, you will be limited. Specifically the object I/O 
features of ROOT will not be available to you for these classes. See 
“Cling the C++ Interpreter”. The <code>ShowMembers</code> and <code>Streamer</code> method, as well as the <code>&gt;&gt;</code> operator overloads, are implemented only if you use <code>ClassDef</code> and <code>ClassImp</code>. See <code>$ROOTSYS/include/Rtypes.h</code> for the definition of <code>ClassDef</code> and <code>ClassImp</code>. To exclude a data member from the <code>Streamer</code>, add a <code>!</code> as the first character in the comments of the field:</p>
<div class="sourceCode" id="cb838"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb838-1" title="1"><span class="dt">Int_t</span>     fTempValue; <span class="co">//! temporary state value</span></a></code></pre></div>
<h3 id="the-linkdef.h-file"><span class="header-section-number">15.5.1</span> The LinkDef.h File</h3>
<p><strong>Step 3:</strong> The <code>LinkDef.h</code> file tells <code>rootcling</code> which classes should be added to the dictionary.</p>
<div class="sourceCode" id="cb839"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb839-1" title="1"><span class="pp">#ifdef __CLING__</span></a>
<a class="sourceLine" id="cb839-2" title="2"><span class="pp">#pragma link C++ class SClass;</span></a>
<a class="sourceLine" id="cb839-3" title="3"><span class="pp">#endif</span></a></code></pre></div>
<p>Three options can trail the class name:</p>
<ul>
<li><code>-</code> : tells <code>rootcling</code> <strong>not</strong> to generate the <code>Streamer</code> method for this class. This is necessary for those classes that need a customized <code>Streamer</code> method.</li>
</ul>
<div class="sourceCode" id="cb840"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb840-1" title="1"><span class="pp">#pragma link C++ class SClass-;  </span><span class="co">// no streamer</span></a></code></pre></div>
<ul>
<li><strong><code>!</code></strong> : tells <code>rootcling</code> <strong>not</strong> to generate the <code>operator&gt;&gt;(</code><strong><code>TBuffer</code></strong> <code>&amp;b,MyClass *&amp;obj)</code> method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from <strong><code>TObject</code></strong>.</li>
</ul>
<div class="sourceCode" id="cb841"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb841-1" title="1"><span class="pp">#pragma link C++ class SClass!;      </span><span class="co">// no &gt;&gt; operator</span></a>
<a class="sourceLine" id="cb841-2" title="2"><span class="co">// or</span></a>
<a class="sourceLine" id="cb841-3" title="3"><span class="pp">#pragma link C++ class SClass-!; </span><span class="co">// no streamer, no &gt;&gt; operator</span></a></code></pre></div>
<ul>
<li><strong>+</strong> : in ROOT version 1 and 2 tells <code>rootcling</code> to generate a <code>Streamer</code>
 with extra byte count information. This adds an integer to each object 
in the output buffer, but it allows for powerful error correction in 
case a <code>Streamer</code> method is out of sync with data in the file. The <code>+</code> option is mutual exclusive with both the <code>-</code> and <code>!</code> options.</li>
</ul>
<p>IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells <code>rootcling</code>
 to use the new I/O system. The byte count check is always added. The 
new I/O system has many advantages including support automatic schema 
evolution, full support for STL collections and better run-time 
performance. We strongly recommend using it.</p>
<div class="sourceCode" id="cb842"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb842-1" title="1"><span class="pp">#pragma link C++ class SClass+; </span><span class="co">// add byte count</span></a></code></pre></div>
<p>For information on <code>Streamers</code> see “Input/Output”. To get help on <code>rootcling</code> type on the UNIX command line: <strong><code>rootcling -h</code></strong></p>
<h4 id="the-order-matters"><span class="header-section-number">15.5.1.1</span> The Order Matters</h4>
<p>When using template classes, the order of the pragma statements matters. For example, here is a template class <code>Tmpl</code> and a normal class <code>Norm</code>, which holds a specialized instance of a <code>Tmpl</code>:</p>
<div class="sourceCode" id="cb843"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb843-1" title="1"><span class="kw">class</span> Norm {</a>
<a class="sourceLine" id="cb843-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb843-3" title="3">   Tmpl&lt;<span class="dt">int</span>&gt;* fIntTmpl;</a>
<a class="sourceLine" id="cb843-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb843-5" title="5">  ...</a>
<a class="sourceLine" id="cb843-6" title="6">};</a></code></pre></div>
<p>Then in <code>Linkdef.h,</code> the pragma statements must be ordered by listing all specializations before any classes that need them:</p>
<div class="sourceCode" id="cb844"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb844-1" title="1"><span class="co">// Correct Linkdef.h ordering</span></a>
<a class="sourceLine" id="cb844-2" title="2">...</a>
<a class="sourceLine" id="cb844-3" title="3"><span class="pp">#pragma link C++ class Tmpl&lt;int&gt;;</span></a>
<a class="sourceLine" id="cb844-4" title="4"><span class="pp">#pragma link C++ class Norm;</span></a>
<a class="sourceLine" id="cb844-5" title="5">...</a></code></pre></div>
<p>And not vice versa:</p>
<div class="sourceCode" id="cb845"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb845-1" title="1"><span class="co">// Bad Linkdef.h ordering</span></a>
<a class="sourceLine" id="cb845-2" title="2">...</a>
<a class="sourceLine" id="cb845-3" title="3"><span class="pp">#pragma link C++ class Norm;</span></a>
<a class="sourceLine" id="cb845-4" title="4"><span class="pp">#pragma link C++ class Tmpl&lt;int&gt;;</span></a>
<a class="sourceLine" id="cb845-5" title="5">...</a></code></pre></div>
<p>In this case, <code>rootcling</code> generates <code>Norm::Streamer()</code> that makes reference to <code>Tmpl&lt;int&gt;::Streamer()</code>. Then <code>rootcling</code> gets to process <code>Tmpl&lt;int&gt;</code> and generates a specialized <code>Tmpl&lt;int&gt;::Streamer()</code> function. The problem is, when the compiler finds the first <code>Tmpl&lt;int&gt;::Streamer()</code>, it will instantiate it. However, later in the file it finds the specialized version that <code>rootcling</code> generated. This causes the error. However, if the <code>Linkdef.h</code> order is reversed then <code>rootcling</code> can generate the specialized <code>Tmpl&lt;int&gt;::Streamer()</code> before it is needed (and thus never instantiated by the compiler).</p>
<h4 id="other-useful-pragma-statements"><span class="header-section-number">15.5.1.2</span> Other Useful Pragma Statements</h4>
<p>The complete list of pragma statements currently supported by Cling is:</p>
<div class="sourceCode" id="cb846"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb846-1" title="1"><span class="pp">#pragma link [C|C++|off] all [class|function|global|typedef];</span></a>
<a class="sourceLine" id="cb846-2" title="2"><span class="pp">#pragma link [C|C++|off]</span></a>
<a class="sourceLine" id="cb846-3" title="3">   [<span class="kw">class</span>|<span class="kw">struct</span>|<span class="kw">union</span>|<span class="kw">enum</span>|<span class="kw">namespace</span>|<span class="kw">protected</span>][name];</a>
<a class="sourceLine" id="cb846-4" title="4"><span class="pp">#pragma link [C|C++|off] [global|typedef][name];</span></a>
<a class="sourceLine" id="cb846-5" title="5"><span class="pp">#pragma link [C|C++|off] [nestedclass|nestedtypedef];</span></a>
<a class="sourceLine" id="cb846-6" title="6"></a>
<a class="sourceLine" id="cb846-7" title="7"><span class="pp">#pragma link [C++|C|off|MACRO] function [name]&lt;(argtypes)&gt;;</span></a>
<a class="sourceLine" id="cb846-8" title="8"><span class="pp">#pragma link</span></a>
<a class="sourceLine" id="cb846-9" title="9">   [C++|C|off|MACRO] function [classname]::[name]&lt;(argtypes)&gt;;</a>
<a class="sourceLine" id="cb846-10" title="10"><span class="pp">#pragma link off all methods;</span></a>
<a class="sourceLine" id="cb846-11" title="11"><span class="pp">#pragma link [C|C++|off] defined_in [filename];</span></a>
<a class="sourceLine" id="cb846-12" title="12"><span class="pp">#pragma link</span></a>
<a class="sourceLine" id="cb846-13" title="13">   [C|C++|off] defined_in [<span class="kw">class</span>|<span class="kw">struct</span>|<span class="kw">namespace</span>] [name];</a>
<a class="sourceLine" id="cb846-14" title="14"><span class="pp">#pragma link [C|C++|off] all_function   [classname];</span></a>
<a class="sourceLine" id="cb846-15" title="15"><span class="pp">#pragma link [C|C++|off] all_datamember [classname];</span></a></code></pre></div>
<p>The <code>[classname]</code> and the <code>[name]</code> can also contain wildcards. For example:</p>
<div class="sourceCode" id="cb847"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb847-1" title="1"><span class="pp">#pragma link C++ class MyClass*;</span></a></code></pre></div>
<p>This will request the dictionary for all the class whose name start with <code>'MyClass'</code> and are already known to Cling (class templates need to have already been instantiated to be considered).</p>
<div class="sourceCode" id="cb848"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb848-1" title="1"><span class="pp">#pragma link [C|C++|off] all [class|function|global|typedef];</span></a></code></pre></div>
<p>This pragma statement turns on or off the dictionary generation for 
all classes, structures, namespaces, global variables, global functions 
and typedefs seen so far by Cling. Example:</p>
<div class="sourceCode" id="cb849"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb849-1" title="1"><span class="co">// some C++ header definition</span></a>
<a class="sourceLine" id="cb849-2" title="2"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb849-3" title="3"><span class="co">// turns off dictionary generation for all</span></a>
<a class="sourceLine" id="cb849-4" title="4"><span class="pp">#pragma link off all class;</span></a>
<a class="sourceLine" id="cb849-5" title="5"><span class="pp">#pragma link off all function;</span></a>
<a class="sourceLine" id="cb849-6" title="6"><span class="pp">#pragma link off all global;</span></a>
<a class="sourceLine" id="cb849-7" title="7"><span class="pp">#pragma link off all typedef;</span></a>
<a class="sourceLine" id="cb849-8" title="8"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma statement selectively turns on or off the dictionary generation for the specified <code>classs</code>, <code>struct</code>, <code>union</code>, <code>enum</code> or <code>namespace</code>:</p>
<div class="sourceCode" id="cb850"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb850-1" title="1"><span class="pp">#pragma link</span></a>
<a class="sourceLine" id="cb850-2" title="2">[C|C++|off][<span class="kw">class</span>|<span class="kw">class</span>+<span class="kw">protected</span>|</a>
<a class="sourceLine" id="cb850-3" title="3"><span class="kw">struct</span>|<span class="kw">union</span>|<span class="kw">enum</span>|<span class="kw">namespace</span>][name];</a></code></pre></div>
<p>The Dictionary of all public members of class and struct will be generated. If the ‘<code>class+protected</code>’
 flag is used, the dictionary for protected members will also be 
generated. However, dictionary for protected constructor and destructor 
will not be generated. This ’ <code>class+protected</code> ’ flag will help you only for plain protected member access, but not for virtual function resolution.</p>
<p>If you use the ‘<code>namespace</code>’ flag, it is recommended to add also:</p>
<div class="sourceCode" id="cb851"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb851-1" title="1"><span class="pp">#pragma link C++ nestedclass;</span></a>
<a class="sourceLine" id="cb851-2" title="2"><span class="pp">#pragma link C++ nestedtypedef;</span></a></code></pre></div>
<p>The behavior of ‘<code>class</code>’, ‘<code>struct</code>’ and ‘<code>namespace</code>’ flag are identical. Example:</p>
<div class="sourceCode" id="cb852"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb852-1" title="1"><span class="co">// some C++ header definition</span></a>
<a class="sourceLine" id="cb852-2" title="2"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb852-3" title="3"><span class="pp">#pragma link off all class;</span></a>
<a class="sourceLine" id="cb852-4" title="4"><span class="pp">#pragma link C++ class A;</span></a>
<a class="sourceLine" id="cb852-5" title="5"><span class="pp">#pragma link C++ class B;</span></a>
<a class="sourceLine" id="cb852-6" title="6"><span class="pp">#pragma link C++ class C&lt;int&gt;;</span></a>
<a class="sourceLine" id="cb852-7" title="7"><span class="pp">#pragma link C++ class+protected D;</span></a>
<a class="sourceLine" id="cb852-8" title="8"><span class="pp">#pragma link C++ namespace project1;</span></a>
<a class="sourceLine" id="cb852-9" title="9"><span class="pp">#pragma link C++ nestedclass;</span></a>
<a class="sourceLine" id="cb852-10" title="10"><span class="pp">#pragma link C++ nestedtypedef;</span></a>
<a class="sourceLine" id="cb852-11" title="11"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma statement selectively turns on or off the dictionary generation for global variables and typedef.</p>
<div class="sourceCode" id="cb853"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb853-1" title="1"><span class="pp">#pragma link [C|C++|off] [global|typedef] [name];</span></a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb854"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb854-1" title="1"><span class="co">// some C/C++ header definition</span></a>
<a class="sourceLine" id="cb854-2" title="2"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb854-3" title="3"><span class="pp">#pragma link off all global;</span></a>
<a class="sourceLine" id="cb854-4" title="4"><span class="pp">#pragma link off all typedef;</span></a>
<a class="sourceLine" id="cb854-5" title="5"><span class="pp">#pragma link C++ global a;</span></a>
<a class="sourceLine" id="cb854-6" title="6"><span class="pp">#pragma link C++ typedef Int_t;</span></a>
<a class="sourceLine" id="cb854-7" title="7"><span class="pp">#endif</span></a></code></pre></div>
<p>This pragma statement turns on the dictionary generation for nested classes and nested typedefs.</p>
<div class="sourceCode" id="cb855"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb855-1" title="1"><span class="pp">#pragma link [C|C++|off] [nestedclass|nestedtypedef];</span></a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb856"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb856-1" title="1"><span class="co">// some C/C++ header definition</span></a>
<a class="sourceLine" id="cb856-2" title="2"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb856-3" title="3"><span class="pp">#pragma link off all global;</span></a>
<a class="sourceLine" id="cb856-4" title="4"><span class="pp">#pragma link off all typedef;</span></a>
<a class="sourceLine" id="cb856-5" title="5"><span class="pp">#pragma link C++ global a;</span></a>
<a class="sourceLine" id="cb856-6" title="6"><span class="pp">#pragma link C++ typedef Int_t;</span></a>
<a class="sourceLine" id="cb856-7" title="7"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma statements turn on or off the dictionary generation 
for the specified function(s) or member function(s). The list of 
arguments’ type is optional. If you omit argument types, all function 
with specified [<code>name</code>] will be affected. If the list of 
arguments’ type is specified, only the function that has exactly same 
argument list will be affected.</p>
<div class="sourceCode" id="cb857"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb857-1" title="1"><span class="pp">#pragma link [C++|C|off|MACRO] function [fname]&lt;(argtypes)&gt;;</span></a>
<a class="sourceLine" id="cb857-2" title="2"><span class="pp">#pragma link</span></a>
<a class="sourceLine" id="cb857-3" title="3">[C++|C|off|MACRO] function [classname]::[fname]&lt;(argtypes)&gt;;</a></code></pre></div>
<p>The ‘<code>#pragma link [C++|C] function</code>’ and ‘<code>#pragma link MACRO function</code>’ behaves similarly. The ‘<code>#pragma link [C++|C] function</code>’
 assumes the target to be a real function which has pointer to it. A 
pointer to registered function is registered. On the other hand, ‘<code>#pragma link MACRO function</code>’ assumes target to be macro function. Pointer to function cannot be referenced in this case.</p>
<p>For the next example:</p>
<div class="sourceCode" id="cb858"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb858-1" title="1"><span class="dt">void</span> f(<span class="dt">int</span> a);</a>
<a class="sourceLine" id="cb858-2" title="2"><span class="dt">void</span> f(<span class="dt">double</span> a);</a>
<a class="sourceLine" id="cb858-3" title="3"><span class="dt">int</span> g(<span class="dt">int</span> a,<span class="dt">double</span> b);</a>
<a class="sourceLine" id="cb858-4" title="4"><span class="dt">int</span> g(<span class="dt">double</span> x);</a>
<a class="sourceLine" id="cb858-5" title="5"><span class="pp">#define max</span>(a,b)<span class="pp"> </span>(a&gt;b?a:b)</a>
<a class="sourceLine" id="cb858-6" title="6"></a>
<a class="sourceLine" id="cb858-7" title="7"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb858-8" title="8">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb858-9" title="9">      <span class="dt">int</span> h(<span class="dt">double</span> y);</a>
<a class="sourceLine" id="cb858-10" title="10">      <span class="dt">int</span> h(<span class="dt">int</span> a,<span class="dt">double</span> b);</a>
<a class="sourceLine" id="cb858-11" title="11">};</a></code></pre></div>
<p>The pragma statements are:</p>
<div class="sourceCode" id="cb859"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb859-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb859-2" title="2"><span class="pp">#pragma link off all functions;</span></a>
<a class="sourceLine" id="cb859-3" title="3"><span class="pp">#pragma link C++ function f;</span></a>
<a class="sourceLine" id="cb859-4" title="4"><span class="pp">#pragma link C++ function g(int,double);</span></a>
<a class="sourceLine" id="cb859-5" title="5"><span class="pp">#pragma link C++ MACRO max;</span></a>
<a class="sourceLine" id="cb859-6" title="6"><span class="pp">#pragma link C++ class A;</span></a>
<a class="sourceLine" id="cb859-7" title="7"><span class="pp">#pragma link off function A::h(double);</span></a>
<a class="sourceLine" id="cb859-8" title="8"><span class="pp">#endif</span></a></code></pre></div>
<p>Until Cling version 5.15.60, in order to generate dictionary for a 
member function, not only the member function but also the class itself 
has to be turned on for the linkage. There was an inconvenience when 
generating dictionary for template member function afterwards.</p>
<p>From Cling v.5.15.61, a new behavior is introduced. If link for a 
member function is specified, dictionary is generated even if link to 
the belonging class is off. For example, if you originally have A.h as 
follows:</p>
<div class="sourceCode" id="cb860"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb860-1" title="1"><span class="co">// A.h</span></a>
<a class="sourceLine" id="cb860-2" title="2"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb860-3" title="3">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb860-4" title="4">      <span class="kw">template</span>&lt;<span class="kw">class</span> E&gt; <span class="dt">void</span> f(E&amp; x) { ... }</a>
<a class="sourceLine" id="cb860-5" title="5">};</a></code></pre></div>
<p>And generate dictionary for that:</p>
<div class="sourceCode" id="cb861"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb861-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb861-2" title="2"><span class="pp">#pragma link C++ class A&lt;int&gt;;</span></a>
<a class="sourceLine" id="cb861-3" title="3"><span class="pp">#endif</span></a></code></pre></div>
<p>Then prepare another header file and instantiate the template member function of A.:</p>
<div class="sourceCode" id="cb862"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb862-1" title="1"><span class="co">// B.h</span></a>
<a class="sourceLine" id="cb862-2" title="2"><span class="pp">#include </span><span class="im">"A.h"</span></a>
<a class="sourceLine" id="cb862-3" title="3"></a>
<a class="sourceLine" id="cb862-4" title="4"><span class="kw">class</span> B {</a>
<a class="sourceLine" id="cb862-5" title="5">...</a>
<a class="sourceLine" id="cb862-6" title="6">};</a></code></pre></div>
<p>You can generate dictionary for the newly instantiated template member function only.</p>
<div class="sourceCode" id="cb863"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb863-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb863-2" title="2"><span class="pp">#pragma link off defined_in A.h;</span></a>
<a class="sourceLine" id="cb863-3" title="3"><span class="pp">#pragma link C++ function A&lt;int&gt;::f(B&amp;);</span></a>
<a class="sourceLine" id="cb863-4" title="4"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma turns off the dictionary generation of all the member functions in all classes.</p>
<div class="sourceCode" id="cb864"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb864-1" title="1"><span class="pp">#pragma link off all methods;</span></a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb865"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb865-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb865-2" title="2"><span class="pp">#pragma link off all methods;</span></a>
<a class="sourceLine" id="cb865-3" title="3"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma statements control the linking of all the member functions or data members for a specified class.</p>
<div class="sourceCode" id="cb866"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb866-1" title="1"><span class="pp">#pragma link [C|C++|off] all_function   [classname];</span></a>
<a class="sourceLine" id="cb866-2" title="2"><span class="pp">#pragma link [C|C++|off] all_datamember [classname];</span></a></code></pre></div>
<p>At this moment, there should be no needs to use those statements. Example:</p>
<div class="sourceCode" id="cb867"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb867-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb867-2" title="2"><span class="pp">#pragma link off all_function   A;</span></a>
<a class="sourceLine" id="cb867-3" title="3"><span class="pp">#pragma link off all_datamember A;</span></a>
<a class="sourceLine" id="cb867-4" title="4"><span class="pp">#endif</span></a></code></pre></div>
<p>See also: <code>#pragma link function</code>.</p>
<p>The next pragma statement turns on/off dictionary generation of the 
object defined in specific file. The filename has to be the full 
pathname of the file.</p>
<div class="sourceCode" id="cb868"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb868-1" title="1"><span class="pp">#pragma link [C|C++|off] defined_in [filename];</span></a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb869"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb869-1" title="1"><span class="co">// file1.h</span></a>
<a class="sourceLine" id="cb869-2" title="2"><span class="co">// any C++ header definition</span></a>
<a class="sourceLine" id="cb869-3" title="3"></a>
<a class="sourceLine" id="cb869-4" title="4"><span class="co">// file2.h</span></a>
<a class="sourceLine" id="cb869-5" title="5"></a>
<a class="sourceLine" id="cb869-6" title="6"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb869-7" title="7"><span class="pp">#pragma link off all classes;</span></a>
<a class="sourceLine" id="cb869-8" title="8"><span class="pp">#pragma link off all functions;</span></a>
<a class="sourceLine" id="cb869-9" title="9"><span class="pp">#pragma link off all globals;</span></a>
<a class="sourceLine" id="cb869-10" title="10"></a>
<a class="sourceLine" id="cb869-11" title="11"><span class="pp">#pragma link off all typedef;</span></a>
<a class="sourceLine" id="cb869-12" title="12"><span class="pp">#pragma link C++ defined_in file1.h;</span></a>
<a class="sourceLine" id="cb869-13" title="13"><span class="pp">#endif</span></a></code></pre></div>
<p>The next pragma statements turn on or off the dictionary generation of the object defined in a specific scope. The [<code>scope_name</code>] should be <code>class</code> name, <code>struct</code> name or <code>namespace</code> name. When using these pragmas, it is recommended to use also:</p>
<div class="sourceCode" id="cb870"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb870-1" title="1"><span class="pp">#pragma link C++ nestedclass</span></a></code></pre></div>
<p>Otherwise, definitions in enclosed scope do not appear in the dictionary.</p>
<div class="sourceCode" id="cb871"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb871-1" title="1"><span class="pp">#pragma link [C|C++|off] defined_in [scope_name];</span></a>
<a class="sourceLine" id="cb871-2" title="2"><span class="pp">#pragma link [C|C++|off] defined_in</span></a>
<a class="sourceLine" id="cb871-3" title="3">[<span class="kw">class</span>|<span class="kw">struct</span>|<span class="kw">namespace</span>] [scope_name];</a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb872"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb872-1" title="1"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb872-2" title="2">   <span class="dt">int</span> a;</a>
<a class="sourceLine" id="cb872-3" title="3">   <span class="dt">double</span> b;</a>
<a class="sourceLine" id="cb872-4" title="4">};</a></code></pre></div>
<p>The pragma statements are:</p>
<div class="sourceCode" id="cb873"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb873-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb873-2" title="2"><span class="pp">#pragma link C++ defined_in ns;</span></a>
<a class="sourceLine" id="cb873-3" title="3"><span class="pp">#pragma link C++ nestedclass;</span></a>
<a class="sourceLine" id="cb873-4" title="4"><span class="pp">#endif</span></a></code></pre></div>
<p>This statements controls default link mode for <code>rootcling</code>.</p>
<div class="sourceCode" id="cb874"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb874-1" title="1"><span class="pp">#pragma link default [on|off]</span></a></code></pre></div>
<p>By turning default ‘on’, all language constructs in given header 
files will be included in generated Cling dictionary (interface method 
source file). If default is set to ‘off’, nothing will be included in 
the generated dictionary. The next statement explicitly set linkage to 
each item:</p>
<div class="sourceCode" id="cb875"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb875-1" title="1"><span class="pp">#pragma link [C|C++|off] [class|function|global]</span></a></code></pre></div>
<p>This pragma statement must be given before <code>rootcling</code> reads any C/C++ definitions from header files. Example:</p>
<div class="sourceCode" id="cb876"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb876-1" title="1"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb876-2" title="2"><span class="pp">#pragma link default off;</span></a>
<a class="sourceLine" id="cb876-3" title="3"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb876-4" title="4"></a>
<a class="sourceLine" id="cb876-5" title="5"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb876-6" title="6">   <span class="dt">int</span> a;</a>
<a class="sourceLine" id="cb876-7" title="7">   <span class="dt">double</span> b;</a>
<a class="sourceLine" id="cb876-8" title="8">};</a>
<a class="sourceLine" id="cb876-9" title="9"></a>
<a class="sourceLine" id="cb876-10" title="10"><span class="kw">class</span> B {</a>
<a class="sourceLine" id="cb876-11" title="11">   <span class="dt">int</span> d;</a>
<a class="sourceLine" id="cb876-12" title="12">   <span class="dt">double</span> e;</a>
<a class="sourceLine" id="cb876-13" title="13">};</a>
<a class="sourceLine" id="cb876-14" title="14"></a>
<a class="sourceLine" id="cb876-15" title="15"><span class="pp">#ifdef __ROOTCLING__</span></a>
<a class="sourceLine" id="cb876-16" title="16"><span class="pp">#pragma link C++ class A;      </span><span class="co">// only class A is linked, not B</span></a>
<a class="sourceLine" id="cb876-17" title="17"><span class="pp">#endif</span></a></code></pre></div>
<h5 id="compilation"><span class="header-section-number">15.5.1.2.1</span> Compilation</h5>
<p><strong>Step 4:</strong> Compile the class using the <code>Makefile.</code>In the <code>Makefile</code> call <code>rootcling</code> to make the dictionary for the class. Call it <code>SClassDict.cxx</code>. The <code>rootcling</code> utility generates the methods <code>Streamer</code>, <strong><code>TBuffer</code></strong> &amp;operator&gt;&gt;() and <code>ShowMembers</code>for ROOT classes.</p>
<div class="sourceCode" id="cb877"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb877-1" title="1">gmake -f Makefile</a></code></pre></div>
<p>Load the shared library:</p>
<div class="sourceCode" id="cb878"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb878-1" title="1">root[] .L SClass.so</a>
<a class="sourceLine" id="cb878-2" title="2">root[] SClass *sc = <span class="kw">new</span> SClass()</a>
<a class="sourceLine" id="cb878-3" title="3">root[] TFile *f = <span class="kw">new</span> TFile(<span class="st">"Afile.root"</span>,<span class="st">"UPDATE"</span>);</a>
<a class="sourceLine" id="cb878-4" title="4">root[] sc-&gt;Write();</a></code></pre></div>
<p>For more information on <code>rootcling</code> see the <code>$ROOTSYS/test</code> directory <code>Makefile</code>, <code>Event.cxx</code>, and <code>Event.h</code> for an example, or follow this link: <a href="http://root.cern.ch/root/RootCintMan.html" class="uri">http://root.cern.ch/root/RootCintMan.html</a></p>
<h2 id="genreflex-a-comfortable-interface-to-rootcling"><span class="header-section-number">15.6</span> genreflex: A Comfortable Interface to rootcling</h2>
<p>Version 5 supported both <code>Cint</code> and <code>Reflex</code> dictionaries. The tool to create <code>Reflex</code> dictionaries was a Python script called <code>genreflex</code> and was very successful in the user community. Even if version 6 has only one type of dictionaries, <code>cling</code> dictionaries, a re-implementation of <code>genreflex</code> is provided. More precisely, in ROOT6, <code>genreflex</code> is nothing but a wrapper around <code>rootcling</code>, which offers an identical CLI and behaviour to the old Python tool. The input to <code>genreflex</code> is a C++ header file, a set of switches and a <em>selection XML file</em>. The output, as for <code>rootcling</code>, is a C++ dictionary source and a <code>pcm</code> files. An exhaustive documentation of the CLI switches of <code>genreflex</code> can be inspected with the <code>genreflex --help</code> command.</p>
<p>The entity corresponding to the <code>LinkDef</code> file for <code>genreflex</code> is the <em>selection XML file</em>, also called <em>selection XML</em> or simply <em>selection file</em>. A <em>selection XML file</em>
 allows to describe a list of classes for which the dictionaries are to 
be created. In addition, it allows to specify properties of classes or 
data members, without the need to add comments in the source code. This 
is of primary importance when dictionaries must be created for classes 
residing in code which cannot be modified. For a complete description of
 the structure of the <em>selection XML files</em> and the way in which attributes can be set, refer to the <code>genreflex --help</code> command.</p>
<p>It is important to observe that <em>selection XML files</em> can be used in presence of <code>rootcling</code> invocations instead of <code>LinkDef</code> files.</p>
<h3 id="the-rootmetaselection-namespace"><span class="header-section-number">15.6.1</span> The <code>ROOT::Meta::Selection</code> namespace</h3>
<p>Not only <code>LinkDef</code> and <code>selection</code> files allow 
to select the classes for which the dictionaries must be created: a 
third method is available. This is represented by the <code>ROOT::Meta::Selection</code>
 namespace. The idea behind this technique is that all the classes which
 are located in this special namespace are automatically selected for 
dictionary generation. All the properties and annotations allowed by <code>LinkDef</code> and <code>selection XML</code> files are possible. For a detailed documentation of the features of the <code>ROOT::Meta::Selection</code> namespace, refer to its online documentation.</p>
<h2 id="adding-a-class-with-aclic"><span class="header-section-number">15.7</span> Adding a Class with ACLiC</h2>
<p> <strong>Step 1:</strong> Define your class</p>
<div class="sourceCode" id="cb879"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb879-1" title="1"><span class="pp">#include </span><span class="im">"TObject.h"</span></a>
<a class="sourceLine" id="cb879-2" title="2"></a>
<a class="sourceLine" id="cb879-3" title="3"><span class="co">// define the ABC class and make it inherit from TObject so that</span></a>
<a class="sourceLine" id="cb879-4" title="4"><span class="co">// we can write ABC to a ROOT file</span></a>
<a class="sourceLine" id="cb879-5" title="5"><span class="kw">class</span> ABC : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb879-6" title="6"></a>
<a class="sourceLine" id="cb879-7" title="7">   <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb879-8" title="8">      <span class="dt">Float_t</span> a, b, c, p;</a>
<a class="sourceLine" id="cb879-9" title="9">      ABC() : a(<span class="dv">0</span>), b(<span class="dv">0</span>), c(<span class="dv">0</span>), p(<span class="dv">0</span>){};</a>
<a class="sourceLine" id="cb879-10" title="10"></a>
<a class="sourceLine" id="cb879-11" title="11"><span class="co">// Define the class for the dictionary</span></a>
<a class="sourceLine" id="cb879-12" title="12">   ClassDef (ABC,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb879-13" title="13">};</a>
<a class="sourceLine" id="cb879-14" title="14"></a>
<a class="sourceLine" id="cb879-15" title="15"><span class="co">// Call the ClassImp macro to give the ABC class RTTI and</span></a>
<a class="sourceLine" id="cb879-16" title="16"><span class="co">// full I/O capabilities.</span></a>
<a class="sourceLine" id="cb879-17" title="17"></a>
<a class="sourceLine" id="cb879-18" title="18"><span class="pp">#if !defined(__CLING__)</span></a>
<a class="sourceLine" id="cb879-19" title="19">ClassImp(ABC);</a>
<a class="sourceLine" id="cb879-20" title="20"><span class="pp">#endif</span></a></code></pre></div>
<p><strong>Step 2:</strong> Load the ABC class in the script.</p>
<div class="sourceCode" id="cb880"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb880-1" title="1">   <span class="co">// Check if ABC is already loaded</span></a>
<a class="sourceLine" id="cb880-2" title="2">   <span class="cf">if</span> (!TClass::GetDict(<span class="st">"ABC"</span>)) {</a>
<a class="sourceLine" id="cb880-3" title="3">      gROOT-&gt;ProcessLine(<span class="st">".L ABCClass.C++"</span>);</a>
<a class="sourceLine" id="cb880-4" title="4">   }</a>
<a class="sourceLine" id="cb880-5" title="5"></a>
<a class="sourceLine" id="cb880-6" title="6">   <span class="co">// Use the Class</span></a>
<a class="sourceLine" id="cb880-7" title="7">   ABC *v = <span class="kw">new</span> ABC;</a>
<a class="sourceLine" id="cb880-8" title="8">   v-&gt;p = (sqrt((v-&gt;a * v-&gt;a)+ (v-&gt;b * v-&gt;b)+(v-&gt;c * v-&gt;c)));</a></code></pre></div>
<h1 id="collection-classes"><span class="header-section-number">16</span> Collection Classes</h1>
<p>Collections are a key feature of the ROOT system. Many, if not most, 
of the applications you write will use collections. If you have used 
parameterized C++ collections or polymorphic collections before, some of
 this material will be review. However, much of this chapter covers 
aspects of collections specific to the ROOT system. When you have read 
this chapter, you will know</p>
<ul>
<li><p>How to create instances of collections</p></li>
<li><p>The difference between lists, arrays, hash tables, maps, etc.</p></li>
<li><p>How to add and remove elements of a collection</p></li>
<li><p>How to search a collection for a specific element</p></li>
<li><p>How to access and modify collection elements</p></li>
<li><p>How to iterate over a collection to access collection elements</p></li>
<li><p>How to manage memory for collections and collection elements</p></li>
<li><p>How collection elements are tested for equality (<code>IsEqual(</code>))</p></li>
<li><p>How collection elements are compared (<code>Compare())</code> in case of sorted collections</p></li>
<li><p>How collection elements are hashed (<code>Hash()</code>) in hash tables</p></li>
</ul>
<h2 id="understanding-collections"><span class="header-section-number">16.1</span> Understanding Collections</h2>
<p>A collection is a group of related objects. You will find it easier 
to manage a large number of items as a collection. For example, a 
diagram editor might manage a collection of points and lines. A set of 
widgets for a graphical user interface can be placed in a collection. A 
geometrical model can be described by collections of shapes, materials 
and rotation matrices. Collections can themselves be placed in 
collections. Collections act as flexible alternatives to traditional 
data structures of computers science such as arrays, lists and trees.</p>
<h3 id="general-characteristics"><span class="header-section-number">16.1.1</span> General Characteristics</h3>
<p>The ROOT collections are polymorphic containers that hold pointers to <code>TObjects</code>, so:</p>
<ul>
<li><p>They can only hold objects that inherit from <strong><code>TObject</code></strong></p></li>
<li><p>They return pointers to <code>TObjects</code>, that have to be cast back to the correct subclass</p></li>
</ul>
<p>Collections are dynamic; they can grow in size as required. Collections themselves are descendants of <strong><code>TObject</code></strong>
 so can themselves be held in collections. It is possible to nest one 
type of collection inside another to any level to produce structures of 
arbitrary complexity.</p>
<p>Collections do not own the objects they hold for the very good reason
 that the same object could be a member of more than one collection. 
Object ownership is important when it comes to deleting objects; if 
nobody owns the object it could end up as wasted memory (i.e.&nbsp;a 
memory leak) when no longer needed. If a collection is deleted, its 
objects are not. The user can force a collection to delete its objects, 
but that is the user’s choice.</p>
<h3 id="determining-the-class-of-contained-objects"><span class="header-section-number">16.1.2</span> Determining the Class of Contained Objects</h3>
<p>Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the <strong><code>TObject</code></strong>
 pointer to the right class. Casting to the wrong class will give wrong 
results and may well crash the program! Therefore, the user has to be 
very careful. Often a container only contains one class of objects, but 
if it really contains a mixture, it is possible to ask each object about
 its class using the <code>InheritsFrom</code> method.</p>
<p>For example if <code>myObject</code> is a <strong><code>TObject</code></strong> pointer:</p>
<div class="sourceCode" id="cb881"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb881-1" title="1"><span class="cf">if</span> (myObject-&gt;InheritsFrom(<span class="st">"TParticle"</span>) {</a>
<a class="sourceLine" id="cb881-2" title="2">   printf(<span class="st">"myObject is a TParticlen"</span>);</a>
<a class="sourceLine" id="cb881-3" title="3">}</a></code></pre></div>
<p>As the name suggests, this test works even if the object is a subclass of <strong><code>TParticle</code></strong>. The member function <code>IsA()</code> can be used instead of <code>InheritsFrom</code> to make the test exact. The <code>InheritsFrom</code> and <code>IsA</code> methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.</p>
<h3 id="types-of-collections"><span class="header-section-number">16.1.3</span> Types of Collections</h3>
<p>The ROOT system implements the following basic types of collections: 
unordered collections, ordered collections and sorted collections. Next 
figure shows the inheritance hierarchy for the primary collection 
classes. All primary collection classes derive from the abstract base 
class <strong><code>TCollection</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/020001A3.jpg" alt="The inheritance hierarchy of the primary collection classes"><figcaption>The inheritance hierarchy of the primary collection classes</figcaption>
</figure>
<h3 id="ordered-collections-sequences"><span class="header-section-number">16.1.4</span> Ordered Collections (Sequences)</h3>
<p>Sequences are collections that are externally ordered because they 
maintain internal elements according to the order in which they were 
added. The following sequences are available:</p>
<ul>
<li><p><strong><code>TList</code></strong></p></li>
<li><p><strong><code>THashList</code></strong></p></li>
<li><p><strong><code>TOrdCollection</code></strong></p></li>
<li><p><strong><code>TObjArray</code></strong></p></li>
<li><p><strong><code>TClonesArray</code></strong></p></li>
</ul>
<p>The <strong><code>TOrdCollection</code></strong>, <strong><code>TObjArray</code></strong> as well as the <strong><code>TClonesArray</code></strong>
 can be sorted using their Sort() member function (for this, the stored 
objects must provide a comparison function by overriding 
TObject::Compare() and also must enable sorting by overriding 
TObject::IsSortable() to return true). Ordered collections all derive 
from the abstract base class <strong><code>TSeqCollection</code></strong>.
 Sorted collections are ordered by an internal (automatic) sorting 
mechanism. The following sorted collections are available (the stored 
items must be sortable):</p>
<ul>
<li><p><strong><code>TSortedList</code></strong></p></li>
<li><p><strong><code>TBtree</code></strong></p></li>
</ul>
<p>Unordered collections don’t maintain the order in which the elements 
were added, i.e.&nbsp;when you iterate over an unordered collection, you
 are not likely to retrieve elements in the same order they were added 
to the collection. The following unordered collections are available:</p>
<ul>
<li><p><strong><code>THashTable</code></strong></p></li>
<li><p><strong><code>TMap</code></strong></p></li>
</ul>
<h2 id="iterators-processing-a-collection"><span class="header-section-number">16.2</span> Iterators: Processing a Collection</h2>
<p>The concept of processing all the members of a collection is generic,
 i.e.&nbsp;independent of any specific representation of a collection. 
To process each object in a collection one needs some type of cursor 
that is initialized and then steps over each member of the collection in
 turn. Collection objects could provide this service but there is a 
snag: as there is only one collection object per collection there would 
only be one cursor. Instead, to permit the use of as many cursors as 
required, they are made separate classes called iterator. For each 
collection class there is an associated iterator class that knows how to
 sequentially retrieve each member in turn. The relationship between a 
collection and its iterator is very close and may require that the 
iterator has full access to the collection (i.e.&nbsp;it is a friend 
class). In general iterator will be used via the <strong><code>TIter</code></strong> wrapper class. For example:</p>
<ul>
<li><p><strong><code>TList</code></strong> <strong><code>TListIter</code></strong></p></li>
<li><p><strong><code>TMap</code></strong> <strong><code>TMapIter</code></strong></p></li>
</ul>
<h2 id="foundation-classes"><span class="header-section-number">16.3</span> Foundation Classes</h2>
<p>All collections are based on the fundamental classes: <strong><code>TCollection</code></strong> and <strong><code>TIterator</code></strong>.
 They are so generic that it is not possible to create objects from 
them; they are only used as base classes for other classes 
(i.e.&nbsp;they are abstract base classes).</p>
<p>The <strong><code>TCollection</code></strong> class provides the 
basic protocol (i.e.&nbsp;the minimum set of member functions) that all 
collection classes have to implement. These include:</p>
<ul>
<li><p><code>Add</code> <code>Adds another object to the collection.</code></p></li>
<li><p><code>GetSize</code> <code>Returns the number of objects in the collection.</code></p></li>
<li><p><code>Clear</code> <code>Clears out the collection, but does not delete the removed objects.</code></p></li>
<li><p><code>Delete</code> <code>Clears out the collection and deletes the removed objects. This should only</code> <code>be used if the collection owns its objects (which are not normally the case).</code></p></li>
<li><p><code>FindObject</code> <code>Finds an object given either its name or address.</code></p></li>
<li><p><code>MakeIterator</code> <code>Returns an iterator associated with the collection.</code></p></li>
<li><p><code>Remove</code> <code>Removes an object from the collection.</code></p></li>
</ul>
<p>The code example below shows a class containing three lists, where the <code>fTracks</code>
 list is the owning collection and the other two lists are used to store
 a sub-set of the track objects. In the destructor of the class, the 
method <code>Delete</code> is called for the owning collection to delete correctly its entire track objects. To delete the objects in the container use <code>fTrack-&gt;Delete()</code>. To delete the container itself, do ’<code>delete fTracks'.</code></p>
<div class="sourceCode" id="cb882"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb882-1" title="1"><span class="kw">class</span> TEvent : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb882-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb882-3" title="3">   TList *fTracks;  <span class="co">//list of all tracks</span></a>
<a class="sourceLine" id="cb882-4" title="4">   TList *fVertex1; <span class="co">//subset of tracks part of vertex1</span></a>
<a class="sourceLine" id="cb882-5" title="5">   TList *fVertex2; <span class="co">//subset of tracks part of vertex2</span></a>
<a class="sourceLine" id="cb882-6" title="6">};</a>
<a class="sourceLine" id="cb882-7" title="7">TEvent::~TEvent()</a>
<a class="sourceLine" id="cb882-8" title="8">{</a>
<a class="sourceLine" id="cb882-9" title="9">   fTracks-&gt;Delete();</a>
<a class="sourceLine" id="cb882-10" title="10">   <span class="kw">delete</span> fTracks;</a>
<a class="sourceLine" id="cb882-11" title="11">   <span class="kw">delete</span> fVertex1;</a>
<a class="sourceLine" id="cb882-12" title="12">   <span class="kw">delete</span> fVertex2;</a>
<a class="sourceLine" id="cb882-13" title="13">}</a></code></pre></div>
<p>The <strong><code>TIterator</code></strong> class defines the minimum set of member functions that all iterators must support. These include:</p>
<ul>
<li><p><code>Next</code> <code>Returns the next member of the collection or 0 if no more members.</code></p></li>
<li><p><code>Reset</code> <code>Resets the iterator so that</code> <code>Next</code> <code>returns the first object.</code></p></li>
</ul>
<h2 id="a-collectable-class"><span class="header-section-number">16.4</span> A Collectable Class</h2>
<p>By default, all objects of <strong><code>TObject</code></strong> derived classes can be stored in ROOT containers. However, the <strong><code>TObject</code></strong>
 class provides some member functions that allow you to tune the 
behavior of objects in containers. For example, by default two objects 
are considered equal if their pointers point to the same address. This 
might be too strict for some classes where equality is already achieved 
if some or all of the data members are equal. By overriding the 
following <strong><code>TObject</code></strong> member functions, you can change the behavior of objects in collections:</p>
<ul>
<li><p><code>IsEqual()</code>is used by the <code>FindObject()</code>collection method. By default, <code>IsEqual()</code> compares the two object pointers.</p></li>
<li><p><code>Compare()</code>returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a <strong><code>TObject</code></strong> has not a valid <code>Compare()</code> method.</p></li>
<li><p><code>IsSortable()</code>returns true if the class is sort able (i.e.&nbsp;if it has a valid <code>Compare(</code>) method). By default, a <strong><code>TObject</code></strong> is not sort able.</p></li>
<li><p><code>Hash()</code>returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like <strong><code>THashTable</code></strong>, <strong><code>THashList</code></strong> and <strong><code>TMap</code></strong>. By default, <code>Hash(</code>) returns the address of the object. It is essential to choose a good hash function.</p></li>
</ul>
<p>The example below shows how to use and override these member functions.</p>
<div class="sourceCode" id="cb883"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb883-1" title="1"><span class="kw">class</span> TObjNum : <span class="kw">public</span> TObject {</a>
<a class="sourceLine" id="cb883-2" title="2">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb883-3" title="3">   <span class="dt">Int_t</span>  num;  <span class="co">// TObjNum is a simple container for an integer.</span></a>
<a class="sourceLine" id="cb883-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb883-5" title="5">   TObjNum(<span class="dt">Int_t</span> i = <span class="dv">0</span>) : num(i) { }</a>
<a class="sourceLine" id="cb883-6" title="6">   ~TObjNum() { }</a>
<a class="sourceLine" id="cb883-7" title="7">   <span class="dt">void</span>     SetNum(<span class="dt">Int_t</span> i) { num = i; }</a>
<a class="sourceLine" id="cb883-8" title="8">   <span class="dt">Int_t</span>    GetNum() <span class="at">const</span> { <span class="cf">return</span> num; }</a>
<a class="sourceLine" id="cb883-9" title="9">   <span class="dt">void</span>     Print(<span class="dt">Option_t</span> *) <span class="at">const</span></a>
<a class="sourceLine" id="cb883-10" title="10">      { printf(<span class="st">"num = </span><span class="sc">%d</span><span class="st">n"</span>, num); }</a>
<a class="sourceLine" id="cb883-11" title="11">   <span class="dt">Bool_t</span>   IsEqual(TObject *obj) <span class="at">const</span></a>
<a class="sourceLine" id="cb883-12" title="12">      { <span class="cf">return</span> num == ((TObjNum*)obj)-&gt;num; }</a>
<a class="sourceLine" id="cb883-13" title="13">   <span class="dt">Bool_t</span>   IsSortable() <span class="at">const</span> { <span class="cf">return</span> kTRUE; }</a>
<a class="sourceLine" id="cb883-14" title="14">   <span class="dt">Int_t</span>    Compare(<span class="at">const</span> TObject *obj) <span class="at">const</span></a>
<a class="sourceLine" id="cb883-15" title="15">      { <span class="cf">if</span> (num &lt; ((TObjNum*)obj)-&gt;num) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb883-16" title="16">        <span class="cf">else</span> <span class="cf">if</span> (num &gt; ((TObjNum*)obj)-&gt;num) <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb883-17" title="17">        <span class="cf">else</span> <span class="cf">return</span> <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb883-18" title="18">   <span class="dt">ULong_t</span>  Hash() <span class="at">const</span> { <span class="cf">return</span> num; }</a>
<a class="sourceLine" id="cb883-19" title="19">};</a></code></pre></div>
<h2 id="the-titer-generic-iterator"><span class="header-section-number">16.5</span> The TIter Generic Iterator</h2>
<p>As stated above, the <strong><code>TIterator</code></strong> class is abstract; it is not possible to create <strong><code>TIterator</code></strong>
 objects. However, it should be possible to write generic code to 
process all members of a collection so there is a need for a generic 
iterator object. A <strong><code>TIter</code></strong> object acts as generic iterator. It provides the same <code>Next()</code> and <code>Reset()</code> methods as <strong><code>TIterator</code></strong> although it has no idea how to support them! It works as follows:</p>
<ul>
<li><p>To create a <strong><code>TIter</code></strong> object its constructor must be passed an object that inherits from <strong><code>TCollection</code></strong>. The <strong><code>TIter</code></strong> constructor calls the <code>MakeIterator()</code> method of this collection to get the appropriate iterator object that inherits from <strong><code>TIterator</code></strong>.</p></li>
<li><p>The <code>Next()</code> and <code>Reset()</code> methods of <strong><code>TIter</code></strong> simply call the <code>Next()</code> and <code>Reset()</code> methods of the iterator object.</p></li>
</ul>
<p>Therefore, <strong><code>TIter</code></strong> simply acts as a wrapper for an object of a concrete class inheriting from <strong><code>TIterator</code></strong>.</p>
<p>To see this working in practice, consider the <strong><code>TObjArray</code></strong> collection. Its associated iterator is <strong><code>TObjArrayIter</code></strong>. Suppose <code>myarray</code> is a pointer to a <strong><code>TObjArray</code></strong> that contains <code>MyClass</code> objects, i.e.</p>
<div class="sourceCode" id="cb884"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb884-1" title="1">TObjArray *myarray;</a></code></pre></div>
<p>To create a <strong><code>TIter</code></strong> object called <code>myiter</code>:</p>
<div class="sourceCode" id="cb885"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb885-1" title="1">TIter myiter(myarray);</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/020001A4.jpg"></p>
<p>As shown in the diagram, this results in several methods being called:</p>
<ul>
<li><p>The <strong><code>TIter</code></strong> constructor is passed a <strong><code>TObjArray</code></strong></p></li>
<li><p><strong><code>TIter</code></strong> asks embedded <strong><code>TCollection</code></strong> to make an iterator</p></li>
<li><p><strong><code>TCollection</code></strong> asks <strong><code>TObjArray</code></strong> to make an iterator</p></li>
<li><p><strong><code>TObjArray</code></strong> returns a <strong><code>TObjArrayIter</code></strong>.</p></li>
</ul>
<p>Now define a pointer for <code>MyClass</code> objects and set it to each member of the <strong><code>TObjArray</code></strong>:</p>
<div class="sourceCode" id="cb886"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb886-1" title="1">MyClass *myobject;</a>
<a class="sourceLine" id="cb886-2" title="2"><span class="cf">while</span> ((myobject = (MyClass *)myiter.Next())) {</a>
<a class="sourceLine" id="cb886-3" title="3">      <span class="co">// process myobject</span></a>
<a class="sourceLine" id="cb886-4" title="4">}</a></code></pre></div>
<p>The heart of this is the <code>myiter.Next()</code> expression which does the following:</p>
<ul>
<li><p>The <code>Next()</code> method of the <strong><code>TIter</code></strong> object <code>myiter</code> is called</p></li>
<li><p>The <strong><code>TIter</code></strong> forwards the call to the <strong><code>TIterator</code></strong> embedded in the <strong><code>TObjArrayIter</code></strong></p></li>
<li><p><strong><code>TIterator</code></strong> forwards the call to the <strong><code>TObjArrayIter</code></strong></p></li>
<li><p><strong><code>TObjArrayIter</code></strong> finds the next <code>MyClass</code> object and returns it</p></li>
<li><p><strong><code>TIter</code></strong> passes the <code>MyClass</code> object back to the caller</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/020001A5.jpg"></p>
<p>Sometimes the <strong><code>TIter</code></strong> object is called next, and then instead of writing: <code>next.Next()</code>which is legal, but looks rather odd, iteration is written as <code>next()</code>. This works because the function <code>operator()</code> is defined for the <strong><code>TIter</code></strong> class to be equivalent to the <code>Next()</code> method.</p>
<h2 id="the-tlist-collection"><span class="header-section-number">16.6</span> The TList Collection</h2>
<p>A <strong><code>TList</code></strong> is a doubly linked list. Before being inserted into the list the object pointer is wrapped in a <strong><code>TObjLink</code></strong> object that contains, besides the object pointer also a previous and next pointer.</p>
<p>Objects are typically added using:</p>
<ul>
<li><p><code>Add()</code></p></li>
<li><p><code>AddFirst(), AddLast()</code></p></li>
<li><p><code>AddBefore(), AddAfter()</code></p></li>
</ul>
<p><strong>Main features of<code>TList</code></strong>: very low cost of adding/removing elements anywhere in the list.</p>
<p><strong>Overhead per element</strong>: 1 <code>TObjLink</code>, i.e.&nbsp;two 4 (or 8) byte pointers + pointer to <code>vtable</code> = 12 (or 24) bytes.</p>
<p>Next figure shows the internal data structure of a <strong><code>TList</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/020001A6.jpg" alt="The internal data structure of a TList"><figcaption>The internal data structure of a TList</figcaption>
</figure>
<h3 id="iterating-over-a-tlist"><span class="header-section-number">16.6.1</span> Iterating Over a TList</h3>
<p>There are four ways to iterate over a <strong><code>TList</code></strong>:</p>
<ul>
<li>Using the <code>ForEach</code> script:</li>
</ul>
<div class="sourceCode" id="cb887"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb887-1" title="1">GetListOfPrimitives()-&gt;ForEach(TObject,Draw)();</a></code></pre></div>
<ul>
<li>Using the <strong><code>TList</code></strong> iterator <strong><code>TListIter</code></strong> (via the wrapper class <strong><code>TIter</code></strong>):</li>
</ul>
<div class="sourceCode" id="cb888"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb888-1" title="1">TIter next(GetListOfTracks());</a>
<a class="sourceLine" id="cb888-2" title="2"><span class="cf">while</span> ((TTrack *obj = (TTrack *)next()))</a>
<a class="sourceLine" id="cb888-3" title="3">   obj-&gt;Draw();</a></code></pre></div>
<ul>
<li>Using the <strong><code>TObjLink</code></strong> list entries (that wrap the <strong><code>TObject</code></strong>*):</li>
</ul>
<div class="sourceCode" id="cb889"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb889-1" title="1">TObjLink *lnk = GetListOfPrimitives()-&gt;FirstLink();</a>
<a class="sourceLine" id="cb889-2" title="2"><span class="cf">while</span> (lnk) {</a>
<a class="sourceLine" id="cb889-3" title="3">   lnk-&gt;GetObject()-&gt;Draw();</a>
<a class="sourceLine" id="cb889-4" title="4">   lnk = lnk-&gt;Next();</a>
<a class="sourceLine" id="cb889-5" title="5">}</a></code></pre></div>
<ul>
<li>Using the <strong><code>TList</code></strong>’s <code>After()</code> and <code>Before()</code> member functions:</li>
</ul>
<div class="sourceCode" id="cb890"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb890-1" title="1">TFree *idcur = <span class="kw">this</span>;</a>
<a class="sourceLine" id="cb890-2" title="2"><span class="cf">while</span> (idcur) {</a>
<a class="sourceLine" id="cb890-3" title="3">   ...</a>
<a class="sourceLine" id="cb890-4" title="4">   idcur = (TFree*)GetListOfFree()-&gt;After(idcur);</a>
<a class="sourceLine" id="cb890-5" title="5">}</a></code></pre></div>
<p>Method 1 uses internally method 2.</p>
<p>Method 2 works for all collection classes. <strong><code>TIter</code></strong> overloads <code>operator()</code>.</p>
<p>Methods 3 and 4 are specific for <strong><code>TList</code></strong>.</p>
<p>Methods 2, 3 and 4 can also easily iterate backwards using either a backward <strong><code>TIter</code></strong> (using argument <code>kIterBackward</code>) or by using <code>LastLink()</code> and <code>lnk&gt;Prev</code>() or by using the <code>Before()</code> method.</p>
<h2 id="the-tobjarray-collection"><span class="header-section-number">16.7</span> The TObjArray Collection</h2>
<p>A <strong><code>TObjArray</code></strong> is a collection which supports traditional array semantics via the overloading of <code>operator[]</code>.
 Objects can be directly accessed via an index. The array expands 
automatically when objects are added. At creation time one specifies the
 default array size (default = 16) and lower bound (default = 0). 
Resizing involves a re-allocation and a copy of the old array to the 
new. This can be costly if done too often. If possible, set initial size
 close to expected final size. Index validity is always checked (if you 
are 100% sure and maximum performance is needed you can use <code>UnCheckedAt()</code> instead of <code>At()</code> or <code>operator[]</code>). If the stored objects are sort able the array can be sorted using <code>Sort()</code>. Once sorted, efficient searching is possible via the <code>BinarySearch()</code> method. The figure shows the internal data structure of a <strong><code>TObjArray</code></strong>:</p>
<figure>
<img src="ROOTUsersGuide_files/020001A7.jpg" alt="The internal data structure of a TObjArray"><figcaption>The internal data structure of a TObjArray</figcaption>
</figure>
<p>Iterating can be done using a <strong><code>TIter</code></strong> iterator or via a simple for loop:</p>
<div class="sourceCode" id="cb891"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb891-1" title="1"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= fArr.GetLast(); i++)</a>
<a class="sourceLine" id="cb891-2" title="2"><span class="cf">if</span> ((track = (TTrack*)fArr[i]))     <span class="co">// or fArr.At(i)</span></a>
<a class="sourceLine" id="cb891-3" title="3">   track-&gt;Draw();</a></code></pre></div>
<p>Main features of <strong><code>TObjArray</code></strong> are simple, well-known array semantics. <strong>Overhead per element</strong>: none, except possible over sizing of <code>fCont</code>.</p>
<h2 id="tclonesarray-an-array-of-identical-objects"><span class="header-section-number">16.8</span> TClonesArray An Array of Identical Objects</h2>
<p>A <strong><code>TClonesArray</code></strong> is an array of identical
 (clone) objects. The memory for the objects stored in the array is 
allocated only once in the lifetime of the clones array. All objects 
must be of the same class. For the rest this class has the same 
properties as a <strong><code>TObjArray</code></strong>.</p>
<figure>
<img src="ROOTUsersGuide_files/020001A8.jpg" alt="The internal data structure of a TClonesArray"><figcaption>The internal data structure of a TClonesArray</figcaption>
</figure>
<p>The figure above shows the internal data structure of a <strong><code>TClonesArray</code></strong>.
 The class is specially designed for repetitive data analysis tasks, 
where in a loop many times the same objects, are created and deleted. 
The only supported way to add objects to a <strong><code>TClonesArray</code></strong> is via the <code>new</code> with placement method. The different <code>Add()</code> methods of <strong><code>TObjArray</code></strong> and its base classes are not supported.</p>
<h3 id="the-idea-behind-tclonesarray"><span class="header-section-number">16.8.1</span> The Idea Behind TClonesArray</h3>
<p>To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):</p>
<div class="sourceCode" id="cb892"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb892-1" title="1">TObjArray a(<span class="dv">10000</span>);</a>
<a class="sourceLine" id="cb892-2" title="2"><span class="cf">while</span> (TEvent *ev = (TEvent *)next()) {        <span class="co">// O(100000)</span></a>
<a class="sourceLine" id="cb892-3" title="3">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ev-&gt;Ntracks; i++) {     <span class="co">// O(10000)</span></a>
<a class="sourceLine" id="cb892-4" title="4">      a[i] = <span class="kw">new</span> TTrack(x,y,z,...);</a>
<a class="sourceLine" id="cb892-5" title="5">      ...</a>
<a class="sourceLine" id="cb892-6" title="6">   }</a>
<a class="sourceLine" id="cb892-7" title="7">   ...</a>
<a class="sourceLine" id="cb892-8" title="8">   a.Delete();</a>
<a class="sourceLine" id="cb892-9" title="9">}</a></code></pre></div>
<p>You better use a <strong><code>TClonesArray</code></strong> which reduces the number of new/delete calls to only O(10000):</p>
<div class="sourceCode" id="cb893"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb893-1" title="1">TClonesArray a(<span class="st">"TTrack"</span>, <span class="dv">10000</span>);</a>
<a class="sourceLine" id="cb893-2" title="2"><span class="cf">while</span> (TEvent *ev = (TEvent *)next()) {      <span class="co">// O(100000)</span></a>
<a class="sourceLine" id="cb893-3" title="3">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ev-&gt;Ntracks; i++) {   <span class="co">// O(10000)</span></a>
<a class="sourceLine" id="cb893-4" title="4">      TTrack *track = (Track*)a.ConstructedAt(i);</a>
<a class="sourceLine" id="cb893-5" title="5">      track-&gt;Set(x,y,z,...);</a>
<a class="sourceLine" id="cb893-6" title="6">      ...</a>
<a class="sourceLine" id="cb893-7" title="7">   }</a>
<a class="sourceLine" id="cb893-8" title="8">   ...</a>
<a class="sourceLine" id="cb893-9" title="9">   a.Clear(); <span class="co">// Or Clear("C") if the track objects must be returned (via Track::Clear) to a default state.</span></a>
<a class="sourceLine" id="cb893-10" title="10">}</a></code></pre></div>
<p>Considering that a pair of new/delete calls on average cost about 70 
ms, O(109) new/deletes will save about 19 hours. For the other 
collections, see the class reference guide on the web and the test 
program <code>$ROOTSYS/test/tcollex.cxx.</code></p>
<h2 id="template-containers-and-stl"><span class="header-section-number">16.9</span> Template Containers and STL</h2>
<p>Some people dislike polymorphic containers because they are not truly
 “type safe”. In the end, the compiler leaves it the user to ensure that
 the types are correct. This only leaves the other alternative: creating
 a new class each time a new (container organization) / (contained 
object) combination is needed. To say the least this could be very 
tedious. Most people faced with this choice would, for each type of 
container:</p>
<p>Define the class leaving a dummy name for the contained object type. 
When a particular container was needed, copy the code and then do a 
global search and replace for the contained class. C++ has a built in 
template scheme that effectively does just this. For example:</p>
<div class="sourceCode" id="cb894"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb894-1" title="1"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb894-2" title="2"><span class="kw">class</span> ArrayContainer {</a>
<a class="sourceLine" id="cb894-3" title="3">   <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb894-4" title="4">   T *member[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb894-5" title="5">   ...</a>
<a class="sourceLine" id="cb894-6" title="6">};</a></code></pre></div>
<p>This is an array container with a 10-element array of pointers to T, 
it could hold up to 10 T objects. This array is flawed because it is 
static and hard-coded, it should be dynamic. However, the important 
point is that the template statement indicates that T is a template, or 
parameterized class. If we need an <code>ArrayContainer</code> for Track objects, it can be created by:</p>
<div class="sourceCode" id="cb895"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb895-1" title="1">ArrayContainer&lt;Track&gt; MyTrackArrayContainer;</a></code></pre></div>
<p>C++ takes the parameter list and substitutes Track for T throughout the definition of the class <code>ArrayContainer</code>, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.</p>
<p>This produces code that is type safe, but does have different drawbacks:</p>
<ul>
<li><p>Templates make code harder to read.</p></li>
<li><p>At the time of writing this documentation, some compilers can be very slow when dealing with templates.</p></li>
<li><p>It does not solve the problem when a container has to hold a heterogeneous set of objects.</p></li>
<li><p>The system can end up generating a great deal of code; each 
container/object combination has its own code, a phenomenon that is 
sometimes referred to as <em>code bloat</em>.</p></li>
<li><p>The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers.</p></li>
</ul>
<h1 id="physics-vectors"><span class="header-section-number">17</span> Physics Vectors</h1>
<p>The physics vector classes describe vectors in three and four 
dimensions and their rotation algorithms. The classes were ported to 
root from CLHEP see:</p>
<p><a href="http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html" class="uri">http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html</a></p>
<h2 id="the-physics-vector-classes"><span class="header-section-number">17.1</span> The Physics Vector Classes</h2>
<p>In order to use the physics vector classes you will have to load the Physics library:</p>
<div class="sourceCode" id="cb896"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb896-1" title="1">gSystem.Load(<span class="st">"libPhysics.so"</span>);</a></code></pre></div>
<p>There are four classes in this package. They are:</p>
<p><strong><code>TVector3</code></strong> is a general three-vector. A <strong><code>TVector3</code></strong>
 may be expressed in Cartesian, polar, or cylindrical coordinates. 
Methods include dot and cross products, unit vectors and magnitudes, 
angles between vectors, and rotations and boosts. There are also 
functions of particular use to HEP, like pseudo-rapidity, projections, 
and transverse part of a <strong><code>TVector3</code></strong>, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles<code>.</code></p>
<p><strong><code>TLorentzVector</code></strong> is a general four-vector class, which can be used either for the description of position and time (<code>x</code>, <code>y</code>, <code>z</code>, <code>t</code>) or momentum and energy (<code>px</code>, <code>py</code>, <code>pz</code>, <code>E</code>). <strong><code>TRotation</code></strong> is a class describing a rotation of a <strong><code>TVector3</code></strong> object. <strong><code>TLorentzRotation</code></strong> is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a <strong><code>TVector2</code></strong> is a basic implementation of a vector in two dimensions and is not part of the CLHEP translation.</p>
<h2 id="tvector3"><span class="header-section-number">17.2</span> TVector3</h2>
<p><img src="ROOTUsersGuide_files/030001A9.png"></p>
<p><strong><code>TVector3</code></strong> is a general three-vector class, which can be used for description of different vectors in 3D. Components of three vectors:</p>
<ul>
<li><p><span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span> = basic components</p></li>
<li><p><span class="math inline">\(\theta\)</span> = azimuth angle</p></li>
<li><p><span class="math inline">\(\phi\)</span> = polar angle</p></li>
<li><p>magnitude = <span class="math inline">\(mag\)</span> = <span class="math inline">\(\sqrt{x^2 + y^2 + z^2}\)</span></p></li>
<li><p>transverse component = <span class="math inline">\(perp\)</span> = <span class="math inline">\(\sqrt{x^2 + y^2}\)</span></p></li>
</ul>
<p>Using the <strong><code>TVector3</code></strong> class, you should 
remember that it contains only common features of three vectors and 
lacks methods specific for some particular vector values. For example, 
it has no translated function because translation has no meaning for 
vectors.</p>
<h3 id="declaration-access-to-the-components"><span class="header-section-number">17.2.1</span> Declaration / Access to the Components</h3>
<p><strong><code>TVector3</code></strong> has been implemented as a vector of three <code>Double_t</code>
 variables, representing the Cartesian coordinates. By default the 
values are initialized to zero, however you can change them in the 
constructor:</p>
<div class="sourceCode" id="cb897"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb897-1" title="1">TVector3 v1;        <span class="co">// v1 = (0,0,0)</span></a>
<a class="sourceLine" id="cb897-2" title="2">TVector3 v2(<span class="dv">1</span>);     <span class="co">// v2 = (1,0,0)</span></a>
<a class="sourceLine" id="cb897-3" title="3">TVector3 v3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>); <span class="co">// v3 = (1,2,3)</span></a>
<a class="sourceLine" id="cb897-4" title="4">TVector3 v4(v2);    <span class="co">// v4 = v2</span></a></code></pre></div>
<p>It is also possible (but not recommended) to initialize a <strong><code>TVector3</code></strong> with a <code>Double_t</code> or <code>Float_t C</code> array. You can get the components by name or by index:</p>
<div class="sourceCode" id="cb898"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb898-1" title="1">xx = v1.X();    <span class="kw">or</span>    xx = v1(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb898-2" title="2">yy = v1.Y();          yy = v1(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb898-3" title="3">zz = v1.Z();          zz = v1(<span class="dv">2</span>);</a></code></pre></div>
<p>The methods <code>SetX()</code>, <code>SetY()</code>, <code>SetZ()</code> and <code>SetXYZ()</code> allow you to set the components:</p>
<div class="sourceCode" id="cb899"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb899-1" title="1">v1.SetX(<span class="fl">1.</span>); v1.SetY(<span class="fl">2.</span>); v1.SetZ(<span class="fl">3.</span>);</a>
<a class="sourceLine" id="cb899-2" title="2">v1.SetXYZ(<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>);</a></code></pre></div>
<h3 id="other-coordinates"><span class="header-section-number">17.2.2</span> Other Coordinates</h3>
<p>To get information on the <strong><code>TVector3</code></strong> in spherical (<code>rho</code>, <code>phi</code>, <code>theta</code>) or cylindrical (<code>z</code>, <code>r</code>, <code>theta</code>) coordinates, the following methods can be used.</p>
<div class="sourceCode" id="cb900"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb900-1" title="1"><span class="dt">Double_t</span> m  = v.Mag();</a>
<a class="sourceLine" id="cb900-2" title="2"><span class="co">// get magnitude (=rho=Sqrt(x*x+y*y+z*z)))</span></a>
<a class="sourceLine" id="cb900-3" title="3"><span class="dt">Double_t</span> m2 = v.Mag2();    <span class="co">// get magnitude squared</span></a>
<a class="sourceLine" id="cb900-4" title="4"><span class="dt">Double_t</span> t  = v.Theta();   <span class="co">// get polar angle</span></a>
<a class="sourceLine" id="cb900-5" title="5"><span class="dt">Double_t</span> ct = v.CosTheta();<span class="co">// get cos of theta</span></a>
<a class="sourceLine" id="cb900-6" title="6"><span class="dt">Double_t</span> p  = v.Phi();     <span class="co">// get azimuth angle</span></a>
<a class="sourceLine" id="cb900-7" title="7"><span class="dt">Double_t</span> pp = v.Perp();    <span class="co">// get transverse component</span></a>
<a class="sourceLine" id="cb900-8" title="8"><span class="dt">Double_t</span> pp2= v.Perp2();   <span class="co">// get transverse squared</span></a></code></pre></div>
<p>It is also possible to get the transverse component with respect to another vector:</p>
<div class="sourceCode" id="cb901"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb901-1" title="1"><span class="dt">Double_t</span> ppv1  = v.Perp(v1);</a>
<a class="sourceLine" id="cb901-2" title="2"><span class="dt">Double_t</span> pp2v1 = v.Perp2(v1);</a></code></pre></div>
<p>The pseudo-rapidity <code>(eta = -ln (tan (theta/2)))</code> can be obtained by <code>Eta()</code> or <code>PseudoRapidity()</code>:</p>
<div class="sourceCode" id="cb902"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb902-1" title="1"><span class="dt">Double_t</span> eta = v.PseudoRapidity();</a></code></pre></div>
<p>These setters change one of the non-Cartesian coordinates:</p>
<div class="sourceCode" id="cb903"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb903-1" title="1">v.SetTheta(<span class="fl">.5</span>);  <span class="co">// keeping rho and phi</span></a>
<a class="sourceLine" id="cb903-2" title="2">v.SetPhi(<span class="fl">.8</span>);    <span class="co">// keeping rho and theta</span></a>
<a class="sourceLine" id="cb903-3" title="3">v.SetMag(<span class="fl">10.</span>);   <span class="co">// keeping theta and phi</span></a>
<a class="sourceLine" id="cb903-4" title="4">v.SetPerp(<span class="fl">3.</span>);   <span class="co">// keeping z and phi</span></a></code></pre></div>
<h3 id="arithmetic-comparison"><span class="header-section-number">17.2.3</span> Arithmetic / Comparison</h3>
<p>The <strong><code>TVector3</code></strong> class has operators to add, subtract, scale and compare vectors:</p>
<div class="sourceCode" id="cb904"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb904-1" title="1">v3  = -v1;</a>
<a class="sourceLine" id="cb904-2" title="2">v1  = v2+v3;</a>
<a class="sourceLine" id="cb904-3" title="3">v1 += v3;</a>
<a class="sourceLine" id="cb904-4" title="4">v1  = v1 - v3;</a>
<a class="sourceLine" id="cb904-5" title="5">v1 -= v3;</a>
<a class="sourceLine" id="cb904-6" title="6">v1 *= <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb904-7" title="7">v1  = <span class="dv">5</span>*v2;</a>
<a class="sourceLine" id="cb904-8" title="8"><span class="cf">if</span>(v1 == v2) {...}</a>
<a class="sourceLine" id="cb904-9" title="9"><span class="cf">if</span>(v1 != v2) {...}</a></code></pre></div>
<h3 id="related-vectors"><span class="header-section-number">17.2.4</span> Related Vectors</h3>
<div class="sourceCode" id="cb905"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb905-1" title="1">v2 = v1.Unit();        <span class="co">// get unit vector parallel to v1</span></a>
<a class="sourceLine" id="cb905-2" title="2">v2 = v1.Orthogonal();  <span class="co">// get vector orthogonal to v1</span></a></code></pre></div>
<h3 id="scalar-and-vector-products"><span class="header-section-number">17.2.5</span> Scalar and Vector Products</h3>
<div class="sourceCode" id="cb906"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb906-1" title="1">s = v1.Dot(v2);   <span class="co">// scalar product</span></a>
<a class="sourceLine" id="cb906-2" title="2">s = v1 * v2;      <span class="co">// scalar product</span></a>
<a class="sourceLine" id="cb906-3" title="3">v = v1.Cross(v2); <span class="co">// vector product</span></a></code></pre></div>
<h3 id="angle-between-two-vectors"><span class="header-section-number">17.2.6</span> Angle between Two Vectors</h3>
<div class="sourceCode" id="cb907"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb907-1" title="1"><span class="dt">Double_t</span> a = v1.Angle(v2);</a></code></pre></div>
<h3 id="rotation-around-axes"><span class="header-section-number">17.2.7</span> Rotation around Axes</h3>
<div class="sourceCode" id="cb908"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb908-1" title="1">v.RotateX(<span class="fl">.5</span>);</a>
<a class="sourceLine" id="cb908-2" title="2">v.RotateY(TMath::Pi());</a>
<a class="sourceLine" id="cb908-3" title="3">v.RotateZ(angle);</a></code></pre></div>
<h3 id="rotation-around-a-vector"><span class="header-section-number">17.2.8</span> Rotation around a Vector</h3>
<div class="sourceCode" id="cb909"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb909-1" title="1">v1.Rotate(TMath::Pi()/<span class="dv">4</span>, v2); <span class="co">// rotation around v2</span></a></code></pre></div>
<h3 id="rotation-by-trotation-class"><span class="header-section-number">17.2.9</span> Rotation by TRotation Class</h3>
<p><strong><code>TVector3</code></strong> objects can be rotated by <strong><code>TRotation</code></strong> objects using the <code>Transform()</code> method, the operator <code>*=</code>, or the operator <code>*</code> of the <strong><code>TRotation</code></strong> class. See the later section on <code>TRotation.</code></p>
<div class="sourceCode" id="cb910"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb910-1" title="1">TRotation m;</a>
<a class="sourceLine" id="cb910-2" title="2">...</a>
<a class="sourceLine" id="cb910-3" title="3">v1.Transform(m);</a>
<a class="sourceLine" id="cb910-4" title="4">v1 = m*v1;</a>
<a class="sourceLine" id="cb910-5" title="5">v1 *= m;                          <span class="co">// v1 = m*v1</span></a></code></pre></div>
<h3 id="transformation-from-rotated-frame"><span class="header-section-number">17.2.10</span> Transformation from Rotated Frame</h3>
<p>This code transforms v1 from the rotated frame (z’ parallel to direction, x’ in the theta plane and y’ in the <code>xy</code> plane as well as perpendicular to the theta plane) to the (x, y, z) frame.</p>
<div class="sourceCode" id="cb911"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb911-1" title="1">TVector3 direction = v.Unit()</a>
<a class="sourceLine" id="cb911-2" title="2">v1.RotateUz(direction);      <span class="co">// direction must be TVector3 of unit length</span></a></code></pre></div>
<h2 id="trotation"><span class="header-section-number">17.3</span> TRotation</h2>
<p>The <strong><code>TRotation</code></strong> class describes a rotation of <strong><code>TVector3</code></strong> object. It is a 3 * 3 matrix of <code>Double_t</code>:</p>
<p><span class="math display">\[\left|
\begin{array}{ccc}
         xx &amp;  xy  &amp; xz \\
         yx &amp;  yy  &amp; yz \\
         zx &amp;  zy  &amp; zz
         \end{array}
\right|\]</span></p>
<p>It describes a so-called active rotation, i.e.&nbsp;a rotation of 
objects inside a static system of coordinates. In case you want to 
rotate the frame and want to know the coordinates of objects in the 
rotated system, you should apply the inverse rotation to the objects. If
 you want to transform coordinates from the rotated frame to the 
original frame you have to apply the direct transformation. A rotation 
around a specified axis means counterclockwise rotation around the 
positive direction of the axis.</p>
<h3 id="declaration-access-comparisons"><span class="header-section-number">17.3.1</span> Declaration, Access, Comparisons</h3>
<div class="sourceCode" id="cb912"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb912-1" title="1">   TRotation r;        <span class="co">// r initialized as identity</span></a>
<a class="sourceLine" id="cb912-2" title="2">   TRotation m(r);     <span class="co">// m = r</span></a></code></pre></div>
<p>There is no direct way to set the matrix elements - to ensure that a <strong><code>TRotation</code></strong> always describes a real rotation. But you can get the values by with the methods <code>XX()..ZZ()</code> or the <code>(,)</code> operator:</p>
<div class="sourceCode" id="cb913"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb913-1" title="1">   <span class="dt">Double_t</span> xx = r.XX();           <span class="co">// the same as xx=r(0,0)</span></a>
<a class="sourceLine" id="cb913-2" title="2">   xx = r(<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb913-3" title="3">   <span class="cf">if</span> (r==m) {...}                 <span class="co">// test for equality</span></a>
<a class="sourceLine" id="cb913-4" title="4">   <span class="cf">if</span> (r!=m) {..}                  <span class="co">// test for inequality</span></a>
<a class="sourceLine" id="cb913-5" title="5">   <span class="cf">if</span> (r.IsIdentity()) {...}       <span class="co">// test for identity</span></a></code></pre></div>
<h3 id="rotation-around-axes-1"><span class="header-section-number">17.3.2</span> Rotation around Axes</h3>
<p>The following matrices describe counter-clockwise rotations around the coordinate axes and are implemented in: <code>RotateX()</code>,<code>RotateY()</code> and <code>RotateZ()</code>:</p>
<p><span class="math display">\[
Rx(a) = \left|
\begin{array}{ccc}
         1 &amp;  0       &amp; 0 \\
         0 &amp;  cos(a)  &amp; -sin(a) \\
         0 &amp;  sin(a)  &amp; cos(a)
         \end{array}
\right|
Ry(a) = \left|
\begin{array}{ccc}
         cos(a)  &amp;  0  &amp; sin(a) \\
              0  &amp;  1  &amp; 0 \\
         -sin(a) &amp;  0  &amp; cos(a)
         \end{array}
\right|
Rz(a) = \left|
\begin{array}{ccc}
         cos(a)  &amp;  -sin(a)  &amp; 0 \\
         sin(a)  &amp;   cos(a)  &amp; 0 \\
              0  &amp;  0        &amp; 1
         \end{array}
\right|
\]</span></p>
<div class="sourceCode" id="cb914"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb914-1" title="1">   r.RotateX(TMath::Pi()); <span class="co">// rotation around the x-axis</span></a></code></pre></div>
<h3 id="rotation-around-arbitrary-axis"><span class="header-section-number">17.3.3</span> Rotation around Arbitrary Axis</h3>
<p>The <code>Rotate()</code> method allows you to rotate around an arbitrary vector (not necessary a unit one) and returns the result.</p>
<div class="sourceCode" id="cb915"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb915-1" title="1">   r.Rotate(TMath::Pi()/<span class="dv">3</span>,TVector3(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>));</a></code></pre></div>
<p>It is possible to find a unit vector and an angle, which describe the same rotation as the current one:</p>
<div class="sourceCode" id="cb916"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb916-1" title="1">   <span class="dt">Double_t</span> angle;</a>
<a class="sourceLine" id="cb916-2" title="2">   TVector3 axis;</a>
<a class="sourceLine" id="cb916-3" title="3">   r.GetAngleAxis(angle,axis);</a></code></pre></div>
<h3 id="rotation-of-local-axes"><span class="header-section-number">17.3.4</span> Rotation of Local Axes</h3>
<p>The <code>RotateAxes()method</code> adds a rotation of local axes to the current rotation and returns the result:</p>
<div class="sourceCode" id="cb917"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb917-1" title="1">   TVector3 newX(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb917-2" title="2">   TVector3 newY(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb917-3" title="3">   TVector3 newZ(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb917-4" title="4">   a.RotateAxes(newX,newX,newZ);</a></code></pre></div>
<p>Methods <code>ThetaX()</code>, <code>ThetaY()</code>, <code>ThetaZ()</code>, <code>PhiX()</code>, <code>PhiY()</code>, <code>PhiZ()</code> return azimuth and polar angles of the rotated axes:</p>
<div class="sourceCode" id="cb918"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb918-1" title="1">   <span class="dt">Double_t</span> tx,ty,tz,px,py,pz;</a>
<a class="sourceLine" id="cb918-2" title="2">   tx= a.ThetaX();</a>
<a class="sourceLine" id="cb918-3" title="3">...</a>
<a class="sourceLine" id="cb918-4" title="4">   pz= a.PhiZ();</a></code></pre></div>
<h3 id="inverse-rotation"><span class="header-section-number">17.3.5</span> Inverse Rotation</h3>
<div class="sourceCode" id="cb919"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb919-1" title="1">   TRotation a,b;</a>
<a class="sourceLine" id="cb919-2" title="2">...</a>
<a class="sourceLine" id="cb919-3" title="3">   b = a.Inverse();<span class="co">// b is inverse of a, a is unchanged</span></a>
<a class="sourceLine" id="cb919-4" title="4">   b = a.Invert();<span class="co">// invert a and set b = a</span></a></code></pre></div>
<h3 id="compound-rotations"><span class="header-section-number">17.3.6</span> Compound Rotations</h3>
<p>The <code>operator *</code> has been implemented in a way that 
follows the mathematical notation of a product of the two matrices which
 describe the two consecutive rotations. Therefore, the second rotation 
should be placed first:</p>
<div class="sourceCode" id="cb920"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb920-1" title="1">   r = r2 * r1;</a></code></pre></div>
<h3 id="rotation-of-tvector3"><span class="header-section-number">17.3.7</span> Rotation of TVector3</h3>
<p>The <strong><code>TRotation</code></strong> class provides an <code>operator *</code> which allows expressing a rotation of a <strong><code>TVector3</code></strong> analog to the mathematical notation:</p>
<p><span class="math display">\[
\left|
\begin{array}{c}
         x' \\
         y' \\
         z'
         \end{array}
\right|
=
\left|
\begin{array}{ccc}
         xx  &amp;  xy  &amp; xz \\
         yx  &amp;  yy  &amp; yz \\
         zx  &amp;  zy  &amp; zz
         \end{array}
\right|
\times
\left|
\begin{array}{c}
         x \\
         y \\
         z
         \end{array}
\right|
\]</span></p>
<div class="sourceCode" id="cb921"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb921-1" title="1">   TRotation r;</a>
<a class="sourceLine" id="cb921-2" title="2">   TVector3 v(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb921-3" title="3">   v = r * v;</a></code></pre></div>
<p>You can also use the <code>Transform()</code> method or the <code>operator *=</code> of the <strong><code>TVector3</code></strong> class:</p>
<div class="sourceCode" id="cb922"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb922-1" title="1">   TVector3 v;</a>
<a class="sourceLine" id="cb922-2" title="2">   TRotation r;</a>
<a class="sourceLine" id="cb922-3" title="3">   v.Transform(r);</a></code></pre></div>
<h2 id="tlorentzvector"><span class="header-section-number">17.4</span> TLorentzVector</h2>
<p><strong><code>TLorentzVector</code></strong> is a general four-vector class, which can be used either for the description of position and time (<code>x</code>, <code>y</code>, <code>z</code>, <code>t</code>) or momentum and energy (<code>px</code>, <code>py</code>, <code>pz</code>, <code>E</code>).</p>
<h3 id="declaration"><span class="header-section-number">17.4.1</span> Declaration</h3>
<p><strong><code>TLorentzVector</code></strong> has been implemented as a set a <strong><code>TVector3</code></strong> and a <code>Double_t</code> variable. By default, all components are initialized by zero.</p>
<div class="sourceCode" id="cb923"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb923-1" title="1">TLorentzVector v1;  <span class="co">// initialized by (0.,0.,0.,0.)</span></a>
<a class="sourceLine" id="cb923-2" title="2">TLorentzVector v2(<span class="fl">1.</span>,<span class="fl">1.</span>,<span class="fl">1.</span>,<span class="fl">1.</span>);</a>
<a class="sourceLine" id="cb923-3" title="3">TLorentzVector v3(v1);</a>
<a class="sourceLine" id="cb923-4" title="4">TLorentzVector v4(TVector3(<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>),<span class="fl">4.</span>);</a></code></pre></div>
<p>For backward compatibility there are two constructors from a <code>Double_t</code> and <code>Float_t</code> array.</p>
<h3 id="access-to-components"><span class="header-section-number">17.4.2</span> Access to Components</h3>
<p>There are two sets of access functions to the components of a <strong><code>TLorentzVector</code></strong>: <code>X()</code>, <code>Y()</code>, <code>Z()</code>, <code>T()</code> and <code>Px()</code>, <code>Py()</code>, <code>Pz()</code> and <code>E()</code>. Both sets return the same values but the first set is more relevant for use where <strong><code>TLorentzVector</code></strong> describes a combination of position and time and the second set is more relevant where <strong><code>TLorentzVector</code></strong> describes momentum and energy:</p>
<div class="sourceCode" id="cb924"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb924-1" title="1">   <span class="dt">Double_t</span> xx =v.X();</a>
<a class="sourceLine" id="cb924-2" title="2">...</a>
<a class="sourceLine" id="cb924-3" title="3">   <span class="dt">Double_t</span> tt = v.T();</a>
<a class="sourceLine" id="cb924-4" title="4">   <span class="dt">Double_t</span> px = v.Px();</a>
<a class="sourceLine" id="cb924-5" title="5">...</a>
<a class="sourceLine" id="cb924-6" title="6">   <span class="dt">Double_t</span> ee = v.E();</a></code></pre></div>
<p>The components of <strong><code>TLorentzVector</code></strong> can also accessed by index:</p>
<div class="sourceCode" id="cb925"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb925-1" title="1">   xx = v(<span class="dv">0</span>);orxx = v[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb925-2" title="2">   yy = v(<span class="dv">1</span>);yy = v[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb925-3" title="3">   zz = v(<span class="dv">2</span>);zz = v[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb925-4" title="4">   tt = v(<span class="dv">3</span>);tt = v[<span class="dv">3</span>];</a></code></pre></div>
<p>You can use the <code>Vect()</code> method to get the vector component of <strong><code>TLorentzVector</code></strong>:</p>
<div class="sourceCode" id="cb926"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb926-1" title="1">   TVector3 p = v.Vect();</a></code></pre></div>
<p>For setting components there are two methods: <code>SetX(),.., SetPx(),..:</code></p>
<div class="sourceCode" id="cb927"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb927-1" title="1">   v.SetX(<span class="fl">1.</span>); orv.SetPx(<span class="fl">1.</span>);</a>
<a class="sourceLine" id="cb927-2" title="2">......</a>
<a class="sourceLine" id="cb927-3" title="3">   v.SetT(<span class="fl">1.</span>);v.SetE(<span class="fl">1.</span>);</a></code></pre></div>
<p>To set more the one component by one call you can use the <code>SetVect()</code> function for the <strong><code>TVector3</code></strong> part or <code>SetXYZT()</code>, <code>SetPxPyPzE()</code>. For convenience there is also a <code>SetXYZM()</code>:</p>
<div class="sourceCode" id="cb928"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb928-1" title="1">   v.SetVect(TVector3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>));</a>
<a class="sourceLine" id="cb928-2" title="2">   v.SetXYZT(x,y,z,t);</a>
<a class="sourceLine" id="cb928-3" title="3">   v.SetPxPyPzE(px,py,pz,e);</a>
<a class="sourceLine" id="cb928-4" title="4">   v.SetXYZM(x,y,z,m);   <span class="co">// v = (x,y,z,e = Sqrt(x*x+y*y+z*z+m*m))</span></a></code></pre></div>
<h3 id="vector-components-in-non-cartesian-coordinates"><span class="header-section-number">17.4.3</span> Vector Components in Non-Cartesian Coordinates</h3>
<p>There are a couple of methods to get and set the <strong><code>TVector3</code></strong> part of the parameters in <code>spherical</code> coordinate systems:</p>
<div class="sourceCode" id="cb929"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb929-1" title="1">   <span class="dt">Double_t</span> m, theta, cost, phi, pp, pp2, ppv2, pp2v2;</a>
<a class="sourceLine" id="cb929-2" title="2">   m = v.Rho();</a>
<a class="sourceLine" id="cb929-3" title="3">   t = v.Theta();</a>
<a class="sourceLine" id="cb929-4" title="4">   cost = v.CosTheta();</a>
<a class="sourceLine" id="cb929-5" title="5">   phi  = v.Phi();</a>
<a class="sourceLine" id="cb929-6" title="6">   v.SetRho(<span class="fl">10.</span>);</a>
<a class="sourceLine" id="cb929-7" title="7">   v.SetTheta(TMath::Pi()*<span class="fl">.3</span>);</a>
<a class="sourceLine" id="cb929-8" title="8">   v.SetPhi(TMath::Pi());</a></code></pre></div>
<p>or get information about the r-coordinate in cylindrical systems:</p>
<div class="sourceCode" id="cb930"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb930-1" title="1">   <span class="dt">Double_t</span> pp, pp2, ppv2, pp2v2;</a>
<a class="sourceLine" id="cb930-2" title="2">   pp   = v.Perp();     <span class="co">// get transverse component</span></a>
<a class="sourceLine" id="cb930-3" title="3">   pp2  = v.Perp2();    <span class="co">// get transverse component squared</span></a>
<a class="sourceLine" id="cb930-4" title="4">   ppv2 = v.Perp(v1);   <span class="co">// get transverse component with respect</span></a>
<a class="sourceLine" id="cb930-5" title="5">                        <span class="co">// to another vector</span></a>
<a class="sourceLine" id="cb930-6" title="6">   pp2v2 = v.Perp(v1);</a></code></pre></div>
<p>there are two more set functions <code>SetPtEtaPhiE(pt,eta,phi,e)</code> and <code>SetPtEtaPhiM(pt,eta,phi,m)</code> for convenience.</p>
<h3 id="arithmetic-and-comparison-operators"><span class="header-section-number">17.4.4</span> Arithmetic and Comparison Operators</h3>
<p>The <strong><code>TLorentzVector</code></strong> class provides operators to add subtract or compare four-vectors:</p>
<div class="sourceCode" id="cb931"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb931-1" title="1">   v3 = -v1;</a>
<a class="sourceLine" id="cb931-2" title="2">   v1 = v2+v3;</a>
<a class="sourceLine" id="cb931-3" title="3">   v1+= v3;</a>
<a class="sourceLine" id="cb931-4" title="4">   v1 = v2 + v3;</a>
<a class="sourceLine" id="cb931-5" title="5">   v1-= v3;</a>
<a class="sourceLine" id="cb931-6" title="6">   <span class="cf">if</span> (v1 == v2) {...}</a>
<a class="sourceLine" id="cb931-7" title="7">   <span class="cf">if</span> (v1 != v3) {...}</a></code></pre></div>
<h3 id="magnitudeinvariant-mass-beta-gamma-scalar-product"><span class="header-section-number">17.4.5</span> Magnitude/Invariant mass, beta, gamma, scalar product</h3>
<p>The scalar product of two four-vectors is calculated with the <code>(-,-,-,+)</code>metric:</p>
<p><strong><code>s = v1*v2</code></strong> <code>= t1*t2-x1*x2-y1*y2-z1*z2</code></p>
<p>The magnitude squared <code>mag2</code> of a four-vector is therefore:</p>
<p><strong><code>mag2 = v*v</code></strong> <code>= t*t-x*x-y*y-z*z</code></p>
<p>If <code>mag2</code> is negative: <strong><code>mag = -Sqrt(-mag*mag)</code></strong>. The methods are:</p>
<div class="sourceCode" id="cb932"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb932-1" title="1">   <span class="dt">Double_t</span> s, s2;</a>
<a class="sourceLine" id="cb932-2" title="2">   s  = v1.Dot(v2);<span class="co">// scalar product</span></a>
<a class="sourceLine" id="cb932-3" title="3">   s  = v1*v2;<span class="co">// scalar product</span></a>
<a class="sourceLine" id="cb932-4" title="4">   s2 = v.Mag2();ors2 = v.M2();</a>
<a class="sourceLine" id="cb932-5" title="5">   s  = v.Mag();s  = v.M();</a></code></pre></div>
<p>Since in case of momentum and energy the magnitude has the meaning of invariant mass <strong><code>TLorentzVector</code></strong> provides the more meaningful aliases <code>M2()</code> and <code>M()</code>. The methods <code>Beta()</code> and <code>Gamma()</code> returns <code>beta</code> and <code>gamma = 1/Sqrt(1-beta*beta)</code>.</p>
<h3 id="lorentz-boost"><span class="header-section-number">17.4.6</span> Lorentz Boost</h3>
<p>A boost in a general direction can be parameterized with three 
parameters which can be taken as the components of a three vector <code>b=(bx,by,bz)</code>. With <code>x=(x,y,z)</code> and <code>gamma=1/Sqrt(1-beta*beta)</code> (beta being the module of vector b)<code>,</code> an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:</p>
<p><code>x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b</code></p>
<p><code>t = gamma(t'+ b*x')</code></p>
<p>The <code>Boost()</code> method performs a boost transformation from the rod frame to the original frame. <code>BoostVector()</code> returns a <strong><code>TVector3</code></strong> of the spatial components divided by the time component:</p>
<div class="sourceCode" id="cb933"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb933-1" title="1">   TVector3 b;</a>
<a class="sourceLine" id="cb933-2" title="2">   v.Boost(bx,by,bz);</a>
<a class="sourceLine" id="cb933-3" title="3">   v.Boost(b);</a>
<a class="sourceLine" id="cb933-4" title="4">   b = v.BoostVector();<span class="co">// b=(x/t,y/t,z/t)</span></a></code></pre></div>
<h3 id="rotations"><span class="header-section-number">17.4.7</span> Rotations</h3>
<p>There are four sets of functions to rotate the <strong><code>TVector3</code></strong> component of a <strong><code>TLorentzVector</code></strong>:</p>
<p>Around Axes:</p>
<div class="sourceCode" id="cb934"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb934-1" title="1">   v.RotateX(TMath::Pi()/<span class="fl">2.</span>);</a>
<a class="sourceLine" id="cb934-2" title="2">   v.RotateY(<span class="fl">.5</span>);</a>
<a class="sourceLine" id="cb934-3" title="3">   v.RotateZ(<span class="fl">.99</span>);</a></code></pre></div>
<p>Around an arbitrary axis:</p>
<div class="sourceCode" id="cb935"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb935-1" title="1">   v.Rotate(TMath::Pi()/<span class="fl">4.</span>, v1); <span class="co">// rotation around v1</span></a></code></pre></div>
<p>Transformation from rotated frame:</p>
<div class="sourceCode" id="cb936"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb936-1" title="1">   v.RotateUz(direction); <span class="co">// direction must be a unit TVector3</span></a></code></pre></div>
<p>Rotation by <strong><code>TRotation</code></strong>:</p>
<div class="sourceCode" id="cb937"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb937-1" title="1">   TRotation r;</a>
<a class="sourceLine" id="cb937-2" title="2">   v.Transform(r);<span class="co">//or v *= r;  (v = r*v)</span></a></code></pre></div>
<h3 id="miscellaneous"><span class="header-section-number">17.4.8</span> Miscellaneous</h3>
<p>Angle between two vectors:</p>
<div class="sourceCode" id="cb938"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb938-1" title="1">   <span class="dt">Double_t</span> a = v1.Angle(v2);<span class="co">// get angle between v1 and v2</span></a></code></pre></div>
<p>Methods <code>Plus()</code> and <code>Minus()</code> return the positive and negative light-cone components:</p>
<div class="sourceCode" id="cb939"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb939-1" title="1">   <span class="dt">Double_t</span> pcone = v.Plus();</a>
<a class="sourceLine" id="cb939-2" title="2">   <span class="dt">Double_t</span> mcone = v.Minus();</a></code></pre></div>
<p>A general Lorentz transformation (see class <code>TLorentzRotation)</code> can be used by the <code>Transform()</code> method, the <code>*=, or *</code> operator of the <strong><code>TLorentzRotation</code></strong> class:</p>
<div class="sourceCode" id="cb940"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb940-1" title="1">   TLorentzRotation l;</a>
<a class="sourceLine" id="cb940-2" title="2">   v.Transform(l);</a>
<a class="sourceLine" id="cb940-3" title="3">   v = l*v;orv *= l;<span class="co">// v = l*v</span></a></code></pre></div>
<h2 id="tlorentzrotation"><span class="header-section-number">17.5</span> TLorentzRotation</h2>
<p>The <strong><code>TLorentzRotation</code></strong> class describes Lorentz transformations including Lorentz boosts and rotations (see <strong><code>TRotation</code></strong>)</p>
<p><span class="math display">\[
lambda =
\left|
\begin{array}{cccc}
         xx  &amp;  xy  &amp; xz &amp; xt \\
         yx  &amp;  yy  &amp; yz &amp; yt \\
         zx  &amp;  zy  &amp; zz &amp; zt \\
         tx  &amp;  ty  &amp; tz &amp; tt
\end{array}
\right|
\]</span></p>
<h3 id="declaration-1"><span class="header-section-number">17.5.1</span> Declaration</h3>
<p>By default it is initialized to the identity matrix, but it may also be initialized by other <strong><code>TLorentzRotation</code></strong>, by a pure <strong><code>TRotation</code></strong> or by a boost:</p>
<div class="sourceCode" id="cb941"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb941-1" title="1">   TLorentzRotation l;   <span class="co">// l is initialized as identity</span></a>
<a class="sourceLine" id="cb941-2" title="2">   TLorentzRotation m(l);<span class="co">// m = l</span></a>
<a class="sourceLine" id="cb941-3" title="3">   TRotation r;</a>
<a class="sourceLine" id="cb941-4" title="4">   TLorentzRotation lr(r);</a>
<a class="sourceLine" id="cb941-5" title="5">   TLorentzRotation lb1(bx,by,bz);</a>
<a class="sourceLine" id="cb941-6" title="6">   TVector3 b;</a>
<a class="sourceLine" id="cb941-7" title="7">   TLorentzRotation lb2(b);</a></code></pre></div>
<p>The Matrix for a Lorentz boosts is:</p>
<p><span class="math display">\[
\left|
\begin{array}{cccc}
1+gamma'*bx*bx &amp;    gamma'*bx*by &amp;    gamma'*bx*bz  &amp; gamma*bx \\
  gamma'*bx*bz &amp;  1+gamma'*by*by &amp;    gamma'*by*by  &amp; gamma*by \\
  gamma'*bz*bx &amp;    gamma'*bz*by &amp;  1+gamma'*bz*bz  &amp; gamma*bz \\
  gamma*bx     &amp;    gamma*by     &amp;    gamma*bz      &amp; gamma
\end{array}
\right|
\]</span></p>
<p>with the boost vector <code>b=(bx,by,bz)</code>; <code>gamma=1/Sqrt(1-beta*beta)</code>;<code>gamma'=(gamma-1)/beta*beta.</code></p>
<h3 id="access-to-the-matrix-componentscomparisons"><span class="header-section-number">17.5.2</span> Access to the Matrix Components/Comparisons</h3>
<p>The access to the matrix components is possible with the methods <code>XX()</code>, <code>XY()</code> … <code>TT()</code>, and with the operator<code>(int,int)</code>:</p>
<div class="sourceCode" id="cb942"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb942-1" title="1">   <span class="dt">Double_t</span> xx;</a>
<a class="sourceLine" id="cb942-2" title="2">   TLorentzRotation l;</a>
<a class="sourceLine" id="cb942-3" title="3">   xx = l.XX();              <span class="co">// gets the xx component</span></a>
<a class="sourceLine" id="cb942-4" title="4">   xx = l(<span class="dv">0</span>,<span class="dv">0</span>);              <span class="co">// gets the xx component</span></a>
<a class="sourceLine" id="cb942-5" title="5">   <span class="cf">if</span> (l == m) {...}         <span class="co">// test for equality</span></a>
<a class="sourceLine" id="cb942-6" title="6">   <span class="cf">if</span> (l != m) {...}         <span class="co">// test for inequality</span></a>
<a class="sourceLine" id="cb942-7" title="7">   <span class="cf">if</span> (l.IsIdentity()) {...} <span class="co">// test for identity</span></a></code></pre></div>
<h3 id="transformations-of-a-lorentz-rotation"><span class="header-section-number">17.5.3</span> Transformations of a Lorentz Rotation</h3>
<p>There are four possibilities to find the product of two <strong><code>TLorentzRotation</code></strong> transformations:</p>
<div class="sourceCode" id="cb943"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb943-1" title="1">   TLorentzRotation a,b,c;</a>
<a class="sourceLine" id="cb943-2" title="2">   c = b*a;                       <span class="co">// product</span></a>
<a class="sourceLine" id="cb943-3" title="3">   c = a.MatrixMultiplication(b); <span class="co">// a is unchanged</span></a>
<a class="sourceLine" id="cb943-4" title="4">   a *= b;                        <span class="co">// a=a*b</span></a>
<a class="sourceLine" id="cb943-5" title="5">   c = a.Transform(b)             <span class="co">// a=b*a then c=a</span></a></code></pre></div>
<p>Lorentz boosts:</p>
<div class="sourceCode" id="cb944"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb944-1" title="1">   <span class="dt">Double_t</span> bx, by, bz;</a>
<a class="sourceLine" id="cb944-2" title="2">   TVector3 v(bx,by,bz);</a>
<a class="sourceLine" id="cb944-3" title="3">   TLorentzRotation l;</a>
<a class="sourceLine" id="cb944-4" title="4">   l.Boost(v);</a>
<a class="sourceLine" id="cb944-5" title="5">   l.Boost(bx,by,bz);</a></code></pre></div>
<p>Rotations:</p>
<div class="sourceCode" id="cb945"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb945-1" title="1">   TVector3 axis;</a>
<a class="sourceLine" id="cb945-2" title="2">   l.RotateX(TMath::Pi()); <span class="co">// rotation around x-axis</span></a>
<a class="sourceLine" id="cb945-3" title="3">   l.Rotate(<span class="fl">.5</span>,axis);      <span class="co">// rotation around specified vector</span></a></code></pre></div>
<p>Inverse transformation: use the method <code>Inverse()</code>to return the inverse transformation keeping the current one unchanged<code>.</code> The method <code>Invert()</code> inverts the current <strong><code>TLorentzRotation</code></strong>:</p>
<div class="sourceCode" id="cb946"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb946-1" title="1">   l1 = l2.Inverse(); <span class="co">// l1 is inverse of l2, l2 unchanged</span></a>
<a class="sourceLine" id="cb946-2" title="2">   l1 = l2.Invert();  <span class="co">// invert l2, then  l1=l2</span></a></code></pre></div>
<p>The matrix for the inverse transformation of a <strong><code>TLorentzRotation</code></strong> is as follows:</p>
<p><span class="math display">\[
\left|
\begin{array}{cccc}
         xx  &amp;  xy  &amp; xz &amp; -tx \\
         yx  &amp;  yy  &amp; yz &amp; -ty \\
         zx  &amp;  zy  &amp; zz &amp; -tz \\
         -xt  &amp;  -yt  &amp; -zt &amp; tt
\end{array}
\right|
\]</span></p>
<h3 id="transformation-of-a-tlorentzvector"><span class="header-section-number">17.5.4</span> Transformation of a TLorentzVector</h3>
<p>To apply <strong><code>TLorentzRotation</code></strong> to <strong><code>TLorentzVector</code></strong> you can use either the <code>VectorMultiplication()</code> method or the <code>* operator</code>. You can also use the <code>Transform()</code> function and the <code>*=</code>operator of the class <strong><code>TLorentzVector</code></strong>.</p>
<div class="sourceCode" id="cb947"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb947-1" title="1">   TLorentzVector v;</a>
<a class="sourceLine" id="cb947-2" title="2">   TLorentzRotation l;</a>
<a class="sourceLine" id="cb947-3" title="3">...</a>
<a class="sourceLine" id="cb947-4" title="4">   v = l.VectorMultiplication(v);</a>
<a class="sourceLine" id="cb947-5" title="5">   v = l * v;</a>
<a class="sourceLine" id="cb947-6" title="6">   v.Transform(l);</a>
<a class="sourceLine" id="cb947-7" title="7">   v *= l;            <span class="co">// v = l*v</span></a></code></pre></div>
<h3 id="physics-vector-example"><span class="header-section-number">17.5.5</span> Physics Vector Example</h3>
<p>The test file <code>$ROOTSYS/test/TestVectors.cxx is</code> an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load <code>libPhysics.so</code> first:</p>
<div class="sourceCode" id="cb948"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb948-1" title="1">root[] .L <span class="er">$</span>ROOTSYS/lib/libPhysics.so</a>
<a class="sourceLine" id="cb948-2" title="2">root[] .x TestVectors.cxx</a></code></pre></div>
<p>To load the physics vector library in a ROOT application use:</p>
<div class="sourceCode" id="cb949"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb949-1" title="1">   gSystem-&gt;Load(<span class="st">"libPhysics"</span>);</a></code></pre></div>
<p>The example <code>$ROOTSYS/test/TestVectors.cxx</code> does not return much, especially if all went well, but when you look at the code you will find examples for many calls.</p>
<h1 id="the-geometry-package"><span class="header-section-number">18</span> The Geometry Package</h1>
<p></p>
<p>The new ROOT geometry package is a tool for building, browsing, 
navigating and visualizing detector geometries. The code works 
standalone with respect to any tracking Monte-Carlo engine; therefore, 
it does not contain any constraints related to physics. However, the 
navigation features provided by the package are designed to optimize 
particle transport through complex geometries, working in correlation 
with simulation packages such as GEANT3, GEANT4 and FLUKA.</p>
<h2 id="quick-start-creating-the-world"><span class="header-section-number">18.1</span> Quick Start: Creating the “world”</h2>
<p>This chapter will provide a detailed description on how to build 
valid geometries as well as the ways to optimize them. There are several
 components gluing together the geometrical model, but for the time 
being let us get used with the most basic concepts.</p>
<p>The basic bricks for building-up the model are called <code>volumes</code><strong>.</strong>These
 represent the un-positioned pieces of the geometry puzzle. The 
difference is just that the relationship between the pieces is not 
defined by neighbors, but by <code>containment</code>. In other words, 
volumes are put one inside another making an in-depth hierarchy. From 
outside, the whole thing looks like a big pack that you can open finding
 out other smaller packs nicely arranged waiting to be opened at their 
turn. The biggest one containing all others defines the “<code>world</code>” of the model. We will often call this <code>master reference system (MARS)</code>.
 Going on and opening our packs, we will obviously find out some empty 
ones, otherwise, something is very wrong… We will call these leaves (by 
analogy with a tree structure).</p>
<p>On the other hand, any volume is a small world by itself - what we 
need to do is to take it out and to ignore all the rest since it is a 
self-contained object. In fact, the modeller can act like this, 
considering a given volume as temporary MARS, but we will describe this 
feature later on. Let us focus on the biggest pack - it is mandatory to 
define one. Consider the simplest geometry that is made of a single box.
 Here is an example on how to build it:</p>
<h3 id="example-1-creating-the-world"><span class="header-section-number">18.1.1</span> Example 1: Creating the World</h3>
<p>We first need to load the geometry library. This is not needed if one does <code>make map</code> in root folder.</p>
<div class="sourceCode" id="cb950"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb950-1" title="1">root[] gSystem-&gt;Load(<span class="st">"libGeom"</span>);</a></code></pre></div>
<p>Second, we have to create an instance of the geometry manager class. 
This takes care of all the modeller components, performing several tasks
 to insure geometry validity and containing the user interface for 
building and interacting with the geometry. After its creation, the 
geometry manager class can be accessed with the global <strong><em><code>gGeoManager</code></em></strong>:</p>
<div class="sourceCode" id="cb951"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb951-1" title="1">root[] <span class="kw">new</span> TGeoManager(<span class="st">"world"</span>, <span class="st">"the simplest geometry"</span>);</a></code></pre></div>
<p>We want to create a single volume in our geometry, but since any 
volume needs to have an associated medium, we will create a dummy one. 
You can safely ignore the following lines for the time being, since 
materials and media will be explained in detail later on.</p>
<div class="sourceCode" id="cb952"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb952-1" title="1">root[] TGeoMaterial *mat = <span class="kw">new</span> TGeoMaterial(<span class="st">"Vacuum"</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb952-2" title="2">root[] TGeoMedium   *med = <span class="kw">new</span> TGeoMedium(<span class="st">"Vacuum"</span>,<span class="dv">1</span>,mat);</a></code></pre></div>
<p>We can finally make our volume having a box shape. Note that the 
world volume does not need to be a box - it can be any other shape. 
Generally, boxes and tubes are the most recommendable shapes for this 
purpose due to their fast navigation algorithms.</p>
<div class="sourceCode" id="cb953"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb953-1" title="1">root[] TGeoVolume *top=gGeoManager-&gt;MakeBox(<span class="st">"Top"</span>,med,<span class="fl">10.</span>,<span class="fl">10.</span>,<span class="fl">10.</span>);</a></code></pre></div>
<p>The default units are in centimeters. Now we want to make this volume our world. We have to do this operation <strong>before</strong> closing the geometry.</p>
<div class="sourceCode" id="cb954"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb954-1" title="1">root[] gGeoManager-&gt;SetTopVolume(top);</a></code></pre></div>
<p>This should be enough, but it is not since always after defining some geometry hierarchy, <strong><code>TGeo</code></strong>
 needs to build some optimization structures and perform some checks. 
Note the messages posted after the statement is executed. We will 
describe the corresponding operations later.</p>
<div class="sourceCode" id="cb955"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb955-1" title="1">root[] gGeoManager-&gt;CloseGeometry();</a></code></pre></div>
<p>Now we are really done with geometry building stage, but we would like to see our simple world:</p>
<div class="sourceCode" id="cb956"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb956-1" title="1">root[] top-&gt;SetLineColor(kMagenta);</a>
<a class="sourceLine" id="cb956-2" title="2">root[] gGeoManager-&gt;SetTopVisible(); <span class="co">// the TOP is invisible</span></a>
<a class="sourceLine" id="cb956-3" title="3">root[] top-&gt;Draw();</a></code></pre></div>
<h3 id="example-2-a-geometrical-hierarchy-look-and-feel"><span class="header-section-number">18.1.2</span> Example 2: A Geometrical Hierarchy Look and Feel</h3>
<p>Before going further, let us get a look and feel of interacting with 
the modeller. For this, we will use one of the examples illustrating the
 geometry package. To get an idea on the geometry structure created in 
this example, just look at the link: <a href="http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html" class="uri">http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html</a>.
 You will notice that this is a bit more complex that just creating the 
“world” since several other volumes are created and put together in a 
hierarchy. The purpose here is just to learn how to interact with a 
geometry that is already built, but just few hints on the building steps
 in this example might be useful. The geometry here represents the word 
ROOT that is replicated in some symmetric manner. You might for instance
 ask some questions after having a first look:</p>
<p><strong><em><code>Q:</code></em></strong> “OK, I understand the first
 lines that load the libGeom library and create a geometry manager 
object. I also recognize from the previous example the following lines 
creating some materials and media, but what about the geometrical 
transformations below?”</p>
<p><strong><em><code>A:</code></em></strong> As explained before, the model that we are trying to create is a hierarchy of volumes based on <strong><em><code>containment</code></em></strong>. This is accomplished by <strong><em><code>positioning</code></em></strong> some volumes <strong><em><code>inside</code></em></strong> others. Any volume is an un-positioned object in the sense that it defines only a <strong><em><code>local frame</code></em></strong> (matching the one of its <strong><em><code>shape</code></em></strong>).
 In order to fully define the mother-daughter relationship between two 
volumes one has to specify how the daughter will be positioned inside. 
This is accomplished by defining a <strong><em><code>local geometrical transformation</code></em></strong> of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.</p>
<p><strong><em><code>Q:</code></em></strong> “I see the lines defining 
the top level volume as in the previous example, but what about the 
other volumes named REPLICA and ROOT?”</p>
<p><strong><em><code>A:</code></em></strong> You will also notice that several other volumes are created by using lines like:</p>
<div class="sourceCode" id="cb957"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb957-1" title="1">TGeoVolume *someVolume = gGeoManager-&gt;MakeXXX(<span class="st">"someName"</span>,</a>
<a class="sourceLine" id="cb957-2" title="2">ptrMedium, <span class="co">/* parameters coresponding to XXX ...*/</span>)</a></code></pre></div>
<p>In the method above <strong><code>XXX</code></strong> represent some 
shape name (Box, Tube, etc.). This is just a simple way of creating a 
volume having a given shape in one-step (see also section: “Creating and
 Positioning Volumes”). As for REPLICA and ROOT volumes, they are just 
some <strong><em><code>virtual volumes</code></em></strong> used for grouping and positioning together other <strong><em><code>real volumes</code></em></strong>. See “Positioned Volumes (Nodes)”. The same structure represented by (a real or) a virtual volume can be <strong><em><code>replicated</code></em></strong> several times in the geometry.</p>
<p><strong><em><code>Q:</code></em></strong> “Fine, so probably the real
 volumes are the ones composing the letters R, O and T. Why one have to 
define so many volumes to make an R?”</p>
<p><strong><em><code>A:</code></em></strong> Well, in real life some objects have much more complex shapes that an <strong><em><code>R</code></em></strong>.
 The modeller cannot just know all of them; the idea is to make a 
complex object by using elementary building blocks that have known 
shapes (called <strong><em><code>primitive shapes</code></em></strong>). Gluing these together in the appropriate way is the user responsibility.</p>
<p><strong><em><code>Q:</code></em></strong> “I am getting the global 
picture but not making much out of it… There are also a lot of calls to 
TGeoVolume::AddNode() that I do not understand.”</p>
<p><strong><em><code>A:</code></em></strong> A volume is positioned 
inside another one by using this method. The relative geometrical 
transformation as well as a copy number must be specified. When 
positioned, a volume becomes a <strong><em><code>node</code></em></strong> of its container and a new object of the class <strong><code>TGeoNode</code></strong>
 is automatically created. This method is therefore the key element for 
the creation of a hierarchical link between two volumes. As it will be 
described further on in this document, there are few other methods 
performing similar actions, but let us keep things simple for the time 
being. In addition, notice that there are some visualization-related 
calls in the example followed by a final <code>TGeoVolume::Draw()</code>call
 for the top volume. These are explained in details in the section 
“Visualization Settings and Attributes”. At this point, you will 
probably like to see how this geometry looks like. You just need to run 
the example and you will get the following picture that you can rotate 
using the mouse; or you can zoom / move it around (see what the Help 
menu of the GL window displays).</p>
<div class="sourceCode" id="cb958"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb958-1" title="1">% root rootgeom.C</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/020001B1.jpg"></p>
<p>Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the <strong><em><code>gGeoManager</code></em></strong> object. Note that right click opens the context menu of the manager class where several global methods are available.</p>
<div class="sourceCode" id="cb959"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb959-1" title="1">root[] <span class="kw">new</span> TBrowser;</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/020001B2.jpg"></p>
<p>The folders <code>Materials</code>, <code>Media</code> and <code>Local transformations</code> are in fact the containers where the geometry manager stores the corresponding objects. The <code>Illegal overlaps</code>
 folder is empty but can be filled after performing a geometry validity 
check (see section: “Checking the Geometry”). If tracking is performed 
using <strong><code>TGeo</code></strong>, the folder <code>Tracks</code>
 might contain user-defined tracks that can be visualized/animated in 
the geometry context (see section: “Creating and Visualizing Tracks”). 
Since for the time being we are interested more in the geometrical 
hierarchy, we will focus on the last two displayed items <code>TOP</code>and <code>TOP_1</code>. These are the top volume and the corresponding top node in the hierarchy.</p>
<p>Double clicking on the <code>TOP</code> volume will unfold all 
different volumes contained by the top volume. In the right panel, we 
will see all the volumes contained by <code>TOP</code> (if the same is 
positioned 4 times we will get 4 identical items). This rule will apply 
to any clicked volume in the hierarchy. Note that right clicking a 
volume item activates the volume context menu containing several 
specific methods. We will call the volume hierarchy developed in this 
way as the <code>logical geometry graph</code>. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.</p>
<p>On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the <code>TOP_1</code> branch. These are the nodes of the <code>physical</code> <code>tree</code> of positioned volumes represented by <strong><code>TGeoNode</code></strong>
 objects. This hierarchy is a tree since a node can have only one parent
 and several daughters. For a better understanding of the hierarchy, 
have a look at <a href="http://root.cern.ch/root/htmldoc/TGeoManager.html" class="uri">http://root.cern.ch/root/htmldoc/TGeoManager.html</a>.</p>
<p>Just close now the <code>X3D</code> window and focus at the wire 
frame picture drawn in a pad. Activate Options/Event Status. Moving the 
mouse in the pad, you will notice that objects are sometimes changing 
color to red. Volumes are highlighted in this way whenever the mouse 
pointer is close enough to one of its vertices. When this happens, the 
corresponding volume is selected and you will see in the bottom right 
size of the ROOT canvas its name, shape type and corresponding path in 
the physical tree. Right clicking on the screen when a volume is 
selected will also open its context menu (picking). Note that there are 
several actions that can be performed both at view (no volume selected) 
and volume level.</p>
<p><strong><code>TView</code></strong> (mouse not selecting any volume):</p>
<ul>
<li>Click-and-drag rotates the view.</li>
<li>Pressing some keys perform different actions:</li>
<li>J/K - zoom / unzoom</li>
<li>H, L, U, I - move the viewpoint</li>
<li>Right click + <code>SetParallel</code> <code>()/SetPerspective</code> <code>()</code> - switch from parallel to perspective view.</li>
<li>Right click + <code>ShowAxis()</code> - show coordinate axes.</li>
<li>Right click + <code>Centered/Left/Side/Top</code> - change view direction.</li>
</ul>
<p><strong><code>TGeoVolume</code></strong> (mouse selecting a volume):</p>
<ul>
<li>Double click will focus the corresponding volume.</li>
<li>Right click + <code>CheckOverlaps()</code> - run overlap checker on current volume.</li>
<li>Right click + <code>Draw</code> <code>()</code> - draw that volume according current global visualization options</li>
<li>Right click + <code>DrawOnly()</code><strong><em><code>-</code></em></strong>draw only the selected volume.</li>
<li>Right click + <code>InspectShape/Material()</code> - print info about shape or material.</li>
<li>Right click + <code>Raytrace()</code> - initiate a ray tracing algorithm on current view.</li>
<li>Right click + <code>RandomPoints/Rays()</code> - shoot random points or rays inside the bounding box of the clicked volume and display only those inside visible volumes.</li>
<li>Right click + <code>Weight()</code> - estimates the weight of a volume within a given precision.</li>
</ul>
<p>Note that there are several additional methods for visibility and line attributes settings.</p>
<h2 id="materials-and-tracking-media"><span class="header-section-number">18.2</span> Materials and Tracking Media</h2>
<p>We have mentioned that volumes are the building blocks for geometry, 
but they describe real objects having well defined properties. In fact, 
there are just two of them: the material they are made from and their 
geometrical <code>shape</code>. These have to be created before creating
 the volume itself, so we will describe the bits and pieces needed for 
making the geometry before moving to an architectural point of view.</p>
<p>As far as materials are concerned, they represent the physical 
properties of the solid from which a volume is made. Materials are just a
 support for the data that has to be provided to the tracking engine 
that uses this geometry package. Due to this fact, the <strong><code>TGeoMaterial</code></strong>
 class is more like a thin data structure needed for building the 
corresponding native materials of the Monte-Carlo tracking code that 
uses <strong><code>TGeo</code></strong>.</p>
<h3 id="elements-materials-and-mixtures"><span class="header-section-number">18.2.1</span> Elements, Materials and Mixtures</h3>
<p>In order to make easier material and mixture creation, one can use the pre-built table of elements owned by <strong><code>TGeoManager</code></strong> class:</p>
<div class="sourceCode" id="cb960"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb960-1" title="1">TGeoElementTable *table = gGeoManager-&gt;GetElementTable();</a>
<a class="sourceLine" id="cb960-2" title="2">TGeoElement *element1 = table-&gt;GetElement(<span class="dt">Int_t</span> Z);</a>
<a class="sourceLine" id="cb960-3" title="3">TGeoElement *element2 = table-&gt;FindElement(<span class="st">"Copper"</span>);</a></code></pre></div>
<p>Materials made of single elements can be defined by their atomic mass (<code>A</code>), charge (<code>Z</code>) and density (<code>rh</code>o).
 One can also create a material by specifying the element that it is 
made of. Optionally the radiation and absorption lengths can be also 
provided; otherwise they can be computed on-demand [<code>G3</code>]. The class representing them is <strong><code>TGeoMaterial</code></strong>:</p>
<div class="sourceCode" id="cb961"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb961-1" title="1">TGeoMaterial(<span class="at">const</span> <span class="dt">char</span> *name,<span class="dt">Double_t</span> a,<span class="dt">Double_t</span> z,</a>
<a class="sourceLine" id="cb961-2" title="2">    <span class="dt">Double_t</span> density, <span class="dt">Double_t</span> radlen=<span class="dv">0</span>,<span class="dt">Double_t</span> intlen=<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb961-3" title="3">TGeoMaterial(<span class="at">const</span> <span class="dt">char</span> *name, TGeoElement *elem,</a>
<a class="sourceLine" id="cb961-4" title="4">    <span class="dt">Double_t</span> density);</a>
<a class="sourceLine" id="cb961-5" title="5">TGeoMaterial(<span class="at">const</span> <span class="dt">char</span>* name, <span class="dt">Double_t</span> a, <span class="dt">Double_t</span> z,</a>
<a class="sourceLine" id="cb961-6" title="6">    <span class="dt">Double_t</span> rho,</a>
<a class="sourceLine" id="cb961-7" title="7">    TGeoMaterial::EGeoMaterialState state,</a>
<a class="sourceLine" id="cb961-8" title="8">    <span class="dt">Double_t</span> temperature = STP_temperature,</a>
<a class="sourceLine" id="cb961-9" title="9">    <span class="dt">Double_t</span> pressure = STP_pressure)</a></code></pre></div>
<p>Any material or derived class is automatically indexed after 
creation. The assigned index is corresponding to the last entry in the 
list of materials owned by <strong><code>TGeoManager</code></strong> class. This can be changed using the <strong><code>TGeoMaterial</code></strong><code>::SetIndex()</code>
 method, however it is not recommended while using the geometry package 
interfaced with a transport MC. Radiation and absorption lengths can be 
set using:</p>
<div class="sourceCode" id="cb962"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb962-1" title="1">TGeoMaterial::SetRadLen(<span class="dt">Double_t</span> radlen, <span class="dt">Double_t</span> intlen);</a></code></pre></div>
<ul>
<li><code>radlen:</code> radiation length. If <code>radlen&lt;=0</code> the value is computed using GSMATE algorithm in GEANT3</li>
<li><code>intlen:</code> absorption length</li>
</ul>
<p>Material state, temperature and pressure can be changed via setters. 
Another material property is transparency. It can be defined and used 
while viewing the geometry with OpenGL.</p>
<div class="sourceCode" id="cb963"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb963-1" title="1"><span class="dt">void</span> SetTransparency (<span class="dt">Char_t</span> transparency = <span class="dv">0</span>)</a></code></pre></div>
<ul>
<li><code>transparency:</code> between 0 (opaque default) to 100 (fully transparent)</li>
</ul>
<p>One can attach to a material a user-defined object storing Cerenkov 
properties. Another hook for material shading properties is currently 
not in use. Mixtures are materials made of several elements. They are 
represented by the class <strong><code>TGeoMixture</code></strong>, deriving from <strong><code>TGeoMaterial</code></strong> and defined by their number of components and the density:</p>
<div class="sourceCode" id="cb964"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb964-1" title="1">TGeoMixture(<span class="at">const</span> <span class="dt">char</span> *name,<span class="dt">Int_t</span> nel,<span class="dt">Double_t</span> rho);</a></code></pre></div>
<p>Elements have to be further defined one by one:</p>
<div class="sourceCode" id="cb965"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb965-1" title="1"><span class="dt">void</span> TGeoMixture::DefineElement(<span class="dt">Int_t</span> iel,<span class="dt">Double_t</span> a,<span class="dt">Double_t</span> z,</a>
<a class="sourceLine" id="cb965-2" title="2">    <span class="dt">Double_t</span> weigth);</a>
<a class="sourceLine" id="cb965-3" title="3"><span class="dt">void</span> TGeoMixture::DefineElement(<span class="dt">Int_t</span> iel, TGeoElement *elem,</a>
<a class="sourceLine" id="cb965-4" title="4">    <span class="dt">Double_t</span> weight);</a>
<a class="sourceLine" id="cb965-5" title="5"><span class="dt">void</span> TGeoMixture::DefineElement(<span class="dt">Int_t</span> iel, <span class="dt">Int_t</span> z, <span class="dt">Int_t</span> natoms);</a></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb966"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb966-1" title="1"><span class="dt">void</span> AddElement(TGeoMaterial* mat, <span class="dt">Double_t</span> weight);</a>
<a class="sourceLine" id="cb966-2" title="2"><span class="dt">void</span> AddElement(TGeoElement* elem, <span class="dt">Double_t</span> weight);</a>
<a class="sourceLine" id="cb966-3" title="3"><span class="dt">void</span> AddElement(TGeoElement* elem, <span class="dt">Int_t</span> natoms);</a>
<a class="sourceLine" id="cb966-4" title="4"><span class="dt">void</span> AddElement(<span class="dt">Double_t</span> a, <span class="dt">Double_t</span> z, <span class="dt">Double_t</span> weight)</a></code></pre></div>
<ul>
<li><code>iel:</code> index of the element<code>[0,nel-1]</code></li>
<li><code>a</code> and <code>z:</code> the atomic mass and charge</li>
<li><code>weight:</code> proportion by mass of the elements</li>
<li><code>natoms</code>: number of atoms of the element in the molecule making the mixture</li>
</ul>
<p>The radiation length is automatically computed when all elements are 
defined. Since tracking MC provide several other ways to create 
materials/mixtures, the materials classes are likely to evolve as the 
interfaces to these engines are being developed. Generally in the 
process of tracking material properties are not enough and more specific
 media properties have to be defined. These highly depend on the MC 
performing tracking and sometimes allow the definition of different 
media properties (e.g.&nbsp;energy or range cuts) for the same material.</p>
<h3 id="radionuclides"><span class="header-section-number">18.2.2</span> Radionuclides</h3>
<p>A new class <strong><code>TGeoElementRN</code></strong> was 
introduced in this version to provide support for radioactive nuclides 
and their decays. A database of 3162 radionuclides can be loaded on 
demand via the table of elements (<strong><code>TGeoElementTable</code></strong> class). One can make then materials/mixtures based on these radionuclides and use them in a geometry</p>
<div class="sourceCode" id="cb967"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb967-1" title="1">root[] TGeoManager *geom = <span class="kw">new</span> TGeoManager(<span class="st">"geom"</span>,<span class="st">"radionuclides"</span>);</a>
<a class="sourceLine" id="cb967-2" title="2">root[] TGeoElementTable *table = geom-&gt;GetElementTable();</a>
<a class="sourceLine" id="cb967-3" title="3">root[] TGeoElementRN *c14 = table-&gt;GetElementRN(<span class="dv">14</span>,<span class="dv">6</span>);  <span class="co">// A,Z</span></a>
<a class="sourceLine" id="cb967-4" title="4">root[] c14-&gt;Print();</a>
<a class="sourceLine" id="cb967-5" title="5"><span class="dv">6</span>-C-<span class="bn">014</span> ENDF=<span class="dv">60140</span>; A=<span class="dv">14</span>; Z=<span class="dv">6</span>; Iso=<span class="dv">0</span>; Level=<span class="dv">0</span>[MeV]; Dmass=<span class="fl">3.0199</span>[MeV];</a>
<a class="sourceLine" id="cb967-6" title="6">Hlife=<span class="fl">1.81e+11</span>[s]  J/P=<span class="dv">0</span>+; Abund=<span class="dv">0</span>; Htox=<span class="fl">5.8e-10</span>; Itox=<span class="fl">5.8e-10</span>; Stat=<span class="dv">0</span></a>
<a class="sourceLine" id="cb967-7" title="7">Decay modes:</a>
<a class="sourceLine" id="cb967-8" title="8">BetaMinus            Diso:   <span class="dv">0</span> BR:   <span class="fl">100.000</span>% Qval: <span class="fl">0.1565</span></a></code></pre></div>
<p>One can make materials or mixtures from radionuclides:</p>
<div class="sourceCode" id="cb968"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb968-1" title="1">root[] TGeoMaterial *mat = <span class="kw">new</span> TGeoMaterial(<span class="st">"C14"</span>, c14, <span class="fl">2.0</span>);</a></code></pre></div>
<p>The following properties of radionuclides can be currently accessed via getters in the <strong><code>TGeoElementRN</code></strong> class:</p>
<p>Atomic number and charge (from the base class <strong><code>TGeoElement</code></strong>)</p>
<ul>
<li>Isomeric number (<code>ISO</code>)</li>
<li>ENDF code - following the convention: <code>ENDF=10000*Z+100*A+ISO</code></li>
<li>Isomeric energy level [<code>MeV</code>]</li>
<li>Mass excess [<code>MeV</code>]</li>
<li>Half life [<code>s</code>]</li>
<li>Spin/Parity - can be retrieved with: <code>TGeoElementRN::GetTitle()</code></li>
<li>Hynalation and ingestion toxicities</li>
<li>List of decays - <code>TGeoElementRN::GetDecays()</code></li>
</ul>
<p>The radioactive decays of a radionuclide are represented by the class <strong><code>TGeoDecayChannel</code></strong> and they are stored in a <strong><code>TObjArray</code></strong>. Decay provides:</p>
<ul>
<li>Decay mode</li>
<li>Variation of isomeric number</li>
<li><code>Q</code> value for the decay [<code>GeV</code>]</li>
<li>Parent element</li>
<li>Daughter element</li>
</ul>
<p>Radionuclides are linked one to each other via their decays, until 
the last element in the decay chain which must be stable. One can 
iterate decay chains using the iterator <strong><code>TGeoElemIter</code></strong>:</p>
<div class="sourceCode" id="cb969"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb969-1" title="1">root[] TGeoElemIter next(c14);</a>
<a class="sourceLine" id="cb969-2" title="2">root[] TGeoElementRN *elem;</a>
<a class="sourceLine" id="cb969-3" title="3">root[] <span class="cf">while</span> ((elem=next())) next.Print();</a>
<a class="sourceLine" id="cb969-4" title="4"><span class="dv">6</span>-C-<span class="bn">014</span> (<span class="dv">100</span>% BetaMinus) T1/<span class="dv">2</span>=<span class="fl">1.81e+11</span></a>
<a class="sourceLine" id="cb969-5" title="5"><span class="dv">7</span>-N-<span class="bn">014</span> stable</a></code></pre></div>
<p>To create a radioactive material based on a radionuclide, one should use the constructor:</p>
<div class="sourceCode" id="cb970"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb970-1" title="1">TGeoMaterial(<span class="at">const</span> <span class="dt">char</span> *name, TGeoElement *elem, <span class="dt">Double_t</span> density)</a></code></pre></div>
<p>To create a radioactive mixture, one can use radionuclides as well as stable elements:</p>
<div class="sourceCode" id="cb971"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb971-1" title="1">TGeoMixture(<span class="at">const</span> <span class="dt">char</span> *name, <span class="dt">Int_t</span> nelements, <span class="dt">Double_t</span> density);</a>
<a class="sourceLine" id="cb971-2" title="2">TGeoMixture::AddElement(TGeoElement *elem,</a>
<a class="sourceLine" id="cb971-3" title="3">    <span class="dt">Double_t</span> weight_fraction);</a></code></pre></div>
<p>Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:</p>
<ol type="1">
<li><code>TGeoMaterial::FillMaterialEvolution(TObjArray *population,</code> <code>Double_t   precision=0.001)</code></li>
</ol>
<p>To use this method, one has to provide an empty <strong><code>TObjArray</code></strong>
 object that will be filled with all elements coming from the decay 
chain of the initial radionuclides contained by the material/mixture. 
The precision represent the cumulative branching ratio for which decay 
products are still considered.</p>
<figure>
<img src="ROOTUsersGuide_files/030001B3.png" alt="Concentration of C14 derived elements"><figcaption>Concentration of C14 derived elements</figcaption>
</figure>
<p>The population list may contain stable elements as well as 
radionuclides, depending on the initial elements. To test if an element 
is a radionuclide:</p>
<div class="sourceCode" id="cb972"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb972-1" title="1"><span class="dt">Bool_t</span> TGeoElement::IsRadioNuclide() <span class="at">const</span></a></code></pre></div>
<p>All radionuclides in the output population list have attached objects
 that represent the time evolution of their fraction of nuclei with 
respect to the top radionuclide in the decay chain. These objects 
(Bateman solutions) can be retrieved and drawn:</p>
<div class="sourceCode" id="cb973"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb973-1" title="1">TGeoBatemanSol *TGeoElementRN::Ratio();</a>
<a class="sourceLine" id="cb973-2" title="2"><span class="dt">void</span> TGeoBatemanSol::Draw();</a></code></pre></div>
<p>Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:</p>
<ol start="2" type="1">
<li><code>TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001)</code></li>
</ol>
<p>The method will create the mixture that result from the decay of a 
initial material/mixture at time, while all resulting elements having a 
fractional weight less than precision are excluded.</p>
<p>A demo macro for radioactive material features is <code>$ROOTSYS/tutorials/geom/RadioNuclides.C</code> It demonstrates also the decay of a mixture made of radionuclides.</p>
<figure>
<img src="ROOTUsersGuide_files/030001B4.png" alt="Concentracion of elements derived fromCa53+Sr78"><figcaption>Concentracion of elements derived fromCa53+Sr78</figcaption>
</figure>
<h3 id="tracking-media"><span class="header-section-number">18.2.3</span> Tracking Media</h3>
<p>The class <strong><code>TGeoMedium</code></strong> describes tracking
 media properties. This has a pointer to a material and the additional 
data members representing the properties related to tracking.</p>
<div class="sourceCode" id="cb974"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb974-1" title="1">TGeoMedium(<span class="at">const</span> <span class="dt">char</span> *name,<span class="dt">Int_t</span> numed,TGeoMaterial *mat,</a>
<a class="sourceLine" id="cb974-2" title="2">           <span class="dt">Double_t</span> *params=<span class="dv">0</span>);</a></code></pre></div>
<ul>
<li><code>name:</code> name assigned to the medium</li>
<li><code>mat:</code> pointer to a material</li>
<li><code>params:</code> array of additional parameters</li>
</ul>
<p>Another constructor allows effectively defining tracking parameters in GEANT3 style:</p>
<div class="sourceCode" id="cb975"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb975-1" title="1">TGeoMedium(<span class="at">const</span> <span class="dt">char</span> *name,<span class="dt">Int_t</span> numed,<span class="dt">Int_t</span> imat,<span class="dt">Int_t</span> ifield,</a>
<a class="sourceLine" id="cb975-2" title="2"><span class="dt">Double_t</span> fieldm,<span class="dt">Double_t</span> tmaxfd,<span class="dt">Double_t</span> stemax,</a>
<a class="sourceLine" id="cb975-3" title="3"><span class="dt">Double_t</span> deemax,<span class="dt">Double_t</span> epsil,<span class="dt">Double_t</span> stmin);</a></code></pre></div>
<p>This constructor is reserved for creating tracking media from the VMC interface […]:</p>
<ul>
<li><code>numed:</code> user-defined medium index</li>
<li><code>imat:</code> unique ID of the material</li>
<li><code>others:</code> see G3 documentation</li>
</ul>
<p>Looking at our simple world example, one can see that for creating 
volumes one needs to create tracking media before. The way to proceed 
for those not interested in performing tracking with external MC’s is to
 define and use only one <code>dummy tracking medium</code> as in the example (or a <code>NULL</code> pointer).</p>
<h3 id="user-interface-for-handling-materials-and-media"><span class="header-section-number">18.2.4</span> User Interface for Handling Materials and Media</h3>
<p>The <strong><code>TGeoManager</code></strong> class contains the API for accessing and handling defined materials:</p>
<div class="sourceCode" id="cb976"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb976-1" title="1">TGeoManager::GetMaterial(name);</a></code></pre></div>
<h2 id="shapes"><span class="header-section-number">18.3</span> Shapes</h2>
<p>Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the <code>local</code>
 coordinate system of the volume. Any volume must have a shape. Any 
shape recognized by the modeller has to derive from the base <strong><code>TGeoShape</code></strong> class, providing methods for:</p>
<ul>
<li>Finding out if a point defined in their local frame is contained or not by the shape;</li>
<li>Computing the distance to enter/exit the shape from a local point, given a known direction;</li>
<li>Computing the maximum distance in any direction from a local point 
that does NOT result in a boundary crossing of the shape (safe 
distance);</li>
<li>Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction.</li>
</ul>
<p>All the features above are globally managed by the modeller in order 
to provide navigation functionality. In addition to those, shapes have 
also to implement additional specific abstract methods:</p>
<ul>
<li>Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;</li>
<li>Algorithms for dividing the shape along a given axis.</li>
</ul>
<p>The modeller currently provides a set of 20 basic shapes, which we will call <code>primitives</code>.
 It also provides a special class allowing the creation of shapes as a 
result of Boolean operations between primitives. These are called <code>composite shapes</code>
 and the composition operation can be recursive (combined composites). 
This allows the creation of a quite large number of different shape 
topologies and combinations. You can have a look and run the tutorial: <a href="http://root.cern.ch/root/html/examples/geodemo.C.html" class="uri">http://root.cern.ch/root/html/examples/geodemo.C.html</a></p>
<figure>
<img src="ROOTUsersGuide_files/030001B5.png" alt="Primitive Shapes - the general inheritance scheme"><figcaption>Primitive Shapes - the general inheritance scheme</figcaption>
</figure>
<p>Shapes are named objects and all primitives have constructors like:</p>
<div class="sourceCode" id="cb977"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb977-1" title="1">TGeoXXX(<span class="at">const</span> <span class="dt">char</span> *name,&lt;type&gt; param1,&lt;type&gt; param2, ...);</a>
<a class="sourceLine" id="cb977-2" title="2">TGeoXXX(&lt;type&gt; param1,&lt;type&gt; param2, ...);</a></code></pre></div>
<p>Naming shape primitive is mandatory only for the primitives used in 
Boolean composites (see “Composite Shapes”). For the sake of simplicity,
 we will describe only the constructors in the second form.</p>
<h3 id="units"><span class="header-section-number">18.3.1</span> Units</h3>
<p>The length units used in the geometry are <strong>arbitrary</strong>.
 However, there are certain functionalities that work with the 
assumption that the used lengths are expressed in centimeters. This is 
the case for shape capacity or volume weight computation. The same is 
valid when using the ROOT geometry as navigator for an external 
transport MC package (e.g. GEANT) via the VMC interface.</p>
<p>Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in <strong>degrees</strong>. Material density is expressed in [<strong>g/cm3</strong>].</p>
<h3 id="primitive-shapes"><span class="header-section-number">18.3.2</span> Primitive Shapes</h3>
<h4 id="boxes---tgeobbox-class"><span class="header-section-number">18.3.2.1</span> Boxes - TGeoBBox Class</h4>
<p>Normally a box has to be built only with 3 parameters: <code>DX,DY,DZ</code>
 representing the half-lengths on X, Y and Z-axes. In this case, the 
origin of the box will match the one of its reference frame and the box 
will range from: <code>-DX</code> to <code>DX</code> on X-axis, from <code>-DY</code> to <code>DY</code> on Y and from <code>-DZ</code> to <code>DZ</code>
 on Z. On the other hand, any other shape needs to compute and store the
 parameters of their minimal bounding box. The bounding boxes are 
essential to optimize navigation algorithms. Therefore all other 
primitives derive from <strong><code>TGeoBBox</code></strong>. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation <code>(Ox</code>,<code>Oy</code>,<code>Oz)</code>.
 All primitive constructors automatically compute the bounding box 
parameters. Users should be aware that building a translated box that 
will represent a primitive shape by itself would affect any further 
positioning of other shapes inside. Therefore it is highly recommendable
 to build non-translated boxes as primitives and translate/rotate their 
corresponding volumes only during positioning stage.</p>
<div class="sourceCode" id="cb978"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb978-1" title="1">TGeoBBox(<span class="dt">Double_t</span> dx,<span class="dt">Double_t</span> dy,<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> *origin=<span class="dv">0</span>);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001B6.png" alt="TGeoBBox class"><figcaption>TGeoBBox class</figcaption>
</figure>
<h4 id="parallelepiped---tgeopara-class"><span class="header-section-number">18.3.2.2</span> Parallelepiped - TGeoPara class</h4>
<p>A parallelepiped is a shape having 3 pairs of parallel faces out of 
which one is parallel with the XY plane (Z faces). All faces are 
parallelograms in the general case. The Z faces have 2 edges parallel 
with the X-axis.</p>
<figure>
<img src="ROOTUsersGuide_files/060001B7.png" alt="TGeoPara class"><figcaption>TGeoPara class</figcaption>
</figure>
<p>The shape has the center in the origin and it is defined by:</p>
<ul>
<li><code>dX, dY, dZ:</code> half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at <code>-dZ</code>, while the upper at <code>+dZ</code>.</li>
<li><code>alpha:</code> angle between the segment defined by the centers of the X-parallel edges and Y axis <code>[-90,90]</code> in degrees</li>
<li><code>theta:</code> theta angle of the segment defined by the centers of the Z faces;</li>
<li><code>phi:</code> phi angle of the same segment</li>
</ul>
<div class="sourceCode" id="cb979"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb979-1" title="1">TGeoPara(dX,dY,dZ,alpha,theta,phi);</a></code></pre></div>
<p>A box is a particular parallelepiped having the parameters: <code>(dX,dY,dZ,0.,0.,0.)</code>.</p>
<h4 id="trapezoids"><span class="header-section-number">18.3.2.3</span> Trapezoids</h4>
<p>In general, we will call trapezoidal shapes having 8 vertices and up 
to 6 trapezoid faces. Besides that, two of the opposite faces are 
parallel to XY plane and are positioned at <code>dZ</code>. Since 
general trapezoids are seldom used in detector geometry descriptions, 
there are several primitives implemented in the modeller for particular 
cases.</p>
<p><code>Trd1</code> is a trapezoid with only X varying with Z. It is 
defined by the half-length in Z, the half-length in X at the lowest and 
highest Z planes and the half-length in Y:</p>
<div class="sourceCode" id="cb980"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb980-1" title="1">TGeoTrd1(<span class="dt">Double_t</span> dx1,<span class="dt">Double_t</span> dx2,<span class="dt">Double_t</span> dy,<span class="dt">Double_t</span> dz);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001B8.png" alt="TGeoTrd1 class"><figcaption>TGeoTrd1 class</figcaption>
</figure>
<p><code>Trd2</code> is a trapezoid with both X and Y varying with Z. It
 is defined by the half-length in Z, the half-length in X at the lowest 
and highest Z planes and the half-length in Y at these planes:</p>
<div class="sourceCode" id="cb981"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb981-1" title="1">TGeoTrd2(<span class="dt">Double_t</span> dx1,<span class="dt">Double_t</span> dx2,<span class="dt">Double_t</span> dy1,<span class="dt">Double_t</span> dy2, <span class="dt">Double_t</span> dz);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001B9.png" alt="TGeoTrd2 class"><figcaption>TGeoTrd2 class</figcaption>
</figure>
<h4 id="general-trapezoid---tgeotrap-class"><span class="header-section-number">18.3.2.4</span> General Trapezoid - TGeoTrap Class</h4>
<p>A general trapezoid is one for which the faces perpendicular to z are
 trapezes but their centers are not necessary at the same x, y 
coordinates.</p>
<figure>
<img src="ROOTUsersGuide_files/image443.jpg" alt="TGeoTrap Class"><figcaption>TGeoTrap Class</figcaption>
</figure>
<p>It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, <code>H1</code> the half length in y at low z, <code>LB1</code> the half length in x at low z and y low edge, <code>LB2</code> the half length in x at low z and y high edge, <strong><code>TH1</code></strong> the angle with respect to the y axis from the center of low y edge to the center of the high y edge, and <code>H2,LB2,LH2,TH2</code>, the corresponding quantities at high z.</p>
<div class="sourceCode" id="cb982"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb982-1" title="1">TGeoTrap(<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> theta,<span class="dt">Double_t</span> phi,</a>
<a class="sourceLine" id="cb982-2" title="2"><span class="dt">Double_t</span> h1,<span class="dt">Double_t</span> bl1,<span class="dt">Double_t</span> tl1,<span class="dt">Double_t</span> alpha1,</a>
<a class="sourceLine" id="cb982-3" title="3"><span class="dt">Double_t</span> h2,<span class="dt">Double_t</span> bl2,<span class="dt">Double_t</span> tl2,<span class="dt">Double_t</span> alpha2);</a></code></pre></div>
<h4 id="twisted-trapezoid---tgeogtra-class"><span class="header-section-number">18.3.2.5</span> Twisted Trapezoid - TGeoGtra class</h4>
<p>A twisted trapezoid is a general trapezoid defined in the same way 
but that is twisted along the Z-axis. The twist is defined as the 
rotation angle between the lower and the higher Z faces.</p>
<div class="sourceCode" id="cb983"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb983-1" title="1">TGeoGtra(<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> theta,<span class="dt">Double_t</span> phi,<span class="dt">Double_t</span> twist,</a>
<a class="sourceLine" id="cb983-2" title="2"><span class="dt">Double_t</span> h1,<span class="dt">Double_t</span> bl1,<span class="dt">Double_t</span> tl1,<span class="dt">Double_t</span> alpha1,</a>
<a class="sourceLine" id="cb983-3" title="3"><span class="dt">Double_t</span> h2,<span class="dt">Double_t</span> bl2,<span class="dt">Double_t</span> tl2,<span class="dt">Double_t</span> alpha2 );</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001BB.png" alt="TGeoGtra class"><figcaption>TGeoGtra class</figcaption>
</figure>
<h4 id="arbitrary-8-vertices-shapes---tgeoarb8-class"><span class="header-section-number">18.3.2.6</span> Arbitrary 8 vertices shapes - TGeoArb8 class</h4>
<p>An <code>Arb8</code> is defined by two quadrilaterals sitting on parallel planes, at <code>dZ</code>. These are defined each by 4 vertices having the coordinates <code>(Xi,Yi,+/-dZ)</code>,<code>i=0</code>,<code>3</code>. The lateral surface of the <code>Arb8</code> is defined by the 4 pairs of edges corresponding to vertices (<code>i,i+1</code>) on both <code>-dZ</code> and <code>+dZ</code>. If M and M’ are the middles of the segments <code>(i,i+1)</code> at <code>-dZ</code> and <code>+dZ</code>, a lateral surface is obtained by sweeping the edge at <code>-dZ</code> along MM’ so that it will match the corresponding one at <code>+dZ</code>.
 Since the points defining the edges are arbitrary, the lateral surfaces
 are not necessary planes - but twisted planes having a twist angle 
linear-dependent on Z.</p>
<div class="sourceCode" id="cb984"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb984-1" title="1">TGeoArb8::TGeoArb8(<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> ivert);</a></code></pre></div>
<ul>
<li><code>dz:</code> half-length in Z;</li>
<li><code>ivert = [0,7]</code></li>
</ul>
<p>Vertices have to be defined clockwise in the XY pane, both at <code>+dz</code> and <code>-dz</code>. The quadrilateral at <code>-dz</code> is defined by indices [0,3], whereas the one at <code>+dz</code> by vertices [4,7]. The vertex with <code>index=7</code>
 has to be defined last, since it triggers the computation of the 
bounding box of the shape. Any two or more vertices in each Z plane can 
have the same (X,Y) coordinates. It this case, the top and bottom 
quadrilaterals become triangles, segments or points. The lateral 
surfaces are not necessary defined by a pair of segments, but by pair 
segment-point (making a triangle) or point-point (making a line). Any 
choice is valid as long as at one of the end-caps is at least a 
triangle.</p>
<figure>
<img src="ROOTUsersGuide_files/080001BC.png" alt="TGeoArb8 class"><figcaption>TGeoArb8 class</figcaption>
</figure>
<h4 id="tubes---tgeotube-class"><span class="header-section-number">18.3.2.7</span> Tubes - TGeoTube Class</h4>
<p>Tubes have Z as their symmetry axis. They have a range in Z, a minimum and a maximum radius:</p>
<div class="sourceCode" id="cb985"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb985-1" title="1">TGeoTube(<span class="dt">Double_t</span> rmin,<span class="dt">Double_t</span> rmax,<span class="dt">Double_t</span> dz);</a></code></pre></div>
<p>The full Z range is from <code>-dz</code> to <code>+dz</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/060001BD.png" alt="TGeoTube Class"><figcaption>TGeoTube Class</figcaption>
</figure>
<h4 id="tube-segments---tgeotubeseg-class"><span class="header-section-number">18.3.2.8</span> Tube Segments - TGeoTubeSeg Class</h4>
<p>A tube segment is a tube having a range in phi. The tube segment class derives from <strong><code>TGeoTube</code></strong>, having 2 extra parameters: <code>phi1</code> and <code>phi2</code>.</p>
<div class="sourceCode" id="cb986"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb986-1" title="1">TGeoTubeSeg(<span class="dt">Double_t</span> rmin,<span class="dt">Double_t</span> rmax,<span class="dt">Double_t</span> dz,</a>
<a class="sourceLine" id="cb986-2" title="2"><span class="dt">Double_t</span> phi1,<span class="dt">Double_t</span> phi2);</a></code></pre></div>
<p>Here <code>phi1</code> and <code>phi2</code>are the starting and ending <code>phi</code>values in degrees. The <code>general phi convention</code> is that the shape ranges from <code>phi1</code> to <code>phi2</code> going counterclockwise. The angles can be defined with either negative or positive values. They are stored such that <code>phi1</code> is converted to <code>[0,360]</code> and <code>phi2 &gt; phi1</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/060001BE.png" alt="TGeoTubeSeg Class"><figcaption>TGeoTubeSeg Class</figcaption>
</figure>
<h4 id="cut-tubes---tgeoctub-class"><span class="header-section-number">18.3.2.9</span> Cut Tubes - TGeoCtub Class</h4>
<p>The cut tubes constructor has the form:</p>
<div class="sourceCode" id="cb987"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb987-1" title="1">TGeoCtub(<span class="dt">Double_t</span> rmin,<span class="dt">Double_t</span> rmax,<span class="dt">Double_t</span> dz,</a>
<a class="sourceLine" id="cb987-2" title="2"><span class="dt">Double_t</span> phi1,<span class="dt">Double_t</span> phi2,</a>
<a class="sourceLine" id="cb987-3" title="3"><span class="dt">Double_t</span> nxlow,<span class="dt">Double_t</span> nylow,<span class="dt">Double_t</span> nzlow, <span class="dt">Double_t</span> nxhi,</a>
<a class="sourceLine" id="cb987-4" title="4"><span class="dt">Double_t</span> nyhi,<span class="dt">Double_t</span> nzhi);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001BF.png" alt="TGeoCtub Class"><figcaption>TGeoCtub Class</figcaption>
</figure>
<p>A cut tube is a tube segment cut with two planes. The centers of the 2 sections are positioned at <code>dZ</code>. Each cut plane is therefore defined by a point <code>(0,0,dZ)</code> and its normal unit vector pointing outside the shape:</p>
<p><code>Nlow=(Nx,Ny,Nz&lt;0)</code>, <code>Nhigh=(Nx',Ny',Nz'&gt;0)</code>.</p>
<h4 id="elliptical-tubes---tgeoeltu-class"><span class="header-section-number">18.3.2.10</span> Elliptical Tubes - TGeoEltu Class</h4>
<p>An elliptical tube is defined by the two semi-axes A and B. It ranges from <code>-dZ</code> to <code>+dZ</code> as all other tubes:</p>
<div class="sourceCode" id="cb988"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb988-1" title="1">TGeoEltu(<span class="dt">Double_t</span> a,<span class="dt">Double_t</span> b,<span class="dt">Double_t</span> dz);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/060001C0.png" alt="TGeoEltu Class"><figcaption>TGeoEltu Class</figcaption>
</figure>
<h4 id="hyperboloids---tgeohype-class"><span class="header-section-number">18.3.2.11</span> Hyperboloids - TGeoHype Class</h4>
<p>A hyperboloid is represented as a solid limited by two planes 
perpendicular to the Z axis (top and bottom planes) and two hyperbolic 
surfaces of revolution about Z axis (inner and outer surfaces). The 
class describing hyperboloids is <strong><code>TGeoHype</code></strong> has 5 input parameters:</p>
<div class="sourceCode" id="cb989"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb989-1" title="1">TGeoHype(<span class="dt">Double_t</span> rin,<span class="dt">Double_t</span> stin,<span class="dt">Double_t</span> rout,</a>
<a class="sourceLine" id="cb989-2" title="2"><span class="dt">Double_t</span> stout,<span class="dt">Double_t</span> dz);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/080001C1.png" alt="TGeoHype Class"><figcaption>TGeoHype Class</figcaption>
</figure>
<p>The hyperbolic surface equation is taken in the form:</p>
<div class="sourceCode" id="cb990"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb990-1" title="1">r2 - z2tan2() = r<span class="dv">2</span><span class="bu">min</span></a></code></pre></div>
<ul>
<li><code>r,z:</code> cylindrical coordinates for a point on the surface</li>
<li><code>:</code> stereo angle between the hyperbola asymptotic lines and Z axis</li>
<li><code>r2min:</code> minimum distance between hyperbola and Z axis (at <code>z=0</code>)</li>
</ul>
<p>The input parameters represent:</p>
<ul>
<li><code>rin, stin:</code> minimum radius and tangent of stereo angle for inner surface</li>
<li><code>rout, stout:</code> minimum radius and tangent of stereo angle for outer surface</li>
<li><code>dz:</code> half length in Z (bounding planes positions at <code>+/-dz</code>)</li>
</ul>
<p>The following conditions are mandatory in order to avoid 
intersections between the inner and outer hyperbolic surfaces in the 
range <code>+/-dz</code>:</p>
<ul>
<li><code>rin&lt;rout</code></li>
<li><code>rout&gt;0</code></li>
<li><code>rin2 + dz2*stin2 &gt; rout2 + dz2*stout2</code></li>
</ul>
<p>Particular cases:</p>
<ul>
<li><code>rin=0, stin0:</code> the inner surface is conical</li>
<li><code>stin=0 / stout=0:</code> cylindrical surface(s)</li>
</ul>
<h4 id="cones---tgeocone-class"><span class="header-section-number">18.3.2.12</span> Cones - TGeoCone Class</h4>
<p>The cones are defined by 5 parameters:</p>
<div class="sourceCode" id="cb991"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb991-1" title="1">TGeoCone(<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> rmin1,<span class="dt">Double_t</span> rmax1,</a>
<a class="sourceLine" id="cb991-2" title="2"><span class="dt">Double_t</span> rmin2,<span class="dt">Double_t</span> rmax2);</a></code></pre></div>
<ul>
<li><code>rmin1:</code> internal radius at Z is <code>-dz</code></li>
<li><code>rmax1:</code> external radius at Z is <code>-dz</code></li>
<li><code>rmin2:</code> internal radius at Z is <code>+dz</code></li>
<li><code>rmax2:</code> external radius at Z is <code>+dz</code></li>
<li><code>dz:</code> half length in Z (a cone ranges from <code>-dz</code> to +<code>dz</code>)</li>
</ul>
<p>A cone has Z-axis as its symmetry axis.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C2.png" alt="TGeoCone Class"><figcaption>TGeoCone Class</figcaption>
</figure>
<h4 id="cone-segments---tgeoconeseg-class"><span class="header-section-number">18.3.2.13</span> Cone Segments - TGeoConeSeg Class</h4>
<p>A cone segment is a cone having a range in <code>phi.</code> The cone segment class derives from <strong><code>TGeoCone</code></strong>, having two extra parameters: <code>phi1</code> and <code>phi2</code>.</p>
<div class="sourceCode" id="cb992"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb992-1" title="1">TGeoConeSeg(<span class="dt">Double_t</span> dz,<span class="dt">Double_t</span> rmin1,<span class="dt">Double_t</span> rmax1,</a>
<a class="sourceLine" id="cb992-2" title="2"><span class="dt">Double_t</span> rmin2,<span class="dt">Double_t</span> rmax2,<span class="dt">Double_t</span> phi1,<span class="dt">Double_t</span> phi2);</a></code></pre></div>
<p>Parameters<code>phi1</code> and <code>phi2</code> have the same meaning and convention as for tube segments.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C3.png" alt="TGeoConeSeg Class"><figcaption>TGeoConeSeg Class</figcaption>
</figure>
<h4 id="sphere---tgeosphere-class"><span class="header-section-number">18.3.2.14</span> Sphere - TGeoSphere Class</h4>
<p>Spheres in <strong><code>TGeo</code></strong> are not just balls having internal and external radii, but sectors of a sphere having defined theta and phi ranges. The <strong><code>TGeoSphere</code></strong> class has the following constructor.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C4.png" alt="TGeoSphere Class"><figcaption>TGeoSphere Class</figcaption>
</figure>
<div class="sourceCode" id="cb993"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb993-1" title="1">TGeoSphere(<span class="dt">Double_t</span> rmin,<span class="dt">Double_t</span> rmax,<span class="dt">Double_t</span> theta1,</a>
<a class="sourceLine" id="cb993-2" title="2"><span class="dt">Double_t</span> theta2,<span class="dt">Double_t</span> phi1, <span class="dt">Double_t</span> phi2);</a></code></pre></div>
<ul>
<li><code>rmin:</code> internal radius of the spherical sector</li>
<li><code>rmax:</code> external radius</li>
<li><code>theta1:</code> starting theta value [0, 180) in degrees</li>
<li><code>theta2:</code> ending theta value (0, 180] in degrees (<code>theta1&lt;theta2</code>)</li>
</ul>
<h4 id="torus-tgeotorus-class"><span class="header-section-number">18.3.2.15</span> Torus : TGeoTorus Class</h4>
<p>The torus is defined by its axial radius, its inner and outer radius.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C5.png" alt="TGeoTorus Class"><figcaption>TGeoTorus Class</figcaption>
</figure>
<p>It may have a <code>phi</code>range:</p>
<div class="sourceCode" id="cb994"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb994-1" title="1">TGeoTorus(<span class="dt">Double_t</span> R,<span class="dt">Double_t</span> Rmin,<span class="dt">Double_t</span> Rmax,<span class="dt">Double_t</span> Phi1,</a>
<a class="sourceLine" id="cb994-2" title="2"><span class="dt">Double_t</span> Dphi);</a></code></pre></div>
<ul>
<li><code>R:</code> axial radius of the torus</li>
<li><code>Rmin:</code> inner radius</li>
<li><code>Rmax:</code> outer radius</li>
<li><code>Phi1:</code> starting phi angle</li>
<li><code>Dphi:</code> total phi range</li>
</ul>
<h4 id="paraboloid-tgeoparaboloid-class"><span class="header-section-number">18.3.2.16</span> Paraboloid : TGeoParaboloid Class</h4>
<p>A paraboloid is defined by the revolution surface generated by a 
parabola and is bounded by two planes perpendicular to Z axis. The 
parabola equation is taken in the form: <code>z = a·r2 + b</code>, where: <code>r2 = x2 + y2</code>. Note the missing linear term (parabola symmetric with respect to Z axis).</p>
<p>The coefficients a and b are computed from the input values which are the radii of the circular sections cut by the planes at <code>+/-dz</code>:</p>
<ul>
<li><code>-dz = a*r2low  + b</code></li>
<li><code>dz = a*r2high + b</code></li>
</ul>
<div class="sourceCode" id="cb995"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb995-1" title="1">TGeoParaboloid(<span class="dt">Double_t</span> rlo,<span class="dt">Double_t</span> rhi,<span class="dt">Double_t</span> dz);</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/080001C6.png" alt="TGeoParaboloid Class"><figcaption>TGeoParaboloid Class</figcaption>
</figure>
<h4 id="polycone-tgeopcon-class"><span class="header-section-number">18.3.2.17</span> Polycone : TGeoPcon Class</h4>
<p>A polycone is represented by a sequence of tubes/cones, glued 
together at defined Z planes. The polycone might have a phi 
segmentation, which globally applies to all the pieces. It has to be 
defined in two steps:</p>
<ol type="1">
<li>First call the <strong><code>TGeoPcon</code></strong> constructor to define a polycone:</li>
</ol>
<div class="sourceCode" id="cb996"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb996-1" title="1">TGeoPcon(<span class="dt">Double_t</span> phi1,<span class="dt">Double_t</span> dphi,<span class="dt">Int_t</span> nz</a></code></pre></div>
<ul>
<li><code>phi1:</code> starting phi angle in degrees</li>
<li><code>dphi:</code> total phi range</li>
<li><code>nz:</code> number of Z planes defining polycone sections (minimum 2)</li>
</ul>
<ol start="2" type="1">
<li>Define one by one all sections [0, nz-1]</li>
</ol>
<div class="sourceCode" id="cb997"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb997-1" title="1"><span class="dt">void</span> TGeoPcon::DefineSection(<span class="dt">Int_t</span> i,<span class="dt">Double_t</span> z,</a>
<a class="sourceLine" id="cb997-2" title="2"><span class="dt">Double_t</span> rmin, <span class="dt">Double_t</span> rmax);</a></code></pre></div>
<ul>
<li><code>i:</code> section index [0, nz-1]</li>
<li><code>z:</code> z coordinate of the section</li>
<li><code>rmin:</code> minimum radius corresponding too this section</li>
<li><code>rmax:</code> maximum radius.</li>
</ul>
<p>The first section (<code>i=0</code>) has to be positioned always the 
lowest Z coordinate. It defines the radii of the first cone/tube segment
 at its lower Z. The next section defines the end-cap of the first 
segment, but it can represent also the beginning of the next one. Any 
discontinuity in the radius has to be represented by a section defined 
at the same Z coordinate as the previous one. The Z coordinates of all 
sections must be sorted in increasing order. Any radius or Z coordinate 
of a given plane have corresponding getters:</p>
<div class="sourceCode" id="cb998"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb998-1" title="1"><span class="dt">Double_t</span> TGeoPcon::GetRmin(<span class="dt">Int_t</span> i);</a>
<a class="sourceLine" id="cb998-2" title="2"><span class="dt">Double_t</span> TGeoPcon::GetRmax(<span class="dt">Int_t</span> i);</a>
<a class="sourceLine" id="cb998-3" title="3"><span class="dt">Double_t</span> TGeoPcon::GetZ(<span class="dt">Int_t</span> i);</a></code></pre></div>
<p>Note that the last section should be defined last, since it triggers the computation of the bounding box of the polycone.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C7.png" alt="TGeoPcon Class"><figcaption>TGeoPcon Class</figcaption>
</figure>
<h4 id="polygon-tgeopgon-class"><span class="header-section-number">18.3.2.18</span> Polygon: TGeoPgon Class</h4>
<p>Polygons are defined in the same way as polycones, the difference 
being just that the segments between consecutive Z planes are regular 
polygons. The phi segmentation is preserved and the shape is defined in a
 similar manner, just that <code>rmin</code> and <code>rmax</code> represent the radii of the circles inscribed in the inner/outer polygon.</p>
<figure>
<img src="ROOTUsersGuide_files/060001C8.png" alt="TGeoPgon Class"><figcaption>TGeoPgon Class</figcaption>
</figure>
<p>The constructor of a polygon has the form:</p>
<div class="sourceCode" id="cb999"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb999-1" title="1">TGeoPgon(<span class="dt">Double_t</span> phi1,<span class="dt">Double_t</span> dphi,<span class="dt">Int_t</span> nedges,<span class="dt">Int_t</span> nz);</a></code></pre></div>
<p>The extra parameter <code>nedges</code> represent the number of equal edges of the polygons, between <code>phi1</code> and <code>phi1+dphi.</code></p>
<h4 id="polygonal-extrusion-tgeoxtru-class"><span class="header-section-number">18.3.2.19</span> Polygonal extrusion: TGeoXtru Class</h4>
<p>A <strong><code>TGeoXtru</code></strong> shape is represented by the 
extrusion of an arbitrary polygon with fixed outline between several Z 
sections. Each Z section is a scaled version of the same “blueprint” 
polygon. Different global XY translations are allowed from section to 
section. Corresponding polygon vertices from consecutive sections are 
connected.</p>
<p>An extruded polygon can be created using the constructor:</p>
<div class="sourceCode" id="cb1000"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1000-1" title="1">TGeoXtru::TGeoXtru(<span class="dt">Int_t</span> nplanes);</a></code></pre></div>
<ul>
<li><code>nplanes:</code>number of Z sections (minimum 2)</li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/030001C9.png" alt="TGeoXtru Class"><figcaption>TGeoXtru Class</figcaption>
</figure>
<p>The lists of X and Y positions for all vertices have to be provided for the “blueprint” polygon:</p>
<div class="sourceCode" id="cb1001"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1001-1" title="1">TGeoXtru::DefinePolygon (<span class="dt">Int_t</span> nvertices, <span class="dt">Double_t</span> *xv,</a>
<a class="sourceLine" id="cb1001-2" title="2"><span class="dt">Double_t</span> *yv);</a></code></pre></div>
<ul>
<li><code>nvertices:</code>number of vertices of the polygon</li>
<li><code>xv,yv:</code>arrays of X and Y coordinates for polygon vertices</li>
</ul>
<p>The method creates an object of the class <strong><code>TGeoPolygon</code></strong> for which the convexity is automatically determined . The polygon is decomposed into convex polygons if needed.</p>
<p>Next step is to define the Z positions for each section plane as well
 as the XY offset and scaling for the corresponding polygons.</p>
<div class="sourceCode" id="cb1002"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1002-1" title="1">TGeoXtru::DefineSection(<span class="dt">Int_t</span> snum,<span class="dt">Double_t</span> zsection,<span class="dt">Double_t</span> x0,</a>
<a class="sourceLine" id="cb1002-2" title="2"><span class="dt">Double_t</span> y0, <span class="dt">Double_t</span> scale);</a></code></pre></div>
<ul>
<li><code>snum:</code>Z section index (0, nplanes-1). The section with <code>snum = nplanes-1</code> must be defined last and triggers the computation of the bounding box for the whole shape</li>
<li><code>zsection:</code>Z position of section <code>snum</code>. Sections must be defined in increasing order of Z (e.g.&nbsp;<code>snum=0</code> correspond to the minimum Z and <code>snum=nplanes-1</code> to the maximum one).</li>
<li><code>x0,y0:</code>offset of section <code>snum</code> with respect to the local shape reference frame <code>T</code></li>
<li><code>scale:</code>factor that multiplies the X/Y coordinates of each vertex of the polygon at section <code>snum</code>:</li>
<li><code>x[ivert] = x0 + scale*xv[ivert]</code></li>
<li><code>y[ivert] = y0 + scale*yv[ivert]</code></li>
</ul>
<h4 id="half-spaces-tgeohalfspace-class"><span class="header-section-number">18.3.2.20</span> Half Spaces: TGeoHalfSpace Class</h4>
<ul>
<li>A half space is limited just by a plane, defined by a point and the 
normal direction. The point lies on the plane and the normal vector 
points outside the half space. The half space is the only shape which is
 infinite and can be used only in Boolean operations that result in 
non-infinite composite shapes (see also “Composite Shapes” below). A 
half space has to be defined using the constructor:</li>
</ul>
<div class="sourceCode" id="cb1003"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1003-1" title="1">TGeoHalfSpace (<span class="at">const</span> <span class="dt">char</span> *name, <span class="dt">Double_t</span> *point[<span class="dv">3</span>],</a>
<a class="sourceLine" id="cb1003-2" title="2"><span class="dt">Double_t</span> *norm[<span class="dv">3</span>]);</a></code></pre></div>
<h3 id="composite-shapes"><span class="header-section-number">18.3.3</span> Composite Shapes</h3>
<p>Composite shapes are Boolean combinations of two or more shape 
components. The supported Boolean operations are union (+), intersection
 (*) and subtraction(-). Composite shapes derive from the base <strong><code>TGeoShape</code></strong>
 class, therefore providing all shape features: computation of bounding 
box, finding if a given point is inside or outside the combination, as 
well as computing the distance to entering/exiting. They can be directly
 used for creating volumes or used in the definition of other composite 
shapes.</p>
<p>Composite shapes are provided in order to complement and extend the 
set of basic shape primitives. They have a binary tree internal 
structure, therefore all shape-related geometry queries are signals 
propagated from top level down to the final leaves, while the provided 
answers are assembled and interpreted back at top. This <code>CSG</code> <code>(composite solid geometry)</code>
 hierarchy is effective for small number of components, while 
performance drops dramatically for large structures. Building a complete
 geometry in this style is virtually possible but highly not 
recommended.</p>
<h4 id="the-structure-of-composite-shapes"><span class="header-section-number">18.3.3.1</span> The Structure of Composite Shapes</h4>
<p>A composite shape can always be looked as the result of a Boolean 
operation between only two shape components. All information identifying
 these two components as well as their positions with respect to the 
frame of the composite is represented by an object called Boolean node. A
 composite shape has a pointer to such a Boolean node. Since the shape 
components may also be composites, they will also contain binary Boolean
 nodes branching out other two shapes in the hierarchy. Any such branch 
ends-up when the final leaves are no longer composite shapes, but basic 
primitives. The figure shows the composite shapes structure.</p>
<figure>
<img src="ROOTUsersGuide_files/080001CA.png" alt="The composite shapes structure"><figcaption>The composite shapes structure</figcaption>
</figure>
<p>Suppose that A, B, C and D represent basic shapes, we will illustrate
 how the internal representation of few combinations look like. We do 
this only for understanding how to create them in a proper way, since 
the user interface for this purpose is in fact very simple. We will 
ignore for the time being the positioning of components. The definition 
of a composite shape takes an expression where the identifiers are shape
 names. The expression is parsed and decomposed in 2 sub-expressions and
 the top-level Boolean operator.</p>
<ol type="1">
<li>Union: <code>A+B+C</code></li>
</ol>
<p>Just to illustrate the Boolean expression parsing and the composite 
shape structure, let’s take a simple example. We will describe the union
 of A, B and C. Both union operators are at the same level. Since:</p>
<p><code>A+B+C = (A+B)+C = A+(B+C)</code></p>
<p>The first<code>(+)</code> is taken as separator, hence the expression split in: <code>A</code> and <code>(B+C)</code>. A Boolean node of type <strong><code>TGeoUnion</code></strong><code>("A","B+C")</code>
 is created. This tries to replace the 2 expressions by actual pointers 
to corresponding shapes. The first expression (A) contains no operators 
therefore is interpreted as representing a shape. The shape named “A” is
 searched into the list of shapes handled by the manager class and 
stored as the “left” shape in the Boolean union node. Since the second 
expression is not yet fully decomposed, the “right” shape in the 
combination is created as a new composite shape. This will split at its 
turn B+C into B and C and create a <strong><code>TGeoUnion</code></strong><code>("B","C")</code>.
 The B and C identifiers will be looked for and replaced by the pointers
 to the actual shapes into the new node. Finally, the composite “<code>A+B+C</code>” will be represented as shown in Fig.17-23.**</p>
<figure>
<img src="ROOTUsersGuide_files/080001CB.png" alt="Representation of A+B+C"><figcaption>Representation of A+B+C</figcaption>
</figure>
<p>To build this composite shape:</p>
<div class="sourceCode" id="cb1004"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1004-1" title="1">TGeoCompositeShape *cs1 = <span class="kw">new</span> TGeoCompositeShape(<span class="st">"CS1"</span>,<span class="st">"A+B+C"</span>);</a></code></pre></div>
<p>Any shape entering a Boolean combination can be prior positioned. In 
order to do so, one has to attach a matrix name to the shape name by 
using a colon (:). As for shapes, the named matrix has to be prior 
defined:</p>
<div class="sourceCode" id="cb1005"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1005-1" title="1">TGeoMatrix *mat;</a>
<a class="sourceLine" id="cb1005-2" title="2"><span class="co">// ... code creating some geometrical transformation</span></a>
<a class="sourceLine" id="cb1005-3" title="3">mat-&gt;SetName(<span class="st">"mat1"</span>);</a>
<a class="sourceLine" id="cb1005-4" title="4">mat-&gt;RegisterYourself();  <span class="co">// see Geometrical transformations</span></a></code></pre></div>
<p>An identifier <code>shape:matrix</code> have the meaning: <code>shape</code> is translated or rotated with <code>matrix</code>
 with respect to the Boolean combination it enters as operand. Note that
 in the expression A+B+C no matrix identifier was provided, therefore 
the identity matrix was used for positioning the shape components. The 
next example will illustrate a more complex case.</p>
<ol start="2" type="1">
<li><code>(A:m1+B):m2-(C:m3*D:m4):m5</code></li>
</ol>
<p>Let’s try to understand the expression above. This expression means: subtract the intersection of <strong>C</strong> and <strong>D</strong> from the union of <strong>A</strong> and <strong>B</strong>.
 The usage of parenthesis to force the desired precedence is always 
recommended. One can see that not only the primitive shapes have some 
geometrical transformations, but also their intermediate compositions.</p>
<figure>
<img src="ROOTUsersGuide_files/080001CC.png" alt="Internal representation for composite shapes"><figcaption>Internal representation for composite shapes</figcaption>
</figure>
<div class="sourceCode" id="cb1006"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1006-1" title="1">TGeoCompositeShape *cs2 = <span class="kw">new</span> TGeoCompositeShape(<span class="st">"CS2"</span>,</a>
<a class="sourceLine" id="cb1006-2" title="2"><span class="st">"(A:m1+B):m2-(C:m3*D:m4):m5"</span>);</a></code></pre></div>
<p>Building composite shapes as in the first example is not always quite
 useful since we were using un-positioned shapes. When supplying just 
shape names as identifiers, the created Boolean nodes will assume that 
the shapes are positioned with an identity transformation with respect 
to the frame of the created composite. In order to provide some 
positioning of the combination components, we have to attach after each 
shape identifier the name of an existing transformation, separated by a 
colon. Obviously all transformations created for this purpose have to be
 objects with unique names in order to be properly substituted during 
parsing.</p>
<h4 id="composite-shape-example"><span class="header-section-number">18.3.3.2</span> Composite Shape Example</h4>
<p>One should have in mind that the same shape or matrix identifiers can
 be used many times in the same expression, as in the following example:</p>
<div class="sourceCode" id="cb1007"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1007-1" title="1"><span class="at">const</span> <span class="dt">Double_t</span> sq2 = TMath::Sqrt(<span class="fl">2.</span>);</a>
<a class="sourceLine" id="cb1007-2" title="2">gSystem-&gt;Load(<span class="st">"libGeom"</span>);</a>
<a class="sourceLine" id="cb1007-3" title="3">TGeoManager *mgr =</a>
<a class="sourceLine" id="cb1007-4" title="4">   <span class="kw">new</span> TGeoManager(<span class="st">"Geom"</span>,<span class="st">"composite shape example"</span>);</a>
<a class="sourceLine" id="cb1007-5" title="5">TGeoMedium *medium = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1007-6" title="6">TGeoVolume *top = mgr-&gt;MakeBox(<span class="st">"TOP"</span>,medium,<span class="dv">100</span>,<span class="dv">250</span>,<span class="dv">250</span>);</a>
<a class="sourceLine" id="cb1007-7" title="7">mgr-&gt;SetTopVolume(top);</a>
<a class="sourceLine" id="cb1007-8" title="8"></a>
<a class="sourceLine" id="cb1007-9" title="9"><span class="co">// make shape components</span></a>
<a class="sourceLine" id="cb1007-10" title="10">TGeoBBox *sbox  = <span class="kw">new</span> TGeoBBox(<span class="st">"B"</span>,<span class="dv">100</span>,<span class="dv">125</span>*sq2,<span class="dv">125</span>*sq2);</a>
<a class="sourceLine" id="cb1007-11" title="11">TGeoTube *stub  = <span class="kw">new</span> TGeoTube(<span class="st">"T"</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">250</span>);</a>
<a class="sourceLine" id="cb1007-12" title="12">TGeoPgon *spgon = <span class="kw">new</span> TGeoPgon(<span class="st">"P"</span>,<span class="fl">0.</span>,<span class="fl">360.</span>,<span class="dv">6</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1007-13" title="13">spgon-&gt;DefineSection(<span class="dv">0</span>,-<span class="dv">250</span>,<span class="dv">0</span>,<span class="dv">80</span>);</a>
<a class="sourceLine" id="cb1007-14" title="14">spgon-&gt;DefineSection(<span class="dv">1</span>,<span class="dv">250</span>,<span class="dv">0</span>,<span class="dv">80</span>);</a>
<a class="sourceLine" id="cb1007-15" title="15"></a>
<a class="sourceLine" id="cb1007-16" title="16"><span class="co">// define some rotations</span></a>
<a class="sourceLine" id="cb1007-17" title="17">TGeoRotation *r1 = <span class="kw">new</span> TGeoRotation(<span class="st">"r1"</span>,<span class="dv">90</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">180</span>,<span class="dv">90</span>,<span class="dv">90</span>);</a>
<a class="sourceLine" id="cb1007-18" title="18">r1-&gt;RegisterYourself();</a>
<a class="sourceLine" id="cb1007-19" title="19">TGeoRotation *r2 = <span class="kw">new</span> TGeoRotation(<span class="st">"r2"</span>,<span class="dv">90</span>,<span class="dv">0</span>,<span class="dv">45</span>,<span class="dv">90</span>,<span class="dv">45</span>,<span class="dv">270</span>);</a>
<a class="sourceLine" id="cb1007-20" title="20">r2-&gt;RegisterYourself();</a>
<a class="sourceLine" id="cb1007-21" title="21"><span class="co">// create a composite</span></a>
<a class="sourceLine" id="cb1007-22" title="22">TGeoCompositeShape *cs = <span class="kw">new</span> TGeoCompositeShape(<span class="st">"cs"</span>,</a>
<a class="sourceLine" id="cb1007-23" title="23"><span class="st">"((T+T:r1)-(P+P:r1))*B:r2"</span>);</a>
<a class="sourceLine" id="cb1007-24" title="24">TGeoVolume *comp = <span class="kw">new</span> TGeoVolume(<span class="st">"COMP"</span>,cs);</a>
<a class="sourceLine" id="cb1007-25" title="25">comp-&gt;SetLineColor(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1007-26" title="26"></a>
<a class="sourceLine" id="cb1007-27" title="27"><span class="co">// put it in the top volume</span></a>
<a class="sourceLine" id="cb1007-28" title="28">top-&gt;AddNode(comp,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1007-29" title="29">mgr-&gt;CloseGeometry();</a>
<a class="sourceLine" id="cb1007-30" title="30"><span class="co">// visualize it with ray tracing</span></a>
<a class="sourceLine" id="cb1007-31" title="31">top-&gt;Raytrace();</a></code></pre></div>
<figure>
<img src="ROOTUsersGuide_files/080001CD.png" alt="A composite shape example"><figcaption>A composite shape example</figcaption>
</figure>
<p>Composite shapes can be subsequently used for defining volumes. 
Moreover, these volumes contain other volumes, following the general 
criteria. Volumes created based on composite shapes cannot be divided.</p>
<h3 id="navigation-methods-performed-by-shapes"><span class="header-section-number">18.3.4</span> Navigation Methods Performed By Shapes</h3>
<p>Shapes are named objects and register themselves to the <code>manager class</code>
 at creation time. This is responsible for their final deletion. Shapes 
can be created without name if their retrieval by name is no needed. 
Generally shapes are objects that are useful only at geometry creation 
stage. The pointer to a shape is in fact needed only when referring to a
 given volume and it is always accessible at that level. Several volumes
 may reference a single shape; therefore its deletion is not possible 
once volumes were defined based on it.</p>
<p>The navigation features related for instance to tracking particles 
are performed in the following way: Each shape implement its specific 
algorithms for all required tasks in its local reference system. Note 
that the manager class handles global queries related to geometry. 
However, shape-related queries might be sometimes useful:</p>
<div class="sourceCode" id="cb1008"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1008-1" title="1"><span class="dt">Bool_t</span> TGeoShape::Contains(<span class="dt">Double_t</span> *point[<span class="dv">3</span>]);</a></code></pre></div>
<p>The method above returns <code>kTRUE</code> if the point *point is 
actually inside the shape. The point has to be defined in the local 
shape reference. For instance, for a box having <code>DX,DY</code> and <code>DZ</code>half-lengths a point will be considered inside if:</p>
<p><code>-DX &lt;= point[0] &lt;= DX</code></p>
<p><code>-DY &lt;= point[1] &lt;= DY</code></p>
<p><code>-DZ &lt;= point[2] &lt;= DZ</code></p>
<div class="sourceCode" id="cb1009"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1009-1" title="1"><span class="dt">Double_t</span> TGeoShape::DistFromInside(<span class="dt">Double_t</span> *point[<span class="dv">3</span>],</a>
<a class="sourceLine" id="cb1009-2" title="2"><span class="dt">Double_t</span> *dir[<span class="dv">3</span>], <span class="dt">Int_t</span> iact,<span class="dt">Double_t</span> step,<span class="dt">Double_t</span> *safe);</a></code></pre></div>
<p>The method computes the distance to exiting a shape from a given point <code>inside</code>,
 along a given direction. This direction is given by its director 
cosines with respect to the local shape coordinate system. This method 
provides additional information according the value of <code>iact</code> input parameter:</p>
<ul>
<li><code>iact = 0</code>computes only safe distance and fill it at the location given by SAFE;</li>
<li><code>iact = 1</code>a proposed STEP is supplied. The safe distance 
is computed first. If this is bigger than STEP than the proposed step is
 approved and returned by the method since it does not cross the shape 
boundaries. Otherwise, the distance to exiting the shape is computed and
 returned;</li>
<li><code>iact = 2</code>computes both safe distance and distance to exiting, ignoring the proposed step;</li>
<li><code>iact &gt; 2</code>computes only the distance to exiting, ignoring anything else</li>
</ul>
<div class="sourceCode" id="cb1010"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1010-1" title="1"><span class="dt">Double_t</span> TGeoShape::DistFromOutside(<span class="dt">Double_t</span> *point[<span class="dv">3</span>],</a>
<a class="sourceLine" id="cb1010-2" title="2"><span class="dt">Double_t</span> *dir[<span class="dv">3</span>],<span class="dt">Int_t</span> iact,<span class="dt">Double_t</span> step,<span class="dt">Double_t</span> *safe);</a></code></pre></div>
<p>This method computes the distance to entering a shape from a given point <code>outside</code>. It acts in the same way as the previous method.</p>
<div class="sourceCode" id="cb1011"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1011-1" title="1"><span class="dt">Double_t</span> TGeoShape::Safety(<span class="dt">Double_t</span> *point[<span class="dv">3</span>],<span class="dt">Bool_t</span> inside);</a></code></pre></div>
<p>This computes the maximum shift of a point in any direction that does not change its <code>inside/outside</code>state (does not cross shape boundaries). The state of the point has to be properly supplied.</p>
<div class="sourceCode" id="cb1012"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1012-1" title="1"><span class="dt">Double_t</span> *TGeoShape::ComputeNormal(<span class="dt">Double_t</span> *point[<span class="dv">3</span>],</a>
<a class="sourceLine" id="cb1012-2" title="2"><span class="dt">Double_t</span> *dir[<span class="dv">3</span>],<span class="dt">Double_t</span> *norm[<span class="dv">3</span>]);</a></code></pre></div>
<p>The method above computes the director cosines of normal to the 
crossed shape surface from a given point towards direction. This is 
filled into the <code>norm</code> array, supplied by the user. The 
normal vector is always chosen such that its dot product with the 
direction is positive defined.</p>
<h3 id="creating-shapes"><span class="header-section-number">18.3.5</span> Creating Shapes</h3>
<p>Shape objects embeds only the minimum set of parameters that are 
fully describing a valid physical shape. For instance, the half-length, 
the minimum and maximum radius represent a tube. Shapes are used 
together with media in order to create volumes, which in their turn are 
the main components of the geometrical tree. A specific shape can be 
created stand-alone:</p>
<div class="sourceCode" id="cb1013"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1013-1" title="1">TGeoBBox *box = <span class="kw">new</span> TGeoBBox(<span class="st">"s_box"</span>,halfX,halfY,halfZ); <span class="co">// named</span></a>
<a class="sourceLine" id="cb1013-2" title="2">TGeoTube *tub = <span class="kw">new</span> TGeoTube(rmin,rmax,halfZ); <span class="co">// no name</span></a>
<a class="sourceLine" id="cb1013-3" title="3"><span class="co">//...  (See all specific shape constructors)</span></a></code></pre></div>
<p>Sometimes it is much easier to create a volume having a given shape 
in one step, since shapes are not directly linked in the geometrical 
tree but volumes are:</p>
<div class="sourceCode" id="cb1014"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1014-1" title="1">TGeoVolume *vol_box = gGeoManager-&gt;MakeBox(<span class="st">"BOX_VOL"</span>,pmed,halfX,</a>
<a class="sourceLine" id="cb1014-2" title="2">halfY,halfZ);</a>
<a class="sourceLine" id="cb1014-3" title="3">TGeoVolume *vol_tub = gGeoManager-&gt;MakeTube(<span class="st">"TUB_VOL"</span>,pmed,rmin,</a>
<a class="sourceLine" id="cb1014-4" title="4">rmax,halfZ);</a>
<a class="sourceLine" id="cb1014-5" title="5"><span class="co">// ...(See MakeXXX() utilities in TGeoManager class)</span></a></code></pre></div>
<h3 id="dividing-shapes"><span class="header-section-number">18.3.6</span> Dividing Shapes</h3>
<p>Shapes can generally be divided along a given axis. Supported axes are: <code>X</code>, <code>Y</code>, <code>Z</code>, <code>Rxy</code>, <code>Phi</code>, <code>Rxyz</code>.
 A given shape cannot be divided however on any axis. The general rule 
is that that divisions are possible on whatever axis that produces still
 known shapes as slices. The division of shapes are performed by the 
call <code>TGeoShape::Divide()</code>, but this operation can be done only via <code>TGeoVolume::Divide()</code>
 method. In other words, the algorithm for dividing a specific shape is 
known by the shape object, but is always invoked in a generic way from 
the volume level. Details on how to do that can be found in the 
paragraph ‘Dividing volumes’. One can see how all division options are 
interpreted and which their result inside specific shape classes is.</p>
<h3 id="parametric-shapes"><span class="header-section-number">18.3.7</span> Parametric Shapes</h3>
<p>Shapes generally have a set of parameters that is well defined at 
build time. In fact, when the final geometrical hierarchy is assembled 
and the geometry is closed, all constituent shapes <code>MUST</code>**have well defined and valid parameters. In order to ease-up geometry creation, some parameterizations are however allowed.</p>
<p>For instance let’s suppose that we need to define several volumes 
having exactly the same properties but different sizes. A way to do this
 would be to create as many different volumes and shapes. The modeller 
allows however the definition of a single volume having undefined shape 
parameters.</p>
<div class="sourceCode" id="cb1015"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1015-1" title="1">TGeoManager::Volume(<span class="at">const</span> <span class="dt">char</span> *name,<span class="at">const</span> <span class="dt">char</span> *shape,<span class="dt">Int_t</span> nmed);</a></code></pre></div>
<ul>
<li><code>name:</code> the name of the newly created volume;</li>
<li><code>shape:</code>the type of the associated shape. This has to 
contain the case-insensitive first 4 letters of the corresponding class 
name (e.g.&nbsp;“<code>tubs</code>” will match <strong><code>TGeoTubeSeg</code></strong>, “<code>bbox</code>” will match <strong><code>TGeoBBox</code></strong>)</li>
<li><code>nmed:</code> the medium number.</li>
</ul>
<p>This will create a special volume that will not be directly used in 
the geometry, but whenever positioned will require a list of actual 
parameters for the current shape that will be created in this process. 
Such volumes having shape parameters known only when used have to be 
positioned only with <strong><code>TGeoManager::Node()</code> method (see ‘Creating and Positioning Volumes’).</strong></p>
<p>Other case when shape parameterizations are quite useful is scaling 
geometry structures. Imagine that we would like to enlarge/shrink a 
detector structure on one or more axes. This happens quite often in real
 life and is handled by “fitting mother” parameters. This is 
accomplished by defining shapes with one or more invalid (negative) 
parameters. For instance, defining a box having <code>dx=10.</code>, <code>dy=10.</code>, and <code>dz=-1</code> will not generate an error but will be interpreted in a different way: A special volume <strong><code>TGeoVolumeMulti</code></strong> will be created. Whenever positioned inside a mother volume, this will create a normal <strong><code>TGeoVolume</code></strong> object having as shape a box with <code>dz</code> fitting the corresponding <code>dz</code>of
 the mother shape. Generally, this type of parameterization is used when
 positioning volumes in containers having a matching shape, but it works
 also for most reasonable combinations.</p>
<h2 id="geometry-creation"><span class="header-section-number">18.4</span> Geometry Creation</h2>
<p>A given geometry can be built in various ways, but one has to follow 
some mandatory steps. Even if we might use some terms that will be 
explained later, here are few general rules:</p>
<ul>
<li>Volumes need media and shapes in order to be created.</li>
<li>Both containers and contained volumes must be created before linking
 them together, and the relative transformation matrix must be provided.</li>
<li>Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.</li>
<li>Visibility or tracking properties of volumes can be provided both at
 build time or after geometry is closed, but global visualization 
settings (see section: “The Drawing Package”) should not be provided at 
build time, otherwise the drawing package will be loaded.</li>
</ul>
<p>There is also a list of specific rules:</p>
<ul>
<li>Positioned volumes should not extrude their container or intersect 
with others within this unless it is specified (see section: Overlapping
 Volumes).</li>
<li>The top volume (containing all geometry trees) must be specified 
before closing the geometry and must not be positioned - it represents 
the global reference frame.</li>
<li>After building the full geometry tree, the geometry must be closed (see the method <strong><code>TGeoManager</code></strong><code>::CloseGeometry()</code>). Voxelization can be redone per volume after this process.</li>
</ul>
<p>The list is much bigger and we will describe in more detail the 
geometry creation procedure in the following sections. Provided that 
geometry was successfully built and closed, the <strong><code>TGeoManager</code></strong> class will register itself to ROOT and the logical/physical structures will become immediately browsable.</p>
<h3 id="the-volume-hierarchy"><span class="header-section-number">18.4.1</span> The Volume Hierarchy</h3>
<p>The basic components used for building the logical hierarchy of the geometry are the positioned volumes called <code>nodes</code>.
 Volumes are fully defined geometrical objects having a given shape and 
medium and possibly containing a list of nodes. Nodes represent just 
positioned instances of volumes inside a container volume but users do 
not directly create them. They are automatically created as a result of 
adding one volume inside other or dividing a volume. The geometrical 
transformation held by nodes is always defined with respect to their 
mother (relative positioning). Reflection matrices are allowed.</p>
<p>A hierarchical element is not fully defined by a node since nodes are
 not directly linked to each other, but through volumes (a node points 
to a volume, which at its turn points to a list of nodes):</p>
<p><code>NodeTop</code> <code>VolTop</code> <code>NodeA</code> <code>VolA</code> <code>...</code></p>
<p>One can therefore talk about “the node or volume hierarchy”, but in 
fact, an element is made by a pair volume-node. In the line above is 
represented just a single branch, but of course from any volume other 
branches can also emerge. The index of a node in such a branch (counting
 only nodes) is called <code>depth</code>. The top node have always <code>depth=0</code>.</p>
<p>Volumes need to have their daughter nodes defined when the geometry is closed. They will build additional structures (called <code>voxels</code>
 ) in order to fasten-up the search algorithms. Finally, nodes can be 
regarded as bi-directional links between containers and contained 
volumes.</p>
<p>The structure defined in this way is a graph structure since volumes 
are replicable (same volume can become daughter node of several other 
volumes), every volume becoming a branch in this graph. Any volume in 
the logical graph can become the actual top volume at run time (see <strong><code>TGeoManager::SetTopVolume()</code>).
 All functionalities of the modeller will behave in this case as if only
 the corresponding branch starting from this volume is the active 
geometry.</strong></p>
<figure>
<img src="ROOTUsersGuide_files/030001CE.png" alt="A geometry hierarchy in memory"><figcaption>A geometry hierarchy in memory</figcaption>
</figure>
<p>Nodes are never instantiated directly by users, but created as a 
result of volume operations. Adding a volume named A with a given <code>user id</code> inside a volume B will create a node named <code>A_id.</code>
 This will be added to the list of nodes stored by B. In addition, when 
applying a division operation in N slices to a volume A, a list of nodes
 <code>B_1</code>, <code>B_2</code>, … , <code>B_N</code> is also created. A node <code>B_i</code>
 does not represent a unique object in the geometry because its 
container A might be at its turn positioned as node inside several other
 volumes. Only when a complete branch of nodes is fully defined up to 
the top node in the geometry, a given path:<code>/TOP_1/</code>…<code>/A_3/B_7</code>
 will represent a unique object. Its global transformation matrix can be
 computed as the pile-up of all local transformations in its branch. We 
will therefore call <code>logical graph</code> the hierarchy defined by 
nodes and volumes. The expansion of the logical graph by all possible 
paths defines a tree structure where all nodes are unique “touchable” 
objects. We will call this the “physical tree”. Unlike the logical 
graph, the physical tree can become a huge structure with several 
millions of nodes in case of complex geometries; therefore, it is not 
always a good idea to keep it transient in memory. Since the logical and
 physical structures are correlated, the modeller rather keeps track 
only of the current branch, updating the current global matrix at each 
change of the level in geometry. The current physical node is not an 
object that can be asked for at a given moment, but rather represented 
by the combination: current node/current global matrix. However, 
physical nodes have unique ID’s that can be retrieved for a given 
modeller state. These can be fed back to the modeller in order to force a
 physical node to become current. The advantage of this comes from the 
fact that all navigation queries check first the current node; therefore
 the location of a point in the geometry can be saved as a starting 
state for later use.</p>
<p>Nodes can be declared as <code>overlapping</code> in case they do 
overlap with other nodes inside the same container or extrude this 
container (see also ‘Checking the Geometry’). Non-overlapping nodes can 
be created with:</p>
<div class="sourceCode" id="cb1016"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1016-1" title="1">TGeoVolume::AddNode(TGeoVolume *daughter,<span class="dt">Int_t</span> copy_No,</a>
<a class="sourceLine" id="cb1016-2" title="2">TGeoMatrix *matr);</a></code></pre></div>
<p>The creation of overlapping nodes can be done with a similar prototype:</p>
<div class="sourceCode" id="cb1017"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1017-1" title="1">TGeoVolume::AddNodeOverlap(<span class="co">/*same arguments*/</span>);</a></code></pre></div>
<p>When closing the geometry, overlapping nodes perform a check of 
possible overlaps with their neighbors. These are stored and checked all
 the time during navigation; therefore, navigation is slower when 
embedding such nodes into geometry. Nodes have visualization attributes 
as the volume has. When undefined by users, painting a node on a pad 
will take the corresponding volume attributes.</p>
<h3 id="creating-and-positioning-volumes"><span class="header-section-number">18.4.2</span> Creating and Positioning Volumes</h3>
<h4 id="making-volumes"><span class="header-section-number">18.4.2.1</span> Making Volumes</h4>
<p>As mentioned before, volumes are the basic objects used in building 
the geometrical hierarchy. They represent objects that are not 
positioned, but store all information about the placement of the other 
volumes they may contain. Therefore a volume can be replicated several 
times in the geometry. As it was explained, in order to create a volume,
 one has to put together a shape and a medium, which are already 
defined.</p>
<p>Volumes have to be named by users at creation time. Every different 
name may represent a unique volume object, but may also represent more 
general a family (class) of volume objects having the same shape type 
and medium, but possibly different shape parameters. It is the user’s 
task to provide different names for different volume families in order 
to avoid ambiguities at tracking time.</p>
<p>A generic family rather than a single volume is created only in two 
cases: when a parametric shape is used or when a division operation is 
applied. Each volume in the geometry stores a unique ID corresponding to
 its family. In order to ease-up their creation, the manager class is 
providing an API that allows making a shape and a volume in a single 
step.</p>
<h4 id="example-of-volume-creation"><span class="header-section-number">18.4.2.2</span> Example of Volume Creation</h4>
<div class="sourceCode" id="cb1018"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1018-1" title="1"><span class="co">// Making a volume out of a shape and a medium.</span></a>
<a class="sourceLine" id="cb1018-2" title="2">TGeoVolume *vol = <span class="kw">new</span> TGeoVolume(<span class="st">"VNAME"</span>,ptrShape,ptrMed);</a>
<a class="sourceLine" id="cb1018-3" title="3"></a>
<a class="sourceLine" id="cb1018-4" title="4"><span class="co">// Making a volume out of a shape but without a defined medium.</span></a>
<a class="sourceLine" id="cb1018-5" title="5">TGeoVolume *vol = <span class="kw">new</span> TGeoVolume(<span class="st">"VNAME"</span>,ptrShape);</a>
<a class="sourceLine" id="cb1018-6" title="6"></a>
<a class="sourceLine" id="cb1018-7" title="7"><span class="co">// Making a volume with a given shape in one step</span></a>
<a class="sourceLine" id="cb1018-8" title="8">TGeoVolume *vol = gGeoManager-&gt;MakeBox(<span class="st">"VNAME"</span>,ptrMed,dx,dy,dz);</a>
<a class="sourceLine" id="cb1018-9" title="9">TGeoVolume *vol = gGeoManager-&gt;MakeTubs(<span class="st">"VNAME"</span>,ptrMed,rmin,rmax,</a>
<a class="sourceLine" id="cb1018-10" title="10">dz,phi1,phi2);</a>
<a class="sourceLine" id="cb1018-11" title="11"></a>
<a class="sourceLine" id="cb1018-12" title="12"><span class="co">// See class TGeoManager for the rest of shapes.</span></a>
<a class="sourceLine" id="cb1018-13" title="13"><span class="co">// Making a volume with a given shape with a unique prototype</span></a>
<a class="sourceLine" id="cb1018-14" title="14">TGeoVolume *vol = gGeoManager-&gt;Volume(<span class="st">"VNAME"</span>,<span class="st">"XXXX"</span>,nmed,upar,</a>
<a class="sourceLine" id="cb1018-15" title="15">npar);</a>
<a class="sourceLine" id="cb1018-16" title="16"></a>
<a class="sourceLine" id="cb1018-17" title="17"><span class="co">// Where XXXX stands for the first 4 letters of the specific shape</span></a>
<a class="sourceLine" id="cb1018-18" title="18"><span class="co">// classes, nmed is the medium number, upar is an Double_t * array</span></a>
<a class="sourceLine" id="cb1018-19" title="19"><span class="co">// of the shape parameters and npar is the number of parameters.</span></a>
<a class="sourceLine" id="cb1018-20" title="20"><span class="co">// This prototype allows (npar = 0) to define volumes with shape</span></a>
<a class="sourceLine" id="cb1018-21" title="21"><span class="co">// defined only at positioning time (volumes defined in this way</span></a>
<a class="sourceLine" id="cb1018-22" title="22"><span class="co">// need to be positioned using TGeoManager::Node() method)</span></a></code></pre></div>
<h4 id="positioned-volumes-nodes"><span class="header-section-number">18.4.2.3</span> Positioned Volumes (Nodes)</h4>
<p>Geometrical modeling is a difficult task when the number of different
 geometrical objects is 106-108. This is more or less the case for 
detector geometries of complex experiments, where a ‘flat’ CSG model 
description cannot scale with the current CPU performances. This is the 
reason why models like GEANT [1] introduced an additional dimension 
(depth) in order to reduce the complexity of the problem. This concept 
is also preserved by the ROOT modeller and introduces a pure geometrical
 constraint between objects (volumes in our case) - containment. This 
means in fact that any positioned volume has to be contained by another.
 Now what means contained and positioned?</p>
<ul>
<li>We will say that a volume <code>contains</code> a point if this is 
inside the shape associated to the volume. For instance, a volume having
 a box shape will contain all points <code>P=(X,Y,Z)</code> verifying the conditions: <code>Abs(Pi)dXi</code>.
 The points on the shape boundaries are considered as inside the volume.
 The volume contains a daughter if it contains all the points contained 
by the daughter.</li>
<li>The definition of containment works of course only with points defined in the local coordinate system of the considered volume. <code>Positioning</code> a volume inside another have to introduce a geometrical transformation between the two. If <code>M</code> defines this transformation, any point in the daughter reference can be converted to the mother reference by: <code>Pmother = MPdaughter</code></li>
</ul>
<p>When creating a volume one does not specify if this will contain or 
not other volumes. Adding daughters to a volume implies creating those 
and adding them one by one to the list of daughters. Since the volume 
has to know the position of all its daughters, we will have to supply at
 the same time a geometrical transformation with respect to its local 
reference frame for each of them.</p>
<div class="sourceCode" id="cb1019"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1019-1" title="1">TGeoVolume::AddNode(TGeoVolume *daughter,<span class="dt">Int_t</span> usernumber,</a>
<a class="sourceLine" id="cb1019-2" title="2">TGeoMatrix *matrix=gGeoIdentity)</a></code></pre></div>
<p>The objects referencing a volume and a transformation are called <code>NODES</code>
 and their creation is fully handled by the modeller. They represent the
 link elements in the hierarchy of volumes. Nodes are unique and 
distinct geometrical objects ONLY from their container point of view. 
Since volumes can be replicated in the geometry, the same node may be 
found on different branches.</p>
<p>In order to provide navigation features, volumes have to be able to 
find the proper container of any point defined in the local reference 
frame. This can be the volume itself, one of its positioned daughter 
volumes or none if the point is actually outside. On the other hand, 
volumes have to provide also other navigation methods such as finding 
the distances to its shape boundaries or which daughter will be crossed 
first. The implementation of these features is done at shape level, but 
the local mother-daughters management is handled by volumes. These build
 additional optimization structures upon geometry closure. In order to 
have navigation features properly working one has to follow some rules 
for building a valid geometry.</p>
<ul>
<li>The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.</li>
<li>The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex.</li>
</ul>
<p>The daughter nodes of a volume can be also removed or replaced with other nodes:</p>
<div class="sourceCode" id="cb1020"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1020-1" title="1"><span class="dt">void</span> RemoveNode(TGeoNode* node)</a>
<a class="sourceLine" id="cb1020-2" title="2">TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1020-3" title="3">TGeoMatrix* newpos = <span class="dv">0</span>, TGeoMedium* newmed = <span class="dv">0</span>)</a></code></pre></div>
<p>The last method allows replacing an existing daughter of a volume 
with another one. Providing only the node to be replaced will just 
create a new volume for the node but having exactly the same parameters 
as the old one. This helps in case of divisions for decoupling a node 
from the logical hierarchy so getting new content/properties. For 
non-divided volumes, one can change the shape and/or the position of the
 daughter.</p>
<h4 id="virtual-containers-and-assemblies-of-volumes"><span class="header-section-number">18.4.2.4</span> Virtual Containers and Assemblies of Volumes</h4>
<p>Virtual containers are volumes that do not represent real objects, 
but they are needed for grouping and positioning together other volumes.
 Such grouping helps not only geometry creation, but also optimizes 
tracking performance; therefore, it is highly recommended. Virtual 
volumes need to inherit material/medium properties from the volume they 
are placed into in order to be “invisible” at tracking time.</p>
<p>Let us suppose that we need to group together two volumes <code>A</code> and <code>B</code> into a structure and position this into several other volumes <code>D,E,</code> and <code>F</code>. What we need to do is to create a virtual container volume <code>C</code> holding <code>A</code> and <code>B</code>, then position <code>C</code> in the other volumes.</p>
<p>Note that <code>C</code> is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of <code>D,E</code> or <code>F</code> in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that <code>D,E,</code> and <code>F</code> must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: <code>C</code>, <code>C'</code> and <code>C"</code>,
 having the same shape but different media matching the corresponding 
containers. This might not happen so often, but when it does, it forces 
the creation of several extra virtual volumes. Other limitation comes 
from the fact that any container is directly used by navigation 
algorithms to optimize tracking. These must geometrically contain their 
belongings (positioned volumes) so that these do not extrude its shape 
boundaries. Not respecting this rule generally leads to unpredictable 
results. Therefore <code>A</code> and <code>B</code> together must fit into <code>C</code> that has to fit also into <code>D,E,</code> and <code>F</code>. This is not always straightforward to accomplish, especially when instead of <code>A</code> and <code>B</code> we have many more volumes.</p>
<p>In order to avoid these problems, one can use for the difficult cases the class <strong><code>TGeoVolumeAssembly</code></strong>,
 representing an assembly of volumes. This behaves like a normal 
container volume supporting other volumes positioned inside, but it has 
neither shape nor medium. It cannot be used directly as a piece of the 
geometry, but just as a temporary structure helping temporary assembling
 and positioning volumes.</p>
<p>If we define now <code>C</code> as an assembly containing <code>A</code> and <code>B</code>, positioning the assembly into <code>D,E</code> and <code>F</code> will actually position only <code>A</code> and <code>B</code>directly into these volumes, taking into account their combined transformations <code>A/B</code> to <code>C</code> and <code>C</code> to <code>D/E/F</code>. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume <code>C</code> in our geometry, but we end-up with a more flat structure for <code>D,E</code> and <code>F</code> (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.</p>
<p>For deciding what to choose between using virtual containers or 
assemblies for a specific case, one can use for both cases, after the 
geometry was closed:</p>
<div class="sourceCode" id="cb1021"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1021-1" title="1">gGeoManager-&gt;SetTopVolume(ptr_D);</a>
<a class="sourceLine" id="cb1021-2" title="2">gGeoManager-&gt;Test();</a>
<a class="sourceLine" id="cb1021-3" title="3">gGeoManager-&gt;RestoreMasterVolume();</a></code></pre></div>
<p>The <code>ptr_D</code> is a pointer to volume <code>D</code> containing the interesting structure. The test will provide the timing for classifying 1 million random points inside <code>D</code>.</p>
<h4 id="examples-of-volume-positioning"><span class="header-section-number">18.4.2.5</span> Examples of Volume Positioning</h4>
<p>Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see <strong><code>TGeoMedium</code></strong> class on how to create media).</p>
<p>We will create a <code>TUBE</code> shape for our wire, having <code>Rmin=0cm</code>, <code>Rmax=0.01cm</code> and a half-length <code>dZ=1cm</code>:</p>
<div class="sourceCode" id="cb1022"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1022-1" title="1">TGeoTube *tube = <span class="kw">new</span> TGeoTube(<span class="st">"wire_tube"</span>,<span class="dv">0</span>,<span class="fl">0.01</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>One may omit the name for the shape <code>wire_tube,</code> if no 
retrieving by name is further needed during geometry building. Different
 volumes having different names and materials can share the same shape.</p>
<p>Now let’s make the volume for our wire:</p>
<div class="sourceCode" id="cb1023"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1023-1" title="1">TGeoVolume *wire_co = <span class="kw">new</span> TGeoVolume(<span class="st">"WIRE_CO"</span>,tube,</a>
<a class="sourceLine" id="cb1023-2" title="2">ptrCOPPER); <span class="co">//(*)</span></a></code></pre></div>
<p><strong>(*)</strong> Do not bother to delete the media, shapes or 
volumes that you have created since all will be automatically cleaned on
 exit by the manager class.</p>
<p>If we would have taken a look inside <code>TGeoManager::MakeTube()</code> method, we would have been able to create our wire with a single line:</p>
<div class="sourceCode" id="cb1024"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1024-1" title="1">TGeoVolume *wire_co = gGeoManager-&gt;MakeTube(<span class="st">"WIRE_CO"</span>,ptrCOPPER,</a>
<a class="sourceLine" id="cb1024-2" title="2"><span class="dv">0</span>,<span class="fl">0.01</span>,<span class="dv">1</span>); <span class="co">//(*)</span></a></code></pre></div>
<p><strong>(*)</strong> The same applies for all primitive shapes, for which there can be found corresponding <code>MakeSHAPE()</code> methods. Their usage is much more convenient unless a shape has to be shared between more volumes.</p>
<p>Let us make now an aluminum wire having the same shape, supposing that we have created the copper wire with the line above:</p>
<div class="sourceCode" id="cb1025"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1025-1" title="1">TGeoVolume *wire_al = <span class="kw">new</span> TGeoVolume(<span class="st">"WIRE_AL"</span>,wire_co&gt;GetShape(),</a>
<a class="sourceLine" id="cb1025-2" title="2">ptrAL);</a></code></pre></div>
<p>We would like now to position our wire in the middle of a gas chamber. We need first to define the gas chamber:</p>
<div class="sourceCode" id="cb1026"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1026-1" title="1">TGeoVolume *chamber = gGeoManager-&gt;MakeTube(<span class="st">"CHAMBER"</span>,ptrGAS,</a>
<a class="sourceLine" id="cb1026-2" title="2"><span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>Now we can put the wire inside:</p>
<div class="sourceCode" id="cb1027"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1027-1" title="1">chamber-&gt;AddNode(wire_co,<span class="dv">1</span>);</a></code></pre></div>
<p>If we inspect now the chamber volume in a browser, we will notice 
that it has one daughter. Of course, the gas has some container also, 
but let us keeps it like that for the sake of simplicity. Since we did 
not supply the third argument, the wire will be positioned with an 
identity transformation inside the chamber.</p>
<h4 id="overlapping-volumes"><span class="header-section-number">18.4.2.6</span> Overlapping Volumes</h4>
<p>Positioning volumes that does not overlap their neighbors nor extrude
 their container is sometimes quite strong constraint. Having a limited 
set of geometric shapes might force sometimes overlaps. Since 
overlapping is contradictory to containment, a point belonging to an 
overlapping region will naturally belong to all overlapping partners. 
The answer provided by the modeller to “Where am I?” is no longer 
deterministic if there is no priority assigned.</p>
<p>There are two ways out provided by the modeller in such cases and we will illustrate them by examples.</p>
<ul>
<li>Suppose we have 2 crossing tubes that we have to describe. Such a 
structure cannot be decomposed in a containment schema. This is a 
typical example of simple structure that can be handled by using 
composite shapes. What we have to do is to define as shapes the inner 
and outer parts of the tubes (tubes having <code>Rmin=0</code>,<code>Rmax=</code>inner/outer radius), then to make a composite:</li>
<li><code>C = (Tub1out+Tub2out)-(Tub1in+Tub2in)</code></li>
<li>On the other hand, if we have an EM calorimeter having a honeycomb 
structure, Boolean combinations do not help anymore. Here the problem is
 that we usually have a very large number of cells that are naturally 
belonging to the same container. This result in a very flat and slow 
structure for that particular container, which we would very much want 
to avoid by introducing additional levels in depth. We can describe the 
basic cell as a hexahedron that we can represent by using a polygon 
primitive shape. Instead of putting one by one all cells in the same 
container, we can define rows of such elements, fitting in box-shaped 
containers. Then we can put row-beside-row inside the container, making 
life much easier for its navigation algorithms. The problem is that in 
order to reproduce the honeycomb structure out of rows of cells, we have
 to overlap row containers. Whoops - we have not obeyed rule No.&nbsp;2 
in positioning. The way out is to position our rows with a special 
prototype:</li>
</ul>
<div class="sourceCode" id="cb1028"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1028-1" title="1">ptrCAL-&gt;AddNodeOverlap(<span class="st">"ROW"</span>,nRow,matrixRow);</a></code></pre></div>
<p>This will instruct the modeller that the daughter ROW inside CAL 
overlaps with something else. The modeller will check this at closure 
time and build a list of possibly overlapping candidates. This option is
 equivalent with the option MANY in GEANT3.</p>
<p>The modeller supports such cases only if user declares the overlapping nodes. In order to do that, one should use <strong><code>TGeoVolume</code></strong><code>::AddNodeOverlap()</code> instead of <code>TGeoVolume::AddNode()</code>.
 When two or more positioned volumes are overlapping, not all of them 
have to be declared so, but at least one. A point inside an overlapping 
region equally belongs to all overlapping nodes, but the way these are 
defined can enforce the modeller to give priorities.</p>
<p>The general rule is that the deepest node in the hierarchy containing
 a point has the highest priority. For the same geometry level, 
non-overlapping is prioritized over overlapping. In order to illustrate 
this, we will consider few examples. We will designate non-overlapping 
nodes as ONLY and the others MANY as in GEANT3, where this concept was 
introduced:</p>
<ol type="1">
<li><p>The part of a MANY node B extruding its container A will never be
 “seen” during navigation, as if B was in fact the result of the 
intersection of A and B.</p></li>
<li><p>If we have two nodes A (ONLY) and B (MANY) inside the same 
container, all points in the overlapping region of A and B will be 
designated as belonging to A.</p></li>
<li><p>If A an B in the above case were both MANY, points in the 
overlapping part will be designated to the one defined first. Both nodes
 must have the same medium.</p></li>
<li><p>The slices of a divided MANY will be as well MANY.</p></li>
</ol>
<p>One needs to know that navigation inside geometry parts MANY nodes is
 much slower. Any overlapping part can be defined based on composite 
shapes - might be in some cases a better way out.</p>
<h4 id="replicating-volumes"><span class="header-section-number">18.4.2.7</span> Replicating Volumes</h4>
<p>What can we do if our chamber contains two identical wires instead of
 one? What if then we would need 1000 chambers in our detector? Should 
we create 2000 wires and 1000 chamber volumes? No, we will just need to 
replicate the ones that we have already created.</p>
<div class="sourceCode" id="cb1029"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1029-1" title="1">chamber-&gt;AddNode(wire_co,<span class="dv">1</span>,<span class="kw">new</span> TGeoTranslation(<span class="fl">0.2</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1029-2" title="2">chamber-&gt;AddNode(wire_co,<span class="dv">2</span>,<span class="kw">new</span> TGeoTranslation(<span class="fl">0.2</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a></code></pre></div>
<p>The 2 nodes that we have created inside chamber will both point to a <code>wire_co</code> object, but will be completely distinct: <code>WIRE_CO_1</code> and <code>WIRE_CO_2</code>.
 We will want now to place symmetrically 1000 chambers on a pad, 
following a pattern of 20 rows and 50 columns. One way to do this will 
be to replicate our chamber by positioning it 1000 times in different 
positions of the pad. Unfortunately, this is far from being the optimal 
way of doing what we want. Imagine that we would like to find out which 
of the 1000 chambers is containing a <code>(x,y,z)</code> point defined 
in the pad reference. You will never have to do that, since the modeller
 will take care of it for you, but let’s guess what it has to do. The 
most simple algorithm will just loop over all daughters, convert the 
point from mother to local reference and check if the current chamber 
contains the point or not. This might be efficient for pads with few 
chambers, but definitely not for 1000. Fortunately the modeller is 
smarter than that and creates for each volume some optimization 
structures called <code>voxels</code> to minimize the penalty having too
 many daughters, but if you have 100 pads like this in your geometry you
 will anyway lose a lot in your tracking performance. The way out when 
volumes can be arranged according to simple patterns is the usage of 
divisions. We will describe them in detail later on. Let’s think now at a
 different situation: instead of 1000 chambers of the same type, we may 
have several types of chambers. Let’s say all chambers are cylindrical 
and have a wire inside, but their dimensions are different. However, we 
would like all to be represented by a single volume family, since they 
have the same properties.</p>
<h4 id="volume-families"><span class="header-section-number">18.4.2.8</span> Volume Families</h4>
<p>A volume family is represented by the class <strong><code>TGeoVolumeMulti</code></strong>.
 It represents a class of volumes having the same shape type and each 
member will be identified by the same name and volume ID. Any operation 
applied to a <strong><code>TGeoVolumeMulti</code></strong> equally 
affects all volumes in that family. The creation of a family is 
generally not a user task, but can be forced in particular cases:</p>
<div class="sourceCode" id="cb1030"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1030-1" title="1">TGeoManager::Volume(<span class="at">const</span> <span class="dt">char</span> *vname,<span class="at">const</span> <span class="dt">char</span> *shape,</a>
<a class="sourceLine" id="cb1030-2" title="2"><span class="dt">Int_t</span> nmed);</a></code></pre></div>
<p>Where: <code>vname</code> is the family name, <code>nmed</code> is the medium number and <code>shape</code> is the shape type that can be:</p>
<ul>
<li><code>box</code>for <strong><code>TGeoBBox</code></strong></li>
<li><code>trd1</code>for <strong><code>TGeoTrd1</code></strong></li>
<li><code>trd2</code>for <strong><code>TGeoTrd2</code></strong></li>
<li><code>trap</code>for <strong><code>TGeoTrap</code></strong></li>
<li><code>gtra</code>for <strong><code>TGeoGtra</code></strong></li>
<li><code>para</code>for <strong><code>TGeoPara</code></strong></li>
<li><code>tube</code>, <code>tubs</code>for <strong><code>TGeoTube</code></strong>, <strong><code>TGeoTubeSeg</code></strong></li>
<li><code>cone</code>, <code>cons</code>for <strong><code>TGeoCone</code></strong>, <strong><code>TGeoCons</code></strong></li>
<li><code>eltu</code>for <strong><code>TGeoEltu</code></strong></li>
<li><code>ctub</code>for <strong><code>TGeoCtub</code></strong></li>
<li><code>pcon</code>for <strong><code>TGeoPcon</code></strong></li>
<li><code>pgon</code>for <strong><code>TGeoPgon</code></strong></li>
</ul>
<p>Volumes are then added to a given family upon adding the generic name as node inside other volume:</p>
<div class="sourceCode" id="cb1031"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1031-1" title="1">TGeoVolume *box_family = gGeoManager-&gt;Volume(<span class="st">"BOXES"</span>,<span class="st">"box"</span>,nmed);</a>
<a class="sourceLine" id="cb1031-2" title="2"><span class="co">//   ...</span></a>
<a class="sourceLine" id="cb1031-3" title="3">gGeoManager-&gt;Node(<span class="st">"BOXES"</span>,<span class="dt">Int_t</span> copy_no,<span class="st">"mother_name"</span>,<span class="dt">Double_t</span> x,</a>
<a class="sourceLine" id="cb1031-4" title="4"><span class="dt">Double_t</span> y,<span class="dt">Double_t</span> z,<span class="dt">Int_t</span> rot_index,<span class="dt">Bool_t</span> is_only,</a>
<a class="sourceLine" id="cb1031-5" title="5"><span class="dt">Double_t</span> *upar,<span class="dt">Int_t</span> npar);</a></code></pre></div>
<ul>
<li><code>BOXES</code>- name of the family of boxes</li>
<li><code>copy_no</code>- user node number for the created node</li>
<li><code>mother_name</code>- name of the volume to which we want to add the node</li>
<li><code>x,y,z</code>- translation components</li>
<li><code>rot_index</code>- index of a rotation matrix in the list of matrices</li>
<li><code>upar</code>- array of actual shape parameters</li>
<li><code>npar</code>- number of parameters</li>
</ul>
<p>The parameters order and number are the same as in the corresponding 
shape constructors. Another particular case where volume families are 
used is when we want that a volume positioned inside a container to 
match one ore more container limits. Suppose we want to position the 
same box inside 2 different volumes and we want the Z size to match the 
one of each container:</p>
<div class="sourceCode" id="cb1032"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1032-1" title="1">TGeoVolume *container1 = gGeoManager-&gt;MakeBox(<span class="st">"C1"</span>,imed,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">30</span>);</a>
<a class="sourceLine" id="cb1032-2" title="2">TGeoVolume *container2 = gGeoManager-&gt;MakeBox(<span class="st">"C2"</span>,imed,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1032-3" title="3">TGeoVolume *pvol       = gGeoManager-&gt;MakeBox(<span class="st">"PVOL"</span>,jmed,<span class="dv">3</span>,<span class="dv">3</span>,-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1032-4" title="4">container1-&gt;AddNode(pvol,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1032-5" title="5">container2-&gt;AddNode(pvol,<span class="dv">1</span>);</a></code></pre></div>
<p>Note that the third parameter of <code>PVOL</code> is negative, which
 does not make sense as half-length on Z. This is interpreted as: when 
positioned, create a box replacing all invalid parameters with the 
corresponding dimensions of the container. This is also internally 
handled by the <strong><code>TGeoVolumeMulti</code></strong> class, which does not need to be instantiated by users.</p>
<h4 id="dividing-volumes"><span class="header-section-number">18.4.2.9</span> Dividing Volumes</h4>
<p>Volumes can be divided according a pattern. The simplest division can be done along one axis that can be: <code>X,Y,Z,Phi,Rxy or Rxyz</code>.
 Let’s take a simple case: we would like to divide a box in N equal 
slices along X coordinate, representing a new volume family. Supposing 
we already have created the initial box, this can be done like:</p>
<div class="sourceCode" id="cb1033"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1033-1" title="1">TGeoVolume *slicex = box-&gt;Divide(<span class="st">"SLICEX"</span>,<span class="dv">1</span>,N);</a></code></pre></div>
<p>Here <code>SLICEX</code> is the name of the new family representing 
all slices and 1 is the slicing axis. The meaning of the axis index is 
the following: for all volumes having shapes like <code>box</code>, <code>trd1</code>, <code>trd2</code>, <code>trap</code>, <code>gtra</code>or<code>para -</code>1, 2, 3 mean X, Y, Z; for <code>tube</code>, <code>tubs</code>, <code>cone</code>, <code>cons -</code>1 means <code>Rxy</code>, 2 means <code>phi</code> and 3 means Z; for <code>pcon</code> and <code>pgon</code> - 2 means <code>phi</code> and 3 means Z; for spheres 1 means <code>R</code>and 2 means <code>phi.</code></p>
<p>In fact, the division operation has the same effect as positioning 
volumes in a given order inside the divided container - the advantage 
being that the navigation in such a structure is much faster. When a 
volume is divided, a volume family corresponding to the slices is 
created. In case all slices can be represented by a single shape, only 
one volume is added to the family and positioned N times inside the 
divided volume, otherwise, each slice will be represented by a distinct 
volume in the family.</p>
<p>Divisions can be also performed in a given range of one axis. For 
that, one has to specify also the starting coordinate value and the 
step:</p>
<div class="sourceCode" id="cb1034"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1034-1" title="1">TGeoVolume *slicex = box-&gt;Divide(<span class="st">"SLICEX"</span>,<span class="dv">1</span>,N,start,step);</a></code></pre></div>
<p>A check is always done on the resulting division range: if not 
fitting into the container limits, an error message is posted. If we 
will browse the divided volume we will notice that it will contain N 
nodes starting with index 1 up to N. The first one has the lower X limit
 at <code>START</code> position, while the last one will have the upper X limit at <code>START+N*STEP</code>.
 The resulting slices cannot be positioned inside another volume (they 
are by default positioned inside the divided one) but can be further 
divided and may contain other volumes:</p>
<div class="sourceCode" id="cb1035"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1035-1" title="1">TGeoVolume *slicey = slicex-&gt;Divide(<span class="st">"SLICEY"</span>,<span class="dv">2</span>,N1);</a>
<a class="sourceLine" id="cb1035-2" title="2">slicey-&gt;AddNode(other_vol,index,some_matrix);</a></code></pre></div>
<p>When doing that, we have to remember that <code>SLICEY</code> 
represents a family, therefore all members of the family will be divided
 on Y and the other volume will be added as node inside all.</p>
<p>In the example above all the resulting slices had the same shape as 
the divided volume (box). This is not always the case. For instance, 
dividing a volume with <code>TUBE</code> shape on <code>PHI</code>axis will create equal slices having <code>TUBESEG</code> shape. Other divisions can also create slices having shapes with different dimensions, e.g.&nbsp;the division of a <code>TRD1</code> volume on Z.</p>
<p>When positioning volumes inside slices, one can do it using the generic volume family (e.g.&nbsp;<code>slicey</code>).
 This should be done as if the coordinate system of the generic slice 
was the same as the one of the divided volume. The generic slice in case
 of <code>PHI</code> division is centered with respect to X-axis. If the
 family contains slices of different sizes, any volume positioned inside
 should fit into the smallest one.</p>
<p>Examples for specific divisions according to shape types can be found inside shape classes.</p>
<div class="sourceCode" id="cb1036"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1036-1" title="1">TGeoVolume::Divide(N,Xmin,Xmax,<span class="st">"X"</span>);</a></code></pre></div>
<p>Create a new volume by dividing an existing one (GEANT3 like).</p>
<p>Divides <code>MOTHER</code> into <code>NDIV</code> divisions called <code>NAME</code> along axis <code>IAXIS</code> starting at coordinate value <code>START</code> and having size <code>STEP</code>. The created volumes will have tracking media <code>ID=NUMED</code> (if <code>NUMED=0</code> -&gt; same media as <code>MOTHER</code>).</p>
<p>The behavior of the division operation can be triggered using <code>OPTION</code> (case insensitive):</p>
<ul>
<li><code>N</code>divide all range in <code>NDIV</code> cells (same effect as <code>STEP&lt;=0</code>) (GSDVN in G3)</li>
<li><code>NX</code>divide range starting with <code>START</code> in <code>NDIV</code> cells (GSDVN2 in G3)</li>
<li><code>S</code>divide all range with given <code>STEP</code>; <code>NDIV</code> is computed and divisions will be centered in full range (same effect as <code>NDIV&lt;=0</code>) (GSDVS, GSDVT in G3)</li>
<li><code>SX</code>same as <code>DVS</code>, but from <code>START</code> position (GSDVS2, GSDVT2 in G3)</li>
</ul>
<h4 id="volume-assemblies"><span class="header-section-number">18.4.2.10</span> Volume Assemblies</h4>
<p>In general, geometry contains structures of positioned volumes that 
have to be grouped and handled together, for different possible reasons.
 One of these is that the structure has to be replicated in several 
parts of the geometry, or it may simply happen that they really 
represent a single object, too complex to be described by a primitive 
shape.</p>
<p>Usually handling structures like these can be easily done by 
positioning all components in the same container volume, then 
positioning the container itself. However, there are many practical 
cases when defining such a container is not straightforward or even 
possible without generating overlaps with the rest of the geometry. 
There are few ways out of this:</p>
<ul>
<li>Defining the container for the structure as “overlapping” (see also " Overlapping Volumes <strong>"</strong>)</li>
<li>Representing the container as a composite shape - the Boolean union of all components (see also " Composite Shapes ")</li>
<li>Using an assembly volume - this will be described in the following.</li>
</ul>
<p>The first two approaches have the disadvantage of penalizing the 
navigation performance with a factor increasing more than linear of the 
number of components in the structure. The best solution is the third 
one because it uses all volume-related navigation optimizations. The 
class <strong><code>TGeoVolumeAssembly</code></strong> represents an assembly volume. Its shape is represented by <strong><code>TGeoShapeAssembly</code></strong> class that is the union of all components. It uses volume voxelization to perform navigation tasks.</p>
<p>An assembly volume creates a hierarchical level and it geometrically 
insulates the structure from the rest (as a normal volume). Physically, a
 point that is INSIDE a <strong><code>TGeoShapeAssembly</code></strong> is always inside one of the components, so a <strong><code>TGeoVolumeAssembly</code></strong>
 does not need to have a medium. Due to the self-containment of 
assemblies, they are very practical to use when a container is hard to 
define due to possible overlaps during positioning. For instance, it is 
very easy creating honeycomb structures. A very useful example for 
creating and using assemblies can be found at: <a href="http://root.cern.ch/root/html/examples/assembly.C.html" class="uri">http://root.cern.ch/root/html/examples/assembly.C.html</a><code>.</code></p>
<p>Creation of an assembly is very easy: one has just to create a <strong><code>TGeoVolumeAssembly</code></strong> object and position the components inside as for any volume:</p>
<div class="sourceCode" id="cb1037"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1037-1" title="1">TGeoVolume *vol = <span class="kw">new</span> TGeoVolumeAssembly(name);</a>
<a class="sourceLine" id="cb1037-2" title="2">vol-&gt;AddNode(vdaughter1, cpy1, matrix1);</a>
<a class="sourceLine" id="cb1037-3" title="3">vol-&gt;AddNode(vdaughter2, cpy2, matrix2);</a></code></pre></div>
<p>Note that components cannot be declared as “overlapping” and that a 
component can be an assembly volume. For existing flat volume 
structures, one can define assemblies to force a hierarchical structure 
therefore optimizing the performance. Usage of assemblies does NOT imply
 penalties in performance, but in some cases, it can be observed that it
 is not as performing as bounding the structure in a container volume 
with a simple shape. Choosing a normal container is therefore 
recommended whenever possible.</p>
<figure>
<img src="ROOTUsersGuide_files/080001CF.png" alt="Assemblies of volumes"><figcaption>Assemblies of volumes</figcaption>
</figure>
<h3 id="geometrical-transformations"><span class="header-section-number">18.4.3</span> Geometrical Transformations</h3>
<p>All geometrical transformations handled by the modeller are provided 
as a built-in package. This was designed to minimize memory requirements
 and optimize performance of point/vector master-to-local and 
local-to-master computation. We need to have in mind that a 
transformation in <strong><code>TGeo</code></strong> has two major 
use-cases. The first one is for defining the placement of a volume with 
respect to its container reference frame. This frame will be called 
‘master’ and the frame of the positioned volume - ‘local’. If <code>T</code> is a transformation used for positioning volume daughters, then: <code>MASTER = T * LOCAL</code></p>
<p>Therefore <code>T</code>is used to perform a local to master conversion, while <code>T-1</code>
 for a master to local conversion. The second use case is the 
computation of the global transformation of a given object in the 
geometry. Since the geometry is built as ‘volumes-inside-volumes’, the 
global transformation represents the pile-up of all local 
transformations in the corresponding branch. Once a given object in the 
hierarchy becomes the current one, the conversion from master to local 
coordinates or the other way around can be done from the manager class.</p>
<p>A general homogenous transformation is defined as a 4x4 matrix 
embedding a rotation, a translation and a scale. The advantage of this 
description is that each basic transformation can be represented as a 
homogenous matrix, composition being performed as simple matrix 
multiplication.</p>
<p>Rotation: <span class="math inline">\(\left|\begin{array}{cccc}  
r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\  r_{21} &amp; r_{22} &amp; 
r_{23} &amp; 0 \\  r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\  0 &amp; 0
 &amp; 0 &amp; 1 \end{array} \right|\)</span> Translation: <span class="math inline">\
(\left|\begin{array}{cccc}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 
&amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 1 &amp; 0 \\  t_x &amp; t_y &amp; 
t_z &amp; 1 \end{array} \right|\)</span> Scale: <span class="math inline">\
(\left|\begin{array}{cccc}  s_x &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; s_y 
&amp; 0 &amp; 0 \\  0 &amp; 0 &amp; s_z &amp; 0 \\  0 &amp; 0 &amp; 0 
&amp; 1 \end{array} \right|\)</span></p>
<p>Inverse rotation: <span class="math inline">\(\left|\begin{array}
{cccc}  r_{11} &amp; r_{21} &amp; r_{31} &amp; 0 \\  r_{12} &amp; r_{22}
 &amp; r_{32} &amp; 0 \\  r_{13} &amp; r_{23} &amp; r_{33} &amp; 0 \\  0
 &amp; 0 &amp; 0 &amp; 1 \end{array} \right|\)</span> Inverse translation: <span class="math inline">\
(\left|\begin{array}{cccc}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 
&amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 1 &amp; 0 \\  -t_x &amp; -t_y &amp; 
-t_z &amp; 1 \end{array} \right|\)</span> Inverse scale: <span class="math inline">\
(\left|\begin{array}{cccc}  \frac{1}{s_x} &amp; 0 &amp; 0 &amp; 0 \\  0 
&amp; \frac{1}{s_y} &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; \frac{1}{s_z} 
&amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1 \end{array} \right|\)</span></p>
<ul>
<li><span class="math inline">\(r_{ij}\)</span> are the 3x3 rotation matrix components</li>
<li><span class="math inline">\(t_x\)</span>,<span class="math inline">\(t_y\)</span>,<span class="math inline">\(t_z\)</span> are the translation components</li>
<li><span class="math inline">\(s_x\)</span>, <span class="math inline">\(s_y\)</span>, <span class="math inline">\(s_z\)</span> are arbitrary scale constants on each axis</li>
</ul>
<p>The disadvantage in using this approach is that computation for 4x4 
matrices is expensive. Even combining two translations would become a 
multiplication of their corresponding matrices, which is quite an 
undesired effect. On the other hand, it is not a good idea to store a 
translation as a block of 16 numbers. We have therefore chosen to 
implement each basic transformation type as a class deriving from the 
same basic abstract class and handling its specific data and 
point/vector transformation algorithms.</p>
<p>The base class <strong><code>TGeoMatrix</code></strong> defines abstract methods for:</p>
<ul>
<li>Translation, rotation and scale getters. Every derived class stores 
only its specific data, e.g.&nbsp;a translation stores an array of 3 
doubles and a rotation an array of 9. However, getting the <strong><code>TGeoTranslation</code></strong> rotation array through the base <strong><code>TGeoMatrix</code></strong>
 interface is a legal operation. The answer in this case is a pointer to
 a global constant array representing an identity rotation.</li>
</ul>
<div class="sourceCode" id="cb1038"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1038-1" title="1"><span class="dt">Double_t</span> *TGeoMatrix::GetTranslation() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1038-2" title="2"><span class="dt">Double_t</span> *TGeoMatrix::GetRotation() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1038-3" title="3"><span class="dt">Double_t</span> *TGeoMatrix::GetScale() <span class="at">const</span>;</a></code></pre></div>
<ul>
<li>Master-to-local and local-to-master point and vector transformations :</li>
</ul>
<div class="sourceCode" id="cb1039"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1039-1" title="1"><span class="dt">void</span> TGeoMatrix::MasterToLocal(<span class="at">const</span> <span class="dt">Double_t</span> *master,</a>
<a class="sourceLine" id="cb1039-2" title="2"><span class="dt">Double_t</span> *local)</a>
<a class="sourceLine" id="cb1039-3" title="3"><span class="dt">void</span> TGeoMatrix::LocalToMaster(<span class="at">const</span> <span class="dt">Double_t</span> *local,</a>
<a class="sourceLine" id="cb1039-4" title="4"><span class="dt">Double_t</span> *master)</a>
<a class="sourceLine" id="cb1039-5" title="5"><span class="dt">void</span> TGeoMatrix::MasterToLocalVect(<span class="at">const</span> <span class="dt">Double_t</span> *master,</a>
<a class="sourceLine" id="cb1039-6" title="6"><span class="dt">Double_t</span> *local)</a>
<a class="sourceLine" id="cb1039-7" title="7"><span class="dt">void</span> TGeoMatrix::LocalToMasterVect(<span class="at">const</span> <span class="dt">Double_t</span> *local,</a>
<a class="sourceLine" id="cb1039-8" title="8"><span class="dt">Double_t</span> *master)</a></code></pre></div>
<p>Here <code>master</code> and <code>local</code> are arrays of size 3. These methods allow correct conversion also for reflections.</p>
<ul>
<li>Transformation type finding:</li>
</ul>
<div class="sourceCode" id="cb1040"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1040-1" title="1"><span class="dt">Bool_t</span> TGeoMatrix::IsIdentity() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1040-2" title="2"><span class="dt">Bool_t</span> TGeoMatrix::IsTranslation() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1040-3" title="3"><span class="dt">Bool_t</span> TGeoMatrix::IsRotation() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1040-4" title="4"><span class="dt">Bool_t</span> TGeoMatrix::IsScale() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1040-5" title="5"><span class="dt">Bool_t</span> TGeoMatrix::IsCombi() <span class="at">const</span>;   <span class="co">// (tr. + rot.)</span></a>
<a class="sourceLine" id="cb1040-6" title="6"><span class="dt">Bool_t</span> TGeoMatrix::IsGeneral() <span class="at">const</span>; <span class="co">// (tr. + rot. + scale)</span></a></code></pre></div>
<p>Specific classes deriving from <strong><code>TGeoMatrix</code></strong>
 represent combinations of basic transformations. In order to define a 
matrix as a combination of several others, a special class <strong><code>TGeoHMatrix</code></strong> is provided. Here is an example of matrix creation:</p>
<h4 id="matrix-creation-example"><span class="header-section-number">18.4.3.1</span> Matrix Creation Example</h4>
<div class="sourceCode" id="cb1041"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1041-1" title="1">TGeoRotation r1,r2;</a>
<a class="sourceLine" id="cb1041-2" title="2">r1.SetAngles(<span class="dv">90</span>,<span class="dv">0</span>,<span class="dv">30</span>);          <span class="co">//rotation defined by Euler angles</span></a>
<a class="sourceLine" id="cb1041-3" title="3">r2.SetAngles(<span class="dv">90</span>,<span class="dv">90</span>,<span class="dv">90</span>,<span class="dv">180</span>,<span class="dv">0</span>,<span class="dv">0</span>); <span class="co">//rotation defined by GEANT3 angles</span></a>
<a class="sourceLine" id="cb1041-4" title="4">TGeoTranslation t1(-<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1041-5" title="5">TGeoTranslation t2(<span class="dv">10</span>,-<span class="dv">10</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1041-6" title="6">TGeoCombiTrans c1(t1,r1);</a>
<a class="sourceLine" id="cb1041-7" title="7">TGeoCombiTrans c2(t2,r2);</a>
<a class="sourceLine" id="cb1041-8" title="8">TGeoHMatrix h = c1 * c2; <span class="co">// composition is done via TGeoHMatrix</span></a>
<a class="sourceLine" id="cb1041-9" title="9">TGeoHMatrix *ph = <span class="kw">new</span> TGeoHMatrix(hm); <span class="co">// class it is what we want</span></a>
<a class="sourceLine" id="cb1041-10" title="10">                                       <span class="co">// to use for positioning</span></a>
<a class="sourceLine" id="cb1041-11" title="11">                                       <span class="co">// a volume</span></a>
<a class="sourceLine" id="cb1041-12" title="12">ph-&gt;Print();</a>
<a class="sourceLine" id="cb1041-13" title="13">...</a>
<a class="sourceLine" id="cb1041-14" title="14">pVolume-&gt;AddNode(pVolDaughter,id,ph) <span class="co">// now ph is owned by</span></a>
<a class="sourceLine" id="cb1041-15" title="15">                   the manager</a></code></pre></div>
<h4 id="rule-for-creation-of-transformations"><span class="header-section-number">18.4.3.2</span> Rule for Creation of Transformations</h4>
<p>Unless explicitly used for positioning nodes <code>(TGeoVolume::AddNode())</code> all matrices deletion have to be managed by users. Matrices passed to geometry have to be created by using <code>new()</code> operator and <strong><code>TGeoManager</code></strong>
 class is responsible for their deletion. Matrices that are used for the
 creation of composite shapes have to be named and registered to the 
manager class:</p>
<div class="sourceCode" id="cb1042"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1042-1" title="1">transf-&gt;SetName(name); <span class="co">// if not already named in the constructor</span></a>
<a class="sourceLine" id="cb1042-2" title="2">transf-&gt;RegisterYourself();</a></code></pre></div>
<p>Generally, it is advisable to create all intermediate transformations used for making the final combined one on the heap:</p>
<div class="sourceCode" id="cb1043"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1043-1" title="1">TGeoRotation r1(...);</a>
<a class="sourceLine" id="cb1043-2" title="2">TGeoRotation r2(...);</a>
<a class="sourceLine" id="cb1043-3" title="3">TGeoHMatrix *mat = <span class="kw">new</span> TGeoHMatrix(<span class="st">"name"</span>); <span class="co">// we want to use only</span></a>
<a class="sourceLine" id="cb1043-4" title="4">                        <span class="co">// this one in geometry</span></a>
<a class="sourceLine" id="cb1043-5" title="5">*mat = r1 * r2;</a></code></pre></div>
<h4 id="available-geometrical-transformations"><span class="header-section-number">18.4.3.3</span> Available Geometrical Transformations</h4>
<ul>
<li>Translations (<strong><code>TGeoTranslation</code></strong> class) represent a <code>(dx,dy,dz)</code> translation. The only data member is: <code>Double_t fTranslation[3]</code>. Translations can be added or subtracted.</li>
</ul>
<div class="sourceCode" id="cb1044"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1044-1" title="1">TGeoTranslation t1;</a>
<a class="sourceLine" id="cb1044-2" title="2">t1-&gt;SetTranslation(-<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb1044-3" title="3">TGeoTranslation *t2 = <span class="kw">new</span> TGeoTranslation(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1044-4" title="4">t2-&gt;Subtract(&amp;t1);</a></code></pre></div>
<ul>
<li>Rotations (<strong><code>TGeoRotation</code></strong> class) represent a pure rotation. Data members are <code>Double_t fRotationMatrix[3*3]</code>. Rotations can be defined either by Euler angles, either, by GEANT3 angles:</li>
</ul>
<div class="sourceCode" id="cb1045"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1045-1" title="1">TGeoRotation *r1 = <span class="kw">new</span> TGeoRotation();</a>
<a class="sourceLine" id="cb1045-2" title="2">r1-&gt;SetAngles(phi,theta,psi);        <span class="co">// all angles in degrees</span></a></code></pre></div>
<p>This represents the composition of: first a rotation about Z axis 
with angle phi, then a rotation with theta about the rotated X axis, and
 finally a rotation with <code>psi</code>about the new Z axis.</p>
<div class="sourceCode" id="cb1046"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1046-1" title="1">r1-&gt;SetAngles(th1,phi1,th2,phi2,th3,phi3)</a></code></pre></div>
<p>This is a rotation defined in GEANT3 style. Theta and phi are the 
spherical angles of each axis of the rotated coordinate system with 
respect to the initial one. This construction allows definition of 
malformed rotations, e.g.&nbsp;not orthogonal. A check is performed and 
an error message is issued in this case.</p>
<p>Specific utilities: determinant, inverse.</p>
<ul>
<li>Scale transformations (<strong><code>TGeoScale</code></strong> class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: <code>Double_t fScale[3]</code>. Not implemented yet.</li>
<li>Combined transformations - represent a rotation followed by a translation. Data members: <code>Double_t fTranslation[3],</code><strong><code>TGeoRotation *fRotation</code>.</strong></li>
</ul>
<div class="sourceCode" id="cb1047"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1047-1" title="1">TGeoRotation *rot = <span class="kw">new</span> TGeoRotation(<span class="st">"rot"</span>,<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>);</a>
<a class="sourceLine" id="cb1047-2" title="2">TGeoTranslation trans;</a>
<a class="sourceLine" id="cb1047-3" title="3">...</a>
<a class="sourceLine" id="cb1047-4" title="4">TGeoCombiTrans *c1 = <span class="kw">new</span> TGeoCombiTrans(trans,rot);</a>
<a class="sourceLine" id="cb1047-5" title="5">TGeoCombiTrans *c2 = <span class="kw">new</span> TGeoCombiTrans(<span class="st">"somename"</span>,<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>,rot)</a></code></pre></div>
<ul>
<li>General transformations: (<strong><code>TGeoHMatrix</code></strong> class) represent combined transformations in any order.</li>
<li>Identity transformation: (<strong><code>TGeoIdentity</code></strong> class) is a generic identity transformation represented by a singleton class object <strong><code>gGeoIdentity</code></strong>.</li>
</ul>
<h3 id="ownership-of-geometry-objects"><span class="header-section-number">18.4.4</span> Ownership of Geometry Objects</h3>
<p>The class <strong><code>TGeoManager</code></strong> class contains the entire API needed for building and tracking geometry. It defines a global pointer <strong><em><code>gGeoManager</code></em></strong>
 in order to be fully accessible from external code. The manager class 
is the owner of all geometry objects defined in a session; therefore, 
users must not try to control their deletion. It contains lists of 
media, materials, transformations, shapes and volumes. A special case is
 the one of geometrical transformations. When creating a matrix or a 
translation, this is by default owned by external objects. The manager 
class becomes owner of all transformations used for positioning volumes.
 In order to force the ownership for other transformations, one can use <code>TGeoMatrix::RegisterYourself()</code>
 method. Do not be therefore surprised that some transformations cannot 
be found by name when creating a composite shape for instance if you did
 not register them after creation.</p>
<p>Logical nodes (positioned volumes) are created and destroyed by the <strong><code>TGeoVolume</code></strong>
 class. Physical nodes and their global transformations are subjected to
 a caching mechanism due to the sometimes very large memory requirements
 of logical graph expansion. The total number of physical instances of 
volumes triggers the caching mechanism and the cache manager is a client
 of <strong><code>TGeoManager</code></strong>. The manager class also controls the drawing/checking package (<strong><code>TGeoPainter</code></strong> client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.</p>
<h2 id="navigation-and-tracking"><span class="header-section-number">18.5</span> Navigation and Tracking</h2>
<p>Tracking is the feature allowing the transport of a given particle 
knowing its kinematics. A state is determined by any combination of the 
position <span class="math inline">\(\vec{r}\)</span> and direction <span class="math inline">\(\vec{n}\)</span> with respect to the world reference frame. The direction <span class="math inline">\(\vec{n}\)</span>
 must be a unit vector having as components the director cosines. The 
full classification of a given state will provide the following 
information: the deepest physical node containing the position vector, 
the distance to the closest boundary along the direction vector, the 
next physical node after propagating the current point with this 
distance and the safety distance to the nearest boundary. This 
information allows the propagation of particles inside a detector 
geometry by taking into account both geometrical and physical 
constraints.</p>
<p>We will hereby describe the user interface of <strong><code>TGeo</code></strong>
 to access tracking functionality. This allows either developing a 
tracker for simple navigation within a given geometry, either 
interfacing to an external tracking engine such as GEANT. Note that the 
abstract interface for external trackers can be found in <code>$ROOTSYS/vmc</code>
 folder and it can be used to run GEANT3, GEANT4 and FLUKA-based 
simulations (*) by using directly a geometry described with ROOT.</p>
<p>The interface methods related to tracking are incorporated into <strong><code>TGeoManager</code></strong> class and implemented in the navigator class <strong><code>TGeoNavigator</code></strong>. In order to be able to start tracking, one has to define the initial state providing the starting point <span class="math inline">\(\vec{r_0}\)</span> and direction <span class="math inline">\(\vec{n_0}\)</span> . There are several ways of doing that.</p>
<h3 id="tgeonavigator-class"><span class="header-section-number">18.5.1</span> TGeoNavigator Class</h3>
<p>One geometry may have several independent navigators to query to 
localize points or compute distances. The geometry manager holds a list 
of active navigators accessible via:</p>
<div class="sourceCode" id="cb1048"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1048-1" title="1">TObjArray *navigators = gGeoManager-&gt;GetListOfNavigators();</a></code></pre></div>
<p>Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:</p>
<div class="sourceCode" id="cb1049"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1049-1" title="1">TGeoNavigator *navig = <span class="kw">new</span> TGeoNavigator(gGeoManager);</a>
<a class="sourceLine" id="cb1049-2" title="2"><span class="co">// Store the index of the user navigator</span></a>
<a class="sourceLine" id="cb1049-3" title="3"><span class="dt">Int_t</span> inav = gGeoManager-&gt;AddNavigator(navig);</a>
<a class="sourceLine" id="cb1049-4" title="4"><span class="co">// Make its own navigator the active one</span></a>
<a class="sourceLine" id="cb1049-5" title="5">gGeoManager-&gt;SetCurrentNavigator(inav);</a>
<a class="sourceLine" id="cb1049-6" title="6"><span class="co">// Switch between navigators</span></a>
<a class="sourceLine" id="cb1049-7" title="7">gGeoManager-&gt;SetCurrentNavigator(<span class="dv">0</span>);</a></code></pre></div>
<p>A navigator holds several variables describing the current navigation
 state: current point position, current direction distance to next 
boundary, isotropic safety, pointer to current and next nods as well as 
several tracking flags related to volume boundary conditions or other 
properties required for track propagation in geometry. Each geometry 
query affects these variables, so the only way in testing several 
navigation alternatives and remembering the active navigation state is 
to use parallel navigation. The following paragraphs will describe the 
usage of a single navigator. All setters/getters for navigation state 
parameters as well as navigation queries provided by <strong><code>TGeoNavigator</code></strong> are interfaced by <strong><code>TGeoManager</code></strong> and will act on the current navigator.</p>
<h3 id="initializing-the-starting-point"><span class="header-section-number">18.5.2</span> Initializing the Starting Point</h3>
<p>The current point (<code>x,y,z</code>) known by the modeller is stored as <code>Double_t fCurrentPoint[3]</code>
 by the navigator class. This array of the three coordinates is defined 
in the current global reference system and can be retrieved any time:</p>
<div class="sourceCode" id="cb1050"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1050-1" title="1">Const <span class="dt">Double_t</span> *cpoint = gGeoManager-&gt;GetCurrentPoint();</a></code></pre></div>
<p>Initializing this point can be done like:</p>
<div class="sourceCode" id="cb1051"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1051-1" title="1">gGeoManager-&gt;SetCurrentPoint(x,y,z);</a>
<a class="sourceLine" id="cb1051-2" title="2"><span class="co">// or:</span></a>
<a class="sourceLine" id="cb1051-3" title="3">gGeoManager-&gt;SetCurrentPoint(<span class="dt">Double_t</span> *point[<span class="dv">3</span>]);</a></code></pre></div>
<h3 id="initializing-the-direction"><span class="header-section-number">18.5.3</span> Initializing the Direction</h3>
<p>In order to move inside geometry starting with the current point, the modeller needs to know the current direction <code>(nx,ny,nz)</code>. This direction is stored as <code>Double_t fCurrentDirection[3]</code> by the navigator and it represents a direction in the global frame. It can be retrieved with:</p>
<div class="sourceCode" id="cb1052"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1052-1" title="1">Const <span class="dt">Double_t</span> *cdir = gGeoManager-&gt;GetCurrentDirection();</a></code></pre></div>
<p>The direction can be initialized in a similar manner as the current point:</p>
<div class="sourceCode" id="cb1053"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1053-1" title="1">gGeoManager-&gt;SetCurrentDirection(nx,ny,nz);</a>
<a class="sourceLine" id="cb1053-2" title="2"><span class="co">// or:</span></a>
<a class="sourceLine" id="cb1053-3" title="3">gGeoManager-&gt;SetCurrentDirection(<span class="dt">Double_t</span> *dir);</a></code></pre></div>
<h3 id="initializing-the-state"><span class="header-section-number">18.5.4</span> Initializing the State</h3>
<p>Setting the initial point and direction is not enough for 
initializing tracking. The modeller needs to find out where the initial 
point is located in the geometrical hierarchy. Due to the containment 
based architecture of the model, this is the deepest positioned object 
containing the point. For illustrating this, imagine that we have a 
simple structure with a top volume <code>A</code> and another one <code>B</code>positioned inside. Since <code>A</code>is a top volume, its associated node <code>A_1</code> will define <code>MARS</code> and our simple hierarchy of nodes (positioned volumes) will be: <code>/A_1/B_1</code>. Suppose now that the initial point is contained by <code>B_1</code>. This implies by default that the point is also contained by <code>A_1</code>, since <code>B_1</code>
 have to be fully contained by this. After searching the point location,
 the modeller will consider that the point is located inside <code>B_1</code>, which will be considered as the representative object (node) for the current state. This is stored as: <strong><code>TGeoNode</code></strong> *<code>TGeoManager::fCurrentNode</code>and can be asked from the manager class only after the <code>'Where am I?'</code> was completed:</p>
<div class="sourceCode" id="cb1054"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1054-1" title="1">TGeoNode *current = gGeoManager-&gt;GetCurrentNode();</a></code></pre></div>
<p>In order to find the location of the current point inside the 
hierarchy of nodes, after setting this point it is mandatory to call the
 <code>‘Where am I?'</code> method:</p>
<div class="sourceCode" id="cb1055"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1055-1" title="1">gGeoManager-&gt;FindNode();</a></code></pre></div>
<p>In order to have more flexibility, there are in fact several alternative ways of initializing a modeller state:</p>
<div class="sourceCode" id="cb1056"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1056-1" title="1"><span class="co">// Setting the point and finding the state in one step:</span></a>
<a class="sourceLine" id="cb1056-2" title="2">gGeoManager-&gt;FindNode(<span class="dt">Double_t</span> x,<span class="dt">Double_t</span> y,<span class="dt">Double_t</span> z);</a>
<a class="sourceLine" id="cb1056-3" title="3">gGeoManager-&gt;FindNode(<span class="dt">Double_t</span> *point[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb1056-4" title="4"><span class="co">// Setting both initial point and direction and finding the state:</span></a>
<a class="sourceLine" id="cb1056-5" title="5">gGeoManager-&gt;InitTrack(<span class="dt">Double_t</span> x,<span class="dt">Double_t</span> y,<span class="dt">Double_t</span> z,</a>
<a class="sourceLine" id="cb1056-6" title="6"><span class="dt">Double_t</span> nx, <span class="dt">Double_t</span> ny, <span class="dt">Double_t</span> nz);</a>
<a class="sourceLine" id="cb1056-7" title="7">gGeoManager-&gt;InitTrack(<span class="dt">Double_t</span> *point[<span class="dv">3</span>],<span class="dt">Double_t</span> *dir[<span class="dv">3</span>]);</a></code></pre></div>
<p>Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the <code>‘Where am I?'</code> geometrical query representing the basic navigation functionality provided by the modeller.</p>
<h3 id="checking-the-current-state"><span class="header-section-number">18.5.5</span> Checking the Current State</h3>
<p>The current state and all variables related to this are essential 
during tracking and have to be checked several times. Besides the 
current point and direction, the following additional information can be
 retrieved from <strong><code>TGeoManager</code></strong> interface:</p>
<ul>
<li>The <code>current path</code>. This represents a string containing the names and copy numbers of all positioned objects in the current <code>branch</code>
 written in the /folder/folder/…/folder/file fashion. The final node 
pointed by the path is the deepest object containing the current point 
and is representative for the current state. All intermediate <code>folders</code>
 in the path are in fact also nodes “touched” by the current point, but 
having some “touched” containment. The current path can be retrieved 
only after the state was initialized and is useful for getting an idea 
of the current point location.</li>
</ul>
<div class="sourceCode" id="cb1057"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1057-1" title="1"><span class="at">const</span> <span class="dt">char</span> *path = gGeoManager-&gt;GetPath();</a>
<a class="sourceLine" id="cb1057-2" title="2">cout &lt;&lt; <span class="st">"Current path is: "</span> &lt;&lt; path &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1057-3" title="3">/A_1/B_34/C_3/D_1</a></code></pre></div>
<ul>
<li>The <code>current node</code><strong><em><code>,</code></em></strong><code>volume</code> and <code>material</code>.
 In order to take decisions on post-step or further stepping actions, 
one has to know these. In order to get a pointer to the current node one
 can do:</li>
</ul>
<div class="sourceCode" id="cb1058"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1058-1" title="1">TGeoNode *cnode = gGeoManager-&gt;GetCurrentNode();</a>
<a class="sourceLine" id="cb1058-2" title="2"><span class="co">// then:</span></a>
<a class="sourceLine" id="cb1058-3" title="3">TGeoVolume *cvol = gGeoManager-&gt;GetCurrentVolume();</a>
<a class="sourceLine" id="cb1058-4" title="4"><span class="co">// or:</span></a>
<a class="sourceLine" id="cb1058-5" title="5">cvol = cnode-&gt;GetVolume();    <span class="co">// (*)</span></a>
<a class="sourceLine" id="cb1058-6" title="6"><span class="co">// then:</span></a>
<a class="sourceLine" id="cb1058-7" title="7">TGeoMaterial *cmat = cvol-&gt;GetMedium()-&gt;GetMaterial();</a></code></pre></div>
<p>(*) Note: If the current point is in fact outside the geometry, the 
current node pointer will not be NULL, but pointing to the top node.</p>
<p>In order to take decisions in such case one needs always to test:</p>
<div class="sourceCode" id="cb1059"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1059-1" title="1"><span class="cf">if</span> (gGeoManager-&gt;IsOutside()) {</a>
<a class="sourceLine" id="cb1059-2" title="2">   <span class="co">// current point is actually outside</span></a>
<a class="sourceLine" id="cb1059-3" title="3">   ... <span class="co">// corresponding action</span></a>
<a class="sourceLine" id="cb1059-4" title="4">}</a></code></pre></div>
<p>Specific information related to the current volume/node like ID’s or shape can be then retrieved from the corresponding objects.</p>
<ul>
<li>Current state <code>index</code>. The number of possible different 
states of the modeller corresponds to the number of different 
objects/paths in the geometry. This has nothing to do with the number of
 nodes, since the same node can be found on different branches. In other
 words, the number of states corresponds to the number of nodes in the <code>expanded geometry tree</code>.
 Since unfortunately this expansion from logical to physical hierarchy 
cannot be stored on regular basis due to the large size of the latter, 
one cannot directly assign state numbers. If the size of the expansion 
proves however to be small enough (less than about 50 million objects), a
 parallel structure storing these state indices is built and stored in 
memory. In such case each state automatically gets an index that can be 
retrieved after any state initialization. These indices can prove to be 
quite useful for being able to keep track of the navigation history and 
force certain states. Let’s illustrate how this works with a simple 
example:</li>
<li>Suppose we have a simple geometry with a volume B positioned twice 
inside a container A. Then A is positioned twice in a top container T. 
The complete list of logical nodes is: <code>T_1</code>, <code>A_1</code>, <code>A_2</code>, <code>B_1</code>, <code>B_2</code>. On the other hand we will have more states than logical nodes:</li>
<li><code>/T_1</code>- 1 state at level = 0</li>
<li><code>/T_1/A_1,/T_1/A_2</code>- 2 states at level = 1</li>
<li><code>/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2</code> - 4 states at level = 2</li>
<li>All these states will get automatic numbers, starting with 0 
corresponding to the top-level state and ending with an integer 
corresponding to Ntotal_states-1. The mapping from a given logical node 
to a state number is generally not possible, as for the node B_1 that 
appears as current node for 2 different states. The numbering order of 
states is therefore not important, but it can be used as in the 
following lines:</li>
</ul>
<div class="sourceCode" id="cb1060"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1060-1" title="1">gGeoManager-&gt;InitTrack(pt,dir); <span class="co">// anything to initialize a state</span></a>
<a class="sourceLine" id="cb1060-2" title="2"><span class="dt">Int_t</span> istate = gGeoManager-&gt;GetCurrentNodeId(); <span class="co">// in fact state Id</span></a>
<a class="sourceLine" id="cb1060-3" title="3">{</a>
<a class="sourceLine" id="cb1060-4" title="4">   <span class="co">//... code changing the current state</span></a>
<a class="sourceLine" id="cb1060-5" title="5">}</a>
<a class="sourceLine" id="cb1060-6" title="6">gGeoManager-&gt;CdNode(istate); <span class="co">// forces state's re-initialization</span></a></code></pre></div>
<ul>
<li>Current <code>global transformation</code>. This represents the transformation from <code>MARS</code>
 to the local reference of the current node, being the product of all 
local mother-daughter transformations in the branch. The global 
transformation can be referenced or copied:</li>
</ul>
<div class="sourceCode" id="cb1061"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1061-1" title="1"><span class="at">const</span> TGeoHMatrix *global = gGeoManager-&gt;GetCurrentMatrix();</a>
<a class="sourceLine" id="cb1061-2" title="2">TGeoHMatrix *copy = <span class="kw">new</span> TGeoHMatrix(*global);</a></code></pre></div>
<ul>
<li>One often needs to perform <code>master-to-local</code> and <code>local-to-master</code> point and vector conversions to get from <code>MARS</code> to the local node coordinates. This can be done by using the global transformation or directly the <strong><code>TGeoManager</code></strong> corresponding interfaces:</li>
</ul>
<div class="sourceCode" id="cb1062"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1062-1" title="1"><span class="dt">Double_t</span> *glob_pt = gGeoManager-&gt;GetCurrentPoint();</a>
<a class="sourceLine" id="cb1062-2" title="2"><span class="dt">Double_t</span> *glob_dir = gGeoManager-&gt;GetCurrentDirection();</a>
<a class="sourceLine" id="cb1062-3" title="3"><span class="dt">Double_t</span> loc_pt[<span class="dv">3</span>], loc_dir[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb1062-4" title="4"><span class="co">// Go from MARS to local coordinates:</span></a>
<a class="sourceLine" id="cb1062-5" title="5">gGeoManager-&gt;MasterToLocal(glob_pt,loc_pt); <span class="co">// or:</span></a>
<a class="sourceLine" id="cb1062-6" title="6">global-&gt;MasterToLocal(glob_pt,loc_pt); <span class="co">// will be omitted from now</span></a></code></pre></div>
<h3 id="saving-and-restoring-the-current-state"><span class="header-section-number">18.5.6</span> Saving and Restoring the Current State</h3>
<p>As we already described, saving and restoring modeller states can be 
quite useful during tracking and is a feature extensively used by 
external tracking engines. We will call this navigation history 
management, which in most of the cases can be performed by handling the 
state identifiers. For quite big geometries, state indexing is not 
possible anymore and will be automatically disabled by the modeller. 
Fortunately there is a backup solution working in any condition: the 
modeller maintains a stack of states that is internally used by its own 
navigation algorithms, but user code is also allowed to access it. This 
works on any stack principle by using PUSH and POP calls and user code 
is responsible for popping the pushed states in order to keep the stack 
clean.</p>
<div class="sourceCode" id="cb1063"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1063-1" title="1"><span class="co">// push the current state in the stack</span></a>
<a class="sourceLine" id="cb1063-2" title="2"><span class="dt">Int_t</span> index = gGeoManager-&gt;PushPath();</a>
<a class="sourceLine" id="cb1063-3" title="3"><span class="co">// push state and current point</span></a>
<a class="sourceLine" id="cb1063-4" title="4"><span class="dt">Int_t</span> index = gGeoManager-&gt;PushPoint();</a>
<a class="sourceLine" id="cb1063-5" title="5"><span class="co">// retrieves the last pushed state (decrements stack index)</span></a>
<a class="sourceLine" id="cb1063-6" title="6">gGeoManager-&gt;PopPath();</a>
<a class="sourceLine" id="cb1063-7" title="7"><span class="co">// the same but retrieves also the point location</span></a>
<a class="sourceLine" id="cb1063-8" title="8">gGeoManager-&gt;PopPoint();</a>
<a class="sourceLine" id="cb1063-9" title="9"><span class="co">// just decrement stack index without changing state</span></a>
<a class="sourceLine" id="cb1063-10" title="10">gGeoManager-&gt;PopDummy();</a>
<a class="sourceLine" id="cb1063-11" title="11"><span class="co">// retrieves a state at given index without changing stack index</span></a>
<a class="sourceLine" id="cb1063-12" title="12">gGeoManager-&gt;PopPath(<span class="dt">Int_t</span> index);</a></code></pre></div>
<h3 id="navigation-queries"><span class="header-section-number">18.5.7</span> Navigation Queries</h3>
<p>After initializing the current state related to a given point and direction defined in <code>MARS</code> <code>(‘Where am I?')</code>,
 one can query for several geometrical quantities. All the related 
algorithms work in the assumption that the current point has been 
localized inside the geometry (by the methods <code>TGeoManager::FindNode()</code> or <strong><code>TGeoManager</code></strong><code>::InitTrack()</code>) and the current node or path has not been changed by the user.</p>
<h4 id="finding-if-current-state-is-changed-for-a-new-point"><span class="header-section-number">18.5.7.1</span> Finding If Current State Is Changed For a New Point</h4>
<p>One can find fast if a point different from the current one has or 
not the same location inside the geometry tree. To do that, the new 
point should not be introduced by using <code>TGeoManager::SetCurrentPoint()</code> method, but rather by calling the specific method:</p>
<div class="sourceCode" id="cb1064"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1064-1" title="1"><span class="dt">Bool_t</span> TGeoManager::IsSameLocation(<span class="dt">Double_t</span> x,<span class="dt">Double_t</span> y,</a>
<a class="sourceLine" id="cb1064-2" title="2"><span class="dt">Double_t</span> z,<span class="dt">Bool_t</span> change=kFALSE);</a></code></pre></div>
<p>In the prototype above, <code>x, y</code> and <code>z</code> are the 
coordinates of the new point. The modeller will check whether the 
current volume still contains the new point or its location has changed 
in the geometry hierarchy. If the new location is different, two actions
 are possible according to the value of <code>change</code>:</p>
<ul>
<li><code>change = kFALSE</code> (default) - the modeller does not change the current state but just inform the caller about this change.</li>
<li><code>change = kTRUE</code> - the modeller will actually perform a new <code>‘Where am I?'</code>search after finding out that the location has changed. The current state will be actualized accordingly.</li>
</ul>
<p>Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. <code>gGeoManager-&gt;FindNode(newX,newY,newZ)</code>), users can always query if the previous state has changed by using a method having the same name but without parameters:</p>
<div class="sourceCode" id="cb1065"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1065-1" title="1"><span class="dt">Bool_t</span> TGeoManager::IsSameLocation();</a></code></pre></div>
<h4 id="finding-the-distance-to-the-next-boundary"><span class="header-section-number">18.5.7.2</span> Finding the Distance to the Next Boundary</h4>
<p>All tracking engines need to compare the currently proposed physical 
step with the maximum allowed distance in the current material. The 
modeller provides this information by computing the distance to the 
first boundary starting from the current point along a straight line. 
The starting point and direction for this procedure are the ones 
corresponding to the current state. The boundary search is initialized 
inside the current volume and the crossed boundary can belong either to 
the current node or to one of its daughters. The full prototype of the 
method is:</p>
<div class="sourceCode" id="cb1066"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1066-1" title="1">TGeoNode *TGeoManager::FindNextBoundary(<span class="dt">Double_t</span> step=kBig);</a></code></pre></div>
<p>In the prototype above, besides the current point and direction that 
are supposed already initialized, the only input parameter is <code>step</code>. This represents the maximum step allowed by the tracking algorithm or the <code>physical step</code>.
 The modeller will search for a boundary crossing only up to a distance 
equal to this value. If a boundary is found, a pointer to the object 
(node) having it is returned; otherwise the method returns <code>NULL</code>.</p>
<p>The computed value for the computed distance can be subsequently retrieved from the manager class:</p>
<div class="sourceCode" id="cb1067"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1067-1" title="1"><span class="dt">Double_t</span> snext  = gGeoManager-&gt;GetStep();</a>
<a class="sourceLine" id="cb1067-2" title="2"><span class="dt">Double_t</span> safety = gGeoManager-&gt;GetSafeDistance();</a></code></pre></div>
<p>According the step value, two use cases are possible:</p>
<ul>
<li><code>step =</code> <code>TGeoShape::kBig</code>(default behavior; <code>kBig = 1030</code>).
 In this case, there is no limitation on the search algorithm, the first
 crossed node is returned and the corresponding distance computed. If 
the current point is outside geometry and the top node is not crossed, 
the corresponding distance will be set to <code>kBig</code> and a <code>NULL</code> pointer returned. No additional quantity will be computed.</li>
<li><code>step &lt; kBig</code>. In this case, the progressive search 
starting from the current point will be stopped after a distance equal 
with the supplied step. In addition to the distance to the first crossed
 boundary, the <code>safety radius</code> is also computed. Whenever the
 information regarding the maximum required step is known it is 
recommended to be provided as input parameter in order to speed-up the 
search.</li>
</ul>
<p>In addition to the distance computation, the method sets an 
additional flag telling if the current track will enter inside some 
daughter of the current volume or it will exit inside its container:</p>
<div class="sourceCode" id="cb1068"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1068-1" title="1"><span class="dt">Bool_t</span> TGeoManager::IsStepEntering() <span class="at">const</span>;</a></code></pre></div>
<p>A combined task is to first find the distance to the next boundary 
and then extrapolate the current point/direction with this distance 
making sure that the boundary was crossed. Finally the goal would be to 
find the next state after crossing the boundary. The problem can be 
solved in principle using FindNextBoundary, but the boundary crossing 
can give unpredictable results due to numerical roundings. The manager 
class provides a method that allows this combined task and ensures 
boundary crossing. This should be used instead of the method <code>FindNextBoundary()</code>
 whenever the tracking is not imposed in association with an external MC
 transport engine (which provide their own algorithms for boundary 
crossing).</p>
<div class="sourceCode" id="cb1069"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1069-1" title="1">TGeoNode *TGeoManager::FindNextBoundaryAndStep(<span class="dt">Double_t</span> stepmax,</a>
<a class="sourceLine" id="cb1069-2" title="2"><span class="dt">Bool_t</span> comp_safe=kFALSE);</a></code></pre></div>
<p>The meaning of the parameters here is the same as for 
FindNextBoundary, but the safety value is triggered by an input flag. 
The output is the node after the boundary crossing.</p>
<h4 id="computing-the-safe-radius"><span class="header-section-number">18.5.7.3</span> Computing the Safe Radius</h4>
<p>Other important navigation query for tracking is the computation of the safe distance. This represents the <code>maximum</code> step that can be made from the current point in <code>any direction</code>
 that assures that no boundary will be crossed. Knowing this value gives
 additional freedom to the stepping algorithm to propagate the current 
track on the corresponding range <code>without checking</code> if the 
current state has changed. In other words, the modeller insures that the
 current state does not change in any point within the safety radius 
around the current point.</p>
<p>The computation of the safe radius is <code>automatically</code> computed any time when the next boundary is queried within a <code>limited step:</code></p>
<div class="sourceCode" id="cb1070"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1070-1" title="1">TGeoNode *crossed = gGeoManager-&gt;FindNextBoundary(pstep);</a>
<a class="sourceLine" id="cb1070-2" title="2"><span class="dt">Double_t</span> safety = gGeoManager-&gt;GetSafeDistance();</a></code></pre></div>
<p>Otherwise, the computation of safety can always be forced:</p>
<div class="sourceCode" id="cb1071"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1071-1" title="1"><span class="dt">Double_t</span> safety = gGeoManager-&gt;Safety();</a></code></pre></div>
<h4 id="making-a-step"><span class="header-section-number">18.5.7.4</span> Making a Step</h4>
<p>The modeller is able to make steps starting from the current point 
along the current direction and having the current step length. The new 
point and its corresponding state will be automatically computed:</p>
<div class="sourceCode" id="cb1072"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1072-1" title="1">TGeoNode *TGeoManager::Step(<span class="dt">Bool_t</span> is_geom = kTRUE,</a>
<a class="sourceLine" id="cb1072-2" title="2"><span class="dt">Bool_t</span> cross = kTRUE);</a></code></pre></div>
<p>We will explain the method above by its use cases. The input flag <code>is_geom</code>
 allows specifying if the step is limited by geometrical reasons (a 
boundary crossing) or is an arbitrary step. The flag cross can be used 
in case the step is made on a boundary and specifies if user wants to 
cross or not the boundary. The returned node represents the new current 
node after the step was made.</p>
<ul>
<li>Making a geometrically contained step with boundary crossing (<code>is_geom=kTRUE</code>, <code>cross=kTRUE</code>) - This is the default method behavior. In this case, the step size is supposed to be already set by a previous <code>TGeoManager::FindNextBoundary()</code> call. Due to floating-point boundary uncertainties, making a step corresponding <code>exactly</code>
 to the distance to next boundary does not insure boundary crossing. If 
the method is called with this purpose, an extra small step will be made
 in order to make the crossing the most probable event (<code>epsil=10-6cm</code>).
 Even with this extra small step cannot insure 100% boundary crossing 
for specific crossed shapes at big incident angles. After such a step is
 made, additional cross-checks become available:</li>
</ul>
<div class="sourceCode" id="cb1073"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1073-1" title="1">gGeoManager-&gt;FindNextBoundary(pstep);</a>
<a class="sourceLine" id="cb1073-2" title="2"><span class="dt">Double_t</span> snext = gGeoManager-&gt;GetStep();</a>
<a class="sourceLine" id="cb1073-3" title="3"><span class="co">// The geometrical step is taken</span></a>
<a class="sourceLine" id="cb1073-4" title="4">TGeoNode *newNode = gGeoManager-&gt;Step();</a>
<a class="sourceLine" id="cb1073-5" title="5"><span class="co">// The step=snext+epsil is made</span></a>
<a class="sourceLine" id="cb1073-6" title="6"><span class="dt">Bool_t</span> hasCrossed = gGeoManager-&gt;IsEntering();</a>
<a class="sourceLine" id="cb1073-7" title="7"><span class="co">// Is the boundary crossed or not?</span></a>
<a class="sourceLine" id="cb1073-8" title="8"><span class="dt">Bool_t</span> isOnBoundary = gGeoManager-&gt;IsOnBoundary(); <span class="co">// The proposed</span></a>
<a class="sourceLine" id="cb1073-9" title="9"><span class="co">// geometrically limited step to be made was smaller</span></a>
<a class="sourceLine" id="cb1073-10" title="10"><span class="co">// than epsil value.</span></a>
<a class="sourceLine" id="cb1073-11" title="11"><span class="dt">Bool_t</span> isOutside = gGeoManager-&gt;IsOutside();</a>
<a class="sourceLine" id="cb1073-12" title="12"><span class="co">//Did we exit geometry ?</span></a></code></pre></div>
<p>In case the desired end-point of the step should be in the same starting volume, the input flag <code>cross</code> should be set to <code>kFALSE</code>. In this case, the <code>epsil</code> value will be subtracted from the current step.</p>
<ul>
<li>Making a step of arbitrary value (<code>is_geom=kFALSE</code>, <code>cross=</code>no matter). In this case, the step to be made can be either resulting from a <code>next</code> computation, either set by hand:</li>
</ul>
<div class="sourceCode" id="cb1074"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1074-1" title="1">gGeoManager-&gt;SetStep(stepvalue);</a>
<a class="sourceLine" id="cb1074-2" title="2">gGeoManager-&gt;Step(kFALSE);</a></code></pre></div>
<p>The step value in this case will <code>exactly</code> match the 
desired step. In case a boundary crossing failed after geometrically 
limited stepping, one can force as many small steps as required to 
really cross the boundary. This is not what generally happens during the
 stepping, but sometimes small rounding of boundary positions may occur 
and cause problems. These have to be properly handled by the stepping 
code.</p>
<h4 id="the-normal-vector-to-the-next-crossed-surface-at-crossing-point"><span class="header-section-number">18.5.7.5</span> The Normal Vector to the Next Crossed Surface at Crossing Point</h4>
<p>Supposing we have found out that a particle will cross a boundary 
during the next step, it is sometimes useful to compute the normal to 
the crossed surface. The modeller uses the following convention: we 
define as <code>normal</code> (<span class="math inline">\(\vec{n}\)</span>) the unit vector perpendicular to a surface in the <code>next crossing point</code>, having the orientation such that: <span class="math inline">\(\vec{n}.\vec{d}&gt;0\)</span>. Here <span class="math inline">\(\vec{d}\)</span>
 represents the current direction. The next crossing point represents 
the point where a ray shot from the current point along the current 
direction crosses the surface.</p>
<div class="sourceCode" id="cb1075"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1075-1" title="1"><span class="dt">Double_t</span> *TGeoManager::FindNormal(<span class="dt">Bool_t</span> forward=kTRUE);</a></code></pre></div>
<p>The method above computes the normal to the next crossed surface in 
forward or backward direction (i.e.&nbsp;the current one), assuming the 
state corresponding to a current arbitrary point is initialized. An 
example of usage of normal computation is ray tracing.</p>
<p>The two most important features of the geometrical modeller 
concerning tracking are scalability and performance as function of the 
total number of physical nodes. The first refers to the possibility to 
make use of the available memory resources and at the same time be able 
to resolve any geometrical query, while the second defines the 
capability of the modeller to respond quickly even for huge geometries. 
These parameters can become critical when simulating big experiments 
like those at LHC.</p>
<h3 id="creating-and-visualizing-tracks"><span class="header-section-number">18.5.8</span> Creating and Visualizing Tracks</h3>
<p>In case the modeller is interfaced with a tracking engine, one might 
consider quite useful being able to store and visualize at least a part 
of the tracks in the context of the geometry. The base class <strong><code>TVirtualGeoTrack</code></strong> provides this functionality. It currently has one implementation inside the drawing package (<strong><code>TGeoTrack</code></strong> class). A track can be defined like:</p>
<div class="sourceCode" id="cb1076"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1076-1" title="1">TVirtualGeoTrack(<span class="dt">Int_t</span> id,<span class="dt">Int_t</span> pdg,TVirtualGeoTrack *parent=<span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1076-2" title="2">TObject *particle=<span class="dv">0</span>);</a></code></pre></div>
<p>Where: <code>id</code> is user-defined id of the track, <code>pdg</code> - <code>pdg</code> code, <code>parent</code> - a pointer to parent track, <code>particle</code> - a pointer to an arbitrary particle object (may be a <strong><code>TParticle</code></strong>).</p>
<p>A track has a list of daughters that have to be filled using the following method:</p>
<div class="sourceCode" id="cb1077"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1077-1" title="1">TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(<span class="dt">Int_t</span> id,<span class="dt">Int_t</span> pdg,</a>
<a class="sourceLine" id="cb1077-2" title="2">TObject *particle=<span class="dv">0</span>);</a></code></pre></div>
<p>The method above is pure virtual and have to create a track daughter 
object. Tracks are fully customizable objects when inheriting from <strong><code>TVirtualGeoTrack</code></strong> class. We will describe the structure and functionality provided by the default implementation of these, which are <strong><code>TGeoTrack</code></strong> objects.</p>
<p>A <strong><code>TGeoTrack</code></strong> is storing a list of <code>control points</code> <code>(x,y,z)</code> belonging to the track, having also time information <code>(t)</code>.
 The painting algorithm of such tracks allows drawing them in any time 
interval after their creation. The track position at a given time is 
computed by interpolation between control points.</p>
<div class="sourceCode" id="cb1078"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1078-1" title="1">myTrack-&gt;AddPoint(x,y,z,t);</a></code></pre></div>
<p>The creation and management of tracks is in fact fully controlled by the <strong><code>TGeoManager</code></strong> class. This holds a list of <code>primary tracks</code> that is also visible during browsing as <code>Tracks</code>
 folder. Primary tracks are tracks having no parent in the tracking 
history (for instance the output of particle generators may be 
considered as primaries from tracking point of view). The manager class 
holds in<strong><code>TGeoManager::fCurrentTrack</code> a pointer to the current track. When starting tracking a particle, one can create a track object like:</strong></p>
<div class="sourceCode" id="cb1079"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1079-1" title="1"><span class="dt">Int_t</span> track_index = gGeoManager-&gt;AddTrack(id,pdg,ptrParticle);</a></code></pre></div>
<p>Here <code>track_index</code> is the index of the newly created track
 in the array of primaries. One can get the pointer of this track and 
make it known as current track by the manager class:</p>
<div class="sourceCode" id="cb1080"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1080-1" title="1">TVirtualGeoTrack *track = gGeoManager-&gt;GetTrack(track_index);</a>
<a class="sourceLine" id="cb1080-2" title="2">gGeoManager-&gt;SetCurrentTrack(track);</a>
<a class="sourceLine" id="cb1080-3" title="3"><span class="co">// or directly</span></a>
<a class="sourceLine" id="cb1080-4" title="4">gGeoManager-&gt;SetCurrentTrack(track_index);</a>
<a class="sourceLine" id="cb1080-5" title="5">TVirtualGeoTrack *current = gGeoManager-&gt;GetCurrentTrack();</a></code></pre></div>
<p>One can also look for a track by <code>user id</code> or <code>track index</code>:</p>
<div class="sourceCode" id="cb1081"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1081-1" title="1">ptrTrack = gGeoManager-&gt;GetTrackOfId(user_id);</a>
<a class="sourceLine" id="cb1081-2" title="2">ptrParent = gGeoManager-&gt;GetParentTrackOfId(user_id);</a>
<a class="sourceLine" id="cb1081-3" title="3">ptrTrack = gGeoManager-&gt;GetTrack(index);</a></code></pre></div>
<p>Supposing a particle represented by a primary track decays or 
interacts, one should not create new primaries as described before, but 
rather add them as secondary:</p>
<div class="sourceCode" id="cb1082"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1082-1" title="1">TVirtualGeoTrack *secondary =</a>
<a class="sourceLine" id="cb1082-2" title="2">ptrTrack-&gt;AddTrack(secondId,pdg,secondParticle);</a></code></pre></div>
<p>At any step made by the current track, one is able to add control points to either primary or secondary:</p>
<div class="sourceCode" id="cb1083"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1083-1" title="1">track-&gt;AddPoint(x,y,z,t);</a></code></pre></div>
<p>After tracks were defined and filled during tracking, one will be 
able to browse directly the list of tracks held by the manager class. 
Any track can be drawn using its <code>Draw()</code> and <code>Animate()</code> methods, but there are also global methods for drawing or animation that can be accessed from <strong><code>TGeoManager</code></strong> context menu:</p>
<div class="sourceCode" id="cb1084"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1084-1" title="1">TGeoManager::DrawTracks(<span class="dt">Option_t</span> *option);</a>
<a class="sourceLine" id="cb1084-2" title="2">TGeoManager::AnimateTracks(<span class="dt">Double_t</span> tmin=<span class="fl">0.</span>,<span class="dt">Double_t</span> tmax=<span class="fl">1E-8</span>,</a>
<a class="sourceLine" id="cb1084-3" title="3"><span class="dt">Int_t</span> nframes=<span class="dv">200</span>,<span class="dt">Option_t</span> *option=<span class="st">""</span>);</a></code></pre></div>
<p>The drawing/animation time range is a global variable that can be directly set:</p>
<div class="sourceCode" id="cb1085"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1085-1" title="1">gGeoManager-&gt;SetTminTmax(tmin, tmax);</a>
<a class="sourceLine" id="cb1085-2" title="2"><span class="co">// without arguments resets the time range to the maximum value</span></a></code></pre></div>
<p>Once set, the time range will be active both for individual or global
 track drawing. For animation, this range is divided to the desired 
number of frames and will be automatically updated at each frame in 
order to get the animation effect.</p>
<p>The option provided to all track-drawing methods can trigger different track selections:</p>
<p><code>default:</code>A track (or all primary tracks) drawn without daughters</p>
<p><code>/D:</code> Track and first level descendents only are drawn</p>
<p><code>/*:</code> Track and all descendents are drawn</p>
<p><code>/Ntype:</code> All tracks having <code>name=type</code> are drawn</p>
<p>Generally several options can be concatenated in the same string (E.g. <code>"/D /Npion-"</code>).</p>
<p>For animating tracks, additional options can be added:</p>
<p><code>/G:</code>Geometry animate. Generally when drawing or animating
 tracks, one has to first perform a normal drawing of the geometry as 
convenient. The tracks will be drawn over the geometry. The geometry 
itself will be animated (camera moving and rotating in order to “catch” 
the majority of current track segments.)</p>
<p><code>/S:</code>Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames.</p>
<h2 id="checking-the-geometry"><span class="header-section-number">18.6</span> Checking the Geometry</h2>
<p>Several checking methods are accessible from the context menu of 
volume objects or of the manager class. They generally apply only to the
 visible parts of the drawn geometry in order to ease geometry checking,
 and their implementation is in the <strong><code>TGeoChecker</code></strong> class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs.</p>
<h3 id="the-overlap-checker"><span class="header-section-number">18.6.1</span> The Overlap Checker</h3>
<p>An overlap is any region in the Euclidian space being contained by 
more than one positioned volume. Due to the containment scheme used by 
the modeller, all points inside a volume have to be also contained by 
the mother therefore are overlapping in that sense. This category of 
overlaps is ignored due to the fact that any such point is treated as 
belonging to the deepest node in the hierarchy.</p>
<figure>
<img src="ROOTUsersGuide_files/030001DE.png" alt="Extruding volumes"><figcaption>Extruding volumes</figcaption>
</figure>
<p>A volume containment region is in fact the result of the subtraction 
of all daughters. On the other hand, there are two other categories of 
overlaps that are considered illegal since they lead to unpredictable 
results during tracking.</p>
<ol type="A">
<li><p>If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an <code>extrusion</code>.
 When navigating from outside to inside (trying to enter such a node) 
these regions are invisible since the current track has not yet reached 
its mother. This is not the case when going the other way since the 
track has first to exit the extruding node before checking the mother. 
In other words, an extrusion behavior is dependent on the track 
parameters, which is a highly undesirable effect.</p></li>
<li><p>We will call <strong><em><code>overlaps</code></em></strong> only
 the regions in space contained by more than one node inside the same 
container. The owner of such regions cannot be determined based on 
hierarchical considerations; therefore they will be considered as 
belonging to the node from which the current track is coming from.</p></li>
</ol>
<p>When coming from their container, the ownership is totally 
unpredictable. Again, the ownership of overlapping regions highly 
depends on the current track parameters.</p>
<p>We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using <strong><code>TGeoVolume</code></strong><code>::AddNodeOverlap()</code>
 method. Navigation is performed in such cases by giving priority to the
 non-overlapping nodes. The modeller has to perform an additional search
 through the overlapping candidates. These are detected automatically 
during the geometry closing procedure in order to optimize the 
algorithm, but we will stress that extensive usage of this feature leads
 to a drastic deterioration of performance. In the following we will 
focus on the non-declared overlaps of type A) and B) since this is the 
main source of errors during tracking. These are generally non-intended 
overlaps due to coding mistakes or bad geometry design. The checking 
package is loaded together with the painter classes and contains an 
automated overlap checker.**</p>
<figure>
<img src="ROOTUsersGuide_files/030001DF.png" alt="Overlap checking"><figcaption>Overlap checking</figcaption>
</figure>
<p>This can be activated both at volume level (checking for illegal 
overlaps only one level inside a given volume) and from the geometry 
manager level (checking full geometry):</p>
<div class="sourceCode" id="cb1086"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1086-1" title="1">myVolume-&gt;CheckOverlaps(precision, option);</a>
<a class="sourceLine" id="cb1086-2" title="2">gGeoManager-&gt;CheckOverlaps(precision);</a>
<a class="sourceLine" id="cb1086-3" title="3">myNode-&gt;CheckOverlaps(precision);</a></code></pre></div>
<p>Here precision represents the desired maximum accepted overlap value 
in centimeters (default value is 0.1). This tool checks all possible 
significant pairs of candidates inside a given volume (not declared as 
overlapping or division volumes). The check is performed by verifying 
the mesh representation of one candidate against the shape of the other.
 This sort of check cannot identify all possible overlapping topologies,
 but it works for more than 95% and is much faster than the usual 
shape-to-shape comparison. For a 100% reliability, one can perform the 
check at the level of a single volume by using <code>option</code>=“<code>d</code>” or <code>option</code>=“<code>d&lt;number&gt;</code>” to perform overlap checking by sampling the volume with &lt;<code>number</code>&gt;
 random points (default 1 million). This produces also a picture showing
 in red the overlapping region and estimates the volume of the overlaps.</p>
<p>An extrusion A) is declared in any of the following cases:</p>
<ul>
<li>At least one of the vertices of the daughter mesh representation is 
outside the mother volume (in fact its shape) and having a safety 
distance to the mother greater than the desired value;</li>
<li>At least one of the mother vertices is contained also by one of its daughters, in the same conditions.</li>
</ul>
<p>An overlap B) is declared if:</p>
<ul>
<li>At least one vertex of a positioned volume mesh is contained (having
 a safety bigger than the accepted maximum value) by other positioned 
volume inside the same container. The check is performed also by 
inverting the candidates.</li>
</ul>
<p>The code is highly optimized to avoid checking candidates that are 
far away in space by performing a fast check on their bounding boxes. 
Once the checking tool is fired-up inside a volume or at top level, the 
list of overlaps (visible as Illegal overlaps inside a <strong><code>TBrowser</code></strong>) held by the manager class will be filled with <strong><code>TGeoOverlap</code></strong>
 objects containing a full description of the detected overlaps. The 
list is sorted in the decreasing order of the overlapping distance, 
extrusions coming first. An overlap object name represents the full 
description of the overlap, containing both candidate node names and a 
letter (x-extrusion, o-overlap) representing the type. Double-clicking 
an overlap item in a <strong><code>TBrowser</code></strong> produces a 
picture of the overlap containing only the two overlapping nodes (one in
 blue and one in green) and having the critical vertices represented by 
red points. The picture can be rotated/zoomed or drawn in X3d as any 
other view. Calling <code>gGeoManager-&gt;PrintOverlaps()</code> prints the list of overlaps.</p>
<h3 id="graphical-checking-methods"><span class="header-section-number">18.6.2</span> Graphical Checking Methods</h3>
<figure>
<img src="ROOTUsersGuide_files/030001E0.png" alt="Safety computation checking"><figcaption>Safety computation checking</figcaption>
</figure>
<p>In order to check a given point, <code>CheckPoint(x,y,z)</code> method of <strong><code>TGeoManager</code></strong>
 draws the daughters of the volume containing the point one level down, 
printing the path to the deepest physical node holding this point. It 
also computes the closest distance to any boundary.</p>
<figure>
<img src="ROOTUsersGuide_files/030001E1.png" alt="Random points"><figcaption>Random points</figcaption>
</figure>
<p>A method to check the validity of a given geometry is shooting random points. This can be called with the method <strong><code>TGeoVolume</code></strong><code>::RandomPoints()</code>
 and it draws a volume with the current visualization settings. Random 
points are generated in the bounding box of the drawn volume. The points
 are drawn with the color of their deepest container. Only points inside
 visible nodes are drawn.</p>
<figure>
<img src="ROOTUsersGuide_files/030001E2.png" alt="Random rays"><figcaption>Random rays</figcaption>
</figure>
<p>A ray tracing method can be called <code>TGeoVolume::RandomRays()</code>.
 This shoots rays from a given point in the local reference frame with 
random directions. The intersections with displayed nodes appear as 
segments having the color of the touched node.</p>
<h2 id="the-drawing-package"><span class="header-section-number">18.7</span> The Drawing Package</h2>
<p><img src="ROOTUsersGuide_files/030001E3.png">The modeller provides a 
powerful drawing package, supporting several different options of 
visualization. A library separated from the main one provides all 
functionality being linked with the underlying ROOT visualization 
system. This library is dynamically loaded by the plug-in manager only 
when drawing features are requested. The geometrical structures that can
 be visualized are volumes and volume hierarchies.</p>
<p>The main component of the visualization system is volume primitive 
painting in a ROOT pad. Starting from this one, several specific options
 or subsystems are available, like: X3D viewing using hidden line and 
surface removal algorithms, OpenGL viewing* or ray tracing.</p>
<p>The method <code>TGeoManager::GetGeomPainter()</code>loads the painting library in memory.</p>
<p>This is generally not needed since it is called automatically by <code>TGeoVolume::Draw()</code> as well as by few other methods setting visualization attributes.</p>
<h3 id="drawing-volumes-and-hierarchies-of-volumes"><span class="header-section-number">18.7.1</span> Drawing Volumes and Hierarchies of Volumes</h3>
<p>The first thing one would like to do after building some geometry is 
to visualize the volume tree. This provides the fastest validation check
 for most common coding or design mistakes. As soon as the geometry is 
successfully closed, one should draw it starting from the top-level 
volume:</p>
<div class="sourceCode" id="cb1087"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1087-1" title="1"><span class="co">//... code for geometry building</span></a>
<a class="sourceLine" id="cb1087-2" title="2">root[] gGeoManager-&gt;CloseGeometry();</a>
<a class="sourceLine" id="cb1087-3" title="3">root[] gGeoManager-&gt;GetMasterVolume()-&gt;Draw();</a></code></pre></div>
<p>Doing this ensures that the original top-level volume of the geometry
 is drawn, even if another volume is currently the geometry <code>root</code>.
 OK, I suppose you already did that with your simple geometry and 
immediately noticed a new ROOT canvas popping-up and having some more or
 less strange picture inside. Here are few questions that might come:</p>
<p><strong><em><code>Q:</code></em></strong> “The picture is strangely rotated; where are the coordinate axes?”</p>
<p><strong><em><code>A:</code></em></strong> If drawn in a new canvas, 
any view has some default viewpoint, center of view and size. One can 
then perform mouse/keyboard actions to change them:</p>
<ul>
<li><p>Mouse left-click and drag will rotate the view;</p></li>
<li><p>Some keys can be pressed when the view canvas is selected: J/K 
zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes
 display as well as changing top or side viewpoints can be activated 
from the <strong><code>TView</code></strong> context menu: right-click on the picture when no object is selected;</p></li>
</ul>
<p><strong><em><code>Q:</code></em></strong> “Every line is black! I cannot figure out what is what…”</p>
<p><strong><em><code>A:</code></em></strong> Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: <code>myvolume-&gt;SetLineColor(Int_t color);</code> otherwise everything is by default black.</p>
<p><strong><em><code>Q:</code></em></strong> “The top volume of my geometry is a box but I see only its content.”</p>
<p><strong><em><code>A:</code></em></strong> By default the drawn volume
 is not displayed just because we do not want to hide its content when 
changing the view to HLR or solid mode. In order to see it in the 
default wire frame picture one has to call <strong><code>TGeoManager::SetTopVisible()</code>.</strong></p>
<p><strong><em><code>Q:</code></em></strong> “I do not see all volumes in my tree but just something inside.”</p>
<p><strong><em><code>A:</code></em></strong> By default, <strong><code>TGeoVolume</code></strong><code>::Draw()</code> paints the content of a given volume three levels down. You can change this by using: <strong><em><code>gGeoManager</code></em></strong><code>::SetVisLevel(n);</code></p>
<p>Not only that, but none of the volumes at intermediate levels (0-2) 
are visible on the drawing unless they are final ‘leaves’ on their 
branch (e.g.&nbsp;have no other volumes positioned inside). This 
behavior is the default one and corresponds to ‘leaves’ global 
visualization mode (<strong><code>TGeoManager::fVisOption = 1</code>). In order to see on the screen the intermediate containers, one can change this mode: <code>gGeoManager-&gt;SetVisOption(0)</code>.</strong></p>
<p><strong><em><code>Q:</code></em></strong> “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”</p>
<p><strong><em><code>A:</code></em></strong> Indeed, moving the mouse close to some volume vertices selects it. By checking the <code>Event Status</code> entry in the root canvas <code>Options</code>
 menu, you will see exactly which is the selected node in the bottom 
right. Right-clicking when a volume is selected will open its context 
menu where several actions can be performed (e.g.&nbsp;drawing it).</p>
<p><strong><em><code>Q:</code></em></strong> “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”</p>
<p><strong><em><code>A:</code></em></strong> Once you have set a convenient global visualization option and level, what you need is just call the <code>Draw()</code>
 method of your interesting volume. You can do this either by 
interacting with the expanded tree of volumes in a ROOT browser (where 
the context menu of any volume is available), either by getting a 
pointer to it (e.g.&nbsp;by name): <code>gGeoManager-&gt;GetVolume("vol_name")-&gt;Draw();</code></p>
<h3 id="visualization-settings-and-attributes"><span class="header-section-number">18.7.2</span> Visualization Settings and Attributes</h3>
<p>Supposing you now understand the basic things to do for drawing the 
geometry or parts of it, you still might be not happy and wishing to 
have more control on it. We will describe below how you can fine-tune 
some settings. Since the corresponding attributes are flags belonging to
 volume and node objects, you can change them at any time (even when the
 picture is already drawn) and see immediately the result.</p>
<h4 id="colors-and-line-styles"><span class="header-section-number">18.7.2.1</span> Colors and Line Styles</h4>
<p>We have already described how to change the line colors for volumes. 
In fact, volume objects inherit from TAttLine class so the line style or
 width can also be changed:</p>
<div class="sourceCode" id="cb1088"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1088-1" title="1">myVolume-&gt;SetLineColor(kRed);</a>
<a class="sourceLine" id="cb1088-2" title="2">myVolume-&gt;SetLineWith(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1088-3" title="3">myVolume-&gt;SetLineStyle(kDotted);</a></code></pre></div>
<p>When drawing in solid mode, the color of the drawn volume corresponds to the line color.</p>
<h4 id="visibility-settings"><span class="header-section-number">18.7.2.2</span> Visibility Settings</h4>
<p>The way geometry is build forces the definition of several volumes 
that does not represent real objects, but just virtual containers used 
for grouping and positioning volumes together. One would not want to see
 them in the picture. Since every volume is by default visible, one has 
to do this sort of tuning by its own:</p>
<div class="sourceCode" id="cb1089"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1089-1" title="1">myVolumeContainer-&gt;SetVisibility(kFALSE);</a></code></pre></div>
<p>As described before, the drawing package supports two main global 
options: 1 (default) - only final volume leaves; 0 - all volumes down 
the drawn one appear on the screen. The global visible level put a 
limitation on the maximum applied depth. Combined with visibility 
settings per volume, these can tune quite well what should appear on the
 screen. However, there are situations when users want to see a volume 
branch displayed down to the maximum depth, keeping at the same time a 
limitation or even suppressing others. In order to accomplish that, one 
should use the volume attribute: <code>Visible daughters</code>. By 
default, all daughters of all volumes are displayed if there is no 
limitation related with their level depth with respect to the top drawn 
volume.</p>
<h3 id="ray-tracing"><span class="header-section-number">18.7.3</span> Ray Tracing</h3>
<p>Ray tracing is a quite known drawing technique based on tracking rays
 from the eye position through all pixels of a view port device. The 
pixel color is derived from the properties of the first crossed surface,
 according some illumination model and material optical properties. 
While there are currently existing quite sophisticated ray tracing 
models, <strong><code>TGeo</code></strong> is currently using a very 
simple approach where the light source is matching the eye position (no 
shadows or back-tracing of the reflected ray). In future we are 
considering providing a base class in order to be able to derive more 
complex models.</p>
<p>Due to the fact that the number of rays that have to be tracked 
matches the size in pixels of the pad, the time required by this 
algorithm is proportional to the pad size. On the other hand, the speed 
is quite acceptable for the default ROOT pad size and the images 
produced by using this technique have high quality. Since the algorithm 
is practically using all navigation features, producing ray-traced 
pictures is also a geometry validation check. Ray tracing can be 
activated at volume level as the normal <code>Draw()</code>.</p>
<figure>
<img src="ROOTUsersGuide_files/020001E4.jpg" alt="Ray-traced view in a pad"><figcaption>Ray-traced view in a pad</figcaption>
</figure>
<div class="sourceCode" id="cb1090"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1090-1" title="1">myVolume-&gt;Raytrace()</a></code></pre></div>
<p>Once ray-tracing a view, this can be zoomed or rotated as a usual 
one. Objects on the screen are no longer highlighted when picking the 
vertices but the corresponding volumes is still accessible.</p>
<h4 id="clipping-ray-traced-images"><span class="header-section-number">18.7.3.1</span> Clipping Ray-traced Images</h4>
<p>A ray-traced view can be <code>clipped</code> with any shape known by
 the modeller. This means that the region inside the clipping shape is 
subtracted from the current drawn geometry (become invisible). In order 
to activate clipping, one has to first define the clipping shape(s):</p>
<p><code>1. TGeoShape *clip1, *clip2, ...</code></p>
<p>One might switch between several clipping shapes. Note that these shapes are considered defined in the current <code>MARS</code>. Composite shapes may be used.</p>
<p>2<code>. gGeoManager-&gt;SetClippingShape(clip1);</code></p>
<p>One can activate or deactivate clipping at any time: <code>gGeoManager-&gt;SetClipping(flag);</code></p>
<ol start="3" type="1">
<li>Perform ray-tracing:<code>gGeoManager-&gt;GetTopVolume()-&gt;Raytrace();</code></li>
</ol>
<p>One can redo the steps 2-3 as many times as needed. Let us look how the <strong><em><code>rootgeom</code></em></strong> example looks clipped with a tube.</p>
<figure>
<img src="ROOTUsersGuide_files/030001E5.png" alt="Ray-tracing example with box-clipping"><figcaption>Ray-tracing example with box-clipping</figcaption>
</figure>
<h2 id="representing-misalignments-of-the-ideal-geometry"><span class="header-section-number">18.8</span> Representing Misalignments of the Ideal Geometry</h2>
<p>The ideal positioning of a detector does not match its position in 
the experimental hall. This generally happens not only for the detector 
modules, but also for their components. The accurate knowledge of the 
detector real misalignments can be extremely important for getting close
 to its designed resolution and the expected tracking efficiency. <strong><code>TGeo</code></strong>
 offers tools for representing positioning misalignments, applying them 
to the ideal geometry and performing navigation under these conditions. 
Detector tracking algorithms can then directly query the geometry for 
navigation purposes or for retrieving actual misalignment information.</p>
<h3 id="physical-nodes"><span class="header-section-number">18.8.1</span> Physical Nodes</h3>
<p>Physical nodes are the actual “touchable” objects in the geometry, 
representing actually a path of positioned volumes starting with the top
 node: <code>path=/TOP/A_1/B_4/C_3</code> , where <code>A</code>, <code>B</code>, <code>C</code>
 represent names of volumes. The number of physical nodes is given by 
the total number of possible of branches in the geometry hierarchy. In 
case of detector geometries and specially for calorimeters this number 
can be of the order 106-109, therefore it is impossible to create all 
physical nodes as objects in memory. In <strong><code>TGeo</code></strong>, physical nodes are represented by the class <strong><code>TGeoPhysicalNode</code></strong> and can be created on demand for alignment purposes:</p>
<div class="sourceCode" id="cb1091"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1091-1" title="1">TGeoPhysicalNode(<span class="at">const</span> <span class="dt">char</span>* path)</a></code></pre></div>
<p>The knowledge of the path to the objects that need to be misaligned 
is essential since there is no other way of identifying them. One can 
however create “symbolic links” to any complex path to make it more 
representable for the object it designates:</p>
<div class="sourceCode" id="cb1092"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1092-1" title="1">TGeoPNEntry(<span class="at">const</span> <span class="dt">char</span>* unique_name, <span class="at">const</span> <span class="dt">char</span>* path)</a>
<a class="sourceLine" id="cb1092-2" title="2"><span class="dt">void</span> TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node)</a></code></pre></div>
<p>Such a symbolic link hides the complexity of the path to the align 
object and replaces it with a more meaningful name. In addition, <strong><code>TGeoPNEntry</code></strong> objects are faster to search by name and they may optionally store an additional user matrix.</p>
<div class="sourceCode" id="cb1093"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1093-1" title="1"><span class="co">// Creating a symlink object.</span></a>
<a class="sourceLine" id="cb1093-2" title="2">TGeoPNEntry *TGeoManager::SetAlignableEntry(<span class="at">const</span> <span class="dt">char</span> *unique_n,</a>
<a class="sourceLine" id="cb1093-3" title="3"><span class="at">const</span> <span class="dt">char</span>*path)</a>
<a class="sourceLine" id="cb1093-4" title="4"><span class="co">// Retrieving an existing alignable object.</span></a>
<a class="sourceLine" id="cb1093-5" title="5">TGeoPNEntry *TGeoManager::GetAlignableEntry(<span class="at">const</span> <span class="dt">char</span> *name)</a>
<a class="sourceLine" id="cb1093-6" title="6"><span class="co">// Retrieving an existing alignable object at a given index.</span></a>
<a class="sourceLine" id="cb1093-7" title="7">TGeoPNEntry *GetAlignableEntry(<span class="dt">Int_t</span> index)</a></code></pre></div>
<p>Physical nodes store internally the full list of logical nodes 
corresponding to the elements from the string path, as well as the 
global transformation matrix for each of them. The top node corresponds 
to the level 0 in the stored array, while the last node will correspond 
to level <code>n</code>. For each level, the node, volume and global matrix can be retrieved using corresponding getters:</p>
<div class="sourceCode" id="cb1094"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1094-1" title="1">TGeoHMatrix *GetMatrix(<span class="dt">Int_t</span> level=-<span class="dv">1</span>) <span class="at">const</span></a>
<a class="sourceLine" id="cb1094-2" title="2">TGeoNode    *GetNode(<span class="dt">Int_t</span> level=-<span class="dv">1</span>) <span class="at">const</span></a>
<a class="sourceLine" id="cb1094-3" title="3">TGeoShape   *GetShape(<span class="dt">Int_t</span> level=-<span class="dv">1</span>) <span class="at">const</span></a>
<a class="sourceLine" id="cb1094-4" title="4">TGeoVolume  *GetVolume(<span class="dt">Int_t</span> level=-<span class="dv">1</span>) <span class="at">const</span></a></code></pre></div>
<p>By default the object at level n is retrieved (the align-able object).</p>
<p>Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:</p>
<div class="sourceCode" id="cb1095"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1095-1" title="1"><span class="dt">void</span> Align(TGeoMatrix* newmat=<span class="dv">0</span>, TGeoShape* newshape=<span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1095-2" title="2"><span class="dt">Bool_t</span> check=kFALSE)</a></code></pre></div>
<p>The convention used is that newmat represents the new local matrix of
 the last node in the branch with respect to its mother volume. The <code>Align()</code>
 method will actually duplicate the corresponding branch within the 
logical hierarchy, creating new volumes and nodes. This is mandatory in 
order to avoid problems due to replicated volumes and can create 
exhaustive memory consumption if used abusively.</p>
<p>Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.</p>
<p>Important NOTE: Calling the <code>Align()</code> method for a 
physical node changes the node pointers for the stored node branch in 
the active geometry, Due to this the other defined physical nodes 
containing elements of this path will be invalid. Example:</p>
<div class="sourceCode" id="cb1096"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1096-1" title="1">TGeoPhysicalNode *pn1 =</a>
<a class="sourceLine" id="cb1096-2" title="2">gGeoManager-&gt;MakePhysicalNode(<span class="st">"/A_1/B_1/C_2"</span>);</a>
<a class="sourceLine" id="cb1096-3" title="3">TGeoPhysicalNode *pn2 =</a>
<a class="sourceLine" id="cb1096-4" title="4">gGeoManager-&gt;MakePhysicalNode(<span class="st">"/A_1/B_1/C_3"</span>);</a>
<a class="sourceLine" id="cb1096-5" title="5">...</a>
<a class="sourceLine" id="cb1096-6" title="6">pn1-&gt;Align(...);</a></code></pre></div>
<p>The call to <code>pn1-&gt;Align()</code> will invalidate the pointer to the node <code>B_1</code> in <code>pn2</code> object.. The way out is to either call <code>pn1-&gt;Align()</code> before the creation of <code>pn2</code>, either to use a global method that will correct all existing physical nodes:</p>
<div class="sourceCode" id="cb1097"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1097-1" title="1"><span class="dt">void</span> RefreshPhysicalNodes(<span class="dt">Bool_t</span> lock = kTRUE)</a></code></pre></div>
<p>The method above will optionally lock the possibility of doing any further misalignment.</p>
<h2 id="geometry-io"><span class="header-section-number">18.9</span> Geometry I/O</h2>
<p>Once geometry is successfully built, it can be saved in a root file, as C++ macro or as GDML file by calling:</p>
<div class="sourceCode" id="cb1098"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1098-1" title="1">TGeoManager::Export(<span class="at">const</span> <span class="dt">char</span> *filename,<span class="at">const</span> <span class="dt">char</span>*keyname=<span class="st">""</span>,</a>
<a class="sourceLine" id="cb1098-2" title="2"><span class="dt">Option_t</span> *opt=<span class="st">"vg"</span>)</a></code></pre></div>
<ul>
<li><code>Filename</code>is the name of the file to be written 
(mandatory). Depending on the extension of the file, the geometry is 
exported either as ,root file or .C(.cxx) macro or GDML file in case 
extension is .gdml.</li>
<li><code>keyname</code>is the name of the key in the file (default "")</li>
<li><code>opt</code> = <code>"v"</code> is an export voxelization (default), otherwise voxelization is recomputed after loading the geometry, <code>"g"</code>
 this option (default) is taken into account only for exporting to gdml 
file and it ensures compatibility with Geant4 (e.g.&nbsp;it adds extra 
plane to incorrectly set polycone, it checks whether offset of Phi 
division is in (-360;0&gt; range, …), for this gdml export there are two
 more option, that are not set by default: <code>"f"</code> and <code>"n"</code>.
 If none of this two options are set, then names of solids and volumes 
in resulting gdml file will have incremental suffix (e.g. TGeoBBox_0x1, 
TGeoBBox_0x2, …). If <code>"f"</code> option is set then then suffix will contain pointer of object (e.g.&nbsp;TGeoBBox_0xAAAAA01, …). Finally if option <code>"n"</code>
 is set then no suffix will be added, though in this case uniqueness of 
the names is not ensured and it can cause that file will be invalid.</li>
</ul>
<p>Loading geometry from a root file can be done in the same way as for 
any other ROOT object, but a static method is also provided:</p>
<div class="sourceCode" id="cb1099"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1099-1" title="1">TGeoManager::Import(<span class="at">const</span> <span class="dt">char</span> *filename,<span class="at">const</span> <span class="dt">char</span> *keyname=<span class="st">""</span>,</a>
<a class="sourceLine" id="cb1099-2" title="2"><span class="dt">Option_t</span> *opt=<span class="st">""</span>)</a></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb1100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1100-1" title="1"><span class="co">// Writing to a file geometry definition ending with:</span></a>
<a class="sourceLine" id="cb1100-2" title="2">root[] gGeoManager-&gt;CloseGeometry();</a>
<a class="sourceLine" id="cb1100-3" title="3"><span class="co">// geometry is ready</span></a>
<a class="sourceLine" id="cb1100-4" title="4">root[] gGeoManager-&gt;Export(<span class="st">"MyGeom.root"</span>);</a>
<a class="sourceLine" id="cb1100-5" title="5"><span class="co">// file MyGeom.root produced</span></a>
<a class="sourceLine" id="cb1100-6" title="6">root[] gGeoManager-&gt;Export(<span class="st">"MyGeom.C"</span>);</a>
<a class="sourceLine" id="cb1100-7" title="7"> <span class="co">// C++ macro MyGeom.C produced</span></a>
<a class="sourceLine" id="cb1100-8" title="8">root[] gGeoManager-&gt;Export(<span class="st">"MyGeom.gdml"</span>);</a>
<a class="sourceLine" id="cb1100-9" title="9"> <span class="co">// GDML file MyGeom.gdml produced</span></a>
<a class="sourceLine" id="cb1100-10" title="10">root[] myVolume-&gt;SaveAs(<span class="st">"MyVolume.C"</span>);</a>
<a class="sourceLine" id="cb1100-11" title="11"> <span class="co">// C++ macro for the branch starting</span></a>
<a class="sourceLine" id="cb1100-12" title="12"> <span class="co">// with MyVolume</span></a>
<a class="sourceLine" id="cb1100-13" title="13"><span class="co">// Reading from a file</span></a>
<a class="sourceLine" id="cb1100-14" title="14">root[] gSystem-&gt;Load(<span class="st">"libGeom"</span>);</a>
<a class="sourceLine" id="cb1100-15" title="15">root[] TGeoManager::Import(<span class="st">"MyGeom.root"</span>);  <span class="co">// geometry is ready</span></a></code></pre></div>
<p>Note that not all-current information held by the modeller is written
 on the file. For instance, the painter and checker objects are not 
written, as well as the temporary current navigation properties: current
 node path, point or direction. On the other hand, all objects belonging
 to the geometrical hierarchy will always be written. The idea is to be 
able to retrieve the geometry in a ready state, ignoring what the state 
variables that can be always re-initialized. When the code is generated 
for a given <strong><code>TGeoVolume</code></strong> in the geometry, 
just the branch starting with that volume will be saved in the file. 
Executing the generated code will create a geometry that has <code>MyVolume</code> as top volume. In this case, only the materials/media/matrices used effectively in the <code>MyVolume</code> branch are exported to file.</p>
<p>Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to <strong><code>TGeoVolume</code></strong> objects):</p>
<div class="sourceCode" id="cb1101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1101-1" title="1">module1-&gt;Export(<span class="st">"file.root"</span>);</a>
<a class="sourceLine" id="cb1101-2" title="2"><span class="co">// by default file is overwritten</span></a>
<a class="sourceLine" id="cb1101-3" title="3">module2-&gt;Export(<span class="st">"file.root"</span>,<span class="st">""</span>,<span class="st">"update"</span>);</a>
<a class="sourceLine" id="cb1101-4" title="4"><span class="co">// to the same file</span></a></code></pre></div>
<p>Importing will append the volume to the current TGeoManager or will create one:</p>
<div class="sourceCode" id="cb1102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1102-1" title="1">TGeoManager *geom = <span class="kw">new</span> TGeoManager(<span class="st">"myGeom"</span>, <span class="st">""</span>);</a>
<a class="sourceLine" id="cb1102-2" title="2">TGeoVolume *top = geom-&gt;MakeBox(...);</a>
<a class="sourceLine" id="cb1102-3" title="3">geom-&gt;SetTopVolume(top);</a>
<a class="sourceLine" id="cb1102-4" title="4"><span class="co">//name of volume or key (depending on export usage)</span></a>
<a class="sourceLine" id="cb1102-5" title="5">TGeoVolume *module1 = TGeoVolume::Import(<span class="st">"file.root"</span>, <span class="st">"MOD1"</span>);</a>
<a class="sourceLine" id="cb1102-6" title="6">TGeoVolume *module2 = TGeoVolume::Import(<span class="st">"file.root"</span>, <span class="st">"MOD2"</span>);</a>
<a class="sourceLine" id="cb1102-7" title="7">top-&gt;AddNode(module1, <span class="dv">1</span>, <span class="kw">new</span> TGeoTranslation(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">100</span>));</a>
<a class="sourceLine" id="cb1102-8" title="8">top-&gt;AddNode(module2, <span class="dv">1</span>, <span class="kw">new</span> TGeoTranslation(<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">100</span>));</a>
<a class="sourceLine" id="cb1102-9" title="9"><span class="co">// One should close oneself the geometry</span></a>
<a class="sourceLine" id="cb1102-10" title="10">geom-&gt;CloseGeometry();</a></code></pre></div>
<h3 id="gdml"><span class="header-section-number">18.9.1</span> GDML</h3>
<p>Few lines above word GDML was used. GDML stands for <strong>G</strong>eometry <strong>D</strong>escription <strong>M</strong>arkup <strong>L</strong>anguage.
 It is an application-independent geometry description format based on 
XML. It is mainly used for geometry interchange between ROOT and Geant4 
framework. More details about this project can be found 
http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml 
file format) is disabled by default in ROOT installation. To enable this
 feature add <code>--enable-gdml</code> option to <code>./configure</code> script call.</p>
<h2 id="navigation-algorithms"><span class="header-section-number">18.10</span> Navigation Algorithms</h2>
<p>This section will describe the main methods and algorithms used for 
implementing the navigation features within the geometrical modeller. 
This includes navigation queries at shape level, global geometrical 
queries and optimization mechanisms.</p>
<h3 id="finding-the-state-corresponding-to-a-location-xyz"><span class="header-section-number">18.10.1</span> Finding the State Corresponding to a Location (x,y,z)</h3>
<p>For reminder, a geometry state is a ‘touchable’ object in the geometry hierarchy. It is represented by a path like: <strong>/TOP_1/A_1/B_3/C_1</strong>, where <strong>B_3</strong> for instance is a copy of volume <strong>B</strong> positioned inside volume <strong>A</strong>. A state is always associated to a transformation matrix <strong>M</strong>
 of the touchable with respect to the global reference frame (obtained 
by piling-up all local transformations of nodes in the branch with 
respect to their containers). The current state and the corresponding 
global matrix are updated whenever the geometry depth is modified. The 
global transformations corresponding to all nodes in the current branch 
are kept in an array: (<strong>MTOP_1, MA_1, MB_3, …</strong>).</p>
<figure>
<img src="ROOTUsersGuide_files/080001E6.png" alt="Navigation in the geometry hierarchy"><figcaption>Navigation in the geometry hierarchy</figcaption>
</figure>
<p>The elementary operations for changing the state are:</p>
<div class="sourceCode" id="cb1103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1103-1" title="1">TGeoManager::CdUp();</a>
<a class="sourceLine" id="cb1103-2" title="2">TGeoManager::CdDown(i);</a>
<a class="sourceLine" id="cb1103-3" title="3">TGeoManager::CdTop()</a></code></pre></div>
<p>The current state accounting and global matrix handling after these 
operations are depicted in the figure below. Now let us suppose that we 
have a particle at position <em>P(x,y,z)</em>. The first thing needed 
for transporting it is the current object our particle is into, so that 
we can retrieve its material properties. This task is done by:</p>
<div class="sourceCode" id="cb1104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1104-1" title="1">TGeoNode *TGeoManager::FindNode(x,y,z)</a></code></pre></div>
<p>Note that the current particle position can be set using <strong><code>SetCurrentPosition(x,y,z)</code></strong> method of the manager class, in which case <strong><code>FindNode()</code></strong> can be called without arguments. The method returns a pointer to the <em>deepest node</em> that geometrically contains <em>P</em> (in our case let us suppose it is <em>B_3</em>). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. <em>Deepest</em> means that <em>B_3</em> still contains point <em>P</em> (as well as <em>A_1</em> and <em>TOP_1</em>), but none of the daughters of volume <strong>B</strong>
 does. After finding out the node containing the particle, one can check
 if the geometry state is different compared to the last located point:</p>
<div class="sourceCode" id="cb1105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1105-1" title="1"><span class="dt">Bool_t</span> *TGeoManager::IsSameLocation()</a></code></pre></div>
<p>The algorithm for finding where a point is located in geometry is presented in the figure 17-36.</p>
<p>It always starts by checking if the last computed modeller state is 
the answer. This optimizes the search when continuously tracking a 
particle. The main actions performed are:</p>
<ul>
<li>moving up and down in the logical node tree while updating the current node and its global matrix</li>
<li>converting the global position into the local frame of the current node/volume</li>
<li>checking whether the local position lies within the geometrical 
shape of the current volume - if this is the case continue the search 
downwards for the daughters of the current node, otherwise search 
upwards its containers until the top level is reached.</li>
<li>the number of candidate nodes to be checked at a given level is 
minimized by an additional optimization structure: voxels. This is 
effective even in case there is only one daughter of the current volume.</li>
<li>in case the current node is declared as possibly overlapping, the 
method FindInCluster() is invoked. This method checks all different 
possibilities within the cluster of overlapping candidates. One of the 
candidates is prioritized if one of the following conditions id 
fulfilled (in order):</li>
<li>Is declared as non-overlapping (these are anyway searched first)</li>
<li>Has at least one daughter that contains the current point</li>
<li>Was already declared as containing the point at a previous step</li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/080001E7.png" alt="Finding the location of a point in the geometry hierarchy"><figcaption>Finding the location of a point in the geometry hierarchy</figcaption>
</figure>
<h3 id="finding-the-distance-to-next-crossed-boundary"><span class="header-section-number">18.10.2</span> Finding the Distance to Next Crossed Boundary</h3>
<p>The most important feature provided by the modeller related to track 
propagation is the computation of the distance to the next boundary 
along a straight line.</p>
<p>The relevant state parameters used for this task are:</p>
<ul>
<li>Current particle position and direction <code>(x,y,z,nx,ny,nz)</code>, where ni is the direction cosine with axis (<code>i</code>).</li>
<li>Current node (and path) in geometry must be set by calling <code>TGeoManager::FindNode(x,y,z)</code>beforehand The method computing the distance to next boundary is:</li>
</ul>
<div class="sourceCode" id="cb1106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1106-1" title="1">TGeoNode *TGeoManager::FindNextBoundary(stepmax, path)</a></code></pre></div>
<p>The output node returned by the method is the object which shape 
boundary will be crossed first. The distance to the next crossing can be
 retrieved after the call:</p>
<div class="sourceCode" id="cb1107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1107-1" title="1"><span class="dt">Double_t</span> TGeoManager::GetStep()</a></code></pre></div>
<ul>
<li>The main input parameter is <code>stepmax,</code> which act as a 
trigger for different features. The absolute value of this parameter 
represents the step value proposed by the user. The algorithm will never
 try o search for boundaries further than this distance. In case no 
boundary is found the returned node will be the current one and the 
computed step to boundary will be equal to abs (<code>stepmax</code>) having the meaning <em>“step approved”</em>. The default value for <code>stepmax</code> is <code>TGeoShape::Big</code>with the meaning that boundaries are looked for without limitation.</li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/080001E8.png" alt="Finding the distance to the next crossed boundary"><figcaption>Finding the distance to the next crossed boundary</figcaption>
</figure>
<p>According the values of the input parameters the method will perform additional optional tasks:</p>
<p><strong><code>|stepmax| &lt;</code></strong> <strong><em><code>TGeoShape::Big()</code></em></strong> <strong><code></code></strong></p>
<p>The safe distance in the current volume is also computed. Moving the 
particle from its current location with this distance in any direction 
is safe in the sense that will never change the current state.</p>
<p><strong><code>stepmax &lt; 0</code></strong></p>
<p>The global matrix for the object that will have the next crossed 
boundary is also computed. This can be retrieved for masterlocal point 
or vector conversions: <strong><code>TGeoManager</code></strong>::<code>GetNextMatrix</code>()</p>
<p>In case the computation of the normal vector to the next crossed 
surface is required, using a negative stepmax value is recommended. In 
this case one can subsequently call a method for fast normal 
computation:</p>
<div class="sourceCode" id="cb1108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1108-1" title="1"><span class="dt">Double_t</span> *TGeoManager::FindNormalFast()</a></code></pre></div>
<p><strong><code>path</code></strong> <strong><code>0</code></strong></p>
<p>In case a path to a given physical object is specified, the distance 
to its boundary is computed ignoring the rest of the geometry</p>
<h4 id="output-values"><span class="header-section-number">18.10.2.1</span> Output Values</h4>
<p><code>TGeoManager::GetStep()</code>: distance to next boundary.</p>
<p><code>TGeoManager::GetSafeDistance()</code>: safe distance (in case it was computed).</p>
<p><code>TGeoManager::IsOnBoundary()</code>: the initial point <code>(x,y,z)</code> was (or was not) on a boundary within <code>TGeoShape::Tolerance()</code>.</p>
<p>The algorithm checks first if the computation of safety was required.
 If this is the case and the global point coordinates did not change 
from the last query, the last computed safety is taken. Otherwise, the 
method <strong><code>TGeoManager</code></strong><code>::Safety ()</code> is invoked. A safety value less than <strong><code>TGeoShape</code></strong><code>::Tolerance()</code>
 will set the flag IsOnBoundary to true. On the other hand, a safety 
value bigger than the proposed step will stop the computation of the 
distance to next boundary, returning the current geometry location with 
the meaning that the proposed step is safe.</p>
<p>The next stage is to check if computation of the distance to a give 
physical object specified by a path was required. If this is the case, 
the modeller changes the state to point to the required object, converts
 the current point and direction coordinates to the local frame of this 
object and computes the distance to its shape. The node returned is the 
one pointed by the input path in case the shape is crossed; otherwise 
the returned value is NULL. In case the distance to next crossed 
boundary is required, the current point has to be physically INSIDE the 
shape pointed by the current volume. This is only insured in case a call
 to <code>TGeoManager::FindNode()</code> was performed for the current 
point. Therefore, the first step is to convert the global current point 
and direction in the local reference frame of the current volume and to 
compute the distance to exit its shape from inside. The returned value 
is again compared to the maximum allowed step (the proposed one) and in 
case the distance is safe no other action is performed and the proposed 
step is approved. In case the boundary is closer, the computed distance 
is taken as maximum allowed step. For optimization purposed, for 
particles starting very close to the current volume boundary (less than 
0.01 microns) and exiting the algorithm stops here.</p>
<p>After computing the distance to exit the current node, the distance 
to the daughter of the current volume which is crossed next is computed 
by <strong><code>TGeoManager</code></strong><code>::FindNextDaughterBoundary().</code>
 This computes the distance to all daughter candidates that can be 
possibly crossed by using volume voxelization. The algorithm is 
efficient in average only in case the number of daughters is greater 
than 4. For fewer nodes, a simple loop is performed and the minimum 
distance (from a point outside each shape) is taken and compared to the 
maximum allowed step. The step value is again updated if <code>step&lt;stepmax</code> .</p>
<p>A special case is when the current node is declared as possibly 
overlapping with something else. If this is the case, the distance is 
computed for all possibly overlapping candidates, taking into account 
the overlapping priorities (see also: " Overlapping volumes ").</p>
<p>The global matrix describing the next crossed physical node is 
systematically computed in case the value of the proposed step is 
negative. In this case, one can subsequently call <code>TGeoManager::ComputeNormalFast()</code> to get the normal vector to the crossed surface, after propagating the current point with the <code>TGeoManager::GetStep()</code> value. This propagation can be done like:</p>
<div class="sourceCode" id="cb1109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1109-1" title="1"><span class="dt">Double_t</span> *current_point = gGeoManager-&gt;GetCurrentPoint();</a>
<a class="sourceLine" id="cb1109-2" title="2"><span class="dt">Double_t</span> *current_dir = gGeoManager-&gt;GetCurrentDirection();</a>
<a class="sourceLine" id="cb1109-3" title="3"><span class="cf">for</span> (<span class="dt">Int_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">3</span>; i++)</a>
<a class="sourceLine" id="cb1109-4" title="4">    current_point[i] += step * current_dir[I];</a></code></pre></div>
<p>Note: The method <code>TGeoManager::FindNextBoundary()</code> does 
not modify the current point/direction nor the current volume/state. The
 returned node is the next crossed one, but the physical path (state) 
AFTER crossing the boundary is not determined. In order to find out this
 new state, one has to propagate the point with a distance slightly 
bigger that the computed step value (which is accurate within numerical 
precision). A method that performs this task finding the next location 
is <code>TGeoManager::Step()</code>, described in " Making a Step ", but users may implement more precise methods to insure post-step boundary crossing.</p>
<h2 id="geometry-graphical-user-interface"><span class="header-section-number">18.11</span> Geometry Graphical User Interface</h2>
<p>The geombuilder package allows you to create and edit geometries. The
 package provides a library of all GUI classes related to geometry. Each
 editable geometry class <strong><code>TGeoXXX</code></strong> have a correspondent editor <strong><code>TGeoXXXEditor</code></strong>
 that provides a graphics user interface allowing to edit some (or all) 
parameters of a geometry object. The editable objects are geometry 
manager, volumes, nodes, shapes, media, materials and matrices. The 
interfaces provide also access to specific functionality of geometry 
objects. The editing mechanism is based on ROOT GED (Graphics Editors) 
functionality and the library is loaded using the plug-in mechanism.</p>
<h3 id="editing-a-geometry"><span class="header-section-number">18.11.1</span> Editing a Geometry</h3>
<p>There are two different use cases having different ways of invoking 
the geometry editors. The first one applies when starting with geometry 
from scratch and using the builder functionality to create new geometry 
objects. In this case, one should use the sequence:</p>
<div class="sourceCode" id="cb1110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1110-1" title="1">root[] TGeoManager *geom = <span class="kw">new</span> TGeoManager(<span class="st">"MyGeom"</span>,</a>
<a class="sourceLine" id="cb1110-2" title="2"><span class="st">"Test builder"</span>);</a>
<a class="sourceLine" id="cb1110-3" title="3">root[] geom-&gt;Edit(<span class="dt">Option_t</span> *option=<span class="st">""</span>);</a></code></pre></div>
<p>The lines above will create a new <strong><code>TGeoManager</code></strong>
 class, create an empty canvas and start the editor in the left-sided 
editor frame attached to the canvas. To open the editor in a separate 
frame one should provide a non-empty string as option to the <code>Edit()</code> method.</p>
<figure>
<img src="ROOTUsersGuide_files/030001E9.png" alt="The geometry manager editor"><figcaption>The geometry manager editor</figcaption>
</figure>
<h3 id="the-geometry-manager-editor"><span class="header-section-number">18.11.2</span> The Geometry Manager Editor</h3>
<p><img src="ROOTUsersGuide_files/020001EA.jpg" alt="Accessing/creating different categories of editable objects"> <img src="ROOTUsersGuide_files/020001EB.jpg" alt="Accessing/creating different categories of editable objects"> <img src="ROOTUsersGuide_files/020001EC.jpg" alt="Accessing/creating different categories of editable objects"> <img src="ROOTUsersGuide_files/020001ED.jpg" alt="Accessing/creating different categories of editable objects"> <img src="ROOTUsersGuide_files/020001EE.jpg" alt="Accessing/creating different categories of editable objects"></p>
<p>The second use case applies when starting to edit an existing 
geometry. Supposing the geometry was loaded into memory, besides the 
first method that still applies one can also edit drawn geometry 
objects. For this, the menu entry View/Editor of the canvas containing 
for instance a drawn volume must be activated. For starting the volume 
editor one can click on a volume. The GUI of the <strong><code>TGeoManager</code></strong> class can be started by clicking on the top-right <code>40x40</code> pixels corner of the pad with a drawn geometry.</p>
<p>This is the main entry point for editing the geometry or creating new
 objects. Once the interface is created (using one of the methods 
described above), several categories can be accessed via a shutter GUI 
widget:</p>
<ul>
<li><em>General.</em> This allows changing the name/title of the 
geometry, setting the top volume, closing the geometry and saving the 
geometry in a file. The file name is formed by <code>geometry_name.C</code> or <code>.root</code> depending if the geometry need to be saved as a <code>C</code> macro or a <code>.root</code> file.</li>
<li><em>Shapes.</em> The category provides buttons for creation of all 
supported shapes. The new shape name is chosen by the interface, but can
 be changed from the shape editor GUI. Existing shapes can be browsed 
and edited from the same category.</li>
<li><em>Volumes.</em> The category allows the creation of a new volume 
having a given name, shape and medium. For creating a volume assembly 
only the name is relevant. Existing volumes can be browsed or edited 
from this category.</li>
<li><em>Materials.</em> Allows creation of new materials/mixtures or editing existing ones.</li>
<li><em>Media.</em> The same for creation/editing of tracking media (materials having a set of properties related to tracking)</li>
<li><em>Matrices.</em> Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited.</li>
</ul>
<h3 id="editing-existing-objects"><span class="header-section-number">18.11.3</span> Editing Existing Objects</h3>
<p>For editing an existing object from one of the categories described 
above, the interface imposes first a selection among all objects of the 
corresponding type stored in the geometry. This can be done by clicking 
the button next to the blue label <em>Select &lt;object&gt;</em>. The 
dialog interfaces are generally different for different types of 
objects. The volume selection dialog offers the possibility to select 
either a volume already connected to the geometry hierarchy or 
non-connected ones. Selection for shapes and matrices is split into 
categories represented by top-level list tree items for: boxes, tubes, 
translations, rotations, etc.</p>
<figure>
<img src="ROOTUsersGuide_files/030001EF.png" alt="Selection dialogs for different TGeo objects"><figcaption>Selection dialogs for different TGeo objects</figcaption>
</figure>
<p>Once a selection is made and the dialog is closed, the selected item 
name will appear in the corresponding label and the button Edit will 
start the object editor in a transient frame. Closing these transient 
frames will not delete, but just hide existing opened editors for later 
reuse. Their lifetime is determined by the canvas to which the manager 
editor is attached to, since these will be destroyed together.</p>
<p><img src="ROOTUsersGuide_files/020001F0.jpg" alt="Editors for shapes, materials, media, matrices"> <img src="ROOTUsersGuide_files/020001F1.jpg" alt="Editors for shapes, materials, media, matrices"> <img src="ROOTUsersGuide_files/020001F2.jpg" alt="Editors for shapes, materials, media, matrices"> <img src="ROOTUsersGuide_files/020001F3.jpg" alt="Editors for shapes, materials, media, matrices"> <img src="ROOTUsersGuide_files/030001F4.png" alt="Editors for shapes, materials, media, matrices"></p>
<p>For most editors, the functionalities Apply and Undo are provided.</p>
<p>For shapes, changing any of the shape parameters will activate the “<em>Apply</em>” button only if the check button “<em>Delayed draw</em>”
 is checked, otherwise the changes are immediately applied. Once the 
apply button is pressed, the changes are applied to the edited shape and
 drawn. The “<em>Undo</em>” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.</p>
<p>NOTE: In this version the “<em>Undo</em>” does not allow restoring an
 intermediate state of the parameters that was applied - it will always 
restore the parameters at the moment the shape was edited.</p>
<p>All material properties changes are undoable. The mixture editor 
currently allows adding elements one by one in the mixture composition. 
This can be done either by element weight fraction or by number of 
atoms. Once an element was added using one method the other method is 
not selectable anymore. Summing component fractions up to 1 in the final
 mixture is the user responsibility. Adding materials as components of a
 mixture is not supported in this version.</p>
<p>The elements that were added to the mixture appear in the bottom of 
the mixture editor. The operations performed on mixture are not 
undoable.</p>
<h3 id="creation-of-new-objects"><span class="header-section-number">18.11.4</span> Creation of New Objects</h3>
<p>As described above, all geometry object creators are accessible 
within the geometry manager editor frame. Generally, if the new object 
that needs to be created does not depend on other objects, it will be 
built with a set of default parameters. This is the case for all shapes 
(except composite shapes) and matrices. For all the other objects the 
interface forces the selection of components before creating the object.</p>
<h3 id="editing-volumes"><span class="header-section-number">18.11.5</span> Editing Volumes</h3>
<p>Volumes are hierarchical components in the geometry, therefore their 
editor is more complex. It provides the following functionalities:</p>
<ul>
<li><p><em>General</em>. This category allows changing the name of the volume and selecting other shape or medium among existing ones.</p></li>
<li><p><em>Daughters</em>. The category allows removing existing daughter nodes or adding new ones. The button “<em>Position</em>” allows editing the positioning matrix of a given node.</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/020001F5.jpg" alt="Setting volume properties and modifying volume hierarchy"> <img src="ROOTUsersGuide_files/020001F6.jpg" alt="Setting volume properties and modifying volume hierarchy"></p>
<ul>
<li><em>Visualization</em>. This category allows changing the visibility
 of the edited volume or for its daughters, as well as other 
visualization settings. The radio button “<em>All</em>” allows viewing all volumes down to the selected depth. “<em>Leaves</em>” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “<em>Only</em>” will allow drawing only the edited volume. The check button “<em>Raytrace</em>” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo.</li>
</ul>
<p><img src="ROOTUsersGuide_files/020001F7.jpg" alt="Volume visualisation settings and division interface for volumes"> <img src="ROOTUsersGuide_files/020001F8.jpg" alt="Volume visualisation settings and division interface for volumes"></p>
<ul>
<li><em>Division</em>. Allows dividing the edited volume according a 
given pattern. The division axes that are allowed are presented in a 
radio-button group. The number entries labeled “<em>From</em>”, “<em>Step</em>” and “<em>Nslices</em>” correspond to the divisioning parameters on the selected axis. The range of the division is between <code>start</code> and <code>start+ndiv*step</code> values and its validity is checked upon changing one of the values.</li>
</ul>
<p>NOTE: When changing a value in a number entry by typing a number, 
press ENTER at the end to validate. This applies for taking into account
 and validation of any number change in the geometry editors.</p>
<h3 id="how-to-create-a-valid-geometry-with-geometry-editors"><span class="header-section-number">18.11.6</span> How to Create a Valid Geometry with Geometry Editors</h3>
<ol type="1">
<li><p>Create a new geometry manager and start the editor as described at the beginning.</p></li>
<li><p>Create at least one material from the “<em>Materials</em>” shutter item category. Generally, for creating objects, the interface is always in the <strong><code>TGeoManagerEditor</code></strong> in different categories - one should just provide a name and requested parameters.</p></li>
<li><p>Create a shape that will be used for the top volume within the “<em>Shapes</em>”
 category. For the moment, the shapes that have editors are Box, Para, 
Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus 
and Sphere.</p></li>
<li><p>Create a medium from one of the existing materials from the “<em>Medium</em>” category. You will notice that some categories as “<em>Volume</em>” and “<em>Medium</em>”
 are inactive at the beginning because at that time there is no material
 yet (for making a medium) and no shape (for making a volume). These 
categories are dynamically activated once all the required components 
are defined.</p></li>
<li><p>Create a volume from the “<em>Volumes</em>” category. You will 
notice that contrary to the other editors, the volume editor is opened 
in a tab, not transient - this is because it is more complex.</p></li>
<li>Go back to “<em>General</em>” category and select the newly created 
volume as the top one (you can do it also from the volume category). 
This is just for starting. To create some hierarchy, one has to create 
several other volumes and the matrices to position them. Once this is 
done, use the volume editor interface to:
<ul>
<li>add/remove daughters, change shape, edit position of daughters</li>
<li>change visualization settings</li>
<li>divide the volume (only if there are no daughters yet)</li>
</ul></li>
<li><p>Close the geometry from the “<em>General</em>” category.</p></li>
</ol>
<h1 id="python-interface"><span class="header-section-number">19</span> Python Interface</h1>
<p></p>
<p>Python is a popular, open-source, dynamic programming language with 
an interactive interpreter. Its interoperability with other programming 
languages, both for extending Python as well as embedding it, is 
excellent and many existing third-party applications and libraries have 
therefore so-called “Python bindings.” PyROOT provides Python bindings 
for ROOT: it enables cross-calls from ROOT/Cling into Python and vice 
versa, the intermingling of the two interpreters, and the transport of 
user-level objects from one interpreter to the other. PyROOT enables 
access from ROOT to any application or library that itself has Python 
bindings, and it makes all ROOT functionality directly available from 
the python interpreter.</p>
<h2 id="pyroot-overview"><span class="header-section-number">19.1</span> PyROOT Overview</h2>
<p>The Python scripting language is widely used for scientific 
programming, including high performance and distributed parallel code 
(see <a href="http://www.scipy.org/" class="uri">http://www.scipy.org</a>).
 It is the second most popular scripting language (after Perl) and 
enjoys a wide-spread use as a “glue language”: practically every library
 and application these days comes with Python bindings (and if not, they
 can be easily written or generated).</p>
<p><code>PyROOT</code>, a Python extension module, provides the bindings
 for the ROOT class library in a generic way using the Cling dictionary.
 This way, it allows the use of any ROOT classes from the Python 
interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT
 library or applications that provide Python bindings. Further, <code>PyROOT</code>
 can be loaded into the Cling interpreter to allow (as of now still 
rudimentary) access to Python classes. The best way to understand the 
benefits of <code>PyROOT</code> is through a few examples.</p>
<h3 id="glue-ing-applications"><span class="header-section-number">19.1.1</span> Glue-ing Applications</h3>
<p>The <code>PyQt</code> library, see <a href="http://www.riverbankcomputing.co.uk/pyqt" class="uri">http://www.riverbankcomputing.co.uk/pyqt</a>, provides Python bindings for the Qt cross-platform GUI framework ( <a href="http://www.trolltech.com/" class="uri">http://www.trolltech.com</a>). With <code>PyROOT</code> and <code>PyQt</code>,
 adding ROOT application layer code to a Qt GUI, becomes children play. 
The following example shows how a Python class can be used to have ROOT 
code respond to a click on a Qt widget.</p>
<div class="sourceCode" id="cb1111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1111-1" title="1"><span class="pp"># </span><span class="er">Glue-ing Qt and ROOT through Python</span></a>
<a class="sourceLine" id="cb1111-2" title="2">import sys, ROOT</a>
<a class="sourceLine" id="cb1111-3" title="3">from qt import *</a>
<a class="sourceLine" id="cb1111-4" title="4"></a>
<a class="sourceLine" id="cb1111-5" title="5">theApp = <span class="ex">QApplication</span>( sys.argv)</a>
<a class="sourceLine" id="cb1111-6" title="6">box = QVBox()</a>
<a class="sourceLine" id="cb1111-7" title="7">box.resize(<span class="ex">QSize</span>(<span class="dv">40</span>,<span class="dv">10</span>).expandedTo(box.minimumSizeHint()))</a>
<a class="sourceLine" id="cb1111-8" title="8"></a>
<a class="sourceLine" id="cb1111-9" title="9"><span class="kw">class</span> myButton(<span class="ex">QPushButton</span>):</a>
<a class="sourceLine" id="cb1111-10" title="10">    def __init__( self,label,master):</a>
<a class="sourceLine" id="cb1111-11" title="11">        <span class="ex">QPushButton</span>.__init__(self,label,master)</a>
<a class="sourceLine" id="cb1111-12" title="12">        self.setFont( <span class="ex">QFont</span>(<span class="ch">'T</span><span class="er">imes</span><span class="ch">'</span>,<span class="dv">18</span>,<span class="ex">QFont</span>.Bold))</a>
<a class="sourceLine" id="cb1111-13" title="13"></a>
<a class="sourceLine" id="cb1111-14" title="14">    def browse(self):</a>
<a class="sourceLine" id="cb1111-15" title="15">        self.b = ROOT.TBrowser()</a>
<a class="sourceLine" id="cb1111-16" title="16"></a>
<a class="sourceLine" id="cb1111-17" title="17">bb = myButton(<span class="ch">'b</span><span class="er">rowser</span><span class="ch">'</span>,box)</a>
<a class="sourceLine" id="cb1111-18" title="18"><span class="ex">QObject</span>.<span class="fu">connect</span>( bb,<span class="ex">SIGNAL</span>(<span class="ch">'c</span><span class="er">licked()</span><span class="ch">'</span>),bb.browse)</a>
<a class="sourceLine" id="cb1111-19" title="19"></a>
<a class="sourceLine" id="cb1111-20" title="20">theApp.setMainWidget(box)</a>
<a class="sourceLine" id="cb1111-21" title="21">box.show()</a>
<a class="sourceLine" id="cb1111-22" title="22">theApp.exec_loop()</a></code></pre></div>
<p>When the example is run, a Qt button is displayed, and when the button is clicked, a <strong><code>TBrowser</code></strong> instance is created and will appear on the screen. <code>PyROOT</code> takes care of feeding system events to ROOT widgets, so the <strong><code>TBrowser</code></strong> instance and the button behave properly when users interact with them.</p>
<h3 id="access-to-root-from-python"><span class="header-section-number">19.1.2</span> Access to ROOT from Python</h3>
<p>There are several tools for scientific analysis that come with 
bindings that allow the use of these tools from the Python interpreter. <code>PyROOT</code>
 provides this for users who want to do analysis in Python with ROOT 
classes. The following example shows how to fill and display a ROOT 
histogram while working in Python. Of course, any actual analysis code 
may come from somewhere else through other bindings, e.g.&nbsp;from a 
C++ program.</p>
<p>When run, the next example will display a 1-dimensional histogram 
showing a Gaussian distribution. More examples like the one above are 
distributed with ROOT under the <code>$ROOTSYS/tutorials</code> directory.</p>
<div class="sourceCode" id="cb1112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1112-1" title="1"><span class="pp"># </span><span class="er">Example: displaying a ROOT histogram from Python</span></a>
<a class="sourceLine" id="cb1112-2" title="2">from ROOT import gRandom,TCanvas,TH1F</a>
<a class="sourceLine" id="cb1112-3" title="3"></a>
<a class="sourceLine" id="cb1112-4" title="4">c1 = TCanvas(<span class="ch">'c</span><span class="er">1</span><span class="ch">'</span>,<span class="ch">'E</span><span class="er">xample</span><span class="ch">'</span>,<span class="dv">200</span>,<span class="dv">10</span>,<span class="dv">700</span>,<span class="dv">500</span>)</a>
<a class="sourceLine" id="cb1112-5" title="5">hpx = TH1F(<span class="ch">'h</span><span class="er">px</span><span class="ch">'</span>,<span class="ch">'p</span><span class="er">x</span><span class="ch">'</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1112-6" title="6"></a>
<a class="sourceLine" id="cb1112-7" title="7"><span class="cf">for</span> i in xrange(<span class="dv">25000</span>):</a>
<a class="sourceLine" id="cb1112-8" title="8">    px = gRandom.Gaus()</a>
<a class="sourceLine" id="cb1112-9" title="9">    hpx.Fill(px)</a>
<a class="sourceLine" id="cb1112-10" title="10"></a>
<a class="sourceLine" id="cb1112-11" title="11">hpx.Draw()</a>
<a class="sourceLine" id="cb1112-12" title="12">c1.Update()</a></code></pre></div>
<h3 id="access-to-python-from-root"><span class="header-section-number">19.1.3</span> Access to Python from ROOT</h3>
<p>Access to Python objects from Cling is not completely fleshed out. 
Currently, ROOT objects and built-in types can cross the boundary 
between the two interpreters, but other objects are much more 
restricted. For example, for a Python object to cross, it has to be a 
class instance, and its class has to be known to Cling first 
(i.e.&nbsp;the class has to cross first, before the instance can). All 
other cross-coding is based on strings that are run on the Python 
interpreter and vise-versa.</p>
<p>With the ROOT v4.00/06 and later, the <strong><code>TPython</code></strong> class will be loaded automatically on use, for older editions, the <code>libPyROOT.so</code> needs to be loaded first before use. It is possible to switch between interpreters by calling <strong><code>TPython::Prompt()</code></strong> on the ROOT side, while returning with <code>^D</code> (<code>EOF</code>).
 State is preserved between successive switches, and string based cross 
calls can nest as long as shared resources are properly handled.</p>
<div class="sourceCode" id="cb1113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1113-1" title="1"><span class="co">// Example: accessing the Python interpreter from ROOT</span></a>
<a class="sourceLine" id="cb1113-2" title="2"><span class="co">// either load PyROOT explicitly or rely on auto-loading</span></a>
<a class="sourceLine" id="cb1113-3" title="3">root[] gSystem-&gt;Load( <span class="st">"libPyROOT"</span> );</a>
<a class="sourceLine" id="cb1113-4" title="4">root[] TPython::Exec(<span class="st">"print1+1"</span>);</a>
<a class="sourceLine" id="cb1113-5" title="5"><span class="dv">2</span></a>
<a class="sourceLine" id="cb1113-6" title="6"></a>
<a class="sourceLine" id="cb1113-7" title="7"><span class="co">// create a TBrowser on the Python side, and transfer it back and forth</span></a>
<a class="sourceLine" id="cb1113-8" title="8">root[] TBrowser* b = (<span class="dt">void</span>*)TPython::Eval(<span class="st">"ROOT.TBrowser()"</span>);</a>
<a class="sourceLine" id="cb1113-9" title="9">(<span class="kw">class</span> TObject*)<span class="bn">0x8d1daa0</span></a>
<a class="sourceLine" id="cb1113-10" title="10">root[] TPython::Bind(b,<span class="st">"b"</span>);</a>
<a class="sourceLine" id="cb1113-11" title="11"></a>
<a class="sourceLine" id="cb1113-12" title="12"><span class="co">// builtin variables can cross-over (after the call i==2)</span></a>
<a class="sourceLine" id="cb1113-13" title="13">root[] <span class="dt">int</span> i = TPython::Eval( <span class="st">"1+1"</span> );</a>
<a class="sourceLine" id="cb1113-14" title="14">root[] i</a>
<a class="sourceLine" id="cb1113-15" title="15">(<span class="dt">int</span>)<span class="dv">2</span></a></code></pre></div>
<h3 id="installation"><span class="header-section-number">19.1.4</span> Installation</h3>
<p>There are several ways of obtaining <code>PyROOT</code>, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on <code>afs</code>. Otherwise, you will want to build from source, as <code>PyROOT</code>
 is not build by default in the binaries distributed from the ROOT 
project site. If you download the ROOT binaries, take care to download 
and install the Python distribution from <a href="http://www.python.org/" class="uri">http://www.python.org/</a> against which they were built.</p>
<h4 id="environment-settings"><span class="header-section-number">19.1.4.1</span> Environment Settings</h4>
<p>ROOT installations with the build of <code>PyROOT</code> enabled are available from the CERN <code>afs</code> cell <code>/afs/cern.ch/sw/root/&lt;version&gt;/&lt;platform&gt;</code>. To use them, simply modify your shell environment accordingly. For Unix:</p>
<p><code>export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH</code></p>
<p><code>export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH</code></p>
<p><code>export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH</code></p>
<p>For Windows:</p>
<p><code>set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%</code></p>
<p><code>set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%</code></p>
<p>where <code>$ROOTSYS</code> should be set to <code>/afs/cern.ch/sw/root/&lt;version&gt;/&lt;platform&gt;</code>, and <code>PYTHONDIR</code> to <code>/afs/cern.ch/sw/lcg/external/Python/2.3.4/&lt;platform&gt;</code> with <code>&lt;version&gt;</code> and <code>&lt;platform&gt;</code> as appropriate. Note that the latest version of Python is 2.4.1.</p>
<h4 id="building-from-source"><span class="header-section-number">19.1.4.2</span> Building from Source</h4>
<p>The standard installation instructions for building ROOT from source apply, with the addition that the build of <code>PyROOT</code>
 needs to be enabled at the configuration step. First, follow the 
instructions for obtaining and unpacking the source, and setting up the 
build environment.</p>
<p>Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):</p>
<p><code>$ ./configure &lt;arch&gt; [--with-python-incdir=&lt;dir&gt;][--with-python-libdir=&gt;dir&gt;]</code></p>
<p>For details on <code>&lt;arch&gt;</code> see the official build pages, the Python include directory should point to the directory that contains <code>Python.h</code> and the library directory should point to the directory containing <code>libpythonx.y.so</code>, where ‘<code>x</code>’ and ‘<code>y</code>’
 are the major and minor version number, respectively. If you do not 
specify include and library directories explicitly, the configuration 
process will try the <code>PYTHONDIR</code> environment variable or, alternatively, the standard locations.</p>
<p>A recent distribution of Python is required: version 2.4.3 is 
preferred, but the older 2.2.x and 2.3.x versions suffice and are 
supported as well. Versions older than 2.2 are not supported and will 
not work. Note that one problem with 2.2 is that the shared library of 
the <code>Python</code> interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building <code>Python</code> from source. If the <code>Python</code> interpreter that is installed on your system is too old, please obtain a new version from <a href="http://www.python.org/" class="uri">http://www.python.org</a>.</p>
<p>Once configured, you continue the build process the normal way:</p>
<p><code>$ make</code></p>
<p><code>$ make install</code></p>
<p>After some time, a library called <code>libPyROOT.so</code> (or <code>libPyROOT.dll</code>, on Windows) will be created in the <code>$ROOTSYS/lib</code>(<code>$ROOTSYS/bin on Windows</code>) directory and a top Python module, <code>ROOT.py</code>,
 will be copied into the same place. The final step is to setup the 
shell environment, which is similar to what is described in the chapter 
‘Environment Settings’. Note that the <code>$ROOTSYS</code> entries are probably already there if you followed the standard instructions, and that the <code>PYTHONDIR</code>
 entries should be replaced as appropriate by your choice at 
configuration time, or be left out if you had the configuration script 
pick up them up from a default location.</p>
<h3 id="using-pyroot"><span class="header-section-number">19.1.5</span> Using PyROOT</h3>
<p>Since it is an extension module, the usage of <code>PyROOT</code> probably comes naturally if you’re used to Python. In general, <code>PyROOT</code>
 attempts to allow working in both Python and ROOT style, and although 
it is succeeding, it isn’t perfect: there are edges. The following 
sections explain in some detail what you can expect, and what you need 
to watch out for.</p>
<h4 id="access-to-root-classes"><span class="header-section-number">19.1.5.1</span> Access to ROOT Classes</h4>
<p>Before a ROOT class can be used from Python, its dictionary needs to 
be loaded into the current process. Starting with ROOT version 4.00/06, 
this happens automatically for all classes that are declared to the 
auto-loading mechanism through so-called <code>rootmap</code> files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:</p>
<div class="sourceCode" id="cb1114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1114-1" title="1">from ROOT import TCanvas          <span class="er"># available at startup</span></a>
<a class="sourceLine" id="cb1114-2" title="2">c = TCanvas()</a>
<a class="sourceLine" id="cb1114-3" title="3"></a>
<a class="sourceLine" id="cb1114-4" title="4">from ROOT import TLorentzVector   <span class="er"># triggers auto-load of libPhysics</span></a>
<a class="sourceLine" id="cb1114-5" title="5">l = TLorentzVector()</a></code></pre></div>
<p>Although it is not recommended, a simple way of working with <code>PyROOT</code> is doing a global import:</p>
<div class="sourceCode" id="cb1115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1115-1" title="1">from ROOT import *</a>
<a class="sourceLine" id="cb1115-2" title="2"></a>
<a class="sourceLine" id="cb1115-3" title="3">c = TCanvas()</a>
<a class="sourceLine" id="cb1115-4" title="4">l = TLorentzVector()</a></code></pre></div>
<p>Keeping the ROOT namespace (“<code>import ROOT</code>”), or only 
importing from ROOT those classes that you will actually use (see 
above), however, will always be cleaner and clearer:</p>
<div class="sourceCode" id="cb1116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1116-1" title="1">import ROOT</a>
<a class="sourceLine" id="cb1116-2" title="2"></a>
<a class="sourceLine" id="cb1116-3" title="3">c = ROOT.TCanvas()</a>
<a class="sourceLine" id="cb1116-4" title="4">l = ROOT.TLorentzVector()</a></code></pre></div>
<p>Since it is foreseen that most people will use the simple approach 
anyway, the request to copy all from module ROOT will not actually 
result in copying all ROOT classes into the current namespace. Instead, 
classes will still be bound (and possibly loaded) on an as-needed basis.
 Note carefully how this is different from other Python (extension) 
modules, and what to expect if you use the normal inspection tools (such
 as e.g.&nbsp;‘<code>dir()</code>’). This feature prevents the 
inspection tools from being swamped by an enormous amount of classes, 
but they can no longer be used to explore unknown parts of the system 
(e.g.&nbsp;to find out which classes are available). Furthermore, 
because of this approach, &lt;<code>tab</code>&gt;-completion will usually not be available until after the first use (and hence creation) of a class.</p>
<p>Access to class static functions, public data members, enums, etc. is
 as expected. Many more example uses of ROOT classes from Python can be 
found in the tutorials directory in the ROOT distribution. The recipes 
section contains a description on working with your own classes (see 
“Using Your Own Classes”).</p>
<h4 id="access-to-stl-classes"><span class="header-section-number">19.1.5.2</span> Access to STL Classes</h4>
<p>The STL classes live in the ROOT.std namespace (or, if you prefer to 
get them from there, in the ROOT module directly, but doing so makes the
 code less clear, of course). Be careful in their use, because Python 
already has types called “<code>string</code>” and “<code>list</code>.”</p>
<p>In order to understand how to get access to a templated class, think 
of the general template as a meta class. By instantiating the meta class
 with the proper parameters, you get an actual class, which can then be 
used to create object instances. An example usage:</p>
<div class="sourceCode" id="cb1117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1117-1" title="1">&gt;&gt;&gt; from ROOT import std</a>
<a class="sourceLine" id="cb1117-2" title="2">&gt;&gt;&gt; v = std.vector(<span class="dt">int</span>)()</a>
<a class="sourceLine" id="cb1117-3" title="3">&gt;&gt;&gt; <span class="cf">for</span> i in range(<span class="dv">0</span>,<span class="dv">10</span>):</a>
<a class="sourceLine" id="cb1117-4" title="4">...    v.push_back(i)</a>
<a class="sourceLine" id="cb1117-5" title="5">...</a>
<a class="sourceLine" id="cb1117-6" title="6">&gt;&gt;&gt; <span class="cf">for</span> i in v:</a>
<a class="sourceLine" id="cb1117-7" title="7">...     print(i, end=<span class="ch">' '</span>)</a>
<a class="sourceLine" id="cb1117-8" title="8"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb1117-9" title="9">&gt;&gt;&gt;</a>
<a class="sourceLine" id="cb1117-10" title="10">&gt;&gt;&gt; list(v)</a>
<a class="sourceLine" id="cb1117-11" title="11">[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb1117-12" title="12">&gt;&gt;&gt;</a></code></pre></div>
<p>The parameters to the template instantiation can either be an actual 
type or value (as is used here, “int”), or a string representation of 
the parameters (e.g.&nbsp;“‘double’”), or a mixture of both 
(e.g.&nbsp;“‘TCanvas, 0’” or “‘double’, 0” ). The 
“std::vector&lt;int&gt;” class is one of the classes builtin by default 
into the Cling extension dlls. You will get a non-functional class 
(instances of which can still be passed around to C++) if the 
corresponding dictionary doesn’t exist.</p>
<h4 id="access-to-root-globals"><span class="header-section-number">19.1.5.3</span> Access to ROOT Globals</h4>
<p>Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably <strong><code>gMinuit</code></strong>,
 although that variable now exists at startup from release 5.08 onward) 
do not exist yet at program startup, as they exist in modules that are 
loaded later (e.g.&nbsp;through the auto-loading mechanism). An example 
session should make this clear:</p>
<div class="sourceCode" id="cb1118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1118-1" title="1">&gt;&gt;&gt; from ROOT import *</a>
<a class="sourceLine" id="cb1118-2" title="2">&gt;&gt;&gt; gROOT                              <span class="er"># directly available</span></a>
<a class="sourceLine" id="cb1118-3" title="3">&lt;ROOT.TROOT object at <span class="bn">0x399c30</span>&gt;</a>
<a class="sourceLine" id="cb1118-4" title="4">&gt;&gt;&gt; gMinuit                            <span class="er"># library not yet loaded: not available</span></a>
<a class="sourceLine" id="cb1118-5" title="5">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb1118-6" title="6">File <span class="st">"&lt;stdin&gt;"</span>, line <span class="dv">1</span>, in ?</a>
<a class="sourceLine" id="cb1118-7" title="7">NameError: name <span class="ch">'g</span><span class="er">Minuit</span><span class="ch">'</span> is <span class="kw">not</span> defined</a>
<a class="sourceLine" id="cb1118-8" title="8">&gt;&gt;&gt; TMinuit                            <span class="er"># use of TMinuit class forces auto-loading</span></a>
<a class="sourceLine" id="cb1118-9" title="9">&lt;<span class="kw">class</span> <span class="ch">'_</span><span class="er">_main__.TMinuit</span><span class="ch">'</span>&gt;</a>
<a class="sourceLine" id="cb1118-10" title="10">&gt;&gt;&gt; gMinuit                            <span class="er"># now gMinuit is available</span></a>
<a class="sourceLine" id="cb1118-11" title="11">&lt;__main__.TMinuit object at <span class="bn">0x1458c70</span>&gt;</a>
<a class="sourceLine" id="cb1118-12" title="12">&gt;&gt;&gt; <span class="kw">not</span> <span class="kw">not</span> gMinuit                    <span class="er"># but it is the null pointer, until set</span></a>
<a class="sourceLine" id="cb1118-13" title="13">False</a>
<a class="sourceLine" id="cb1118-14" title="14">&gt;&gt;&gt; g = TMinuit()</a>
<a class="sourceLine" id="cb1118-15" title="15">&gt;&gt;&gt; <span class="kw">not</span> <span class="kw">not</span> gMinuit</a>
<a class="sourceLine" id="cb1118-16" title="16">True</a></code></pre></div>
<p>It is also possible to create globals interactively, either by executing a Cling macro, or by a call to <code>gROOT.ProcessLine()</code>.
 These globals are made available in the same way: either use them 
directly after creation in ‘from ROOT import *’ more, or get them from 
the ROOT namespace after an ‘import ROOT’.</p>
<p>As of 5.08, the behaviour of ROOT globals is the same as python 
globals, which is sometimes counterintuitive: since they are references,
 they can be changed only if done so directly through their containing 
module. The following session shows that in detail:</p>
<div class="sourceCode" id="cb1119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1119-1" title="1">&gt;&gt;&gt; from ROOT import *</a>
<a class="sourceLine" id="cb1119-2" title="2">&gt;&gt;&gt; print(gDebug)</a>
<a class="sourceLine" id="cb1119-3" title="3"><span class="dv">0</span></a>
<a class="sourceLine" id="cb1119-4" title="4">&gt;&gt;&gt; gROOT.ProcessLine( <span class="ch">'g</span><span class="er">Debug = 7;</span><span class="ch">'</span> )</a>
<a class="sourceLine" id="cb1119-5" title="5">&gt;&gt;&gt; print(gDebug)</a>
<a class="sourceLine" id="cb1119-6" title="6"><span class="dv">0</span>                                 <span class="er"># local gDebug is unchanged</span></a>
<a class="sourceLine" id="cb1119-7" title="7">&gt;&gt;&gt; gDebug = <span class="dv">5</span>                    <span class="er"># changes _local_ reference only</span></a>
<a class="sourceLine" id="cb1119-8" title="8">&gt;&gt;&gt; print(gDebug)</a>
<a class="sourceLine" id="cb1119-9" title="9"><span class="dv">5</span>                                 <span class="er"># locally correct, but ...</span></a>
<a class="sourceLine" id="cb1119-10" title="10">&gt;&gt;&gt; gROOT.ProcessLine( <span class="ch">'c</span><span class="er">out &lt;&lt; gDebug &lt;&lt; endl;</span><span class="ch">'</span> )</a>
<a class="sourceLine" id="cb1119-11" title="11"><span class="dv">7</span>                                 <span class="er"># ... ROOT global unchanged</span></a>
<a class="sourceLine" id="cb1119-12" title="12">&gt;&gt;&gt; import ROOT</a>
<a class="sourceLine" id="cb1119-13" title="13">&gt;&gt;&gt; print(ROOT.gDebug)</a>
<a class="sourceLine" id="cb1119-14" title="14"><span class="dv">7</span>                                 <span class="er"># still the old value (not '5')</span></a>
<a class="sourceLine" id="cb1119-15" title="15">&gt;&gt;&gt; ROOT.gDebug = <span class="dv">3</span>               <span class="er"># changes ROOT module reference</span></a>
<a class="sourceLine" id="cb1119-16" title="16">&gt;&gt;&gt; gROOT.ProcessLine( <span class="ch">'c</span><span class="er">out &lt;&lt; gDebug &lt;&lt; endl;</span><span class="ch">'</span> )</a>
<a class="sourceLine" id="cb1119-17" title="17"><span class="dv">3</span>                                 <span class="er"># ROOT global properly changed</span></a>
<a class="sourceLine" id="cb1119-18" title="18">&gt;&gt;&gt;</a></code></pre></div>
<p>The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.</p>
<h4 id="access-to-python"><span class="header-section-number">19.1.5.4</span> Access to Python</h4>
<p>The access to Python from Cling goes through the <strong><code>TPython</code></strong> class, or directly if a Python object or class has crossed the border. The <strong><code>TPython</code></strong> class, which looks approximately like this:</p>
<div class="sourceCode" id="cb1120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1120-1" title="1"><span class="kw">class</span> TPython {</a>
<a class="sourceLine" id="cb1120-2" title="2"></a>
<a class="sourceLine" id="cb1120-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1120-4" title="4">   <span class="co">// load a Python script as if it were a macro</span></a>
<a class="sourceLine" id="cb1120-5" title="5">    <span class="at">static</span> <span class="dt">void</span> LoadMacro(<span class="at">const</span> <span class="dt">char</span>* name);</a>
<a class="sourceLine" id="cb1120-6" title="6"></a>
<a class="sourceLine" id="cb1120-7" title="7">   <span class="co">// execute a Python statement (e.g. "import ROOT")</span></a>
<a class="sourceLine" id="cb1120-8" title="8">    <span class="at">static</span> <span class="dt">void</span> Exec(<span class="at">const</span> <span class="dt">char</span>* cmd);</a>
<a class="sourceLine" id="cb1120-9" title="9"></a>
<a class="sourceLine" id="cb1120-10" title="10">   <span class="co">// evaluate a Python expression (e.g. "1+1")</span></a>
<a class="sourceLine" id="cb1120-11" title="11">    <span class="at">static</span> <span class="at">const</span> TPyReturn&amp; Eval(<span class="at">const</span> <span class="dt">char</span>* expr);</a>
<a class="sourceLine" id="cb1120-12" title="12"></a>
<a class="sourceLine" id="cb1120-13" title="13">   <span class="co">// bind a ROOT object with, at the Python side, the name "label"</span></a>
<a class="sourceLine" id="cb1120-14" title="14">    <span class="at">static</span> <span class="dt">bool</span> Bind(TObject* obj,<span class="at">const</span> <span class="dt">char</span>* label);</a>
<a class="sourceLine" id="cb1120-15" title="15"></a>
<a class="sourceLine" id="cb1120-16" title="16">   <span class="co">// enter an interactive Python session (exit with ^D)</span></a>
<a class="sourceLine" id="cb1120-17" title="17">    <span class="at">static</span> <span class="dt">void</span> Prompt();</a>
<a class="sourceLine" id="cb1120-18" title="18">};</a></code></pre></div>
<p><code>LoadMacro(const char* name)</code> - the argument is a name of a Python file that is to be executed (<code>'execfile'</code>), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.</p>
<p><code>ExecScript(const char* name,int argc=0,const char** argv=0)</code>
 - the argument is a name of a python file that is to be executed 
(‘execfile’) in a private namespace to minimize side-effects. 
Optionally, you can add CLI-style arguments which are handed to the 
script through ‘sys.argv’ in the normal way.</p>
<p><code>Exec(const char* cmd)</code>- the argument is a string of 
Python code that is executed as a statement. There is no return value, 
but an error message will be printed if there are problems such as 
syntax errors.</p>
<p><code>Eval(const char* expr)</code>- the argument is a string of 
Python code that is evaluated as an expression. The result of the 
expression is returned, if it is either a builtin type (int, long, 
float, double, and <code>const char*</code> are supported), a Python 
type that can cross, or a ROOT type. If a ROOT type is returned, an 
explicit cast to void* is needed to assign the return value to a local 
pointer (which may have a different type), whereas builtin types will be
 cast implicitly, if possible, to the type of the local variable to 
which they are assigned.</p>
<p><code>Bind(TObject* obj,const char* label)</code> - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “<code>label</code>”.</p>
<p><code>Prompt()</code> - Transfer the interactive prompt to Python.</p>
<p>With the ROOT v4.00/06 and later, the <strong><code>TPython</code></strong> class will be loaded automatically on use, for older editions, the <code>libPyROOT.so</code> needs to be loaded first with <code>gSystem-&gt;Load()</code> before use. Refer back to the other example of the use of <strong><code>TPython</code></strong> that was given in “Access to Python from ROOT”.</p>
<p>To show in detail how Python access can be used, an example Python module is needed, as follows:</p>
<div class="sourceCode" id="cb1121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1121-1" title="1">print(<span class="ch">'c</span><span class="er">reating class MyPyClass ... </span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1121-2" title="2"><span class="kw">class</span> MyPyClass:</a>
<a class="sourceLine" id="cb1121-3" title="3">    def __init__(self):</a>
<a class="sourceLine" id="cb1121-4" title="4">        print(<span class="ch">'i</span><span class="er">n MyPyClass.__init__</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1121-5" title="5">        self._browser = None</a>
<a class="sourceLine" id="cb1121-6" title="6">    def gime(self, what):</a>
<a class="sourceLine" id="cb1121-7" title="7">        <span class="cf">return</span> what</a></code></pre></div>
<p>This module can now be loaded into a Cling session, the class used to
 instantiate objects, and their member functions called for showing how 
different types can cross:</p>
<div class="sourceCode" id="cb1122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1122-1" title="1">root[] TPython::LoadMacro(<span class="st">"MyPyClass.py"</span>);</a>
<a class="sourceLine" id="cb1122-2" title="2">creating <span class="kw">class</span> MyPyClass ...</a>
<a class="sourceLine" id="cb1122-3" title="3">root[] MyPyClass m;</a>
<a class="sourceLine" id="cb1122-4" title="4">in MyPyClass.__init__</a>
<a class="sourceLine" id="cb1122-5" title="5">root[] <span class="dt">char</span>* s = m.gime(<span class="st">"aap"</span>);</a>
<a class="sourceLine" id="cb1122-6" title="6">root[] s</a>
<a class="sourceLine" id="cb1122-7" title="7">(<span class="dt">char</span>* <span class="bn">0x41ee7754</span>)<span class="st">"aap"</span></a></code></pre></div>
<p>Note that the <code>LoadMacro()</code> call makes the class automatically available, such that it can be used directly. Otherwise, a <code>gROOT-&gt;GetClass()</code> call is required first.</p>
<h4 id="callbacks"><span class="header-section-number">19.1.5.5</span> Callbacks</h4>
<p>The simplest way of setting a callback to Python from Cling, 
e.g.&nbsp;for a button, is by providing the execution string. See for 
example <code>tutorials/pyroot/demo.py</code> that comes with the ROOT installation:</p>
<div class="sourceCode" id="cb1123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1123-1" title="1"><span class="pp"># </span><span class="er">[..]</span></a>
<a class="sourceLine" id="cb1123-2" title="2">bar = ROOT.TControlBar(<span class="ch">'v</span><span class="er">ertical</span><span class="ch">'</span>,<span class="ch">'D</span><span class="er">emos</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1123-3" title="3">bar.AddButton(<span class="ch">'H</span><span class="er">elp on Demos</span><span class="ch">'</span>,r<span class="ch">'T</span><span class="er">Python::Exec("execfile(</span><span class="ch">'</span>demoshelp.py<span class="ch">')</span><span class="er">");</span><span class="ch">'</span>,<span class="ch">'C</span><span class="er">lick Here For Help on Running the Demos</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1123-4" title="4">bar.AddButton(<span class="ch">'b</span><span class="er">rowser</span><span class="ch">'</span>,r<span class="ch">'T</span><span class="er">Python::Exec("b = Tbrowser()");</span><span class="ch">'</span>,<span class="ch">'S</span><span class="er">tart the ROOT browser</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1123-5" title="5"><span class="pp"># </span><span class="er">[..]</span></a></code></pre></div>
<p>Here, the callback is a string that will be interpreted by Cling to call <code>TPython::Exec()</code>, which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘<code>r</code>’ in front of the second argument string), in order to remove the need of escaping the backslashes.</p>
<h4 id="cling-commands"><span class="header-section-number">19.1.5.6</span> Cling Commands</h4>
<p>In interactive mode, the Python exception hook is used to mimic some of the Cling commands available. These are: <code>.q</code>, <strong><code>.!</code></strong>, <strong><code>.x</code></strong>, <strong><code>.L</code></strong>, <strong><code>.cd</code></strong>, <strong><code>.ls</code></strong>, <strong><code>.pwd</code></strong>, <strong><code>.?</code></strong> and <strong><code>.help</code></strong>. Note that <strong><code>.x</code></strong> translates to Python ‘<code>execfile()</code>’ and thus accepts only Python files, not Cling macros.</p>
<h3 id="memory-handling"><span class="header-section-number">19.1.6</span> Memory Handling</h3>
<p>The Python interpreter handles memory for the user by employing 
reference counting and a garbage collector (for new-style objects, which
 includes <code>PyROOT</code> objects). In C++, however, memory handling
 is done either by hand, or by an application specific, customized 
mechanism (as is done in ROOT). Although <code>PyROOT</code> is made 
aware of ROOT memory management, there are still a few boundary 
conditions that need to be dealt with by hand. Also, the heuristics that
 <code>PyROOT</code> employs to deal with memory management are not 
infallible. An understanding in some detail of the choices that are made
 is thus important.</p>
<h4 id="automatic-memory-management"><span class="header-section-number">19.1.6.1</span> Automatic Memory Management</h4>
<p>There are two global policies that can be set: heuristics and strict.
 By default, the heuristic policy is used, in which the following rules 
are observed:</p>
<ul>
<li><p>A ROOT object created on the Python interpreter side is owned by 
Python and will be deleted once the last Python reference to it goes 
away. If, however, such an object is passed by non-const address as a 
parameter to a C++ function (with the exception of the use as “self” to a
 member function), ownership is relinquished.</p></li>
<li><p>A ROOT object coming from a ROOT call is not owned, but before it
 passes to the Python interpreter, its “must cleanup” bit is set if its 
type is a class derived from <strong><code>TObject</code></strong>. When
 the object goes out of scope on the C++ side, the Python object will 
change type into an object that largely behaves like None.</p></li>
</ul>
<p>The strict policy differs in that it will never relinquish ownership 
when passing an object as a parameter to a function. It is then up to 
the developer to prevent double deletes. Choosing one or the other 
policy is done by:</p>
<div class="sourceCode" id="cb1124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1124-1" title="1">ROOT.SetMemoryPolicy( ROOT.kMemoryStrict )</a></code></pre></div>
<p>for the strict policy, or for the heuristic policy:</p>
<div class="sourceCode" id="cb1125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1125-1" title="1">ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics )</a></code></pre></div>
<p>Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that <code>PyROOT</code> isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See <code>$ROOTSYS/tutorials/pyroot/zdemo.py</code>
 (available in the latest release) for an example. Alternatively, one 
can tell python to give up ownership for individual instances:</p>
<div class="sourceCode" id="cb1126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1126-1" title="1">o = ROOT.TObject()</a>
<a class="sourceLine" id="cb1126-2" title="2">ROOT.SetOwnership( o, False )      <span class="er"># True to own, False to release</span></a></code></pre></div>
<h4 id="memory-management-by-hand"><span class="header-section-number">19.1.6.2</span> Memory Management by Hand</h4>
<p>If needed, you can explicitly destroy a ROOT object that you own through its associated <strong><code>TClass</code></strong>:</p>
<div class="sourceCode" id="cb1127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1127-1" title="1">myobject.IsA().Destructor(myobject)</a></code></pre></div>
<p>which will send out the deletion notification to the system (thus you
 do not need to care anymore at this point about Python reference 
counting, the object will go, even if it’s reference count it non-zero),
 and free the memory.</p>
<h3 id="performance"><span class="header-section-number">19.1.7</span> Performance</h3>
<p>The performance of <code>PyROOT</code> when programming with ROOT in 
Python is similar to that of Cling. Differences occur mainly because of 
differences in the respective languages: C++ is much harder to parse, 
but once parsed, it is much easier to optimize. Consequently, individual
 calls to ROOT are typically faster from <code>PyROOT</code>, whereas loops are typically slower.</p>
<p>When programming in Python, the modus operandi is to consider 
performance generally “good enough” on the outset, and when it turns out
 that, it is not good enough; the performance critical part is converted
 into C/C++ in an extension module. The school of thought where 
pre-mature optimization is the root of all evil should find this way of 
working very satisfying. In addition, if you look at their history, you 
will see that many of the standard Python modules have followed this 
path.</p>
<p>Your code should always make maximum use of ROOT facilities; such 
that most of the time is spending in compiled code. This goes even for 
very simple things: e.g.&nbsp;do not compute invariant masses in Python,
 use <strong><code>TLorentzVector</code></strong> instead. Moreover, 
before you start optimizing, make sure that you have run a profiler to 
find out where the bottlenecks are. Some performance, without cost in 
terms of programmer effort, may be gained by using <code>psyco</code>, see the next link: <a href="http://psyco.sourceforge.net/" class="uri">http://psyco.sourceforge.net</a>, a Python just in time compiler (JIT). Note, however, that <code>psyco</code> is limited to Intel i386 CPUs. Since <code>psyco</code> optimizes Python, not <code>PyROOT</code>
 calls; it generally does not improve performance that much if most of 
your code consists of ROOT API calls. Mathematical computations in 
Python, on the other hand, benefit a lot.</p>
<p>Every call to a Python member function results in a lookup of that member function and an association of this method with <code>'self'</code>.
 Furthermore, a temporary object is created during this process that is 
discarded after the method call. In inner loops, it may be worth your 
while (up to 30%), to short-cut this process by looking up and binding 
the method before the loop, and discarding it afterwards. Here is an 
example:</p>
<div class="sourceCode" id="cb1128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1128-1" title="1">hpx = TH1F(<span class="ch">'h</span><span class="er">px</span><span class="ch">'</span>,<span class="ch">'p</span><span class="er">x</span><span class="ch">'</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1128-2" title="2">hpxFill = hpx.Fill                <span class="er"># cache bound method</span></a>
<a class="sourceLine" id="cb1128-3" title="3"><span class="cf">for</span> i in xrange(<span class="dv">25000</span>):</a>
<a class="sourceLine" id="cb1128-4" title="4">    px = gRandom.Gaus()</a>
<a class="sourceLine" id="cb1128-5" title="5">hpxFill(px)                    <span class="er"># use bound method: no lookup needed</span></a>
<a class="sourceLine" id="cb1128-6" title="6">del hpxFill                       <span class="er"># done with cached method</span></a></code></pre></div>
<p>Note that if you do not discard the bound method, a reference to the 
histogram will remain outstanding, and it will not be deleted when it 
should be. It is therefore important to delete the method when you’re 
done with it.</p>
<h3 id="use-of-python-functions"><span class="header-section-number">19.1.8</span> Use of Python Functions</h3>
<p>It is possible to mix Python functions with ROOT and perform such 
operations as plotting and fitting of histograms with them. In all 
cases, the procedure consists of instantiating a ROOT <strong><code>TF1</code></strong>, <strong><code>TF2</code></strong>, or <strong><code>TF3</code></strong>
 with the Python function and working with that ROOT object. There are 
some memory issues, so it is for example not yet possible to delete a <strong><code>TF1</code></strong> instance and then create another one with the same name. In addition, the Python function, once used for instantiating the <strong><code>TF1</code></strong>, is never deleted.</p>
<p>Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the <code>__call__</code>
 member function). The signature of the Python callable should provide 
for one or two arrays. The first array, which must always be present, 
shall contain the <code>x</code>, <code>y</code>, <code>z</code>, and t values for the call. The second array, which is optional and its size depends on the number given to the <strong><code>TF1</code></strong> constructor, contains the values that parameterize the function. For more details, see the <strong><code>TF1</code></strong> documentation and the examples below.</p>
<h4 id="plotting-python-function"><span class="header-section-number">19.1.8.1</span> Plotting Python Function</h4>
<p>This is an example of a parameter less Python function that is plotted on a default canvas:</p>
<div class="sourceCode" id="cb1129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1129-1" title="1">from ROOT import TF1, TCanvas</a>
<a class="sourceLine" id="cb1129-2" title="2"></a>
<a class="sourceLine" id="cb1129-3" title="3">def identity( x ):</a>
<a class="sourceLine" id="cb1129-4" title="4">    <span class="cf">return</span> x[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1129-5" title="5"></a>
<a class="sourceLine" id="cb1129-6" title="6"><span class="pp"># </span><span class="er">create an identity function</span></a>
<a class="sourceLine" id="cb1129-7" title="7">f = TF1(<span class="ch">'p</span><span class="er">yf1</span><span class="ch">'</span>, identity, -<span class="fl">1.</span>, <span class="fl">1.</span>)</a>
<a class="sourceLine" id="cb1129-8" title="8"></a>
<a class="sourceLine" id="cb1129-9" title="9"><span class="pp"># </span><span class="er">plot the function</span></a>
<a class="sourceLine" id="cb1129-10" title="10">c = TCanvas()</a>
<a class="sourceLine" id="cb1129-11" title="11">f.Draw()</a></code></pre></div>
<p>Because no number of parameters is given to the <strong><code>TF1</code></strong> constructor, ‘<code>0</code>’ (the default) is assumed. This way, the ‘<code>identity'</code>
 function need not handle a second argument, which would normally be 
used to pass the function parameters. Note that the argument’<code>x</code>’
 is an array of size 4. The following is an example of a parameterized 
Python callable instance that is plotted on a default canvas:</p>
<div class="sourceCode" id="cb1130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1130-1" title="1">from ROOT import TF1, TCanvas</a>
<a class="sourceLine" id="cb1130-2" title="2"></a>
<a class="sourceLine" id="cb1130-3" title="3"><span class="kw">class</span> Linear:</a>
<a class="sourceLine" id="cb1130-4" title="4">    def __call__( self, x, par ):</a>
<a class="sourceLine" id="cb1130-5" title="5">        <span class="cf">return</span> par[<span class="dv">0</span>] + x[<span class="dv">0</span>]*par[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1130-6" title="6"></a>
<a class="sourceLine" id="cb1130-7" title="7"><span class="pp"># </span><span class="er">create a linear function with offset 5, and pitch 2</span></a>
<a class="sourceLine" id="cb1130-8" title="8">f = TF1(<span class="ch">'p</span><span class="er">yf2</span><span class="ch">'</span>,Linear(),-<span class="fl">1.</span>,<span class="fl">1.</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1130-9" title="9">f.SetParameters(<span class="fl">5.</span>,<span class="fl">2.</span>)</a>
<a class="sourceLine" id="cb1130-10" title="10"></a>
<a class="sourceLine" id="cb1130-11" title="11"><span class="pp"># </span><span class="er">plot the function</span></a>
<a class="sourceLine" id="cb1130-12" title="12">c = TCanvas()</a>
<a class="sourceLine" id="cb1130-13" title="13">f.Draw()</a></code></pre></div>
<p>Note that this time the constructor is told that there are two 
parameters, and note in particular how these parameters are set. It is, 
of course, also possible (and preferable if you only use the function 
for plotting) to keep the parameters as data members of the callable 
instance and use and set them directly from Python.</p>
<h4 id="fitting-histograms-1"><span class="header-section-number">19.1.8.2</span> Fitting Histograms</h4>
<p>Fitting a histogram with a Python function is no more difficult than plotting: instantiate a <strong><code>TF1</code></strong> with the Python callable and supply that <strong><code>TF1</code></strong> as a parameter to the <code>Fit()</code> member function of the histogram. After the fit, you can retrieve the fit parameters from the <strong><code>TF1</code></strong> instance. For example:</p>
<div class="sourceCode" id="cb1131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1131-1" title="1">from ROOT import TF1, TH1F, TCanvas</a>
<a class="sourceLine" id="cb1131-2" title="2"></a>
<a class="sourceLine" id="cb1131-3" title="3"><span class="kw">class</span> Linear:</a>
<a class="sourceLine" id="cb1131-4" title="4">    def __call__( self, x, par ):</a>
<a class="sourceLine" id="cb1131-5" title="5">        <span class="cf">return</span> par[<span class="dv">0</span>] + x[<span class="dv">0</span>]*par[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1131-6" title="6"></a>
<a class="sourceLine" id="cb1131-7" title="7"><span class="pp"># </span><span class="er">create a linear function for fitting</span></a>
<a class="sourceLine" id="cb1131-8" title="8">f = TF1(<span class="ch">'p</span><span class="er">yf3</span><span class="ch">'</span>,Linear(),-<span class="fl">1.</span>,<span class="fl">1.</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1131-9" title="9"></a>
<a class="sourceLine" id="cb1131-10" title="10"><span class="pp"># </span><span class="er">create and fill a histogram</span></a>
<a class="sourceLine" id="cb1131-11" title="11">h = TH1F(<span class="ch">'h'</span>,<span class="ch">'t</span><span class="er">est</span><span class="ch">'</span>,<span class="dv">100</span>,-<span class="fl">1.</span>,<span class="fl">1.</span>)</a>
<a class="sourceLine" id="cb1131-12" title="12">f2 = TF1(<span class="ch">'c</span><span class="er">f2</span><span class="ch">'</span>,<span class="ch">'6</span><span class="er">.+x*4.5</span><span class="ch">'</span>,-<span class="fl">1.</span>,<span class="fl">1.</span>)</a>
<a class="sourceLine" id="cb1131-13" title="13">h.FillRandom(<span class="ch">'c</span><span class="er">f2</span><span class="ch">'</span>,<span class="dv">10000</span>)</a>
<a class="sourceLine" id="cb1131-14" title="14"></a>
<a class="sourceLine" id="cb1131-15" title="15"><span class="pp"># </span><span class="er">fit the histo with the python 'linear' function</span></a>
<a class="sourceLine" id="cb1131-16" title="16">h.Fit(f)</a>
<a class="sourceLine" id="cb1131-17" title="17"></a>
<a class="sourceLine" id="cb1131-18" title="18"><span class="pp"># </span><span class="er">print results</span></a>
<a class="sourceLine" id="cb1131-19" title="19">par = f.GetParameters()</a>
<a class="sourceLine" id="cb1131-20" title="20">print(<span class="ch">'f</span><span class="er">it results: const =</span><span class="ch">'</span>, par[<span class="dv">0</span>], <span class="ch">',</span><span class="er">pitch =</span><span class="ch">'</span>, par[<span class="dv">1</span>])</a></code></pre></div>
<h3 id="working-with-trees"><span class="header-section-number">19.1.9</span> Working with Trees</h3>
<p>Next to making histograms, working with trees is probably the most common part of any analysis. The <strong><code>TTree</code></strong> implementation uses pointers and dedicated buffers to reduce the memory usage and to speed up access. Consequently, mapping <strong><code>TTree</code></strong>
 functionality to Python is not straightforward, and most of the 
following features are implemented in ROOT release 4.01/04 and later 
only, whereas you will need 5.02 if you require all of them.</p>
<h4 id="accessing-an-existing-tree"><span class="header-section-number">19.1.9.1</span> Accessing an Existing Tree</h4>
<p>Let us assume that you have a file containing <strong><code>TTrees</code></strong>, <strong><code>TChains</code></strong>, or <strong><code>TNtuples</code></strong>
 and want to read the contents for use in your analysis code. This is 
commonly the case when you work with the result of the reconstruction 
software of your experiment (e.g.&nbsp;the combined ntuple in ATLAS). 
The following example code outlines the main steps (you can run it on 
the result of the <code>tree1.C</code> macro):</p>
<div class="sourceCode" id="cb1132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1132-1" title="1">from ROOT import TFile</a>
<a class="sourceLine" id="cb1132-2" title="2"></a>
<a class="sourceLine" id="cb1132-3" title="3"><span class="pp"># </span><span class="er">open the file</span></a>
<a class="sourceLine" id="cb1132-4" title="4">myfile = TFile(<span class="ch">'t</span><span class="er">ree1.root</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1132-5" title="5"></a>
<a class="sourceLine" id="cb1132-6" title="6"><span class="pp"># </span><span class="er">retrieve the ntuple of interest</span></a>
<a class="sourceLine" id="cb1132-7" title="7">mychain = myfile.Get(<span class="ch">'t</span><span class="er">1</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1132-8" title="8">entries = mychain.GetEntriesFast()</a>
<a class="sourceLine" id="cb1132-9" title="9"></a>
<a class="sourceLine" id="cb1132-10" title="10"><span class="cf">for</span> jentry in xrange(entries):</a>
<a class="sourceLine" id="cb1132-11" title="11">    <span class="pp"># </span><span class="er">get the next tree in the chain and verify</span></a>
<a class="sourceLine" id="cb1132-12" title="12">    ientry = mychain.LoadTree(jentry)</a>
<a class="sourceLine" id="cb1132-13" title="13">    <span class="cf">if</span> ientry &lt; <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1132-14" title="14">        <span class="cf">break</span></a>
<a class="sourceLine" id="cb1132-15" title="15"></a>
<a class="sourceLine" id="cb1132-16" title="16">    <span class="pp"># </span><span class="er">copy next entry into memory and verify</span></a>
<a class="sourceLine" id="cb1132-17" title="17">    nb = mychain.GetEntry(jentry)</a>
<a class="sourceLine" id="cb1132-18" title="18">    <span class="cf">if</span> nb&lt;=<span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1132-19" title="19">        <span class="cf">continue</span></a>
<a class="sourceLine" id="cb1132-20" title="20"></a>
<a class="sourceLine" id="cb1132-21" title="21">    <span class="pp"># </span><span class="er">use the values directly from the tree</span></a>
<a class="sourceLine" id="cb1132-22" title="22">    nEvent = <span class="dt">int</span>(mychain.ev)</a>
<a class="sourceLine" id="cb1132-23" title="23">    <span class="cf">if</span> nEvent&lt;<span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1132-24" title="24">        <span class="cf">continue</span></a>
<a class="sourceLine" id="cb1132-25" title="25"></a>
<a class="sourceLine" id="cb1132-26" title="26">    print(mychain.pz, <span class="ch">'='</span>, mychain.px*mychain.px, <span class="ch">'+'</span>, mychain.py*mychain.py)</a></code></pre></div>
<p>Access to arrays works the same way as access to single value tree 
elements, where the size of the array is determined by the number of 
values actually read from the file. For example:</p>
<div class="sourceCode" id="cb1133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1133-1" title="1"><span class="pp"># </span><span class="er">loop over array tree element</span></a>
<a class="sourceLine" id="cb1133-2" title="2"><span class="cf">for</span> d in mychain.mydoubles:</a>
<a class="sourceLine" id="cb1133-3" title="3">    print(d)</a>
<a class="sourceLine" id="cb1133-4" title="4"></a>
<a class="sourceLine" id="cb1133-5" title="5"><span class="pp"># </span><span class="er">direct access into an array tree element</span></a>
<a class="sourceLine" id="cb1133-6" title="6">i5 = mychain.myints[<span class="dv">5</span>]</a></code></pre></div>
<h4 id="writing-a-tree"><span class="header-section-number">19.1.9.2</span> Writing a Tree</h4>
<p>Writing a ROOT <strong><code>TTree</code></strong> in a Python 
session is a little convoluted, if only because you will need a C++ 
class to make sure that data members can be mapped, unless you are 
working with built-in types. Here is an example for working with the 
latter only:</p>
<div class="sourceCode" id="cb1134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1134-1" title="1">from ROOT import TFile, TTree</a>
<a class="sourceLine" id="cb1134-2" title="2">from array import array</a>
<a class="sourceLine" id="cb1134-3" title="3"></a>
<a class="sourceLine" id="cb1134-4" title="4">h = TH1F(<span class="ch">'h</span><span class="er">1</span><span class="ch">'</span>,<span class="ch">'t</span><span class="er">est</span><span class="ch">'</span>,<span class="dv">100</span>,-<span class="fl">10.</span>,<span class="fl">10.</span>)</a>
<a class="sourceLine" id="cb1134-5" title="5">f = TFile(<span class="ch">'t</span><span class="er">est.root</span><span class="ch">'</span>,<span class="ch">'r</span><span class="er">ecreate</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1134-6" title="6">t = TTree(<span class="ch">'t</span><span class="er">1</span><span class="ch">'</span>,<span class="ch">'t</span><span class="er">ree with histos</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1134-7" title="7">maxn = <span class="dv">10</span></a>
<a class="sourceLine" id="cb1134-8" title="8">n = array(<span class="ch">'i'</span>,[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb1134-9" title="9">d = array(<span class="ch">'f'</span>,maxn*[<span class="fl">0.</span>])</a>
<a class="sourceLine" id="cb1134-10" title="10">t.Branch(<span class="ch">'m</span><span class="er">ynum</span><span class="ch">'</span>,n,<span class="ch">'m</span><span class="er">ynum/I</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1134-11" title="11">t.Branch(<span class="ch">'m</span><span class="er">yval</span><span class="ch">'</span>,d,<span class="ch">'m</span><span class="er">yval[mynum]/F</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1134-12" title="12"></a>
<a class="sourceLine" id="cb1134-13" title="13"><span class="cf">for</span> i in range(<span class="dv">25</span>):</a>
<a class="sourceLine" id="cb1134-14" title="14">    n[<span class="dv">0</span>] = min(i,maxn)</a>
<a class="sourceLine" id="cb1134-15" title="15">    <span class="cf">for</span> j in range(n[<span class="dv">0</span>]):</a>
<a class="sourceLine" id="cb1134-16" title="16">        d[j] = i*<span class="fl">0.1</span>+j</a>
<a class="sourceLine" id="cb1134-17" title="17">        t.Fill()</a>
<a class="sourceLine" id="cb1134-18" title="18"></a>
<a class="sourceLine" id="cb1134-19" title="19">f.Write()</a>
<a class="sourceLine" id="cb1134-20" title="20">f.Close()</a></code></pre></div>
<p>The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the <strong><code>TTree::Branch()</code></strong> call, even though the formal argument is declared a ’<code>void*'</code>. In the case of ROOT objects, similar pointer manipulation is unnecessary, because the full type information is available, and <code>TTree::Branch()</code>
 has been Pythonized to take care of the call details. However, data 
members of such objects that are of built-in types, still require 
something extra since they are normally translated to Python primitive 
types on access and hence their address cannot be taken. For that 
purpose, there is the <code>AddressOf()</code> function. As an example:</p>
<div class="sourceCode" id="cb1135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1135-1" title="1">from ROOT import TFile, TTree</a>
<a class="sourceLine" id="cb1135-2" title="2">from ROOT import gROOT, AddressOf</a>
<a class="sourceLine" id="cb1135-3" title="3"></a>
<a class="sourceLine" id="cb1135-4" title="4">gROOT.ProcessLine(</a>
<a class="sourceLine" id="cb1135-5" title="5"><span class="st">"struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"</span> );</a>
<a class="sourceLine" id="cb1135-6" title="6"></a>
<a class="sourceLine" id="cb1135-7" title="7">from ROOT import MyStruct</a>
<a class="sourceLine" id="cb1135-8" title="8">mystruct = MyStruct()</a>
<a class="sourceLine" id="cb1135-9" title="9">f = TFile(<span class="ch">'m</span><span class="er">ytree.root</span><span class="ch">'</span>,<span class="ch">'R</span><span class="er">ECREATE</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1135-10" title="10">tree = TTree(<span class="ch">'T'</span>,<span class="ch">'J</span><span class="er">ust A Tree</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1135-11" title="11">tree.Branch(<span class="ch">'m</span><span class="er">yints</span><span class="ch">'</span>,mystruct,<span class="ch">'M</span><span class="er">yInt1/I:MyInt2:MyInt3</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1135-12" title="12">tree.Branch(<span class="ch">'m</span><span class="er">ycode</span><span class="ch">'</span>,AddressOf(mystruct,<span class="ch">'f</span><span class="er">MyCode</span><span class="ch">'</span>),<span class="ch">'M</span><span class="er">yCode/C</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1135-13" title="13"><span class="cf">for</span> i in range(<span class="dv">0</span>,<span class="dv">10</span>):</a>
<a class="sourceLine" id="cb1135-14" title="14">    mystruct.fMyInt1 = i</a>
<a class="sourceLine" id="cb1135-15" title="15">    mystruct.fMyInt2 = i*i</a>
<a class="sourceLine" id="cb1135-16" title="16">    mystruct.fMyInt3 = i*i*i</a>
<a class="sourceLine" id="cb1135-17" title="17">    mystruct.fMyCode = <span class="st">"%03d"</span> % i      <span class="er"># note string assignment</span></a>
<a class="sourceLine" id="cb1135-18" title="18"></a>
<a class="sourceLine" id="cb1135-19" title="19">    tree.Fill()</a>
<a class="sourceLine" id="cb1135-20" title="20"></a>
<a class="sourceLine" id="cb1135-21" title="21">f.Write()</a>
<a class="sourceLine" id="cb1135-22" title="22">f.Close()</a></code></pre></div>
<p>The C++ class is defined through the <code>gROOT.ProcessLine()</code> call, and note how the <code>AddressOf()</code>
 function is used for data members of built-in type. Most of the above 
is for ROOT version 5.02 and later only. For older releases, and without
 further support, here is an example as to how you can get hold of a 
pointer-to-pointer to a ROOT object:</p>
<div class="sourceCode" id="cb1136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1136-1" title="1">h = TH1F()</a>
<a class="sourceLine" id="cb1136-2" title="2">addressofobject = array(<span class="ch">'i'</span>,[h.IsA().DynamicCast(h.IsA(),h)])</a></code></pre></div>
<h3 id="using-your-own-classes"><span class="header-section-number">19.1.10</span> Using Your Own Classes</h3>
<p>A user’s own classes can be accessed after loading, either directly 
or indirectly, the library that contains the dictionary. One easy way of
 obtaining such a library, is by using ACLiC:</p>
<div class="sourceCode" id="cb1137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1137-1" title="1"><span class="er">$</span> cat MyClass.C</a>
<a class="sourceLine" id="cb1137-2" title="2"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb1137-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1137-4" title="4"></a>
<a class="sourceLine" id="cb1137-5" title="5">MyClass(<span class="dt">int</span> value = <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb1137-6" title="6"><span class="va">m_value</span> = value;</a>
<a class="sourceLine" id="cb1137-7" title="7">}</a>
<a class="sourceLine" id="cb1137-8" title="8"></a>
<a class="sourceLine" id="cb1137-9" title="9"><span class="dt">void</span> SetValue(<span class="dt">int</span> value) {</a>
<a class="sourceLine" id="cb1137-10" title="10"><span class="va">m_value</span> = value;</a>
<a class="sourceLine" id="cb1137-11" title="11">}</a>
<a class="sourceLine" id="cb1137-12" title="12"></a>
<a class="sourceLine" id="cb1137-13" title="13"><span class="dt">int</span> GetValue() {</a>
<a class="sourceLine" id="cb1137-14" title="14"><span class="cf">return</span> <span class="va">m_value</span>;</a>
<a class="sourceLine" id="cb1137-15" title="15">}</a>
<a class="sourceLine" id="cb1137-16" title="16"></a>
<a class="sourceLine" id="cb1137-17" title="17"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1137-18" title="18">    <span class="dt">int</span> <span class="va">m_value</span>;</a>
<a class="sourceLine" id="cb1137-19" title="19">};</a>
<a class="sourceLine" id="cb1137-20" title="20"></a>
<a class="sourceLine" id="cb1137-21" title="21"><span class="er">$</span> echo .L MyClass.C+ | root.exe -b</a>
<a class="sourceLine" id="cb1137-22" title="22">[...]</a>
<a class="sourceLine" id="cb1137-23" title="23">Info in &lt;TUnixSystem::ACLiC&gt;: creating shared library [..]/./MyClass_C.so</a>
<a class="sourceLine" id="cb1137-24" title="24"><span class="er">$</span></a></code></pre></div>
<p>Then you can use it, for example, like so:</p>
<div class="sourceCode" id="cb1138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1138-1" title="1">from ROOT import gSystem</a>
<a class="sourceLine" id="cb1138-2" title="2"></a>
<a class="sourceLine" id="cb1138-3" title="3"><span class="pp"># </span><span class="er">load library with MyClass dictionary</span></a>
<a class="sourceLine" id="cb1138-4" title="4">gSystem.Load(<span class="ch">'M</span><span class="er">yClass_C</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1138-5" title="5"></a>
<a class="sourceLine" id="cb1138-6" title="6"><span class="pp"># </span><span class="er">get MyClass from ROOT</span></a>
<a class="sourceLine" id="cb1138-7" title="7">from ROOT import MyClass</a>
<a class="sourceLine" id="cb1138-8" title="8"><span class="pp"># </span><span class="er">use MyClass</span></a>
<a class="sourceLine" id="cb1138-9" title="9">m = MyClass(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb1138-10" title="10">print(m.GetValue())</a></code></pre></div>
<p>You can also load a macro directly, but if you do not use ACLiC, you 
will be restricted to use the default constructor of your class, which 
is otherwise fully functional. For example:</p>
<div class="sourceCode" id="cb1139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1139-1" title="1">from ROOT import gROOT</a>
<a class="sourceLine" id="cb1139-2" title="2"></a>
<a class="sourceLine" id="cb1139-3" title="3"><span class="pp"># </span><span class="er">load MyClass definition macro (append '+' to use ACLiC)</span></a>
<a class="sourceLine" id="cb1139-4" title="4">gROOT.LoadMacro(<span class="ch">'M</span><span class="er">yClass.C</span><span class="ch">'</span>)</a>
<a class="sourceLine" id="cb1139-5" title="5"></a>
<a class="sourceLine" id="cb1139-6" title="6"><span class="pp"># </span><span class="er">get MyClass from ROOT</span></a>
<a class="sourceLine" id="cb1139-7" title="7">from ROOT import MyClass</a>
<a class="sourceLine" id="cb1139-8" title="8"></a>
<a class="sourceLine" id="cb1139-9" title="9"><span class="pp"># </span><span class="er">use MyClass</span></a>
<a class="sourceLine" id="cb1139-10" title="10">m = MyClass()</a>
<a class="sourceLine" id="cb1139-11" title="11">m.SetValue(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb1139-12" title="12">print(m.GetValue())</a></code></pre></div>
<h1 id="the-tutorials-and-tests"><span class="header-section-number">20</span> The Tutorials and Tests</h1>
<p>This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: <code>$ROOTSYS/tutorials</code> and <code>$ROOTSYS/test</code>.</p>
<h2 id="rootsystutorials-1"><span class="header-section-number">20.1</span> $ROOTSYS/tutorials</h2>
<p><img src="ROOTUsersGuide_files/030001F9.png"></p>
<p>The tutorials directory contains many example scripts. <em>To have all examples working you must have write permission and you will need to execute<code>hsimple.C</code> first</em>. If you do not have write permission in the directory<code>$ROOTSYS/tutorials</code>, copy the entire directory to your area. The script <code>hsimple.C</code> displays a histogram as it is being filled, and creates a ROOT file used by the other examples.</p>
<p>To execute it type:</p>
<div class="sourceCode" id="cb1140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1140-1" title="1"><span class="er">$</span> cd <span class="er">$</span>ROOTSYS/tutorials</a>
<a class="sourceLine" id="cb1140-2" title="2"><span class="er">$</span> root</a>
<a class="sourceLine" id="cb1140-3" title="3">   -------------------------------------------------------------------------</a>
<a class="sourceLine" id="cb1140-4" title="4">  | Welcome to ROOT <span class="fl">6.10</span>/<span class="bn">01</span>                             http:<span class="co">//root.cern.ch |</span></a>
<a class="sourceLine" id="cb1140-5" title="5">  |                                            (c) <span class="dv">1995</span>-<span class="dv">2017</span>, The ROOT Team |</a>
<a class="sourceLine" id="cb1140-6" title="6">  | Built <span class="cf">for</span> macosx64                                                      |</a>
<a class="sourceLine" id="cb1140-7" title="7">  | From heads/v6-<span class="dv">10</span>-<span class="bn">00</span>-patches<span class="er">@</span>v6-<span class="dv">10</span>-<span class="bn">00</span>-<span class="dv">25</span>-g9f78c3a, Jul <span class="bn">03</span> <span class="dv">2017</span>, <span class="dv">11</span>:<span class="dv">39</span>:<span class="dv">44</span> |</a>
<a class="sourceLine" id="cb1140-8" title="8">  | Try <span class="ch">'.</span><span class="er">help</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">demo</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">license</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">credits</span><span class="ch">'</span>, <span class="ch">'.</span><span class="er">quit</span><span class="ch">'</span>/<span class="ch">'.</span><span class="er">q</span><span class="ch">'</span>              |</a>
<a class="sourceLine" id="cb1140-9" title="9">   -------------------------------------------------------------------------</a>
<a class="sourceLine" id="cb1140-10" title="10"></a>
<a class="sourceLine" id="cb1140-11" title="11">root [<span class="dv">0</span>] .x hsimple.C</a></code></pre></div>
<p>Now execute <code>demos.C</code>, which brings up the button bar 
shown on the left. You can click on any button to execute another 
example. To see the source, open the corresponding source file (for 
example <code>fit1.C</code>). Once you are done, and want to quit the ROOT session, you can do so by typing <strong><code>.q</code></strong>.</p>
<div class="sourceCode" id="cb1141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1141-1" title="1">root[] .x demos.C</a>
<a class="sourceLine" id="cb1141-2" title="2">root[] .q</a></code></pre></div>
<h2 id="rootsystest-1"><span class="header-section-number">20.2</span> $ROOTSYS/test</h2>
<p>The test directory contains a set of examples that represent all 
areas of the framework. When a new release is cut, the examples in this 
directory are compiled and run to test the new release’s backward 
compatibility.</p>
<p>We see these source files:</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>Makefile</code></td>
<td>Makefile to build all test programs.</td>
</tr>
<tr class="even">
<td><code>hsimple.cxx</code></td>
<td>Simple test program that creates and saves some histograms</td>
</tr>
<tr class="odd">
<td><code>MainEvent.cxx</code></td>
<td>Simple test program that creates a ROOT Tree object and fills it 
with some simple structures but also with complete histograms. This 
program uses the files <code>Event.cxx</code>, <code>EventCint.cxx</code> and <code>Event.h</code>. An example of a procedure to link this program is in <code>bind_Event</code>. Note that the <code>Makefile</code> invokes the <code>rootcling</code> utility to generate the Cling interface <code>EventCint.cxx</code></td>
</tr>
<tr class="even">
<td><code>Event.cxx</code></td>
<td>Implementation for classes Event and Track</td>
</tr>
<tr class="odd">
<td><code>minexam.cxx</code></td>
<td>Simple test program for data fitting</td>
</tr>
<tr class="even">
<td><code>tcollex.cxx</code></td>
<td>Example usage of the ROOT collection classes</td>
</tr>
<tr class="odd">
<td><code>tcollbm.cxx</code></td>
<td>Benchmarks of ROOT collection classes</td>
</tr>
<tr class="even">
<td>ctorture.cxx</td>
<td>Test program for the class <strong><code>TComplex</code></strong></td>
</tr>
<tr class="odd">
<td><code>tstring.cxx</code></td>
<td>Example usage of the ROOT string class</td>
</tr>
<tr class="even">
<td><code>vmatrix.cxx</code></td>
<td>Verification program for the <strong><code>TMatrix</code></strong> class</td>
</tr>
<tr class="odd">
<td><code>vvector.cxx</code></td>
<td>Verification program for the <strong><code>TVector</code></strong>class</td>
</tr>
<tr class="even">
<td><code>vlazy.cxx</code></td>
<td>Verification program for lazy matrices</td>
</tr>
<tr class="odd">
<td><code>hworld.cxx</code></td>
<td>Small program showing basic graphics</td>
</tr>
<tr class="even">
<td><code>guitest.cxx</code></td>
<td>Example usage of the ROOT GUI classes</td>
</tr>
<tr class="odd">
<td><code>gui</code> <code>viewer</code> <code>.cxx</code></td>
<td>Another ROOT GUI example program</td>
</tr>
<tr class="even">
<td><code>Hello.cxx</code></td>
<td>Dancing text example</td>
</tr>
<tr class="odd">
<td><code>Aclock.cxx</code></td>
<td>Analog clock (a la X11 <code>xclock</code>)</td>
</tr>
<tr class="even">
<td><code>Tetris.cxx</code></td>
<td>The known Tetris game based on the ROOT graphics</td>
</tr>
<tr class="odd">
<td><code>stress.cxx</code></td>
<td>Important ROOT stress testing program</td>
</tr>
<tr class="even">
<td><code>stress*.cxx</code></td>
<td>Stress testing of different ROOT classes</td>
</tr>
<tr class="odd">
<td><code>bench.cxx</code></td>
<td>STL and ROOT container test and benchmarking program</td>
</tr>
<tr class="even">
<td>QpRandomDriver.cx x</td>
<td>Verification program for Quadratic programming classes in Quadp library</td>
</tr>
<tr class="odd">
<td>DrawTest.sh</td>
<td>Entry script to extensive <strong><code>TTree</code></strong> query test suite</td>
</tr>
<tr class="even">
<td>dt_*</td>
<td>Scripts used by DrawTest.sh</td>
</tr>
</tbody>
</table>
<p>The <code>$ROOTSYS/test</code> directory is a gold mine of 
root-wisdom nuggets, and we encourage you to explore and exploit it. 
These instructions will compile all programs in <code>$ROOTSYS/test</code>:</p>
<p>If you do not have write permission in the <code>$ROOTSYS/test</code> directory, copy the entire <code>$ROOTSYS/test</code> directory to your area. The <code>Makefile</code> is a useful example of how ROOT applications are linked and built. Edit the <code>Makefile</code> to specify your architecture by changing the <code>ARCH</code> variable, for example, on an SGI machine type:<code>ARCH</code> = <code>sgikcc</code>.</p>
<p>Now compile all programs:</p>
<p>% <strong><code>gmake</code></strong></p>
<p>This will build several applications and shared libraries. We are especially interested in Event, stress, and <code>guitest</code>.</p>
<h3 id="event---an-example-of-a-root-application"><span class="header-section-number">20.2.1</span> Event - An Example of a ROOT Application</h3>
<p>Event is created by compiling <code>MainEvent.cxx</code>, and <code>Event.cxx</code>. It creates a ROOT file with a tree and two histograms. When running <code>Event</code> we have four optional arguments with defaults:</p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 73%">
<col style="width: 18%">
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td>Argument</td>
<td>Default</td>
</tr>
<tr class="even">
<td>1</td>
<td>Number of Events (1 … n)</td>
<td>400</td>
</tr>
<tr class="odd">
<td>2</td>
<td><p>Compression level:</p>
<p>0: no compression at all.</p>
<p>1: If the split level is set to zero, everything is compressed according to the <code>gzip</code> level 1. If split level is set to 1, leaves that are not floating point numbers are compressed using the <code>gzip</code> level 1.</p>
<p>2: If the split level is set to zero, everything is compressed according to the <code>gzip</code> level 2. If split level is set to 1, all non floating point leaves are compressed according to the <code>gzip</code> level 2 and the floating point leaves are compressed according to the <code>gzip</code> level 1 (<code>gzip</code> level -1).</p>
<p>Floating point numbers are compressed differently because the gain 
when compressing them is about 20 - 30%. For other data types it is 
generally better and around 100%.</p></td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td><p>Split or not Split</p>
<p>0: only one single branch is created and the complete event is serialized in one single buffer</p>
<p>1: a branch per variable is created.</p></td>
<td><p>1</p>
<p>(Split)</p></td>
</tr>
<tr class="odd">
<td>4</td>
<td><p>Fill</p>
<p>0: read the file</p>
<p>1: write the file, but don’t fill the histograms</p>
<p>2: don’t write, don’t fill the histograms</p>
<p>10: fill the histograms, don’t write the file</p>
<p>11: fill the histograms, write the file</p>
<p>20: read the file sequentially</p>
<p>25: read the file at random</p></td>
<td><p>1</p>
<p>(Write, no fill)</p></td>
</tr>
</tbody>
</table>
<h4 id="effect-of-compression-on-file-size-and-write-times"><span class="header-section-number">20.2.1.1</span> Effect of Compression on File Size and Write Times</h4>
<p>You may have noticed that a ROOT file has up to nine compression 
level, but here only levels 0, 1, and 2 are described. Compression 
levels above 2 are not competitive. They take up to much write time 
compared to the gain in file space. Below are three runs of <code>Event</code> on a Pentium III 650 MHz and the resulting file size and write and read times.</p>
<p>No Compression:</p>
<div class="sourceCode" id="cb1142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1142-1" title="1">&gt; Event <span class="dv">400</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1142-2" title="2"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1142-3" title="3">RealTime=<span class="fl">6.840000</span> seconds, CpuTime=<span class="fl">3.560000</span> seconds</a>
<a class="sourceLine" id="cb1142-4" title="4">compression level=<span class="dv">0</span>, split=<span class="dv">1</span>, arg4=<span class="dv">1</span></a>
<a class="sourceLine" id="cb1142-5" title="5">You write <span class="fl">2.800173</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1142-6" title="6">You write <span class="fl">5.380107</span> Mbytes/Cputime seconds</a>
<a class="sourceLine" id="cb1142-7" title="7"></a>
<a class="sourceLine" id="cb1142-8" title="8">&gt; ls -l Event.root</a>
<a class="sourceLine" id="cb1142-9" title="9">... <span class="dv">19752171</span> Feb <span class="dv">23</span> <span class="dv">18</span>:<span class="dv">26</span> Event.root</a>
<a class="sourceLine" id="cb1142-10" title="10"></a>
<a class="sourceLine" id="cb1142-11" title="11">&gt; Event <span class="dv">400</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb1142-12" title="12"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1142-13" title="13">RealTime=<span class="fl">0.790000</span> seconds, CpuTime=<span class="fl">0.790000</span> seconds</a>
<a class="sourceLine" id="cb1142-14" title="14">You read <span class="fl">24.244533</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1142-15" title="15">You read <span class="fl">24.244533</span> Mbytes/Cputime seconds</a></code></pre></div>
<p>We see the file size without compression is 19.75 MB, the write time is 6.84 seconds and the read time is 0.79 seconds.</p>
<p>Compression = 1: event is compressed:</p>
<div class="sourceCode" id="cb1143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1143-1" title="1">&gt; Event <span class="dv">400</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1143-2" title="2"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1143-3" title="3">RealTime=<span class="fl">6.440000</span> seconds, CpuTime=<span class="fl">4.020000</span> seconds</a>
<a class="sourceLine" id="cb1143-4" title="4">compression level=<span class="dv">1</span>, split=<span class="dv">1</span>, arg4=<span class="dv">1</span></a>
<a class="sourceLine" id="cb1143-5" title="5">You write <span class="fl">2.974096</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1143-6" title="6">You write <span class="fl">4.764473</span> Mbytes/Cputime seconds</a>
<a class="sourceLine" id="cb1143-7" title="7"></a>
<a class="sourceLine" id="cb1143-8" title="8">&gt; ls -l Event.root</a>
<a class="sourceLine" id="cb1143-9" title="9">...     <span class="dv">17728188</span> Feb <span class="dv">23</span> <span class="dv">18</span>:<span class="dv">28</span> Event.root</a>
<a class="sourceLine" id="cb1143-10" title="10"></a>
<a class="sourceLine" id="cb1143-11" title="11">&gt; Event <span class="dv">400</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb1143-12" title="12"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1143-13" title="13">RealTime=<span class="fl">0.900000</span> seconds, CpuTime=<span class="fl">0.900000</span> seconds</a>
<a class="sourceLine" id="cb1143-14" title="14">You read <span class="fl">21.281312</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1143-15" title="15">You read <span class="fl">21.281312</span> Mbytes/Cputime seconds</a></code></pre></div>
<p>We see the file size 17.73, the write time was 6.44 seconds and the read time was 0.9 seconds.</p>
<p>Compression = 2: Floating point numbers are compressed with level 1:</p>
<div class="sourceCode" id="cb1144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1144-1" title="1">&gt; Event <span class="dv">400</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1144-2" title="2"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1144-3" title="3">RealTime=<span class="fl">11.340000</span> seconds, CpuTime=<span class="fl">9.510000</span> seconds</a>
<a class="sourceLine" id="cb1144-4" title="4">compression level=<span class="dv">2</span>, split=<span class="dv">1</span>, arg4=<span class="dv">1</span></a>
<a class="sourceLine" id="cb1144-5" title="5">You write <span class="fl">1.688993</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1144-6" title="6">You write <span class="fl">2.014004</span> Mbytes/Cputime seconds</a>
<a class="sourceLine" id="cb1144-7" title="7"></a>
<a class="sourceLine" id="cb1144-8" title="8">&gt; ls -l Event.root</a>
<a class="sourceLine" id="cb1144-9" title="9">...     <span class="dv">13783799</span> Feb <span class="dv">23</span> <span class="dv">18</span>:<span class="dv">29</span> Event.root</a>
<a class="sourceLine" id="cb1144-10" title="10"></a>
<a class="sourceLine" id="cb1144-11" title="11">&gt; Event <span class="dv">400</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb1144-12" title="12"><span class="dv">400</span> events <span class="kw">and</span> <span class="dv">19153182</span> bytes processed.</a>
<a class="sourceLine" id="cb1144-13" title="13">RealTime=<span class="fl">2.170000</span> seconds, CpuTime=<span class="fl">2.170000</span> seconds</a>
<a class="sourceLine" id="cb1144-14" title="14">You read <span class="fl">8.826351</span> Mbytes/Realtime seconds</a>
<a class="sourceLine" id="cb1144-15" title="15">You read <span class="fl">8.826351</span> Mbytes/Cputime seconds</a></code></pre></div>
<p>The file size is 13.78 MB, the write time is 11.34 seconds and the read time is 2.17 seconds.</p>
<p>This table summarizes the findings on the impact of compressions:</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 28%">
<col style="width: 24%">
<col style="width: 19%">
</colgroup>
<tbody>
<tr class="odd">
<td>Compression</td>
<td>File Size</td>
<td>Write Times</td>
<td>Read Times</td>
</tr>
<tr class="even">
<td>0</td>
<td>19.75 MB</td>
<td>6.84 sec.</td>
<td>0.79 sec.</td>
</tr>
<tr class="odd">
<td>1</td>
<td>17.73 MB</td>
<td>6.44 sec.</td>
<td>0.90 sec.</td>
</tr>
<tr class="even">
<td>2</td>
<td>13.78 MB</td>
<td>11.34 sec.</td>
<td>2.17 sec.</td>
</tr>
</tbody>
</table>
<h4 id="setting-the-split-level-1"><span class="header-section-number">20.2.1.2</span> Setting the Split Level</h4>
<p><img src="ROOTUsersGuide_files/080001FA.png"></p>
<p>Split Level = 0:<br>
Now we execute Event with the split parameter set to 0:</p>
<div class="sourceCode" id="cb1145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1145-1" title="1">&gt; Event <span class="dv">400</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1145-2" title="2">&gt; root</a>
<a class="sourceLine" id="cb1145-3" title="3">root[] TFile f(<span class="st">"Event.root"</span>)</a>
<a class="sourceLine" id="cb1145-4" title="4">root[] TBrowser T</a></code></pre></div>
<p>We notice that only one branch is visible (event). The individual data members of the <code>Event</code>
 object are no longer visible in the browser. They are contained in the 
event object on the event branch, because we specified no splitting. 
Split Level = 1:</p>
<p>Setting the split level to 1 will create a branch for each data member in the Event object. First we execute <code>Event</code> and set the split level to 1 and start the browser to examine the split tree:</p>
<div class="sourceCode" id="cb1146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1146-1" title="1">&gt;     Event <span class="dv">400</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb1147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1147-1" title="1">&gt;     root</a>
<a class="sourceLine" id="cb1147-2" title="2">root[] TFile f(<span class="st">"Event.root"</span>)</a>
<a class="sourceLine" id="cb1147-3" title="3">root[] TBrowser browser</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/080001FB.png"></p>
<h3 id="stress---test-and-benchmark"><span class="header-section-number">20.2.2</span> stress - Test and Benchmark</h3>
<p>The executable stress is created by compiling <code>stress.cxx</code>. It completes sixteen tests covering the following capabilities of the ROOT framework.</p>
<ul>
<li><p>Functions, Random Numbers, Histogram Fits</p></li>
<li><p>Size &amp; compression factor of a ROOT file</p></li>
<li><p>Purge, Reuse of gaps in <strong><code>TFile</code></strong></p></li>
<li><p>2D Histograms, Functions, 2D Fits</p></li>
<li><p>Graphics &amp; PostScript</p></li>
<li><p>Subdirectories in a ROOT file</p></li>
<li><p><strong><code>TNtuple</code></strong>, Selections, <strong><code>TCutG</code></strong>, <strong><code>TEventList</code></strong></p></li>
<li><p>Split and Compression modes for Trees</p></li>
<li><p>Analyze <code>Event.root</code> file of stress 8</p></li>
<li><p>Create 10 files starting from <code>Event.root</code></p></li>
<li><p>Test chains of Trees using the 10 files</p></li>
<li><p>Compare histograms of test 9 and 11</p></li>
<li><p>Merging files of a chain</p></li>
<li><p>Check correct rebuilt of <code>Event.root</code> in test 13</p></li>
<li><p>Divert Tree branches to separate files</p></li>
<li><p>Cling test (3 nested loops) with <code>LHCb</code> trigger</p></li>
</ul>
<p>The program stress takes one argument, the number of events to 
process. The default is 1000 events. Be aware that executing stress with
 1000 events<em>will create several files consuming about 100 MB of disk space;</em> running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.</p>
<p>There are two ways to run <code>stress</code>:</p>
<p>From the system prompt or from the ROOT prompt using the interpreter.</p>
<div class="sourceCode" id="cb1148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1148-1" title="1">&gt; cd <span class="er">$</span>ROOTSYS/test</a>
<a class="sourceLine" id="cb1148-2" title="2">&gt; stress             <span class="co">// default 1000 events</span></a>
<a class="sourceLine" id="cb1148-3" title="3">&gt; stress <span class="dv">30</span>          <span class="co">// test with 30 events</span></a></code></pre></div>
<p>Start ROOT with the batch mode option (-b) to suppress the graphic output.</p>
<div class="sourceCode" id="cb1149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1149-1" title="1">&gt; root -b</a>
<a class="sourceLine" id="cb1149-2" title="2">root[] .L stress.cxx</a>
<a class="sourceLine" id="cb1149-3" title="3">root[] stress(<span class="dv">1000</span>)<span class="co">// test with 1000 events</span></a>
<a class="sourceLine" id="cb1149-4" title="4">root[] stress(<span class="dv">30</span>)<span class="co">// test with 30 events</span></a></code></pre></div>
<p>The output of stress includes a pass/fail conclusion for each test, 
the total number of bytes read and written, and the elapsed real and CPU
 time. It also calculates a performance index for your machine relative 
to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 
256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means 
better performance. The reference machine has 200 ROOTMARKS, so the 
sample run below with 53.7 ROOTMARKS is about four times slower than the
 reference machine.</p>
<p>Here is a sample run:</p>
<div class="sourceCode" id="cb1150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1150-1" title="1">% root -b</a>
<a class="sourceLine" id="cb1150-2" title="2">root[] .x stress.cxx(<span class="dv">30</span>)</a>
<a class="sourceLine" id="cb1150-3" title="3"></a>
<a class="sourceLine" id="cb1150-4" title="4">Test  <span class="dv">1</span> : Functions, Random Numbers, Histogram Fits............. OK</a>
<a class="sourceLine" id="cb1150-5" title="5">Test  <span class="dv">2</span> : Check size &amp; compression factor of a Root file........ OK</a>
<a class="sourceLine" id="cb1150-6" title="6">Test  <span class="dv">3</span> : Purge, Reuse of gaps in TFile......................... OK</a>
<a class="sourceLine" id="cb1150-7" title="7">Test  <span class="dv">4</span> : Test of <span class="dv">2</span>-d histograms, functions, <span class="dv">2</span>-d fits........... OK</a>
<a class="sourceLine" id="cb1150-8" title="8">Test  <span class="dv">5</span> : Test graphics &amp; PostScript ............................OK</a>
<a class="sourceLine" id="cb1150-9" title="9">Test  <span class="dv">6</span> : Test subdirectories in a Root file.................... OK</a>
<a class="sourceLine" id="cb1150-10" title="10">Test  <span class="dv">7</span> : TNtuple, selections, TCutG, TEventList.......... OK</a>
<a class="sourceLine" id="cb1150-11" title="11">Test  <span class="dv">8</span> : Trees split <span class="kw">and</span> compression modes..................... OK</a>
<a class="sourceLine" id="cb1150-12" title="12">Test  <span class="dv">9</span> : Analyze Event.root file of stress <span class="fl">8.</span><span class="er">.</span>................. OK</a>
<a class="sourceLine" id="cb1150-13" title="13">Test <span class="dv">10</span> : Create <span class="dv">10</span> files starting from Event.root.............. OK</a>
<a class="sourceLine" id="cb1150-14" title="14">Test <span class="dv">11</span> : Test chains of Trees <span class="kw">using</span> the <span class="dv">10</span> files............... OK</a>
<a class="sourceLine" id="cb1150-15" title="15">Test <span class="dv">12</span> : Compare histograms of test <span class="dv">9</span> <span class="kw">and</span> <span class="fl">11.</span><span class="er">.</span>................. OK</a>
<a class="sourceLine" id="cb1150-16" title="16">Test <span class="dv">13</span> : Test merging files of a chain......................... OK</a>
<a class="sourceLine" id="cb1150-17" title="17">Test <span class="dv">14</span> : Check correct rebuilt of Event.root in test <span class="fl">13.</span><span class="er">.</span>...... OK</a>
<a class="sourceLine" id="cb1150-18" title="18">Test <span class="dv">15</span> : Divert Tree branches to separate files................ OK</a>
<a class="sourceLine" id="cb1150-19" title="19">Test <span class="dv">16</span> : Cling test (<span class="dv">3</span> nested loops) with LHCb trigger.......... OK</a>
<a class="sourceLine" id="cb1150-20" title="20">******************************************************************</a>
<a class="sourceLine" id="cb1150-21" title="21">*  IRIX64 fnpat1 <span class="fl">6.5</span> <span class="bn">01221553</span> IP27</a>
<a class="sourceLine" id="cb1150-22" title="22">******************************************************************</a>
<a class="sourceLine" id="cb1150-23" title="23">stress    : Total I/O =   <span class="fl">75.3</span> Mbytes, I =   <span class="fl">59.2</span>, O =  <span class="fl">16.1</span></a>
<a class="sourceLine" id="cb1150-24" title="24">stress    : Compr I/O =   <span class="fl">75.7</span> Mbytes, I =   <span class="fl">60.0</span>, O =  <span class="fl">15.7</span></a>
<a class="sourceLine" id="cb1150-25" title="25">stress    : Real Time = <span class="fl">307.61</span> seconds Cpu Time = <span class="fl">292.82</span> seconds</a>
<a class="sourceLine" id="cb1150-26" title="26">******************************************************************</a>
<a class="sourceLine" id="cb1150-27" title="27">*  ROOTMARKS =  <span class="fl">53.7</span>   *  Root2<span class="fl">.25</span>/<span class="bn">00</span>   <span class="dv">20000710</span>/<span class="dv">1022</span></a></code></pre></div>
<h3 id="guitest---a-graphical-user-interface"><span class="header-section-number">20.2.3</span> guitest - A Graphical User Interface</h3>
<p></p>
<p>The <code>guitest</code> example, created by compiling <code>guitest.cxx</code>,
 tests and illustrates the use of the native GUI widgets such as 
cascading menus, dialog boxes, sliders and tab panels. It is a very 
useful example to study when designing a GUI. Some examples of the 
output of <code>guitest</code> are shown next. To run it type <code>guitest</code> at the system prompt in the <code>$ROOTSYS/test</code> directory. We have included an entire chapter on this subject where we explore <code>guitest</code> in detail and use it to explain how to build our own ROOT application with a GUI. See “Writing a Graphical User Interface”.</p>
<figure>
<img src="ROOTUsersGuide_files/030001FC.png" alt="Native GUI widgets"><figcaption>Native GUI widgets</figcaption>
</figure>
<h1 id="example-analysis"><span class="header-section-number">21</span> Example Analysis</h1>
<p>This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the <strong><code>TSelector</code></strong> class.</p>
<h2 id="explanation"><span class="header-section-number">21.1</span> Explanation</h2>
<p>This script uses four large data sets from the H1 collaboration at 
DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT 
web site at: <a href="ftp://root.cern.ch/root/h1analysis/" class="uri">ftp://root.cern.ch/root/h1analysis/</a></p>
<p>The physics plots generated by this example cannot be produced using smaller data sets.</p>
<p>There are several ways to analyze data stored in a ROOT Tree</p>
<ul>
<li><p>Using <code>TTree::Draw</code>:</p></li>
<li><p>This is very convenient and efficient for small tasks. A <strong><code>TTree</code></strong>::Draw
 call produces one histogram at the time. The histogram is automatically
 generated. The selection expression may be specified in the command 
line.</p></li>
<li><p>Using the <strong><code>TTreeViewer</code></strong>:</p></li>
<li><p>This is a graphical interface to <code>TTree::Draw</code> with the same functionality.</p></li>
<li><p>Using the code generated by <code>TTree::MakeClass</code>:</p></li>
<li><p>In this case, the user creates an instance of the analysis class.
 They have the control over the event loop and can generate an unlimited
 number of histograms.</p></li>
<li><p>Using the code generated by <code>TTree::MakeSelector</code>: Like for the code generated by <strong><code>TTree::MakeClass</code></strong>, the user can do complex analysis. However, they cannot control the event loop. The event loop is controlled by <code>TTree::Process</code>
 called by the user. This solution is illustrated by the code below. The
 advantage of this method is that it can be run in a parallel 
environment using PROOF (the Parallel Root Facility).</p></li>
</ul>
<p>A chain of four files (originally converted from PAW ntuples) is used
 to illustrate the various ways to loop on ROOT data sets. Each contains
 a ROOT Tree named “<code>h42</code>”. The class definition in h1analysis.h has been generated automatically by the ROOT utility <strong><code>TTree</code></strong><code>::MakeSelector</code> using one of the files with:</p>
<div class="sourceCode" id="cb1151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1151-1" title="1">h42-&gt;MakeSelector(<span class="st">"h1analysis"</span>);</a></code></pre></div>
<p>This produces two files: h1analysis.h and <code>h1analysis.C</code>. A skeleton of <code>h1analysis.C</code> file is made for you to customize. The h1analysis class is derived from the ROOT class <strong><code>TSelector</code></strong>. The following members functions of h1analyhsis (i.e.&nbsp;<strong><code>TSelector</code></strong>) are called by the <code>TTree::Process</code> method.</p>
<ul>
<li><p><code>Begin</code>: This function is called every time a loop over the tree starts. This is a convenient place to create your histograms.</p></li>
<li><p><code>Notify():</code> This function is called at the first entry of a new tree in a chain.</p></li>
<li><p><code>ProcessCut</code>: This function is called at the beginning of each entry to return a flag true if the entry must be analyzed.</p></li>
<li><p><code>ProcessFill</code>: This function is called in the entry loop for all entries accepted by Select.</p></li>
<li><p><code>Terminate</code>: This function is called at the end of a loop on a <strong><code>TTree</code></strong>. This is a convenient place to draw and fit your histograms.</p></li>
</ul>
<p>To use this program, try the following session.</p>
<p>First, turn the timer on to show the real and CPU time per command.</p>
<div class="sourceCode" id="cb1152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1152-1" title="1">root[] gROOT-&gt;Time();</a></code></pre></div>
<p><em>Step A:</em> create a <strong><code>TChain</code></strong> with the four H1 data files. The chain can be created by executed this short script <code>h1chain.C</code> below. $H1 is a system symbol pointing to the H1 data directory.</p>
<div class="sourceCode" id="cb1153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1153-1" title="1">{</a>
<a class="sourceLine" id="cb1153-2" title="2">   TChain chain(<span class="st">"h42"</span>);</a>
<a class="sourceLine" id="cb1153-3" title="3">   chain.Add(<span class="st">"$H1/dstarmb.root"</span>);</a>
<a class="sourceLine" id="cb1153-4" title="4">   <span class="co">//21330730 bytes, 21920 events</span></a>
<a class="sourceLine" id="cb1153-5" title="5">   chain.Add(<span class="st">"$H1/dstarp1a.root"</span>);</a>
<a class="sourceLine" id="cb1153-6" title="6">   <span class="co">//71464503 bytes, 73243 events</span></a>
<a class="sourceLine" id="cb1153-7" title="7">   chain.Add(<span class="st">"$H1/dstarp1b.root"</span>);</a>
<a class="sourceLine" id="cb1153-8" title="8">   <span class="co">//83827959 bytes, 85597 events</span></a>
<a class="sourceLine" id="cb1153-9" title="9">   chain.Add(<span class="st">"$H1/dstarp2.root"</span>);</a>
<a class="sourceLine" id="cb1153-10" title="10">   <span class="co">//100675234 bytes, 103053 events</span></a>
<a class="sourceLine" id="cb1153-11" title="11">}</a></code></pre></div>
<p>Run the above script from the command line:</p>
<div class="sourceCode" id="cb1154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1154-1" title="1">root[] .x h1chain.C</a></code></pre></div>
<p><em>Step B</em>: Now we have a directory containing the four data files. Since a <strong><code>TChain</code></strong> is a descendent of <code>TTree</code> we can call <strong><code>TChain::Process</code></strong> to loop on all events in the chain. The parameter to the <code>TChain::Process</code> method is the name of the file containing the created <strong><code>TSelector</code></strong> class (<code>h1analysis.C</code>).</p>
<div class="sourceCode" id="cb1155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1155-1" title="1">root[] chain.Process(<span class="st">"h1analysis.C"</span>)</a></code></pre></div>
<p><em>Step C</em>: Same as step B, but in addition fill the event list with selected entries. The event list is saved to a file “<code>elist.root</code>” by the <code>TSelector::Terminate</code> method. To see the list of selected events, you can do <code>elist-&gt;Print("all")</code>. The selection function has selected 7525 events out of the 283813 events in the chain of files. (2.65 per cent)</p>
<div class="sourceCode" id="cb1156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1156-1" title="1">root[] chain.Process(<span class="st">"h1analysis.C"</span>,<span class="st">"fillList"</span>)</a></code></pre></div>
<p><em>Step D:</em> Process only entries in the event list. The event list is read from the file in <code>elist.root</code> generated by step C.</p>
<div class="sourceCode" id="cb1157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1157-1" title="1">root[] chain.Process(<span class="st">"h1analysis.C"</span>,<span class="st">"useList"</span>)</a></code></pre></div>
<p><em>Step E</em>: The above steps have been executed with the interpreter. You can repeat the steps B, C, and D using ACLiC by replacing “<code>h1analysis.C</code>” by “<code>h1analysis.C+</code>” or “<code>h1analysis.C++</code>”.</p>
<p><em>Step F:</em> If you want to see the differences between the 
interpreter speed and ACLiC speed start a new session, create the chain 
as in step 1, then execute</p>
<div class="sourceCode" id="cb1158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1158-1" title="1">root[] chain.Process(<span class="st">"h1analysis.C+"</span>,<span class="st">"useList"</span>)</a></code></pre></div>
<p>The commands executed with the four different methods B, C, D and E produce two canvases shown below:</p>
<p><img src="ROOTUsersGuide_files/030001FD.png"> <img src="ROOTUsersGuide_files/030001FE.png"></p>
<h2 id="script"><span class="header-section-number">21.2</span> Script</h2>
<p>This is the <code>h1analsysis.C</code> file that was generated by <code>TTree::MakeSelector</code> and then modified to perform the analysis.</p>
<div class="sourceCode" id="cb1159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1159-1" title="1"><span class="pp">#include </span><span class="im">"h1analysis.h"</span></a>
<a class="sourceLine" id="cb1159-2" title="2"><span class="pp">#include </span><span class="im">"TH2.h"</span></a>
<a class="sourceLine" id="cb1159-3" title="3"><span class="pp">#include </span><span class="im">"TF1.h"</span></a>
<a class="sourceLine" id="cb1159-4" title="4"><span class="pp">#include </span><span class="im">"TStyle.h"</span></a>
<a class="sourceLine" id="cb1159-5" title="5"><span class="pp">#include </span><span class="im">"TCanvas.h"</span></a>
<a class="sourceLine" id="cb1159-6" title="6"><span class="pp">#include </span><span class="im">"TLine.h"</span></a>
<a class="sourceLine" id="cb1159-7" title="7"><span class="pp">#include </span><span class="im">"TEventList.h"</span></a>
<a class="sourceLine" id="cb1159-8" title="8"></a>
<a class="sourceLine" id="cb1159-9" title="9"><span class="at">const</span> <span class="dt">Double_t</span> dxbin = (<span class="fl">0.17</span>-<span class="fl">0.13</span>)/<span class="dv">40</span>;   <span class="co">// Bin-width</span></a>
<a class="sourceLine" id="cb1159-10" title="10"><span class="at">const</span> <span class="dt">Double_t</span> sigma = <span class="fl">0.0012</span>;</a>
<a class="sourceLine" id="cb1159-11" title="11">TEventList *elist = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1159-12" title="12"><span class="dt">Bool_t</span> useList, fillList;</a>
<a class="sourceLine" id="cb1159-13" title="13">TH1F *hdmd;</a>
<a class="sourceLine" id="cb1159-14" title="14">TH2F *h2;</a>
<a class="sourceLine" id="cb1159-15" title="15"></a>
<a class="sourceLine" id="cb1159-16" title="16"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-17" title="17"><span class="dt">Double_t</span> fdm5(<span class="dt">Double_t</span> *xx, <span class="dt">Double_t</span> *par)</a>
<a class="sourceLine" id="cb1159-18" title="18">{</a>
<a class="sourceLine" id="cb1159-19" title="19">   <span class="dt">Double_t</span> x = xx[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb1159-20" title="20">   <span class="cf">if</span> (x &lt;= <span class="fl">0.13957</span>) <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1159-21" title="21">   <span class="dt">Double_t</span> xp3 = (x-par[<span class="dv">3</span>])*(x-par[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb1159-22" title="22">   <span class="dt">Double_t</span> res = dxbin*(par[<span class="dv">0</span>]*TMath::Power(x-<span class="fl">0.13957</span>,par[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb1159-23" title="23">   + par[<span class="dv">2</span>]/<span class="fl">2.5066</span>/par[<span class="dv">4</span>]*TMath::Exp(-xp3/<span class="dv">2</span>/par[<span class="dv">4</span>]/par[<span class="dv">4</span>]));</a>
<a class="sourceLine" id="cb1159-24" title="24">   <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb1159-25" title="25">}</a>
<a class="sourceLine" id="cb1159-26" title="26"></a>
<a class="sourceLine" id="cb1159-27" title="27"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-28" title="28"><span class="dt">Double_t</span> fdm2(<span class="dt">Double_t</span> *xx, <span class="dt">Double_t</span> *par)</a>
<a class="sourceLine" id="cb1159-29" title="29">{</a>
<a class="sourceLine" id="cb1159-30" title="30">   <span class="dt">Double_t</span> x = xx[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb1159-31" title="31">   <span class="cf">if</span> (x &lt;= <span class="fl">0.13957</span>) <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1159-32" title="32">   <span class="dt">Double_t</span> xp3 = (x-<span class="fl">0.1454</span>)*(x-<span class="fl">0.1454</span>);</a>
<a class="sourceLine" id="cb1159-33" title="33">   <span class="dt">Double_t</span> res = dxbin*(par[<span class="dv">0</span>]*TMath::Power(x-<span class="fl">0.13957</span>,<span class="fl">0.25</span>)</a>
<a class="sourceLine" id="cb1159-34" title="34">   + par[<span class="dv">1</span>]/<span class="fl">2.5066</span>/sigma*TMath::Exp(-xp3/<span class="dv">2</span>/sigma/sigma));</a>
<a class="sourceLine" id="cb1159-35" title="35">   <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb1159-36" title="36">}</a>
<a class="sourceLine" id="cb1159-37" title="37"></a>
<a class="sourceLine" id="cb1159-38" title="38"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-39" title="39"><span class="dt">void</span> h1analysis::Begin(TTree *tree)</a>
<a class="sourceLine" id="cb1159-40" title="40">{</a>
<a class="sourceLine" id="cb1159-41" title="41"><span class="co">// function called before starting the event loop</span></a>
<a class="sourceLine" id="cb1159-42" title="42"><span class="co">//  -it performs some cleanup</span></a>
<a class="sourceLine" id="cb1159-43" title="43"><span class="co">//  -it creates histograms</span></a>
<a class="sourceLine" id="cb1159-44" title="44"><span class="co">//  -it sets some initialization for the event list</span></a>
<a class="sourceLine" id="cb1159-45" title="45"></a>
<a class="sourceLine" id="cb1159-46" title="46">   <span class="co">//initialize the Tree branch addresses</span></a>
<a class="sourceLine" id="cb1159-47" title="47">   Init(tree);</a>
<a class="sourceLine" id="cb1159-48" title="48"></a>
<a class="sourceLine" id="cb1159-49" title="49">   <span class="co">//print the option specified in the Process function</span></a>
<a class="sourceLine" id="cb1159-50" title="50">   TString option = GetOption();</a>
<a class="sourceLine" id="cb1159-51" title="51">   printf(<span class="st">"Starting h1analysis with process option: </span><span class="sc">%s</span><span class="st">n"</span>,option.Data());</a>
<a class="sourceLine" id="cb1159-52" title="52"></a>
<a class="sourceLine" id="cb1159-53" title="53">   <span class="co">//Some cleanup in case this function had already been executed</span></a>
<a class="sourceLine" id="cb1159-54" title="54">   <span class="co">//Delete any previously generated histograms or functions</span></a>
<a class="sourceLine" id="cb1159-55" title="55">   gDirectory-&gt;Delete(<span class="st">"hdmd"</span>);</a>
<a class="sourceLine" id="cb1159-56" title="56">   gDirectory-&gt;Delete(<span class="st">"h2*"</span>);</a>
<a class="sourceLine" id="cb1159-57" title="57">   <span class="kw">delete</span> gROOT-&gt;GetFunction(<span class="st">"f5"</span>);</a>
<a class="sourceLine" id="cb1159-58" title="58">   <span class="kw">delete</span> gROOT-&gt;GetFunction(<span class="st">"f2"</span>);</a>
<a class="sourceLine" id="cb1159-59" title="59"></a>
<a class="sourceLine" id="cb1159-60" title="60">   <span class="co">//create histograms</span></a>
<a class="sourceLine" id="cb1159-61" title="61">   hdmd = <span class="kw">new</span> TH1F(<span class="st">"hdmd"</span>,<span class="st">"dm_d"</span>,<span class="dv">40</span>,<span class="fl">0.13</span>,<span class="fl">0.17</span>);</a>
<a class="sourceLine" id="cb1159-62" title="62">   h2   = <span class="kw">new</span> TH2F(<span class="st">"h2"</span>,<span class="st">"ptD0 vs dm_d"</span>,<span class="dv">30</span>,<span class="fl">0.135</span>,<span class="fl">0.165</span>,<span class="dv">30</span>,-<span class="dv">3</span>,<span class="dv">6</span>);</a>
<a class="sourceLine" id="cb1159-63" title="63"></a>
<a class="sourceLine" id="cb1159-64" title="64">   <span class="co">//process cases with event list</span></a>
<a class="sourceLine" id="cb1159-65" title="65">   fillList = kFALSE;</a>
<a class="sourceLine" id="cb1159-66" title="66">   useList  = kFALSE;</a>
<a class="sourceLine" id="cb1159-67" title="67">   fChain-&gt;SetEventList(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1159-68" title="68">   <span class="kw">delete</span> gDirectory-&gt;GetList()-&gt;FindObject(<span class="st">"elist"</span>);</a>
<a class="sourceLine" id="cb1159-69" title="69"></a>
<a class="sourceLine" id="cb1159-70" title="70">   <span class="co">// case when one creates/fills the event list</span></a>
<a class="sourceLine" id="cb1159-71" title="71">   <span class="cf">if</span> (option.Contains(<span class="st">"fillList"</span>)) {</a>
<a class="sourceLine" id="cb1159-72" title="72">      fillList = kTRUE;</a>
<a class="sourceLine" id="cb1159-73" title="73">      elist = <span class="kw">new</span> TEventList(<span class="st">"elist"</span>,<span class="st">"selection from Cut"</span>,<span class="dv">5000</span>);</a>
<a class="sourceLine" id="cb1159-74" title="74">   }</a>
<a class="sourceLine" id="cb1159-75" title="75">   <span class="co">// case when one uses the event list generated in a previous call</span></a>
<a class="sourceLine" id="cb1159-76" title="76">   <span class="cf">if</span> (option.Contains(<span class="st">"useList"</span>)) {</a>
<a class="sourceLine" id="cb1159-77" title="77">      useList  = kTRUE;</a>
<a class="sourceLine" id="cb1159-78" title="78">      TFile f(<span class="st">"elist.root"</span>);</a>
<a class="sourceLine" id="cb1159-79" title="79">      elist = (TEventList*)f.Get(<span class="st">"elist"</span>);</a>
<a class="sourceLine" id="cb1159-80" title="80">      <span class="cf">if</span> (elist) elist-&gt;SetDirectory(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1159-81" title="81">      <span class="co">//otherwise the file destructor will delete elist</span></a>
<a class="sourceLine" id="cb1159-82" title="82">      fChain-&gt;SetEventList(elist);</a>
<a class="sourceLine" id="cb1159-83" title="83">   }</a>
<a class="sourceLine" id="cb1159-84" title="84">}</a>
<a class="sourceLine" id="cb1159-85" title="85"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-86" title="86"><span class="dt">Bool_t</span> h1analysis::ProcessCut(<span class="dt">Int_t</span> entry)</a>
<a class="sourceLine" id="cb1159-87" title="87">{ <span class="co">// Selection function to select D* and D0.</span></a>
<a class="sourceLine" id="cb1159-88" title="88"></a>
<a class="sourceLine" id="cb1159-89" title="89">   <span class="co">//in case one event list is given in input,</span></a>
<a class="sourceLine" id="cb1159-90" title="90">   <span class="co">//the selection has already been done.</span></a>
<a class="sourceLine" id="cb1159-91" title="91">   <span class="cf">if</span> (useList) <span class="cf">return</span> kTRUE;</a>
<a class="sourceLine" id="cb1159-92" title="92">   <span class="co">// Read only the necessary branches to select entries.</span></a>
<a class="sourceLine" id="cb1159-93" title="93">   <span class="co">// return as soon as a bad entry is detected</span></a>
<a class="sourceLine" id="cb1159-94" title="94">   b_md0_d-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-95" title="95">   <span class="cf">if</span> (TMath::Abs(md0_d-<span class="fl">1.8646</span>) &gt;= <span class="fl">0.04</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-96" title="96">   b_ptds_d-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-97" title="97">   <span class="cf">if</span> (ptds_d &lt;= <span class="fl">2.5</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-98" title="98">   b_etads_d-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-99" title="99">   <span class="cf">if</span> (TMath::Abs(etads_d) &gt;= <span class="fl">1.5</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-100" title="100">   b_ik-&gt;GetEntry(entry);  ik--;</a>
<a class="sourceLine" id="cb1159-101" title="101">   <span class="co">//original ik used f77 convention starting at 1</span></a>
<a class="sourceLine" id="cb1159-102" title="102">   b_ipi-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-103" title="103">   ipi--;</a>
<a class="sourceLine" id="cb1159-104" title="104">   b_ntracks-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-105" title="105">   b_nhitrp-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-106" title="106">   <span class="cf">if</span> (nhitrp[ik]*nhitrp[ipi] &lt;= <span class="dv">1</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-107" title="107">   b_rend-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-108" title="108">   b_rstart-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-109" title="109">   <span class="cf">if</span> (rend[ik]-rstart[ik] &lt;= <span class="dv">22</span>)   <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-110" title="110">   <span class="cf">if</span> (rend[ipi]-rstart[ipi] &lt;= <span class="dv">22</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-111" title="111">   b_nlhk-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-112" title="112">   <span class="cf">if</span> (nlhk[ik] &lt;= <span class="fl">0.1</span>)    <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-113" title="113">   b_nlhpi-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-114" title="114">   <span class="cf">if</span> (nlhpi[ipi] &lt;= <span class="fl">0.1</span>)  <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-115" title="115">   b_ipis-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-116" title="116">   ipis--;</a>
<a class="sourceLine" id="cb1159-117" title="117">   <span class="cf">if</span> (nlhpi[ipis] &lt;= <span class="fl">0.1</span>) <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-118" title="118">   b_njets-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-119" title="119">   <span class="cf">if</span> (njets &lt; <span class="dv">1</span>)          <span class="cf">return</span> kFALSE;</a>
<a class="sourceLine" id="cb1159-120" title="120"></a>
<a class="sourceLine" id="cb1159-121" title="121">    <span class="co">// if option fillList, fill the event list</span></a>
<a class="sourceLine" id="cb1159-122" title="122">   <span class="cf">if</span> (fillList) elist-&gt;Enter(fChain-&gt;GetChainEntryNumber(entry));</a>
<a class="sourceLine" id="cb1159-123" title="123"></a>
<a class="sourceLine" id="cb1159-124" title="124">   <span class="cf">return</span> kTRUE;</a>
<a class="sourceLine" id="cb1159-125" title="125">}</a>
<a class="sourceLine" id="cb1159-126" title="126"></a>
<a class="sourceLine" id="cb1159-127" title="127"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-128" title="128"><span class="dt">void</span> h1analysis::ProcessFill(<span class="dt">Int_t</span> entry)</a>
<a class="sourceLine" id="cb1159-129" title="129">{ <span class="co">// Function called for selected entries only</span></a>
<a class="sourceLine" id="cb1159-130" title="130"></a>
<a class="sourceLine" id="cb1159-131" title="131">   <span class="co">// read branches not processed in ProcessCut</span></a>
<a class="sourceLine" id="cb1159-132" title="132">   b_dm_d-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-133" title="133">   <span class="co">//read branch holding dm_d</span></a>
<a class="sourceLine" id="cb1159-134" title="134">   <span class="dt">b_rpd0_t</span>-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-135" title="135">   <span class="co">//read branch holding rpd0_t</span></a>
<a class="sourceLine" id="cb1159-136" title="136">   b_ptd0_d-&gt;GetEntry(entry);</a>
<a class="sourceLine" id="cb1159-137" title="137">   <span class="co">//read branch holding ptd0_d           //continued...</span></a>
<a class="sourceLine" id="cb1159-138" title="138">   <span class="co">//fill some histograms</span></a>
<a class="sourceLine" id="cb1159-139" title="139">   hdmd-&gt;Fill(dm_d);</a>
<a class="sourceLine" id="cb1159-140" title="140">   h2-&gt;Fill(dm_d,<span class="dt">rpd0_t</span>/<span class="fl">0.029979</span>*<span class="fl">1.8646</span>/ptd0_d);</a>
<a class="sourceLine" id="cb1159-141" title="141">}</a>
<a class="sourceLine" id="cb1159-142" title="142"></a>
<a class="sourceLine" id="cb1159-143" title="143"><span class="co">//_________________________________________________________</span></a>
<a class="sourceLine" id="cb1159-144" title="144"><span class="dt">void</span> h1analysis::Terminate()</a>
<a class="sourceLine" id="cb1159-145" title="145">{ <span class="co">// Function called at the end of the event loop</span></a>
<a class="sourceLine" id="cb1159-146" title="146"></a>
<a class="sourceLine" id="cb1159-147" title="147">   <span class="co">//create the canvas for the h1analysis fit</span></a>
<a class="sourceLine" id="cb1159-148" title="148">   gStyle-&gt;SetOptFit();</a>
<a class="sourceLine" id="cb1159-149" title="149">   TCanvas *c1 = <span class="kw">new</span> TCanvas(<span class="st">"c1"</span>,<span class="st">"h1analysis analysis"</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">800</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb1159-150" title="150">   c1-&gt;SetBottomMargin(<span class="fl">0.15</span>);</a>
<a class="sourceLine" id="cb1159-151" title="151">   hdmd-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"m_{K#pi#pi}-m_{K#pi}[GeV/c^{2}]"</span>);</a>
<a class="sourceLine" id="cb1159-152" title="152">   hdmd-&gt;GetXaxis()-&gt;SetTitleOffset(<span class="fl">1.4</span>);</a>
<a class="sourceLine" id="cb1159-153" title="153"></a>
<a class="sourceLine" id="cb1159-154" title="154">   <span class="co">//fit histogram hdmd with function f5 using</span></a>
<a class="sourceLine" id="cb1159-155" title="155">   <span class="co">//the loglikelihood option</span></a>
<a class="sourceLine" id="cb1159-156" title="156">   TF1 *f5 = <span class="kw">new</span> TF1(<span class="st">"f5"</span>,fdm5,<span class="fl">0.139</span>,<span class="fl">0.17</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1159-157" title="157">   f5-&gt;SetParameters(<span class="dv">1000000</span>,<span class="fl">.25</span>,<span class="dv">2000</span>,<span class="fl">.1454</span>,<span class="fl">.001</span>);</a>
<a class="sourceLine" id="cb1159-158" title="158">   hdmd-&gt;Fit(<span class="st">"f5"</span>,<span class="st">"lr"</span>);</a>
<a class="sourceLine" id="cb1159-159" title="159"></a>
<a class="sourceLine" id="cb1159-160" title="160">   <span class="co">//create the canvas for tau d0</span></a>
<a class="sourceLine" id="cb1159-161" title="161">   gStyle-&gt;SetOptFit(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1159-162" title="162">   gStyle-&gt;SetOptStat(<span class="dv">1100</span>);</a>
<a class="sourceLine" id="cb1159-163" title="163">   TCanvas *c2 = <span class="kw">new</span> TCanvas(<span class="st">"c2"</span>,<span class="st">"tauD0"</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">800</span>,<span class="dv">600</span>);</a>
<a class="sourceLine" id="cb1159-164" title="164">   c2-&gt;SetGrid();</a>
<a class="sourceLine" id="cb1159-165" title="165">   c2-&gt;SetBottomMargin(<span class="fl">0.15</span>);</a>
<a class="sourceLine" id="cb1159-166" title="166"></a>
<a class="sourceLine" id="cb1159-167" title="167">   <span class="co">// Project slices of 2-d histogram h2 along X ,</span></a>
<a class="sourceLine" id="cb1159-168" title="168">   <span class="co">// then fit each slice with function f2 and make a</span></a>
<a class="sourceLine" id="cb1159-169" title="169">   <span class="co">// histogram for each fit parameter.</span></a>
<a class="sourceLine" id="cb1159-170" title="170">   <span class="co">// Note that the generated histograms are added</span></a>
<a class="sourceLine" id="cb1159-171" title="171">   <span class="co">// to the list of objects in the current directory.</span></a>
<a class="sourceLine" id="cb1159-172" title="172"></a>
<a class="sourceLine" id="cb1159-173" title="173">   TF1 *f2 = <span class="kw">new</span> TF1(<span class="st">"f2"</span>,fdm2,<span class="fl">0.139</span>,<span class="fl">0.17</span>,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1159-174" title="174">   f2-&gt;SetParameters(<span class="dv">10000</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1159-175" title="175">   h2-&gt;FitSlicesX(f2,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="st">"qln"</span>);</a>
<a class="sourceLine" id="cb1159-176" title="176">   TH1D *h2_1 = (TH1D*)gDirectory-&gt;Get(<span class="st">"h2_1"</span>);</a>
<a class="sourceLine" id="cb1159-177" title="177">   h2_1-&gt;GetXaxis()-&gt;SetTitle(<span class="st">"#tau[ps]"</span>);</a>
<a class="sourceLine" id="cb1159-178" title="178">   h2_1-&gt;SetMarkerStyle(<span class="dv">21</span>);</a>
<a class="sourceLine" id="cb1159-179" title="179">   h2_1-&gt;Draw();</a>
<a class="sourceLine" id="cb1159-180" title="180">   c2-&gt;Update();</a>
<a class="sourceLine" id="cb1159-181" title="181">   TLine *line = <span class="kw">new</span> TLine(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,c2-&gt;GetUymax());</a>
<a class="sourceLine" id="cb1159-182" title="182">   line-&gt;Draw();</a>
<a class="sourceLine" id="cb1159-183" title="183"></a>
<a class="sourceLine" id="cb1159-184" title="184">   <span class="co">// save the event list to a Root file if one was produced</span></a>
<a class="sourceLine" id="cb1159-185" title="185">   <span class="cf">if</span> (fillList) {</a>
<a class="sourceLine" id="cb1159-186" title="186">      TFile efile(<span class="st">"elist.root"</span>,<span class="st">"recreate"</span>);</a>
<a class="sourceLine" id="cb1159-187" title="187">      elist-&gt;Write();</a>
<a class="sourceLine" id="cb1159-188" title="188">   }</a>
<a class="sourceLine" id="cb1159-189" title="189">}</a></code></pre></div>
<h1 id="networking"><span class="header-section-number">22</span> Networking</h1>
<p>In this chapter, you will learn how to send data over the network using the ROOT socket classes.</p>
<h2 id="setting-up-a-connection"><span class="header-section-number">22.1</span> Setting-up a Connection</h2>
<p><em>On the serverside</em>, we create a <strong><code>TServerSocket</code></strong>
 to wait for a connection request over the network. If the request is 
accepted, it returns a full-duplex socket. Once the connection is 
accepted, we can communicate to the client that we are ready to go by 
sending the string “go”, and we can close the server socket.</p>
<div class="sourceCode" id="cb1160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1160-1" title="1">{ <span class="co">// server</span></a>
<a class="sourceLine" id="cb1160-2" title="2">   TServerSocket *ss = <span class="kw">new</span> TServerSocket(<span class="dv">9090</span>,kTRUE);</a>
<a class="sourceLine" id="cb1160-3" title="3">   TSocket *socket = ss-&gt;Accept();</a>
<a class="sourceLine" id="cb1160-4" title="4">   socket-&gt;Send(<span class="st">"go"</span>);</a>
<a class="sourceLine" id="cb1160-5" title="5">   ss-&gt;Close();</a>
<a class="sourceLine" id="cb1160-6" title="6">}</a></code></pre></div>
<p><em>On the clientside</em>, we create a socket and ask the socket to receive input.</p>
<div class="sourceCode" id="cb1161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1161-1" title="1">{ <span class="co">// client</span></a>
<a class="sourceLine" id="cb1161-2" title="2">   TSocket *socket = <span class="kw">new</span> TSocket(<span class="st">"localhost"</span>,<span class="dv">9090</span>);</a>
<a class="sourceLine" id="cb1161-3" title="3">   Char str[<span class="dv">32</span>];</a>
<a class="sourceLine" id="cb1161-4" title="4">   socket-&gt;Recv(str,<span class="dv">32</span>);</a>
<a class="sourceLine" id="cb1161-5" title="5">}</a></code></pre></div>
<h2 id="sending-objects-over-the-network"><span class="header-section-number">22.2</span> Sending Objects over the Network</h2>
<p>We have just established a connection and you just saw how to send 
and receive a string with the example “go”. Now let’s send a histogram.</p>
<p><em>To send an object (in our case on the client side</em>) it has to derive from <strong><code>TObject</code></strong> class because it uses the <code>Streamers</code> to fill a buffer that is then sent over the connection. On the receiving side, the <code>Streamers</code> are used to read the object from the message sent via the socket. For network communication, we have a specialized <strong><code>TBuffer</code></strong>, a descendant of <strong><code>TBuffer</code></strong> called <strong><code>TMessage</code></strong>. In the following example, we create a <strong><code>TMessage</code></strong> with the intention to store an object, hence the constant <code>kMESS_OBJECT</code> in the constructor. We create and fill the histogram and write it into the message. Then we call <strong><code>TSocket</code></strong><code>::Send</code> to send the message with the histogram.</p>
<div class="sourceCode" id="cb1162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1162-1" title="1">...</a>
<a class="sourceLine" id="cb1162-2" title="2"><span class="co">// create an object to be sent</span></a>
<a class="sourceLine" id="cb1162-3" title="3">TH1F *hpx = <span class="kw">new</span> TH1F(<span class="st">"hpx"</span>,<span class="st">"px distribution"</span>,<span class="dv">100</span>,-<span class="dv">4</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb1162-4" title="4">hpx-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb1162-5" title="5"></a>
<a class="sourceLine" id="cb1162-6" title="6"><span class="co">// create a TMessage to send the object</span></a>
<a class="sourceLine" id="cb1162-7" title="7">TMessage message(kMESS_OBJECT);</a>
<a class="sourceLine" id="cb1162-8" title="8"></a>
<a class="sourceLine" id="cb1162-9" title="9"><span class="co">// write the histogram into the message buffer</span></a>
<a class="sourceLine" id="cb1162-10" title="10">message.WriteObject(hpx);</a>
<a class="sourceLine" id="cb1162-11" title="11"></a>
<a class="sourceLine" id="cb1162-12" title="12"><span class="co">// send the message</span></a>
<a class="sourceLine" id="cb1162-13" title="13">socket-&gt;Send(message);</a>
<a class="sourceLine" id="cb1162-14" title="14">...</a></code></pre></div>
<p>On the receiving end (in our case the server side), we write a while 
loop to wait and receive a message with a histogram. Once we have a 
message, we call <code>TMessage::ReadObject</code>, which returns a pointer to <strong><code>TObject</code></strong>. We have to cast it to a <strong><code>TH1</code></strong>
 pointer, and now we have a histogram. At the end of the loop, the 
message is deleted, and another one is created at the beginning.</p>
<div class="sourceCode" id="cb1163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1163-1" title="1"><span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb1163-2" title="2">   TMessage *message;</a>
<a class="sourceLine" id="cb1163-3" title="3">   socket-&gt;Recv(message);</a>
<a class="sourceLine" id="cb1163-4" title="4">   TH1 *h = (TH1*)message-&gt;ReadObject(message-&gt;GetClass());</a>
<a class="sourceLine" id="cb1163-5" title="5">   <span class="kw">delete</span> message;</a>
<a class="sourceLine" id="cb1163-6" title="6">}</a></code></pre></div>
<h2 id="closing-the-connection"><span class="header-section-number">22.3</span> Closing the Connection</h2>
<p>Once we are done sending objects, we close the connection by closing the sockets at both ends.</p>
<div class="sourceCode" id="cb1164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1164-1" title="1">Socket-&gt;Close();</a></code></pre></div>
<p>This diagram summarizes the steps we just covered:</p>
<figure>
<img src="ROOTUsersGuide_files/080001FF.png" alt="Server - Client setting-up and closing the connection"><figcaption>Server - Client setting-up and closing the connection</figcaption>
</figure>
<h2 id="a-server-with-multiple-sockets"><span class="header-section-number">22.4</span> A Server with Multiple Sockets</h2>
<p>Chances are that your server has to be able to receive data from multiple clients. The class we need for this is <strong><code>TMonitor</code></strong>. It lets you add sockets and the <code>TMonitor::Select</code>
 method returns the socket with data waiting. Sockets can be added, 
removed, or enabled and disabled. Here is an example of a server that 
has a <strong><code>TMonitor</code></strong> to manage multiple sockets:</p>
<div class="sourceCode" id="cb1165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1165-1" title="1">{</a>
<a class="sourceLine" id="cb1165-2" title="2">   TServerSocket *ss = <span class="kw">new</span> TServerSocket (<span class="dv">9090</span>, kTRUE);</a>
<a class="sourceLine" id="cb1165-3" title="3"></a>
<a class="sourceLine" id="cb1165-4" title="4">   <span class="co">// Accept a connection and return a full-duplex communication socket.</span></a>
<a class="sourceLine" id="cb1165-5" title="5">   TSocket *s0 = ss-&gt;Accept();</a>
<a class="sourceLine" id="cb1165-6" title="6">   TSocket *s1 = ss-&gt;Accept();</a>
<a class="sourceLine" id="cb1165-7" title="7"></a>
<a class="sourceLine" id="cb1165-8" title="8">   <span class="co">// tell the clients to start</span></a>
<a class="sourceLine" id="cb1165-9" title="9">   s0-&gt;Send(<span class="st">"go 0"</span>);</a>
<a class="sourceLine" id="cb1165-10" title="10">   s1-&gt;Send(<span class="st">"go 1"</span>);</a>
<a class="sourceLine" id="cb1165-11" title="11"></a>
<a class="sourceLine" id="cb1165-12" title="12">   <span class="co">// Close the server socket (unless we will use it</span></a>
<a class="sourceLine" id="cb1165-13" title="13">   <span class="co">// later to wait for another connection).</span></a>
<a class="sourceLine" id="cb1165-14" title="14">   ss-&gt;Close();</a>
<a class="sourceLine" id="cb1165-15" title="15"></a>
<a class="sourceLine" id="cb1165-16" title="16">   TMonitor *mon = <span class="kw">new</span> TMonitor;</a>
<a class="sourceLine" id="cb1165-17" title="17">   mon-&gt;Add(s0);</a>
<a class="sourceLine" id="cb1165-18" title="18">   mon-&gt;Add(s1);</a>
<a class="sourceLine" id="cb1165-19" title="19"></a>
<a class="sourceLine" id="cb1165-20" title="20">   <span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb1165-21" title="21">      TMessage *mess;</a>
<a class="sourceLine" id="cb1165-22" title="22">      TSocket  *s;</a>
<a class="sourceLine" id="cb1165-23" title="23">      s = mon-&gt;Select();</a>
<a class="sourceLine" id="cb1165-24" title="24">      s-&gt;Recv(mess);</a>
<a class="sourceLine" id="cb1165-25" title="25">      ...</a>
<a class="sourceLine" id="cb1165-26" title="26">   }</a>
<a class="sourceLine" id="cb1165-27" title="27">}</a></code></pre></div>
<p>The full code for the example above is in <code>$ROOTSYS/tutorials/net/hserv.C and</code></p>
<p><code>$ROOTSYS/tutorials/net/hclient.C</code>.</p>
<h1 id="threads"><span class="header-section-number">23</span> Threads</h1>
<p>A thread is an independent flow of control that operates within the 
same address space as other independent flows of controls within a 
process. In most UNIX systems, thread and process characteristics are 
grouped into a single entity called a process. Sometimes, threads are 
called "lightweight processes’’.</p>
<p>Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.</p>
<h2 id="threads-and-processes"><span class="header-section-number">23.1</span> Threads and Processes</h2>
<p>In traditional single-threaded process systems, a process has a set 
of properties. In multi-threaded systems, these properties are divided 
between processes and threads.</p>
<h3 id="process-properties"><span class="header-section-number">23.1.1</span> Process Properties</h3>
<p>A process in a multi-threaded system is the changeable entity. It 
must be considered as an execution frame. It has all traditional process
 attributes, such as:</p>
<ul>
<li><p>Process ID, process group ID, user ID, and group ID</p></li>
<li><p>Environment</p></li>
<li><p>Working directory</p></li>
</ul>
<p>A process also provides a common address space and common system resources:</p>
<ul>
<li><p>File descriptors</p></li>
<li><p>Signal actions</p></li>
<li><p>Shared libraries</p></li>
<li><p>Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory)</p></li>
</ul>
<h3 id="thread-properties"><span class="header-section-number">23.1.2</span> Thread Properties</h3>
<p>A thread is the schedulable entity. It has only those properties that
 are required to ensure its independent flow of control. These include 
the following properties:</p>
<ul>
<li><p>Stack</p></li>
<li><p>Scheduling properties (such as policy or priority)</p></li>
<li><p>Set of pending and blocked signals</p></li>
<li><p>Some thread-specific data (TSD)</p></li>
</ul>
<p>An example of thread-specific data is the error indicator, <code>errno</code>. In multi-threaded systems, <code>errno</code> is no longer a global variable, but usually a subroutine returning a thread-specific <code>errno</code> value. Some other systems may provide other implementations of <code>errno</code>. With respect to ROOT, a thread specific data is for example the <strong><em><code>gPad</code></em></strong> pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.</p>
<p>Threads within a process must not be considered as a group of 
processes (even though in Linux each thread receives an own process id, 
so that it can be scheduled by the kernel scheduler). All threads share 
the same address space. This means that two pointers having the same 
value in two threads refer to the same data. Also, if any thread changes
 one of the shared system resources, all threads within the process are 
affected. For example, if a thread closes a file, the file is closed for
 all threads.</p>
<h3 id="the-initial-thread"><span class="header-section-number">23.1.3</span> The Initial Thread</h3>
<p>When a process is created, one thread is automatically created. This 
thread is called the initial thread or the main thread. The initial 
thread executes the main routine in multi-threaded programs.</p>
<p>Note: At the end of this chapter is a glossary of thread specific terms</p>
<h2 id="implementation-of-threads-in-root"><span class="header-section-number">23.2</span> Implementation of Threads in ROOT</h2>
<p>The <strong><code>TThread</code></strong> class has been developed to provide a platform independent interface to threads for ROOT.</p>
<h3 id="installation-1"><span class="header-section-number">23.2.1</span> Installation</h3>
<p>For the time being, it is still necessary to compile a threaded 
version of ROOT to enable some very special treatments of the canvas 
operations. We hope that this will become the default later.</p>
<p>To compile ROOT, just do (for example on a debian Linux):</p>
<pre><code>./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so
gmake depend
gmake</code></pre>
<p>This configures and builds ROOT using <code>/usr/lib/libpthread.so</code> as the <code>Pthread</code> library, and defines <code>R__THREAD</code>.</p>
<p>This enables the thread specific treatment of <em><code>gPad</code></em>, and creates <code>$ROOTSYS/lib/libThread.so.</code></p>
<p>Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.</p>
<h3 id="classes"><span class="header-section-number">23.2.2</span> Classes</h3>
<p><strong><code>TThread</code></strong> class implements threads . The platform dependent implementation is in the <strong><code>TThreadImp</code></strong> class and its descendant classes (e.g.&nbsp;<strong><code>TPosixThread</code></strong> ).</p>
<p><strong><code>TMutex</code></strong> class implements <code>mutex</code> locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the <strong><code>TMutexImp</code></strong> class and its descendant classes (e.g. <strong><code>TPosixMutex</code></strong>)</p>
<p><strong><code>TCondition</code></strong> class implements a condition
 variable. Use a condition variable to signal threads. The platform 
dependent implementation is in the <strong><code>TConditionImp</code></strong> and <strong><code>TPosixCondition</code></strong> classes .</p>
<p><strong><code>TSemaphore</code></strong> class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the <strong><code>TMutexImp</code></strong> and <strong><code>TConditionImp</code></strong> classes.</p>
<h3 id="tthread-for-pedestrians"><span class="header-section-number">23.2.3</span> TThread for Pedestrians</h3>
<p>To run a thread in ROOT, follow these steps:</p>
<ol type="1">
<li>Initialization</li>
</ol>
<p>Add these lines to your <code>rootlogon.C</code>:</p>
<div class="sourceCode" id="cb1167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1167-1" title="1">{</a>
<a class="sourceLine" id="cb1167-2" title="2">   ...</a>
<a class="sourceLine" id="cb1167-3" title="3">   <span class="co">// The next line may be unnecessary on some platforms</span></a>
<a class="sourceLine" id="cb1167-4" title="4">   gSystem-&gt;Load(<span class="st">"/usr/lib/libpthread.so"</span>);</a>
<a class="sourceLine" id="cb1167-5" title="5">   gSystem-&gt;Load(<span class="st">"$ROOTSYS/lib/libThread.so"</span>);</a>
<a class="sourceLine" id="cb1167-6" title="6">   ...</a>
<a class="sourceLine" id="cb1167-7" title="7">}</a></code></pre></div>
<p>This loads the library with the <strong><code>TThread</code></strong> class and the <code>pthread</code> specific implementation file for <code>Posix</code> threads.</p>
<ol start="2" type="1">
<li>Coding</li>
</ol>
<p>Define a function (e.g.&nbsp;<code>void* UserFun(void* UserArgs))</code>
 that should run as a thread. The code for the examples is at the web 
site of the authors (Jörn Adamczewski, Marc Hemberger). After 
downloading the code from this site, you can follow the example below:</p>
<p><a href="http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html" class="uri">http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html</a></p>
<ol start="3" type="1">
<li>Loading</li>
</ol>
<p>Start an interactive ROOT session. Load the shared library:</p>
<div class="sourceCode" id="cb1168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1168-1" title="1">root[] gSystem-&gt;Load(<span class="st">"mhs3.so"</span>);              <span class="co">// or</span></a>
<a class="sourceLine" id="cb1168-2" title="2">root[] gSystem-&gt;Load(<span class="st">"CalcPiThread.so"</span>);</a></code></pre></div>
<ol start="4" type="1">
<li>Creating</li>
</ol>
<p>Create a thread instance (see also example <code>RunMhs3.C</code>or<code>RunPi.C</code>) with:</p>
<div class="sourceCode" id="cb1169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1169-1" title="1">root[] TThread *th = <span class="kw">new</span> TThread(UserFun,UserArgs);</a></code></pre></div>
<p>When called from the interpreter, this gives the name “<code>UserFun</code>”
 to the thread. This name can be used to retrieve the thread later. 
However, when called from compiled code, this method does not give any 
name to the thread. So give a name to the thread in compiled use:</p>
<div class="sourceCode" id="cb1170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1170-1" title="1">root[] TThread *th = <span class="kw">new</span> TThread(<span class="st">"MyThread"</span>, UserFun, UserArgs);</a></code></pre></div>
<p>You can pass arguments to the thread function using the <code>UserArgs</code>-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as <code>UserArgs</code>.</p>
<ol start="5" type="1">
<li>Running</li>
</ol>
<div class="sourceCode" id="cb1171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1171-1" title="1">root[] th-&gt;Run();</a>
<a class="sourceLine" id="cb1171-2" title="2">root[] TThread::Ps(); <span class="co">// like UNIX ps c.ommand;</span></a></code></pre></div>
<p>With the <code>mhs3</code> example, you should be able to see a 
canvas with two pads on it. Both pads keep histograms updated and filled
 by three different threads. With the <code>CalcPi</code> example, you should be able to see two threads calculating Pi with the given number of intervals as precision.</p>
<h3 id="tthread-in-more-details"><span class="header-section-number">23.2.4</span> TThread in More Details</h3>
<p>Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.</p>
<h4 id="asynchronous-actions"><span class="header-section-number">23.2.4.1</span> Asynchronous Actions</h4>
<p>Different threads can work simultaneously with the same object. Some 
actions can be dangerous. For example, when two threads create a 
histogram object, ROOT allocates memory and puts them to the same 
collection. If it happens at the same time, the results are 
undetermined. To avoid this problem, the user has to synchronize these 
actions with:</p>
<div class="sourceCode" id="cb1172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1172-1" title="1">   TThread::Lock()    <span class="co">// Locking the following part of code</span></a>
<a class="sourceLine" id="cb1172-2" title="2">   ...                <span class="co">// Create an object, etc...</span></a>
<a class="sourceLine" id="cb1172-3" title="3">   TThread::UnLock()  <span class="co">// Unlocking</span></a></code></pre></div>
<p>The code between <code>Lock()</code> and <code>UnLock()</code> will 
be performed uninterrupted. No other threads can perform actions or 
access objects/collections while it is being executed. The methods <code>TThread::Lock()</code>and <strong><code>TThread::UnLock()</code></strong> internally use a global <code>TMutex</code> instance for locking.</p>
<p>The user may also define their own <strong><code>TMutex</code></strong> <code>MyMutex</code> instance and may locally protect their asynchronous actions by calling <code>MyMutex.Lock()</code> and <code>MyMutex.UnLock().</code></p>
<h4 id="synchronous-actions-tcondition"><span class="header-section-number">23.2.4.2</span> Synchronous Actions: TCondition</h4>
<p>To synchronize the actions of different threads you can use the <strong><code>TCondition</code></strong> class, which provides a signaling mechanism. The <strong><code>TCondition</code></strong>
 instance must be accessible by all threads that need to use it, 
i.e.&nbsp;it should be a global object (or a member of the class which 
owns the threaded methods, see below). To create a <strong><code>TCondition</code></strong> object, a <strong><code>TMutex</code></strong> instance is required for the Wait and <code>TimedWait</code> locking methods. One can pass the address of an external mutex to the <strong><code>TCondition</code></strong> constructor:</p>
<div class="sourceCode" id="cb1173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1173-1" title="1">   TMutex MyMutex;</a>
<a class="sourceLine" id="cb1173-2" title="2">   TCondition MyCondition(&amp;MyMutex);</a></code></pre></div>
<p>If zero is passed, <strong><code>TCondition</code></strong> creates and uses its own internal mutex:</p>
<div class="sourceCode" id="cb1174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1174-1" title="1">   TCondition MyCondition(<span class="dv">0</span>);</a></code></pre></div>
<p>You can now use the following methods of synchronization:</p>
<ul>
<li><p><code>TCondition::Wait()</code> waits until any thread sends a signal of the same condition instance: <code>MyCondition.Wait()</code> reacts on <code>MyCondition.Signal()</code> or <code>MyCondition.Broadcast()</code>. <code>MyOtherCondition.Signal()</code> has no effect.</p></li>
<li><p>If several threads wait for the signal from the same <strong><code>TCondition</code></strong> <code>MyCondition</code>, at <code>MyCondition.Signal()</code> only one thread will react; to activate a further thread another <code>MyCondition.Signal()</code> is required, etc.</p></li>
<li><p>If several threads wait for the signal from the same <strong><code>TCondition</code></strong> <code>MyCondition</code>, at <code>MyCondition.Broadcast()</code> all threads waiting for <code>MyCondition</code> are activated at once.</p></li>
</ul>
<p>In some tests of <code>MyCondition</code> using an internal mutex, <code>Broadcast()</code> activated only one thread (probably depending whether <code>MyCondition</code> had been signaled before).</p>
<ul>
<li><code>MyCondition.TimedWait(secs,nanosecs)</code> waits for <code>MyCondition</code> until the <em>absolute</em>
 time in seconds and nanoseconds since beginning of the epoch (January, 
1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is 
required to calculate the absolute time at the beginning of waiting 
‘‘now’’; for example:</li>
</ul>
<div class="sourceCode" id="cb1175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1175-1" title="1">   <span class="dt">Ulong_t</span> now,then,delta;                   <span class="co">// seconds</span></a>
<a class="sourceLine" id="cb1175-2" title="2">   TDatime myTime;                           <span class="co">// root daytime class</span></a>
<a class="sourceLine" id="cb1175-3" title="3">   myTime.Set();                             <span class="co">// myTime set to "now"</span></a>
<a class="sourceLine" id="cb1175-4" title="4">   now=myTime.Convert();                     <span class="co">// to seconds since 1970</span></a></code></pre></div>
<ul>
<li>Return value wait of <code>MyCondition.TimedWait</code> should be 0, if <code>MyCondition.Signal()</code> was received, and should be nonzero, if timeout was reached.</li>
</ul>
<p>The conditions example shows how three threaded functions are synchronized using <strong><code>TCondition</code></strong>: a ROOT script <code>condstart.C</code> starts the threads, which are defined in a shared library (<code>conditions.cxx, conditions.h</code>).</p>
<h4 id="xlib-connections"><span class="header-section-number">23.2.4.3</span> Xlib Connections</h4>
<p>Usually <code>Xlib</code> is not thread safe. This means that calls 
to the X could fail, when it receives X-messages from different threads.
 The actual result depends strongly on which version of <code>Xlib</code> has been installed on your system. The only thing we can do here within ROOT is calling a special function <code>XInitThreads()</code>(which is part of the <code>Xlib</code>), which should (!) prepare the <code>Xlib</code> for the usage with threads.</p>
<p>To avoid further problems within ROOT some redefinition of the <strong><em><code>gPad</code></em></strong> pointer was done (that’s the main reason for the recompilation). When a thread creates a <strong><code>TCanvas</code></strong>,
 this object is actually created in the main thread; this should be 
transparent to the user. Actions on the canvas are controlled via a 
function, which returns a pointer to either thread specific data (TSD) 
or the main thread pointer. This mechanism works currently only for <strong><em><code>gPad</code></em></strong>, <strong><em><code>gDirectory</code></em></strong>, <strong><em><code>gFile</code></em></strong> and will be implemented soon for other global Objects as e.g.&nbsp;<strong><em><code>gVirtualX</code></em></strong>.</p>
<h4 id="canceling-a-tthread"><span class="header-section-number">23.2.4.4</span> Canceling a TThread</h4>
<p>Canceling of a thread is a rather dangerous action. In <strong><code>TThread</code></strong> canceling is forbidden by default. The user can change this default by calling <code>TThread::SetCancelOn()</code>. There are two cancellation modes: deferred and asynchronous.</p>
<h4 id="deferred"><span class="header-section-number">23.2.4.5</span> Deferred</h4>
<p>Set by <code>TThread::SetCancelDeferred()</code> (default): When the 
user knows safe places in their code where a thread can be canceled 
without risk for the rest of the system, they can define these points by
 invoking <strong><code>TThread</code></strong><code>::CancelPoint()</code>. Then, if a thread is canceled, the cancellation is deferred up to the call of <strong><code>TThread</code></strong><code>::CancelPoint()</code> and then the thread is canceled safely. There are some default cancel points for <code>pthreads</code> implementation, e.g. any call of the <code>TCondition::Wait()</code>, <strong><code>TCondition</code></strong><code>::TimedWait()</code>, <code>TThread::Join()</code>.</p>
<h4 id="asynchronous"><span class="header-section-number">23.2.4.6</span> Asynchronous</h4>
<p>Set by <code>TThread::SetCancelAsynchronous()</code>: If the user is sure that their application is cancel safe, they could call:</p>
<div class="sourceCode" id="cb1176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1176-1" title="1">   TThread::SetCancelAsynchronous();</a>
<a class="sourceLine" id="cb1176-2" title="2">   TThread::SetCancelOn();</a>
<a class="sourceLine" id="cb1176-3" title="3">   <span class="co">// Now cancelation in any point is allowed.</span></a>
<a class="sourceLine" id="cb1176-4" title="4">   ...</a>
<a class="sourceLine" id="cb1176-5" title="5">   <span class="co">// Return to default</span></a>
<a class="sourceLine" id="cb1176-6" title="6">   TThread::SetCancelOff();</a>
<a class="sourceLine" id="cb1176-7" title="7">   TThread::SetCancelDeferred();</a></code></pre></div>
<p>To cancel a thread <code>TThread* th</code> call:</p>
<div class="sourceCode" id="cb1177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1177-1" title="1">   th-&gt;Kill();</a></code></pre></div>
<p>To cancel by thread name:</p>
<div class="sourceCode" id="cb1178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1178-1" title="1">   TThread::Kill(name);</a></code></pre></div>
<p>To cancel a thread by ID:</p>
<div class="sourceCode" id="cb1179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1179-1" title="1">   TThread::Kill(tid);</a></code></pre></div>
<p>To cancel a thread and delete <code>th</code> when cancel finished:</p>
<div class="sourceCode" id="cb1180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1180-1" title="1">   th-&gt;Delete();</a></code></pre></div>
<p>Deleting of the thread instance by the operator delete is dangerous. Use <code>th-&gt;Delete()</code>
 instead. C++ delete is safe only if thread is not running. Often during
 the canceling, some clean up actions must be taken. To define clean up 
functions use:</p>
<div class="sourceCode" id="cb1181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1181-1" title="1">   <span class="dt">void</span> UserCleanUp(<span class="dt">void</span> *arg) {</a>
<a class="sourceLine" id="cb1181-2" title="2">      <span class="co">// here the user cleanup is done</span></a>
<a class="sourceLine" id="cb1181-3" title="3">      ...</a>
<a class="sourceLine" id="cb1181-4" title="4">   }</a>
<a class="sourceLine" id="cb1181-5" title="5">   TThread::CleanUpPush(&amp;UserCleanUp,arg);</a>
<a class="sourceLine" id="cb1181-6" title="6">          <span class="co">// push user function into cleanup stack"last in, first out"</span></a>
<a class="sourceLine" id="cb1181-7" title="7">   TThread::CleanUpPop(<span class="dv">1</span>); <span class="co">// pop user function out of stack and</span></a>
<a class="sourceLine" id="cb1181-8" title="8">                        <span class="co">// execute it, thread resumes after this call</span></a>
<a class="sourceLine" id="cb1181-9" title="9">   TThread::CleanUpPop(<span class="dv">0</span>); <span class="co">// pop user function out of stack</span></a>
<a class="sourceLine" id="cb1181-10" title="10">   <span class="co">// _without_ executing it</span></a></code></pre></div>
<p>Note: <code>CleanUpPush</code> and <code>CleanUpPop</code> should be used as corresponding pairs like brackets; unlike <code>pthreads</code> cleanup stack (which is <em>not</em> implemented here), <strong><code>TThread</code></strong> does not force this usage.</p>
<h4 id="finishing-thread"><span class="header-section-number">23.2.4.7</span> Finishing thread</h4>
<p>When a thread returns from a user function the thread is finished. It also can be finished by <code>TThread::Exit()</code>. Then, in case of <code>thread</code>-detached mode, the thread vanishes completely. By default, on finishing <strong><code>TThread</code></strong> executes the most recent cleanup function (<code>CleanUpPop(1)</code> is called automatically once).</p>
<h2 id="advanced-tthread-launching-a-method-in-a-thread"><span class="header-section-number">23.3</span> Advanced TThread: Launching a Method in a Thread</h2>
<p>Consider a class <code>Myclass</code> with a member function that shall be launched as a thread.</p>
<div class="sourceCode" id="cb1182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1182-1" title="1">   <span class="dt">void</span>* Myclass::Thread0((<span class="dt">void</span>* arg)</a></code></pre></div>
<p>To start Thread0 as a <strong><code>TThread</code></strong>, class <code>Myclass</code> may provide a method:</p>
<div class="sourceCode" id="cb1183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1183-1" title="1"><span class="dt">Int_t</span> Myclass::Threadstart(){</a>
<a class="sourceLine" id="cb1183-2" title="2">   <span class="cf">if</span>(!mTh){</a>
<a class="sourceLine" id="cb1183-3" title="3">      mTh= <span class="kw">new</span> TThread(<span class="st">"memberfunction"</span>,</a>
<a class="sourceLine" id="cb1183-4" title="4">                 (<span class="dt">void</span>(*)(<span class="dt">void</span> *))&amp;Thread0,(<span class="dt">void</span>*) <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb1183-5" title="5">      mTh-&gt;Run();</a>
<a class="sourceLine" id="cb1183-6" title="6">      <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1183-7" title="7">   }</a>
<a class="sourceLine" id="cb1183-8" title="8">   <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1183-9" title="9">}</a></code></pre></div>
<p>Here <code>mTh</code> is a <code>TThread*</code> pointer which is member of <code>Myclass</code>and should be initialized to 0 in the constructor. The <strong><code>TThread</code></strong> constructor is called as when we used a plain C function above, except for the following two differences.</p>
<p>First, the member function Thread0 requires an explicit cast to <code>(void(*) (void *)</code>). This may cause an annoying but harmless compiler warning:</p>
<div class="sourceCode" id="cb1184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1184-1" title="1">Myclass.cxx:<span class="dv">98</span>: warning:</a>
<a class="sourceLine" id="cb1184-2" title="2">              converting from <span class="st">"void (Myclass::*)(void *)"</span>to <span class="st">"void *"</span> )</a></code></pre></div>
<p>Strictly speaking, <code>Thread0</code> must be a static member function to be called from a thread. Some compilers, for example <code>gcc</code> version 2.95.2, may not allow the <code>(void(*) (void*))s</code> cast and just stop if <code>Thread0</code> is not static. On the other hand, if <code>Thread0</code> is static, no compiler warnings are generated at all. Because the <code>'this'</code> pointer is passed in <code>'arg'</code> in the call to <code>Thread0(void *arg),</code> you have access to the instance of the class even if <code>Thread0</code> is static. Using the <code>'this'</code> pointer, non static members can still be read and written from <code>Thread0</code>, as long as you have provided Getter and Setter methods for these members. For example:</p>
<div class="sourceCode" id="cb1185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1185-1" title="1">   <span class="dt">Bool_t</span> state = arg-&gt;GetRunStatus();</a>
<a class="sourceLine" id="cb1185-2" title="2">   arg-&gt;SetRunStatus(state);</a></code></pre></div>
<p>Second, the pointer to the current instance of <code>Myclass</code>, 
i.e.&nbsp;(void*) this, has to be passed as first argument of the 
threaded function Thread0 (C++ member functions internally expect this 
pointer as first argument to have access to class members of the same 
instance). <code>pthreads</code> are made for simple C functions and do 
not know about Thread0 being a member function of a class. Thus, you 
have to pass this information by hand, if you want to access all members
 of the <code>Myclass</code> instance from the Thread0 function.</p>
<p>Note: Method Thread0 cannot be a virtual member function, since the cast of <code>Thread0</code> to <code>void(*)</code> in the <strong><code>TThread</code></strong>
 constructor may raise problems with C++ virtual function table. 
However, Thread0 may call another virtual member function virtual void <code>Myclass::Func0()</code> which then can be overridden in a derived class of <code>Myclass</code>. (See example <code>TMhs3</code>).</p>
<p>Class <code>Myclass</code> may also provide a method to stop the running thread:</p>
<div class="sourceCode" id="cb1186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1186-1" title="1"><span class="dt">Int_t</span> Myclass::Threadstop() {</a>
<a class="sourceLine" id="cb1186-2" title="2">   <span class="cf">if</span> (mTh) {</a>
<a class="sourceLine" id="cb1186-3" title="3">      TThread::Delete(mTh);</a>
<a class="sourceLine" id="cb1186-4" title="4">      <span class="kw">delete</span> mTh;</a>
<a class="sourceLine" id="cb1186-5" title="5">      mTh=<span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1186-6" title="6">      <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1186-7" title="7">   }</a>
<a class="sourceLine" id="cb1186-8" title="8">   <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1186-9" title="9">}</a></code></pre></div>
<p>Example <code>TMhs3:</code> Class <strong><code>TThreadframe</code></strong> (<code>TThreadframe.h, TThreadframe.cxx</code>) is a simple example of a framework class managing up to four threaded methods. Class <code>TMhs3</code> (<code>TMhs3.h, TMhs3.cxx)</code> inherits from this base class, showing the <code>mhs3</code> example 8.1 <code>(mhs3.h, mhs3.cxx)</code>within a class. The <code>Makefile</code> of this example builds the shared libraries <code>libTThreadframe.so</code> and <code>libTMhs3.so</code>. These are either loaded or executed by the ROOT script <code>TMhs3demo.C,</code> or are linked against an executable: <code>TMhs3run.cxx</code>.</p>
<h3 id="known-problems"><span class="header-section-number">23.3.1</span> Known Problems</h3>
<p>Parts of the ROOT framework, like the interpreter, are not yet 
thread-safe. Therefore, you should use this package with caution. If you
 restrict your threads to distinct and `simple’ duties, you will able to
 benefit from their use. The <strong><code>TThread</code></strong> class
 is available on all platforms, which provide a POSIX compliant thread 
implementation. On Linux, Xavier Leroy’s Linux Threads implementation is
 widely used, but the <strong><code>TThread</code></strong> implementation should be usable on all platforms that provide <code>pthread</code>.</p>
<p><strong>Linux Xlib on SMP machines</strong> is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.</p>
<p><strong>Object instantiation:</strong> there is no implicit locking 
mechanism for memory allocation and global ROOT lists. The user has to 
explicitly protect their code when using them.</p>
<h2 id="the-signals-of-root"><span class="header-section-number">23.4</span> The Signals of ROOT</h2>
<p>The list of default signals handled by ROOT is:</p>
<div class="sourceCode" id="cb1187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1187-1" title="1">kSigChildkSigPipe</a>
<a class="sourceLine" id="cb1187-2" title="2">kSigBuskSigAlarm</a>
<a class="sourceLine" id="cb1187-3" title="3">kSigSegmentationViolationkSigUrgent</a>
<a class="sourceLine" id="cb1187-4" title="4">kSigIllegalInstructionkSigFloatingException</a>
<a class="sourceLine" id="cb1187-5" title="5">kSigSystemkSigWindowChanged</a></code></pre></div>
<p>The signals <strong><em><code>kSigFloatingException</code></em></strong>, <strong><em><code>kSigSegmentationViolation</code></em></strong>, <strong><em><code>kSigIllegalInstruction</code></em></strong>, and <strong><em><code>kSigBus</code></em></strong> cause the printing of the <strong><em><code>*** Break ***</code></em></strong> message and make a long jump back to the ROOT prompt. No other custom <strong><code>TSignalHandler</code></strong> can be added to these signals.</p>
<p>The <strong><em><code>kSigAlarm</code></em></strong> signal handles asynchronous timers. The <strong><em><code>kSigWindowChanged</code></em></strong> signal handles the resizing of the terminal window. The other signals have no other behavior then that to call any registered <strong><code>TSignalHandler</code><em><code>::Notify()</code></em></strong>.</p>
<p>When building in interactive application the use of the <strong><code>TRint</code></strong> object handles the <code>kSigInterrupt</code> signal. It causes the printing of the message: <strong><em><code>*** Break *** keyboard interrupt</code></em></strong>and makes a long jump back to the ROOT command prompt. If no <strong><code>TRint</code></strong> object is created, there will be no <code>kSigInterrupt</code> handling. All signals can be reset to their default UNIX behavior via the call of <strong><code>TSytem</code></strong><code>::ResetSignal()</code>. All signals can be ignored via <code>TSytem::IgnoreSignal()</code>. The <strong><code>TSytem::IgnoreInterrupt()</code></strong> is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a <code>SIGINT</code> to interrupt some important call (like writing to a ROOT file).</p>
<p>If <strong><code>TRint</code></strong> is used and the default ROOT interrupt handler is not desired, you should use <code>GetSignalHandler()</code> of <strong><code>TApplication</code></strong> to get the interrupt handler and to remove it by <code>RemoveSignalHandler()</code>of <strong><code>TSystem</code></strong> .</p>
<h2 id="glossary"><span class="header-section-number">23.5</span> Glossary</h2>
<p>The following glossary is adapted from the description of the Rogue Wave <code>Threads.h</code>++ package.</p>
<p>A <strong><code>process</code></strong> is a program that is loaded 
into memory and prepared for execution. Each process has a private 
address space. Processes begin with a single thread.</p>
<p>A <strong><code>thread</code></strong> is a sequence of instructions 
being executed in a program. A thread has a program counter and a 
private stack to keep track of local variables and return addresses. A 
multithreaded process is associated with one or more threads. Threads 
execute independently. All threads in a given process share the private 
address space of that process.</p>
<p><strong><code>Concurrency</code></strong> exists when at least two 
threads are in progress at the same time. A system with only a single 
processor can support concurrency by switching execution contexts among 
multiple threads.</p>
<p><strong><code>Parallelism</code></strong> arises when at least two 
threads are executing simultaneously. This requires a system with 
multiple processors. Parallelism implies concurrency, but not 
vice-versa.</p>
<p>A function is <strong><code>reentrant</code></strong> if it will 
behave correctly even if a thread of execution enters the function while
 one or more threads are already executing within the function. These 
could be the same thread, in the case of recursion, or different 
threads, in the case of concurrency.</p>
<p><strong><code>Thread-specific data</code></strong> (<strong><code>TSD</code></strong>)
 is also known as thread-local storage (TLS). Normally, any data that 
has lifetime beyond the local variables on the thread’s private stack 
are shared among all threads within the process. Thread-specific data is
 a form of static or global data that is maintained on a per-thread 
basis. That is, each thread gets its own private copy of the data.</p>
<p>Left to their own devices, threads execute independently. <strong><code>Synchronization</code></strong>
 is the work that must be done when there are, in fact, 
interdependencies that require some form of communication among threads.
 Synchronization tools include mutexes, semaphores, condition variables,
 and other variations on locking.</p>
<p>A <strong><code>critical section</code></strong> is a section of code
 that accesses a non-sharable resource. To ensure correct code, only one
 thread at a time may execute in a critical section. In other words, the
 section is not reentrant.</p>
<p>A <strong><code>mutex</code></strong>, or mutual exclusion lock, is a
 synchronization object with two states locked and unlocked. A mutex is 
usually used to ensure that only one thread at a time executes some 
critical section of code. Before entering a critical section, a thread 
will attempt to lock the mutex, which guards that section. If the mutex 
is already locked, the thread will block until the mutex is unlocked, at
 which time it will lock the mutex, execute the critical section, and 
unlock the mutex upon leaving the critical section.</p>
<p>A <strong><code>semaphore</code></strong> is a synchronization 
mechanism that starts out initialized to some positive value. A thread 
may ask to wait on a semaphore in which case the thread blocks until the
 value of the semaphore is positive. At that time the semaphore count is
 decremented and the thread continues. When a thread releases semaphore,
 the semaphore count is incremented. Counting semaphores are useful for 
coordinating access to a limited pool of some resource.</p>
<p><strong><code>Readers/Writer Lock</code></strong> - a 
multiple-reader, single-writer lock is one that allows simultaneous read
 access by many threads while restricting write access to only one 
thread at a time. When any thread holds the lock for reading, other 
threads can also acquire the lock reading. If one thread holds the lock 
for writing, or is waiting to acquire the lock for writing, other 
threads must wait to acquire the lock for either reading or writing.</p>
<p>Use a <strong><code>condition variable</code></strong> in conjunction with a mutex lock to automatically block threads until a particular condition is true.</p>
<p><strong><code>Multithread Safe Levels</code></strong> - a possible classification scheme to describe thread-safety of libraries:</p>
<ul>
<li><p>All public and protected functions are reentrant. The library 
provides protection against multiple threads trying to modify static and
 global data used within a library. The developer must explicitly lock 
access to objects shared between threads. No other thread can write to a
 locked object unless it is unlocked. The developer needs to lock local 
objects. The spirit, if not the letter of this definition, requires the 
user of the library only to be familiar with the semantic content of the
 objects in use. Locking access to objects that are being shared due to 
extra-semantic details of implementation (for example, copy-on-write) 
should remain the responsibility of the library.</p></li>
<li><p>All public and protected functions are reentrant. The library 
provides protection against multiple threads trying to modify static and
 global data used within the library. The preferred way of providing 
this protection is to use mutex locks. The library also locks an object 
before writing to it. The developer is not required to explicitly lock 
or unlock a class object (static, global or local) to perform a single 
operation on the object. Note that even multithread safe level II hardly
 relieves the user of the library from the burden of locking.</p></li>
</ul>
<p>A thread suffers from <strong><code>deadlock</code></strong> if it is
 blocked waiting for a condition that will never occur. Typically, this 
occurs when one thread needs to access a resource that is already locked
 by another thread, and that other thread is trying to access a resource
 that has already been locked by the first thread. In this situation, 
neither thread is able to progress; they are deadlocked.</p>
<p>A <strong><code>multiprocessor</code></strong> is a hardware system with multiple processors or multiple, simultaneous execution units.</p>
<ul>
<li>Examples can be found at <a href="http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html" class="uri">http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html</a> (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger).</li>
</ul>
<h1 id="proof-parallel-processing"><span class="header-section-number">24</span> PROOF: Parallel Processing</h1>
<p> </p>
<p>The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing 
transparent analysis of large sets of ROOT files in parallel on remote 
computer clusters or multi-core computers. The main design goals for the
 PROOF system are:</p>
<p><em>Transparency</em> : there should be as little difference as 
possible between a local ROOT based analysis session and a remote 
parallel PROOF session, both being interactive and giving the same 
results.</p>
<p><em>Scalability</em> : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.</p>
<p><em>Adaptability</em> : the system should be able to adapt itself to 
variations in the remote environment (changing load on the cluster 
nodes, network interruptions, etc.).</p>
<p>Being an extension of the ROOT system, PROOF is designed to work on 
objects in ROOT data stores, though, for the time being, it mainly 
addresses the case of <strong><code>TTree</code></strong> based object collections.</p>
<p>PROOF is primarily meant as an interactive alternative to batch 
systems for Central Analysis Facilities and departmental workgroups 
(Tier-2’s). However, thanks to a multi-tier architecture allowing 
multiple levels of masters, it can be easily adapted to wide range 
virtual clusters distributed over geographically separated domains and 
heterogeneous machines (GRIDs).</p>
<p>While pure interactivity might not always be possible when performing
 a complicated analysis on a very large data set, PROOF still tries to 
give the user the interactive experience with something we call 
“interactive batch”. With “interactive batch” the user can start very 
long running queries, disconnect the client and at any time, any 
location and from any computer reconnect to the query to monitor its 
progress or retrieve the results. This feature gives it a distinct 
advantage over purely batch based solutions, that only provide an answer
 once all sub-jobs have been finished.</p>
<figure>
<img src="ROOTUsersGuide_files/03000200.png" alt="The Multi-tier structure of a PROOF cluster"><figcaption>The Multi-tier structure of a PROOF cluster</figcaption>
</figure>
<p>Details about the PROOF system and the way to use it can be found at <proofwiki> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></proofwiki></p>
<p>The PROOF development is a joint effort between CERN and MIT.</p>
<h1 id="writing-a-graphical-user-interface"><span class="header-section-number">25</span> Writing a Graphical User Interface</h1>
<p></p>
<p>The ROOT GUI classes support an extensive and rich set of widgets 
with the Windows 95 look and feel. The widget classes interface to the 
underlying graphics system via a single abstract class. Concrete 
versions of this abstract class have been implemented for X11 and Win32,
 thereby making the ROOT GUI fully cross-platform. Originally the GUI 
classes were based on Hector Peraza’s Xclass’95 widget library <a href="http://xclass.sourceforge.net/" class="uri">http://xclass.sourceforge.net/</a></p>
<h2 id="the-root-gui-classes"><span class="header-section-number">25.1</span> The ROOT GUI Classes</h2>
<p>Features of the GUI classes in a nutshell:</p>
<ul>
<li><p>Originally based on the Xclass’95 widget library</p></li>
<li><p>A rich and complete set of widgets</p></li>
<li><p>Win’95 look and feel</p></li>
<li><p>All machine dependent graphics calls abstracted via the <strong><code>TVirtualX</code></strong> “abstract” class</p></li>
<li><p>Completely scriptable via the C++ interpreter (fast prototyping)</p></li>
<li><p>Supports signal/slot event handling as pioneered by Trolltech’s Qt</p></li>
<li><p>Full class documentation is generated automatically (as for all ROOT classes)</p></li>
<li><p>Code generation for variety of GUI’s</p></li>
</ul>
<h2 id="widgets-and-frames"><span class="header-section-number">25.2</span> Widgets and Frames</h2>
<p>The ROOT GUI classes provide of set of components that allow an easy 
way to develop cross-platform GUI applications with a Windows look and 
feel.</p>
<p>The main widgets are:</p>
<ul>
<li><p>Simple widgets: labels, icons, push buttons, either with text or 
pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll
 bars, list boxes, combo boxes, group frames, text entry widgets, tab 
widgets, progress bars, sliders, tool tips</p></li>
<li><p>Complex widgets: shutter, toolbar, status bar, list view, list tree</p></li>
<li><p>Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About</p></li>
<li><p>The widgets are shown in frames:</p></li>
<li><p>frame, composite frame, main frame, transient frame, group frame</p></li>
<li><p>Arranged by layout managers:</p></li>
<li><p>horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout</p></li>
</ul>
<p>Using a combination of layout hints:</p>
<ul>
<li>left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets</li>
</ul>
<p>Event handling by signals/slots and messaging (as opposed to callbacks):</p>
<ul>
<li><p>in response to actions widgets send messages and emit signals</p></li>
<li><p>associated frames process these messages or the slot methods connected to the signals are executed</p></li>
</ul>
<h2 id="tvirtualx"><span class="header-section-number">25.3</span> TVirtualX</h2>
<p>The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class <strong><code>TVirtualX</code></strong>.
 Currently concrete implementations exist for X11 and Win32 (MacOS X is 
fully supported via Apple’s X11 implementation). Thanks to this single 
graphics interface, porting the ROOT GUI to a new platform requires only
 the implementation of <strong><code>TVirtualX</code></strong>.</p>
<p><img src="ROOTUsersGuide_files/02000201.jpg"></p>
<h2 id="a-simple-example"><span class="header-section-number">25.4</span> A Simple Example</h2>
<p>We will start with a simple example that builds a small application 
containing a canvas and two buttons: Draw and Exit. Its functionality 
will be very simple: every time you click on Draw button, the graphics 
of the function <code>sin(x)/x</code> will be drawn in randomly chosen 
interval in the canvas window, if you click on Exit - you close the 
application. This example shows the basic concepts for almost any 
GUI-application in ROOT and it is important to understand how it is 
constructed. The example program is written as a named script. See 
“Cling the C++ Interpreter”. Remember that the named script can be 
executed via</p>
<div class="sourceCode" id="cb1188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1188-1" title="1">root[] .x example.C</a></code></pre></div>
<p>only if the filename (without extension) and the function entry point are both the same.</p>
<p><img src="ROOTUsersGuide_files/02000202.jpg"></p>
<p>We need to say a few words about the parent-children relationship 
between the widgets before going through the real code. The widgets’ 
behaviors are based on this relationship. Every parent widget is 
responsible for where the children are and it ensures all properties and
 behavior for them. For example, if you want to hide several widgets, it
 will be enough to hide their parent widget. Later you can show the 
parent and the children will appear too. Writing your code you have to 
specify the parent-child relationship. Usually in a child constructor 
the address of the parent is passed as an argument. In general frames 
are parents of simple widgets. In this example you will see how we 
organize the parent-children relationship by using frame widgets in 
addition to the canvas window and button widgets.</p>
<p>Let’s now go through the code of the <code>example.C</code>.</p>
<p>The first lines include ROOT header files. The header file names are almost always as the class names (<strong><code>TApplication</code></strong>, <strong><code>TF1</code></strong>, <strong><code>TCanvas</code></strong>), but there are cases when similar classes are grouped together in one header file: all frames are declared in <code>TGFrame.h</code>, all buttons - in <code>TGButton.h</code>, etc. Our small example is based on an object of the class <code>MyMainFrame</code>.</p>
<div class="sourceCode" id="cb1189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1189-1" title="1"><span class="kw">new</span> MyMainFrame(gClient-&gt;GetRoot(),<span class="dv">200</span>,<span class="dv">200</span>);</a></code></pre></div>
<p>The first parameter <code>gClient-&gt;GetRoot()</code> makes the initial connection to the window server. It is a pointer to the root window of the screen, which is obtained from <strong><em><code>gClient</code></em></strong>. The next two parameters initialize the width and height of the application window in pixels. Let see what <code>MyMainFrame</code> is. The three arguments pass to the <strong><code>TGMainFrame</code></strong> constructor when we create the <code>fMain</code> object.</p>
<p>The first thing to note is the inclusion of the <code>RQ_OBJECT</code> macro in the class declaration of <code>MyMainFrame</code>.
 It is necessary to provide a standalone class signal/slot capability. 
The signal/slot communication mechanism is described in a separate 
chapter. See “Event Processing: Signals and Slots”.</p>
<div class="sourceCode" id="cb1190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1190-1" title="1"><span class="co">// example.C</span></a>
<a class="sourceLine" id="cb1190-2" title="2"></a>
<a class="sourceLine" id="cb1190-3" title="3"><span class="pp">#include </span><span class="im">&lt;TGClient.h&gt;</span></a>
<a class="sourceLine" id="cb1190-4" title="4"><span class="pp">#include </span><span class="im">&lt;TCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1190-5" title="5"><span class="pp">#include </span><span class="im">&lt;TF1.h&gt;</span></a>
<a class="sourceLine" id="cb1190-6" title="6"><span class="pp">#include </span><span class="im">&lt;TRandom.h&gt;</span></a>
<a class="sourceLine" id="cb1190-7" title="7"><span class="pp">#include </span><span class="im">&lt;TGButton.h&gt;</span></a>
<a class="sourceLine" id="cb1190-8" title="8"><span class="pp">#include </span><span class="im">&lt;TGFrame.h&gt;</span></a>
<a class="sourceLine" id="cb1190-9" title="9"><span class="pp">#include </span><span class="im">&lt;TRootEmbeddedCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1190-10" title="10"><span class="pp">#include </span><span class="im">&lt;RQ_OBJECT.h&gt;</span></a>
<a class="sourceLine" id="cb1190-11" title="11"></a>
<a class="sourceLine" id="cb1190-12" title="12"><span class="kw">class</span> MyMainFrame {</a>
<a class="sourceLine" id="cb1190-13" title="13">   RQ_OBJECT(<span class="st">"MyMainFrame"</span>)</a>
<a class="sourceLine" id="cb1190-14" title="14"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1190-15" title="15">   TGMainFrame         *fMain;</a>
<a class="sourceLine" id="cb1190-16" title="16">   TRootEmbeddedCanvas *fEcanvas;</a>
<a class="sourceLine" id="cb1190-17" title="17"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1190-18" title="18">   MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h);</a>
<a class="sourceLine" id="cb1190-19" title="19">   <span class="kw">virtual</span> ~MyMainFrame();</a>
<a class="sourceLine" id="cb1190-20" title="20">   <span class="dt">void</span> DoDraw();</a>
<a class="sourceLine" id="cb1190-21" title="21">};</a>
<a class="sourceLine" id="cb1190-22" title="22">MyMainFrame::MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h) {</a>
<a class="sourceLine" id="cb1190-23" title="23">   <span class="co">// Create a main frame</span></a>
<a class="sourceLine" id="cb1190-24" title="24">   fMain = <span class="kw">new</span> TGMainFrame(p,w,h);</a>
<a class="sourceLine" id="cb1190-25" title="25"></a>
<a class="sourceLine" id="cb1190-26" title="26">   <span class="co">// Create canvas widget</span></a>
<a class="sourceLine" id="cb1190-27" title="27">   fEcanvas = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="st">"Ecanvas"</span>,fMain,<span class="dv">200</span>,<span class="dv">200</span>);</a>
<a class="sourceLine" id="cb1190-28" title="28">   fMain-&gt;AddFrame(fEcanvas, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1190-29" title="29">                   kLHintsExpandY, <span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">1</span>));</a>
<a class="sourceLine" id="cb1190-30" title="30">   <span class="co">// Create a horizontal frame widget with buttons</span></a>
<a class="sourceLine" id="cb1190-31" title="31">   TGHorizontalFrame *hframe = <span class="kw">new</span> TGHorizontalFrame(fMain,<span class="dv">200</span>,<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb1190-32" title="32">   TGTextButton *draw = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Draw"</span>);</a>
<a class="sourceLine" id="cb1190-33" title="33">   draw-&gt;Connect(<span class="st">"Clicked()"</span>,<span class="st">"MyMainFrame"</span>,<span class="kw">this</span>,<span class="st">"DoDraw()"</span>);</a>
<a class="sourceLine" id="cb1190-34" title="34">   hframe-&gt;AddFrame(draw, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,</a>
<a class="sourceLine" id="cb1190-35" title="35">                                            <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a>
<a class="sourceLine" id="cb1190-36" title="36">   TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit"</span>,</a>
<a class="sourceLine" id="cb1190-37" title="37">                                <span class="st">"gApplication-&gt;Terminate(0)"</span>);</a>
<a class="sourceLine" id="cb1190-38" title="38">   hframe-&gt;AddFrame(exit, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,</a>
<a class="sourceLine" id="cb1190-39" title="39">                                            <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a>
<a class="sourceLine" id="cb1190-40" title="40">   fMain-&gt;AddFrame(hframe, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,</a>
<a class="sourceLine" id="cb1190-41" title="41">                                             <span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>));</a>
<a class="sourceLine" id="cb1190-42" title="42"></a>
<a class="sourceLine" id="cb1190-43" title="43">   <span class="co">// Set a name to the main frame</span></a>
<a class="sourceLine" id="cb1190-44" title="44">   fMain-&gt;SetWindowName(<span class="st">"Simple Example"</span>);</a>
<a class="sourceLine" id="cb1190-45" title="45"></a>
<a class="sourceLine" id="cb1190-46" title="46">   <span class="co">// Map all subwindows of main frame</span></a>
<a class="sourceLine" id="cb1190-47" title="47">   fMain-&gt;MapSubwindows();</a>
<a class="sourceLine" id="cb1190-48" title="48"></a>
<a class="sourceLine" id="cb1190-49" title="49">   <span class="co">// Initialize the layout algorithm</span></a>
<a class="sourceLine" id="cb1190-50" title="50">   fMain-&gt;Resize(fMain-&gt;GetDefaultSize());</a>
<a class="sourceLine" id="cb1190-51" title="51"></a>
<a class="sourceLine" id="cb1190-52" title="52">   <span class="co">// Map main frame</span></a>
<a class="sourceLine" id="cb1190-53" title="53">   fMain-&gt;MapWindow();</a>
<a class="sourceLine" id="cb1190-54" title="54">}</a>
<a class="sourceLine" id="cb1190-55" title="55"><span class="dt">void</span> MyMainFrame::DoDraw() {</a>
<a class="sourceLine" id="cb1190-56" title="56">   <span class="co">// Draws function graphics in randomly chosen interval</span></a>
<a class="sourceLine" id="cb1190-57" title="57">   TF1 *f1 = <span class="kw">new</span> TF1(<span class="st">"f1"</span>,<span class="st">"sin(x)/x"</span>,<span class="dv">0</span>,gRandom-&gt;Rndm()*<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1190-58" title="58">   f1-&gt;SetLineWidth(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb1190-59" title="59">   f1-&gt;Draw();</a>
<a class="sourceLine" id="cb1190-60" title="60">   TCanvas *fCanvas = fEcanvas-&gt;GetCanvas();</a>
<a class="sourceLine" id="cb1190-61" title="61">   fCanvas-&gt;cd();</a>
<a class="sourceLine" id="cb1190-62" title="62">   fCanvas-&gt;Update();</a>
<a class="sourceLine" id="cb1190-63" title="63">}</a>
<a class="sourceLine" id="cb1190-64" title="64">MyMainFrame::~MyMainFrame() {</a>
<a class="sourceLine" id="cb1190-65" title="65">   <span class="co">// Clean up used widgets: frames, buttons, layout hints</span></a>
<a class="sourceLine" id="cb1190-66" title="66">   fMain-&gt;Cleanup();</a>
<a class="sourceLine" id="cb1190-67" title="67">   <span class="kw">delete</span> fMain;</a>
<a class="sourceLine" id="cb1190-68" title="68">}</a>
<a class="sourceLine" id="cb1190-69" title="69"><span class="dt">void</span> example() {</a>
<a class="sourceLine" id="cb1190-70" title="70">   <span class="co">// Popup the GUI...</span></a>
<a class="sourceLine" id="cb1190-71" title="71">   <span class="kw">new</span> MyMainFrame(gClient-&gt;GetRoot(),<span class="dv">200</span>,<span class="dv">200</span>);</a>
<a class="sourceLine" id="cb1190-72" title="72">}</a></code></pre></div>
<p>The <strong><code>TGMainFrame</code></strong>class defines a top level window that interacts with the system window manager. Its method <code>CloseWindow()</code>
 is invoked when Alt+F4 are pressed or a window manager close/exit 
command is used. To terminate the application when this happens you need
 to override the <code>CloseWindow()</code> method and call <code>gApplication-&gt;Terminate(0)</code>.</p>
<p>The main frame can be considered as a container where all widgets of 
the application are organized with respect to their parent-child 
relationship. After the main frame we create <code>fEcanvas</code> - an object of class <strong><code>TRootEmbeddedCanvas</code></strong>.
 It is a quite complex widget and we will explain it in detail later. 
For the moment keep in mind only its main purpose - to create a <strong><code>TCanvas</code></strong> - the ROOT basic whiteboard for drawing and editing different graphical objects.</p>
<div class="sourceCode" id="cb1191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1191-1" title="1">fEcanvas = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="st">"Ecanvas"</span>,fMain,<span class="dv">200</span>,<span class="dv">200</span>);</a></code></pre></div>
<p>In the <strong><code>TRootEmbeddedCanvas</code></strong> constructor we pass the address of the main frame widget <code>fMain</code> as a second parameter. This pass is important because it makes <code>fMain</code> the parent of the canvas window. The first parameter <code>Ecanvas</code> is the name of the <strong><code>TCanvas</code></strong>, the last two parameters give the width and height of canvas window in pixels. Next step is to add <code>fEcanvas</code> to the parent frame defining its appearance inside the parent window. We use the method <code>AddFrame():</code></p>
<div class="sourceCode" id="cb1192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1192-1" title="1">fMain-&gt;AddFrame(fEcanvas,<span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1192-2" title="2">                kLHintsExpandY, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">1</span>));</a></code></pre></div>
<p>It adds the <code>fEcanvas</code> into the list of children widgets of the main frame <code>fMain</code>. The specification of how it should be placed inside the parent frame is made by the <strong><code>TGLayoutHints</code></strong> object. Setting its first parameter to <code>kLHintsExpandX|kLHintsExpandY</code>we
 define the canvas window as expanded on x and y in the frame. The next 
four parameters define amounts of padding in left, right, top and bottom
 in pixels. This means that the canvas window will be expanded when the 
parent window expands, but it will keep around a frame of 10 pixels on 
left, right, top and 1 pixel on bottom.</p>
<p><img src="ROOTUsersGuide_files/02000203.jpg"></p>
<p>The laying out is always made with respect to the parent-children 
relationship. There is a special chapter presenting the different layout
 managers, but we will quickly introduce the concept here. The layout 
process will apply not to the embedded canvas window but to its parent -
 the main frame. A popular layout manager and the one used in this case 
is the vertical layout manager which arranges its widgets vertically in a
 column.</p>
<p>The next widget we create as a child of the main frame is the horizontal frame <code>hframe</code>:</p>
<div class="sourceCode" id="cb1193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1193-1" title="1">TGHorizontalFrame *hframe=<span class="kw">new</span> TGHorizontalFrame(fMain,<span class="dv">200</span>,<span class="dv">40</span>);</a></code></pre></div>
<p>The first parameter of its constructor is again the address of its parent, <code>fMain</code>. The next ones define the frame width and height in pixels. The name of the class <strong><code>TGHorizontalFrame</code></strong>
 gives a hint that a horizontal layout will apply on its children 
widgets. The Draw and Exit buttons will be laid out horizontally. Here 
are their constructors:</p>
<div class="sourceCode" id="cb1194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1194-1" title="1">TGTextButton *draw = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Draw"</span>);</a>
<a class="sourceLine" id="cb1194-2" title="2">hframe -&gt;AddFrame(draw, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a>
<a class="sourceLine" id="cb1194-3" title="3">TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit"</span>,</a>
<a class="sourceLine" id="cb1194-4" title="4">                                     <span class="st">"gApplication-&gt;Terminate(0)"</span>);</a>
<a class="sourceLine" id="cb1194-5" title="5">hframe -&gt;AddFrame(exit,<span class="kw">new</span> TGLayoutHints(kLHintsCenterX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a></code></pre></div>
<p>They are created as objects of the <strong><code>TGTextButton</code></strong>
 class that represent the command buttons with a text label. When you 
click on a command button it performs the action shown on its label. 
These buttons are well known as “push buttons” or just “buttons”. The 
parent address <code>hframe</code> is passed as first parameter. The 
second one defines the button label and normally indicates the action to
 be taken when the button is clicked. It is possible to define a hot key
 for the button at that point using the hot string for its label. A hot 
string is a string with a “hot” character underlined. This character we 
call the button hot key. It shows the assigned keyboard mnemonic for the
 button choice. Following our example, this means that you can use <code>Alt+D</code> to click on Draw button and <code>Alt+E</code>
 to click on Exit. There is a possibility to specify a command string as
 third parameter of the button constructor. We use it to assign the 
command <code>gApplication-&gt;Terminate(0)</code>. The application will be terminated when you click on the Exit button.</p>
<p>We call again <code>AddFrame()</code> to add the buttons to their 
parent widget giving layout hints for each of them. This time we would 
like to have centered buttons with an amount of 5 pixels on the left, 5 
on the right, 3 on the top and 4 on the bottom. You can feel already 
that the same steps are repeated three times: to create a new widget 
with passing a parent address as a parameter, to define layout hints for
 it and to add it in the parent list. The next line is something new:</p>
<div class="sourceCode" id="cb1195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1195-1" title="1">draw-&gt;Connect(<span class="st">"Clicked()"</span>,<span class="st">"MyMainFrame"</span>,<span class="kw">this</span>,<span class="st">"DoDraw()"</span>);</a></code></pre></div>
<p>Here we connect a signal to a slot. Whenever the draw button is 
clicked, it emits a signal that something has happened (it is clicked) 
to whom might be interesting in the outside world. The widget does not 
know who will use this information. On the other side of the program 
world there is some code which should be executed when the button is 
clicked. This code is called a slot. Think about slots as normal C++ 
functions or class methods. The line above specifies that the slot <code>MyMainFrame::DoDraw()</code> will be executed when the draw button is clicked. Our slot draws the graphics of <code>sin(x)/x</code>
 in randomly chosen interval every time the draw button sends a signal 
“I am clicked”. The signal/slot communication mechanism originally 
featured in Qt by TrollTech(see <a href="http://doc.trolltech.com/3.1/signalsandslots.html" class="uri">http://doc.trolltech.com/3.1/signalsandslots.html</a>).
 ROOT supports its own version of signals/slots. We will return to that 
point in details later. We specified all child widgets of the horizontal
 frame (the Draw and Exit buttons in our case). Next, we need to add 
their parent frame to the main frame:</p>
<div class="sourceCode" id="cb1196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1196-1" title="1">fMain-&gt;AddFrame(hframe,<span class="kw">new</span> TGLayoutHints(kLHintsCenterX,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>));</a></code></pre></div>
<p>The last thing to do is to set the main window title and to make all 
widgets visible. Commonly in all systems windows are assigned by name to
 be identified by users. This name is displayed in the application’s 
title bar and can be set by:</p>
<div class="sourceCode" id="cb1197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1197-1" title="1">fMain-&gt;SetWindowName(<span class="st">"Simple Example"</span>);</a></code></pre></div>
<p>The next lines make the widgets visible. The first one maps all child
 frames of the top-level frame; the last one - the main frame itself, 
i.e.&nbsp;makes it appear on the screen.</p>
<div class="sourceCode" id="cb1198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1198-1" title="1">fMain-&gt;MapSubwindows();</a>
<a class="sourceLine" id="cb1198-2" title="2">fMain-&gt;Resize(fMain-&gt;GetDefaultSize());</a>
<a class="sourceLine" id="cb1198-3" title="3">fMain-&gt;MapWindow();</a></code></pre></div>
<p>The line in between has an important mission - to execute all layout 
specifications for the widgets before the top-level window itself is 
shown on the screen. We can run the named script via the Cling 
interpreter with the command:</p>
<div class="sourceCode" id="cb1199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1199-1" title="1">root[].x example.C</a></code></pre></div>
<p>The event processing starts. If you change the state of a widget, it 
emits a signal and the corresponding slot is executed ensuring the 
functionality we want for this small example.</p>
<p>The steps we passed can be generalized as follows:</p>
<ul>
<li><p>Opening of the connection to the system</p></li>
<li><p>Definition of main frame (top level window)</p></li>
<li><p>Creation of widgets as children of the top-level frame; assign them desired properties following the steps:</p></li>
<li><p>Create a new widget passing its parent in the constructor</p></li>
<li><p>Connect widget’s signals with desired slots to ensure desired functionality</p></li>
<li><p>Define widget’s layout and add it to the parent list of children</p></li>
<li><p>Set main window attributes</p></li>
<li><p>Map all sub windows</p></li>
<li><p>Initialize the layout algorithm via <code>Resize(GetDefaultSize())</code> method</p></li>
<li><p>Map the main frame</p></li>
<li><p>Execution of the even-processing loop</p></li>
</ul>
<h3 id="a-standalone-version"><span class="header-section-number">25.4.1</span> A Standalone Version</h3>
<p>As usual a standalone program in C++ has to contain a main() function
 - the starting point for the application execution. In this case it is 
better to separate the program code creating a program header file 
example2a.h with the <code>MyMainFrame</code> class declaration and <code>example2a.cxx</code>-
 with the class methods implementation. To run our simple example as a 
standalone application we need to create in addition an object of class <strong><code>TApplication</code></strong>.
 It will make a correct initialization of the dictionaries if it is not 
yet done. It will be responsible for holding everything together and to 
handle all events in the application. Its environment provides an 
interface to the ROOT graphics system and by calling the <code>Run()</code>
 method the event loop starts and the application program is waiting for
 the user action. The application exits only if the top level window is 
not closed. Two header files are used in addition: <code>TApplication.h</code> - for the class <strong><code>TApplication</code></strong> and <code>TGClient.h</code> that is used to make initial connection to the graphics system. The class <strong><code>TApplication</code></strong> must be instantiated only once in any given application. The original list of argument options can be retrieved via the <code>Argc()</code> and <code>Argv()</code> methods.</p>
<p>Note: to have signals/slots working we need to create a dictionary for the class <code>MyMainFrame</code>, i.e.&nbsp;we create the file <code>ex2aLinkDef.h</code> containing the line:</p>
<div class="sourceCode" id="cb1200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1200-1" title="1"><span class="pp">#pragma link C++ class MyMainFrame;</span></a></code></pre></div>
<p>We compile the example:</p>
<div class="sourceCode" id="cb1201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1201-1" title="1">rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h</a>
<a class="sourceLine" id="cb1201-2" title="2">g++ -o example2a example2a.cxx ex2aDict.cxx <span class="er">`</span>root-config --cflags --glibs<span class="er">`</span></a></code></pre></div>
<p><code>example2a.h</code></p>
<div class="sourceCode" id="cb1202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1202-1" title="1"><span class="pp">#include </span><span class="im">&lt;TQObject.h&gt;</span></a>
<a class="sourceLine" id="cb1202-2" title="2"><span class="pp">#include </span><span class="im">&lt;RQ_OBJECT.h&gt;</span></a>
<a class="sourceLine" id="cb1202-3" title="3"></a>
<a class="sourceLine" id="cb1202-4" title="4"><span class="kw">class</span> TGWindow;</a>
<a class="sourceLine" id="cb1202-5" title="5"><span class="kw">class</span> TGMainFrame;</a>
<a class="sourceLine" id="cb1202-6" title="6"><span class="kw">class</span> TRootEmbeddedCanvas;</a>
<a class="sourceLine" id="cb1202-7" title="7"></a>
<a class="sourceLine" id="cb1202-8" title="8"><span class="kw">class</span> MyMainFrame {</a>
<a class="sourceLine" id="cb1202-9" title="9">   RQ_OBJECT(<span class="st">"MyMainFrame"</span>)</a>
<a class="sourceLine" id="cb1202-10" title="10"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1202-11" title="11">   TGMainFrame         *fMain;</a>
<a class="sourceLine" id="cb1202-12" title="12">   TRootEmbeddedCanvas *fEcanvas;</a>
<a class="sourceLine" id="cb1202-13" title="13"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1202-14" title="14">   MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h);</a>
<a class="sourceLine" id="cb1202-15" title="15">   <span class="kw">virtual</span> ~MyMainFrame();</a>
<a class="sourceLine" id="cb1202-16" title="16">   <span class="dt">void</span> DoDraw();</a>
<a class="sourceLine" id="cb1202-17" title="17">};</a></code></pre></div>
<p><code>example2a.cxx</code></p>
<div class="sourceCode" id="cb1203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1203-1" title="1"><span class="pp">#include </span><span class="im">&lt;TApplication.h&gt;</span></a>
<a class="sourceLine" id="cb1203-2" title="2"><span class="pp">#include </span><span class="im">&lt;TGClient.h&gt;</span></a>
<a class="sourceLine" id="cb1203-3" title="3"><span class="pp">#include </span><span class="im">&lt;TCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1203-4" title="4"><span class="pp">#include </span><span class="im">&lt;TF1.h&gt;</span></a>
<a class="sourceLine" id="cb1203-5" title="5"><span class="pp">#include </span><span class="im">&lt;TRandom.h&gt;</span></a>
<a class="sourceLine" id="cb1203-6" title="6"><span class="pp">#include </span><span class="im">&lt;TGButton.h&gt;</span></a>
<a class="sourceLine" id="cb1203-7" title="7"><span class="pp">#include </span><span class="im">&lt;TRootEmbeddedCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1203-8" title="8"><span class="pp">#include </span><span class="im">"example2a.h"</span></a>
<a class="sourceLine" id="cb1203-9" title="9"></a>
<a class="sourceLine" id="cb1203-10" title="10">MyMainFrame::MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h) {...}</a>
<a class="sourceLine" id="cb1203-11" title="11">MyMainFrame::~MyMainFrame() { ... }</a>
<a class="sourceLine" id="cb1203-12" title="12"><span class="dt">void</span> MyMainFrame::DoDraw() { ... }</a>
<a class="sourceLine" id="cb1203-13" title="13"><span class="dt">void</span> example() { ... }</a>
<a class="sourceLine" id="cb1203-14" title="14"></a>
<a class="sourceLine" id="cb1203-15" title="15"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</a>
<a class="sourceLine" id="cb1203-16" title="16">   TApplication theApp(<span class="st">"App"</span>,&amp;argc,argv);</a>
<a class="sourceLine" id="cb1203-17" title="17">   example();</a>
<a class="sourceLine" id="cb1203-18" title="18">   theApp.Run();</a>
<a class="sourceLine" id="cb1203-19" title="19">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1203-20" title="20">}</a></code></pre></div>
<p>The class <code>MyMainFrame</code> could derive from <strong><code>TGMainFrame</code></strong>. In that case the <code>RQ_OBJECT</code> macro is not needed anymore, since the functionality it provides is obtained now via inheritance from <strong><code>TGMainFrame</code></strong>. This will reflect in the <code>MyMainFrame</code> class declaration and in the code of the <code>MyMainFrame::MyMainFrame</code> constructor as follows:</p>
<p><code>example2b.h</code></p>
<div class="sourceCode" id="cb1204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1204-1" title="1"><span class="pp">#include </span><span class="im">&lt;TGFrame.h&gt;</span></a>
<a class="sourceLine" id="cb1204-2" title="2"><span class="kw">class</span> MyMainFrame : <span class="kw">public</span> TGMainFrame {</a>
<a class="sourceLine" id="cb1204-3" title="3"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1204-4" title="4">   TRootEmbeddedCanvas *fEcanvas;</a>
<a class="sourceLine" id="cb1204-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1204-6" title="6">   MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h);</a>
<a class="sourceLine" id="cb1204-7" title="7">   <span class="kw">virtual</span> ~MyMainFrame() {  ...  }</a>
<a class="sourceLine" id="cb1204-8" title="8">   <span class="dt">void</span> DoDraw(){  ...  }</a>
<a class="sourceLine" id="cb1204-9" title="9">   ClassDef(MyMainFrame,<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1204-10" title="10">};</a></code></pre></div>
<p><code>example2b.cxx</code></p>
<div class="sourceCode" id="cb1205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1205-1" title="1"><span class="pp">#include </span><span class="im">&lt;TApplication.h&gt;</span></a>
<a class="sourceLine" id="cb1205-2" title="2"><span class="pp">#include </span><span class="im">&lt;TGClient.h&gt;</span></a>
<a class="sourceLine" id="cb1205-3" title="3"><span class="pp">#include </span><span class="im">&lt;TCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1205-4" title="4"><span class="pp">#include </span><span class="im">&lt;TF1.h&gt;</span></a>
<a class="sourceLine" id="cb1205-5" title="5"><span class="pp">#include </span><span class="im">&lt;TRandom.h&gt;</span></a>
<a class="sourceLine" id="cb1205-6" title="6"><span class="pp">#include </span><span class="im">&lt;TGButton.h&gt;</span></a>
<a class="sourceLine" id="cb1205-7" title="7"><span class="pp">#include </span><span class="im">&lt;TRootEmbeddedCanvas.h&gt;</span></a>
<a class="sourceLine" id="cb1205-8" title="8"><span class="pp">#include </span><span class="im">"example2b.h"</span></a>
<a class="sourceLine" id="cb1205-9" title="9"></a>
<a class="sourceLine" id="cb1205-10" title="10">MyMainFrame::MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h)</a>
<a class="sourceLine" id="cb1205-11" title="11">   : TGMainFrame(p,w,h) {</a>
<a class="sourceLine" id="cb1205-12" title="12"></a>
<a class="sourceLine" id="cb1205-13" title="13">   <span class="co">// Creates widgets of the example</span></a>
<a class="sourceLine" id="cb1205-14" title="14">   fEcanvas = <span class="kw">new</span> TRootEmbeddedCanvas (<span class="st">"Ecanvas"</span>,<span class="kw">this</span>,<span class="dv">200</span>,<span class="dv">200</span>);</a>
<a class="sourceLine" id="cb1205-15" title="15">   AddFrame(fEcanvas, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1205-16" title="16">                                    kLHintsExpandY, <span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">1</span>));</a>
<a class="sourceLine" id="cb1205-17" title="17">   TGHorizontalFrame *hframe=<span class="kw">new</span> TGHorizontalFrame(<span class="kw">this</span>, <span class="dv">200</span>,<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb1205-18" title="18">   TGTextButton *draw = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Draw"</span>);</a>
<a class="sourceLine" id="cb1205-19" title="19">   draw-&gt;Connect(<span class="st">"Clicked()"</span>,<span class="st">"MyMainFrame"</span>,<span class="kw">this</span>,<span class="st">"DoDraw()"</span>);</a>
<a class="sourceLine" id="cb1205-20" title="20">   hframe-&gt;AddFrame(draw, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,</a>
<a class="sourceLine" id="cb1205-21" title="21">                                            <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a>
<a class="sourceLine" id="cb1205-22" title="22">   TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit "</span>,</a>
<a class="sourceLine" id="cb1205-23" title="23">                                <span class="st">"gApplication-&gt;Terminate()"</span>);</a>
<a class="sourceLine" id="cb1205-24" title="24">   hframe-&gt;AddFrame(exit, <span class="kw">new</span> TGLayoutHints(kLHintsCenterX,</a>
<a class="sourceLine" id="cb1205-25" title="25">                                            <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>));</a>
<a class="sourceLine" id="cb1205-26" title="26">   AddFrame(hframe,<span class="kw">new</span> TGLayoutHints(kLHintsCenterX,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>));</a>
<a class="sourceLine" id="cb1205-27" title="27"></a>
<a class="sourceLine" id="cb1205-28" title="28">   <span class="co">// Sets window name and shows the main frame</span></a>
<a class="sourceLine" id="cb1205-29" title="29">   SetWindowName(<span class="st">"Simple Example"</span>);</a>
<a class="sourceLine" id="cb1205-30" title="30">   MapSubwindows();</a>
<a class="sourceLine" id="cb1205-31" title="31">   Resize(GetDefaultSize());</a>
<a class="sourceLine" id="cb1205-32" title="32">   MapWindow();</a>
<a class="sourceLine" id="cb1205-33" title="33">}</a></code></pre></div>
<h2 id="widgets-overview"><span class="header-section-number">25.5</span> Widgets Overview</h2>
<p>The word widget is a contraction of windows and gadget. Almost all 
GUI elements are widgets. A button is a widget, a menu item is a widget,
 a scrollbar is a widget, and a complete dialog box is a widget too. 
Some widgets may have sub widgets. For example, a dialog box can contain
 buttons, text fields, a combo-box, etc.</p>
<p>On the screen widgets look like rectangular areas with special 
behaviors. In terms of the object-oriented programming we can define a 
widget in ROOT as an object of a class deriving from <strong><code>TGObject</code></strong>.</p>
<p>This section presents all currently supported widgets in ROOT and 
their most useful methods. All of them can be considered as building 
blocks for an application, and most of them can be found in dialogs. 
Provided snippets of the code will give you practical guidelines where 
and how to use certain widgets. The macro <code>$ROOTSYS/tutorials/gui/guitest.C</code> contains the complete source code.</p>
<figure>
<img src="ROOTUsersGuide_files/02000204.jpg" alt="Widgets created by ROOT GUI classes"><figcaption>Widgets created by ROOT GUI classes</figcaption>
</figure>
<p>Any custom widget can be created by sub classing existing widgets. To
 achieve a better understanding of the widgets’ properties they are 
separated by their type and their inheritance. As all of them inherit 
from <strong><code>TGObject</code></strong> and most from <strong><code>TGWidget</code></strong>, these base classes are described first.</p>
<h3 id="tgobject"><span class="header-section-number">25.5.1</span> TGObject</h3>
<p><strong><code>TGObject</code></strong> is the base class for all ROOT GUI classes. It inherits from <strong><code>TObject</code></strong>.
 The two data members of this class contain important information about 
X11/Win32 window identifier and the connection to the host’s graphics 
system. Every GUI element, which derives from <strong><code>TGObject</code></strong> has access to the <strong><code>TGClient</code></strong> via the data member <code>fClient</code> of <strong><code>TGObject. TGClient</code></strong> creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.</p>
<h3 id="tgwidget"><span class="header-section-number">25.5.2</span> TGWidget</h3>
<p>The widgets base class <strong><code>TGWidget</code></strong> is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: <strong><code>TGButton</code></strong>, <strong><code>TGComboBox</code></strong>, <strong><code>TGTab</code></strong>, <strong><code>TGColorPalette</code></strong>, <strong><code>TGColorPick</code></strong>, <strong><code>TGDoubleSlider</code></strong>, <strong><code>TGListTree</code></strong>, <strong><code>TGNumberEntry</code></strong>, <strong><code>TGScrollBar</code></strong>, <strong><code>TGShutterItem</code></strong>, <strong><code>TGTextEntry</code></strong>, <strong><code>TGSlider</code></strong>, <strong><code>TGListBox</code></strong>, <strong><code>TGView.</code></strong></p>
<p>This class has four data members keeping information about the widget
 id - important for event processing, the window which handles the 
widget’s events, the widget status flags and the assigned command (if 
there is any). The general properties of <strong><code>TGWidget</code></strong> are specified by <code>SetFlags(Int_t flags)</code> and <code>ClearFlags(Int_t flags)</code> methods. The status flags are: <code>kWidgetWantFocus</code>, <code>kWidgetHasFocus</code>, and <code>kWidgetIsEnabled</code>. The method <code>Associate(const TGWindow* w)</code> - sets the window which handles the widget events. <code>SetCommand(const char* command)</code> - sets the command to be executed. The command string can be gathering via <code>GetCommand()</code> method. For example, the third parameter in <strong><code>TGTextButton</code></strong> constructor can be omitted and set later in your program, i.e.&nbsp;instead of:</p>
<div class="sourceCode" id="cb1206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1206-1" title="1">TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit"</span>,</a>
<a class="sourceLine" id="cb1206-2" title="2">                                     <span class="st">"gApplication-&gt;Terminate()"</span>);</a></code></pre></div>
<p>You will have the following the two lines:</p>
<div class="sourceCode" id="cb1207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1207-1" title="1">TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit"</span>);</a>
<a class="sourceLine" id="cb1207-2" title="2">exit-&gt;SetCommand(<span class="st">"gApplication-&gt;Terminate()"</span>);</a></code></pre></div>
<p>The method <code>IsEnabled()</code> - returns <code>kTRUE</code> if the widget has flag <code>kWidgetIsEnabled</code>
 and it accepts user events. This method is very important for creating a
 good user interface because it allows you to disable or enable a widget
 depending on the situation of your application. As a standard all 
disabled widgets are displayed “grayed out”. <code>HasFocus()</code> - returns <code>kTRUE</code> if the widget has the input focus (i.e.&nbsp;flag <code>kWidgetHasFocus</code> is set). Remember that only one item in a complex widget as a dialog can have the value of <code>HasFocus()</code> sets as true. <code>WantFocus()</code> - returns <code>kTRUE</code> if the flag <code>kWidgetWantFocus</code> is set.</p>
<h3 id="tgwindow"><span class="header-section-number">25.5.3</span> TGWindow</h3>
<p><strong><code>TGWindow</code></strong> is a ROOT GUI window base class. It inherits from <strong><code>TGObject</code></strong> and <strong><code>TGFrame</code></strong>
 derives from it. The application does not use it directly. It creates 
and registers a new window within the system. This window has common 
characteristics: existing parent, location, size in height and width (it
 has a default minimum size 1, 1 under which it cannot shrink), border 
with particular view, state, specific attributes. If there are no 
specified arguments their values will be taken from the parent. It 
receives events from the window system and can paint a representation of
 itself on the screen.</p>
<p><img src="ROOTUsersGuide_files/02000205.jpg"></p>
<h3 id="frames"><span class="header-section-number">25.5.4</span> Frames</h3>
<p>Most of the frame classes are mainly created for arranging widgets in a window. The class <strong><code>TGFrame</code></strong> is a subclass of <strong><code>TGWindow</code></strong> providing additional window characteristics and overriding some methods of <strong><code>TGWindow</code></strong>.
 It is a base class for the simple widgets as buttons, labels, etc. Its 
only purpose is to draw a frame around widgets that do not have a frame 
of their own. The main groups of <strong><code>TGFrame</code></strong> member functions are:</p>
<ul>
<li><p>Window’s functions: <code>DoRedraw()</code>, <code>DeleteWindow()</code>, <code>Activate()</code>, etc.</p></li>
<li><p>Geometry functions: <code>Move()</code>, <code>Resize()</code>, <code>SetSize()</code>, etc.</p></li>
<li><p>Graphics handlers: <code>ChangeBackground()</code>, <code>ChangeOptions()</code>, etc.</p></li>
<li><p>Mouse and keyboard functions: <code>HandleButton()</code>, <code>HandleFocusChange()</code>, <code>HandleKey()</code>, <code>HandleMotion()</code>, etc.</p></li>
<li><p>Event handlers: <code>HandleEvent()</code>, <code>ProcessEvent()</code>, <code>GetSender()</code>, <code>SendMessage()</code>,<code>ProcessMessage()</code>, <code>GetLastClick()</code>, etc.</p></li>
</ul>
<figure>
<img src="ROOTUsersGuide_files/02000206.jpg" alt="The GUI classes hierarchy"><figcaption>The GUI classes hierarchy</figcaption>
</figure>
<p>Ones of <strong><code>TGFrame</code></strong> member functions provide direct functionality; others - will be overridden by <strong><code>TGFrame</code></strong> subclasses to ensure particular widget’s functionality. There are two constructors provided in <strong><code>TGFrame</code></strong> class. One creates a frame using an externally created window:</p>
<div class="sourceCode" id="cb1208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1208-1" title="1">TGFrame(TGClient *c,<span class="dt">Window_t</span> id,<span class="at">const</span> TGWindow *parent = <span class="dv">0</span>);</a></code></pre></div>
<p>For example, it can register the root window (called by <strong><code>TGClient</code></strong>), or a window created via <strong><code>TVirtualX::InitWindow()</code></strong> (window id is obtained by <code>TVirtualX::GetWindowID()</code> method). The other <strong><code>TGFrame</code></strong> constructor is:</p>
<div class="sourceCode" id="cb1209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1209-1" title="1">TGFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h,<span class="dt">UInt_t</span> options=<span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1209-2" title="2"><span class="dt">ULong_t</span> back = GetDefaultBackground());</a></code></pre></div>
<p>The options parameter is the bitwise OR between defined frame types. Here is a short description of these types:</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<tbody>
<tr class="odd">
<td>Frame Type</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>kChildFrame</code></td>
<td>a frame embedded in a parent</td>
</tr>
<tr class="odd">
<td><code>kMainFrame</code></td>
<td>a main frame interacting with the system Window Manager</td>
</tr>
<tr class="even">
<td><code>kTransientFrame</code></td>
<td>a top level dialog’s frame</td>
</tr>
<tr class="odd">
<td><code>kVerticalFrame</code></td>
<td>a frame that layouts its children in a column</td>
</tr>
<tr class="even">
<td><code>kHorizontalFrame</code></td>
<td>a frame that layouts its children in a row</td>
</tr>
<tr class="odd">
<td><code>kSunkenFrame</code></td>
<td>a frame with a sunken board appearance</td>
</tr>
<tr class="even">
<td><code>kRaisedFrame</code></td>
<td>a frame with a raised board appearance</td>
</tr>
<tr class="odd">
<td><code>kFitWidth</code></td>
<td>a frame with dynamically scaled width</td>
</tr>
<tr class="even">
<td><code>kFitHeight</code></td>
<td>a frame with dynamically scaled height</td>
</tr>
<tr class="odd">
<td><code>kFixedWidth</code></td>
<td>a frame with fixed width</td>
</tr>
<tr class="even">
<td><code>kFixedHeight</code></td>
<td>a frame with fixed height</td>
</tr>
<tr class="odd">
<td><code>kFixedSize</code></td>
<td><p>= <code>kFixedWidth</code> | <code>kFixedHeight</code></p>
<p>a frame with fixed width and height</p></td>
</tr>
<tr class="even">
<td><code>kDoubleBorder</code></td>
<td>a frame having a double line border</td>
</tr>
<tr class="odd">
<td><code>kOwnBackground</code></td>
<td>a frame having own background</td>
</tr>
<tr class="even">
<td><code>kTempFrame</code></td>
<td>a temporary frame shown in certain circumstances; for example, it is used for creation of tool tip widget</td>
</tr>
</tbody>
</table>
<p>The method <code>ChangeOpton(UInt_t options)</code> allows you to change frame options. Next example shows you how to change <code>kVerticalFrame</code> option to <code>kHorizontalFrame</code>:</p>
<div class="sourceCode" id="cb1210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1210-1" title="1">frame-&gt;ChangeOptions((frame-&gt;GetOptions()&amp; ~kVerticalFrame) |</a>
<a class="sourceLine" id="cb1210-2" title="2">                     kHorizontalFrame);</a></code></pre></div>
<p>The class <strong><code>TGCompositeFrame</code></strong> is the base class of all composite widgets as a menu bar, a list box, a combo box, etc. It subclasses <strong><code>TGFrame</code></strong>
 and has in addition a layout manager and a list of child 
frames/widgets. There are two steps to do the design using a composite 
frame widget. First you put all widgets you need within this frame and 
assign them desired properties using <code>AddFrame(),</code> then you lay them out by the <code>Layout()</code> method according to the assigned layout manager. The method <code>AddFrame()</code> creates an instance of <strong><code>TGFrameElement</code></strong>
 class for every child widget of a composite frame. This class has three
 public data members: the child pointer, its layout hints, and a status 
variable showing if the child is visible or hidden. If no hints are 
specified, the default layout hints are used. Because the layout is very
 important part of any design we include a special section about layout 
management and layout hints.</p>
<p>You can set a layout manager for the composite frame via:</p>
<div class="sourceCode" id="cb1211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1211-1" title="1">compFrame-&gt;SetLayoutManager(TGLayoutManager *l);</a></code></pre></div>
<p>The child widgets cannot be added to different composite frames.</p>
<p>Any child frame can be removed from the parent list by:</p>
<div class="sourceCode" id="cb1212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1212-1" title="1">compFrame-&gt;RemoveFrame(TGFrame *f);</a></code></pre></div>
<p>You can hide or show a child frame of a composite frame using the methods: <code>HideFrame(TGFrame *f)</code> or <code>ShowFrame(TGFrame *f).</code> You should call, for example <code>HideFrame(TGFrame *f),</code> only after the frames have been laid out and the sub windows of the composite frame have been mapped via method <code>MapSubwindows(),</code> i.e.</p>
<div class="sourceCode" id="cb1213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1213-1" title="1">frame-&gt;AddFrame(hFrame1,fLayout1);</a>
<a class="sourceLine" id="cb1213-2" title="2">frame-&gt;AddFrame(hFrame2,fLayout2);</a>
<a class="sourceLine" id="cb1213-3" title="3">frame-&gt;Resize(frame-&gt;GetDefaultSize()); <span class="co">// lays out frames</span></a>
<a class="sourceLine" id="cb1213-4" title="4">frame-&gt;MapSubwindows();                 <span class="co">// maps subwindows</span></a>
<a class="sourceLine" id="cb1213-5" title="5">frame-&gt;HideFrame(hFrame2);              <span class="co">// hides frame hFrame2</span></a>
<a class="sourceLine" id="cb1213-6" title="6">frame-&gt;MapWindow();                     <span class="co">// maps main frame</span></a></code></pre></div>
<p>The state information about a child frame can be obtained from the methods <code>GetState(TGframe *f)</code>, <code>IsArranged(TGFrame *f)</code>, and <code>IsVisible(TGFrame *f)</code>.</p>
<p>The method <code>Cleanup()</code> deletes all objects of the composite frame added via <code>AddFrame()</code>. All <strong><code>TGFrameElement</code></strong> objects (frames and layout hints) must be unique, i.e.&nbsp;cannot be shared.</p>
<p>We already mentioned that <strong><code>TGMainFrame</code></strong> 
class defines top level windows interacting with the system window 
manager. It handles applications with a menu bar, toolbar, text entry 
fields and other widgets surrounding a central area (e.g.&nbsp;a canvas 
widget). It lays out a set of related widgets and provides the typical 
application main window behavior. As you can see from the Figure above, 
it inherits from <strong><code>TGCompositeFrame</code></strong> and is inherited by <strong><code>TGTransientFrame</code></strong> and several ROOT interface classes: <strong><code>TViewerX3D</code></strong>,<strong><code>TRootBrowser</code></strong>, <strong><code>TRootCanvas</code></strong>, <strong><code>TRootControlBar</code></strong>, <strong><code>TTreeViewer.</code></strong></p>
<p>To fix the size of a top level window you have to use the method <code>TGMainFrame::SetWMSize().</code> This call tells the Window Manager that it should not resize the window. The option <code>kFixedSize</code> works only for embedded frames like <strong><code>TGCompositeFrame</code></strong> and derived classes (in combination with layout hints).</p>
<p>The <strong><code>TGVerticalFrame</code></strong> and <strong><code>TGHorizontalFrame</code></strong>
 are composite frames that lay out their child frames in vertical or 
horizontal way in the same order as they were added and according to 
their hints preferences.</p>
<p>The <strong><code>TGTransientFrame</code></strong> class defines 
transient windows that typically are used for dialogs. They extend and 
complete an interaction within a limited context. Always transient 
frames are displayed from another window or another dialog. They may 
appear because of a command button being activated or a menu item being 
selected. They may also present automatically when an additional input 
and the user attention are required by a certain condition.</p>
<p>The <strong><code>TGGroupFrame</code></strong> class presents a very 
convenient frame which surrounds visually a group of logically connected
 widgets: radio buttons, related check boxes, two or more functionally 
related controls.</p>
<p><img src="ROOTUsersGuide_files/02000207.jpg"></p>
<p>It is a composite frame with a border and a title. The title explains
 the purpose of the group and should be a noun or noun phrase. Here is 
an example taken from <code>guitest.C</code>:</p>
<div class="sourceCode" id="cb1214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1214-1" title="1">groupFrame = <span class="kw">new</span> TGGroupFrame(tf,<span class="st">"Options"</span>,kVerticalFrame);</a>
<a class="sourceLine" id="cb1214-2" title="2">groupFrame-&gt;SetTitlePos(TGGroupFrame::kLeft);</a></code></pre></div>
<p>The second line sets the title position on the left. You can change it to be centered or right aligned if you use <strong><code>TGGroupFrame::kCenter</code></strong> or <code>TGGroupFrame::kRight</code> as a parameter.</p>
<p><img src="ROOTUsersGuide_files/02000208.jpg"></p>
<p>Be conservative in the use of borders because of the potential for 
clutter. Do not place them around single entry fields, single combo 
boxes, list boxes and groups of command buttons. The design of these 
widgets provides them with a border. The picture above provides kind of 
borders to avoid.</p>
<h2 id="layout-management"><span class="header-section-number">25.6</span> Layout Management</h2>
<p>The layout process is an integral part of any GUI. When you create a 
simple message window, laying out its few buttons and text widgets is 
quite simple. However, this process becomes increasingly difficult if 
you have to implement large GUI’s with many widgets that should behave 
properly when the GUI is resized or uses a different font type or size. 
Layout management is the process of determining the size and position of
 every widget in a container.</p>
<p>A layout manager is an object that performs layout management for the
 widgets within a container. You already know that when adding a 
component (child widget) to a container (parent widget) you can provide 
alignment hints (or rely on the default ones). These hints are used by 
the layout manager to correctly position the widgets in the container. 
The <strong><code>TGLayoutManager</code></strong> is an abstract class providing the basic layout functionality.</p>
<figure>
<img src="ROOTUsersGuide_files/02000209.jpg" alt="The layout classes hierarchy"><figcaption>The layout classes hierarchy</figcaption>
</figure>
<p>The base “container” class is <strong><code>TGCmpositeFrame</code></strong>. You can easily change the layout manager using the <code>SetLayoutManager(TGLayoutManager *l)</code>
 method. Setting the proper layout manager for each container is the 
first step you have to do. The container uses that layout manager to 
position and size the components before they are painted. ROOT currently
 provides the layout managers shown on the picture above.</p>
<p>The next important step is to provide hints about every widget in the
 container, i.e.&nbsp;to provide positions and right amount of space 
between the components. The <strong><code>TGLayoutHints</code></strong> objects set hints by specifying the white space in pixels around every widget.</p>
<p>Let’s see an example with five buttons. First you put them in a 
container, assign them desired properties, and then you lay them out 
according to the layout manager. This process can be repeated: you go 
back and add, remove or change some of the widgets and lay them out 
again.</p>
<p><img src="ROOTUsersGuide_files/0200020A.jpg"></p>
<p>Once created, you can consider these widgets as elementary objects 
even though they are compound ones. The pictures above present four 
different layouts of five buttons. The first one shows laid out 
vertically buttons. Almost everywhere you can find this vertical 
orientation. Looking at dialogs you see that often they consist of 
number of rows laid out below each other. Some of the rows could have an
 internal vertical structure as well. The second picture shows the same 
buttons laid out horizontally - the next common orientation. The other 
two show different layouts based on mixed use of the vertical and 
horizontal orientation. You might recognize their pattern: two (third 
picture) and three (last picture) rows that are vertically laid out.</p>
<p>As we already explained the layout process is always applying to a 
container. It will be enough to define the container frame with vertical
 or horizontal layout to have buttons as in the first and second 
pictures.</p>
<p>To design them in several rows we need to use additional frames as 
invisible containers: two horizontal frames, children of a vertical 
parent frame; or one horizontal frame laid out vertically with the Draw 
and Exit buttons. For widgets in a group it is obvious to use a vertical
 layout.</p>
<p>The layout hints data member of <strong><code>TGLayoutHints</code></strong> is the bit wise OR between the hints:</p>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<tbody>
<tr class="odd">
<td>Hints</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>kLHintsNoHints</code></td>
<td>no specified layout hints, the default ones will be used</td>
</tr>
<tr class="odd">
<td><code>kLHintsLeft</code></td>
<td>specifies the frame position to the left of the container frame after other frames with the same hint into the list</td>
</tr>
<tr class="even">
<td><code>kLHintsCenterX</code></td>
<td>specifies the frame position centered horizontally (with vertical containers only)</td>
</tr>
<tr class="odd">
<td><code>kLHintsRight</code></td>
<td>specifies the frame position to the right of the container frame 
before any other laid out frames with the same hint into the list</td>
</tr>
<tr class="even">
<td><code>kLHintsTop</code></td>
<td>specifies the frame position to the top of the container frame, below any laid out frames with the same hint</td>
</tr>
<tr class="odd">
<td><code>kLHintsCenterY</code></td>
<td>specifies the frame position centered vertically (with horizontal containers only)</td>
</tr>
<tr class="even">
<td><code>kLHintsBottom</code></td>
<td>specifies the frame position to the bottom of the container frame, above any laid out frames with the same hint</td>
</tr>
<tr class="odd">
<td><code>kLHintsExpandX</code></td>
<td>specifies the frame to be expanded up to the width of the container 
frame. If the container frame is a vertical frame - it will fit the 
whole width. If it is a horizontal frame - after the positioning of all 
frames the available “free” width space is shared between the frames 
having this hint</td>
</tr>
<tr class="even">
<td><code>kLHintsExpandY</code></td>
<td>specifies the frame to be expanded up to the height of the container
 frame. If the container frame is a horizontal frame - it will fit the 
whole height. If the container frame is a vertical frame - after the 
arrangement of all frames the available “free” height space is shared 
between the frames having this hint</td>
</tr>
<tr class="odd">
<td><code>kLHintsNormal</code></td>
<td>= <code>kLHintsLeft | kLHintsTop</code> - default hints</td>
</tr>
</tbody>
</table>
<p>Layout policy:</p>
<p>Child frames never modify their container frame. The container frame 
can (or cannot) adapt its size in the layout process. It can show all or
 a part of its frames. Every <strong><code>TGFrame</code></strong> object has a default minimum size (1, 1) assured by <strong><code>TGWindow</code></strong>.</p>
<h2 id="event-processing-signals-and-slots"><span class="header-section-number">25.7</span> Event Processing: Signals and Slots</h2>
<p>Event handling covers the interaction between different objects and 
between the user and the objects in an application. There are two 
general ways for the user to interact with an application: the keyboard 
and the mouse. The Graphical User Interface is as a bridge between the 
user and the program - it provides methods to detect the user actions 
and instruments that do something as a reaction of these actions. The 
user communicates with an application through the window system. The 
window system reports interaction events to the application. The 
application in turn forwards them to the currently active window. The 
objects/widgets receive the events and react to them according to the 
application functionality.</p>
<p><img src="ROOTUsersGuide_files/0200020B.jpg"></p>
<p>The signals/slot communication mechanism is an advanced object 
communication concept; it largely replaces the concept of callback 
functions to handle actions in GUI’s. Signals and slots are just like 
any object-oriented methods implemented in C++. The objects are the 
instances of classes that don’t know anything about each other. They 
interact and allow method calls of other object’s methods. The idea is 
simple: any object can send out (emit) a signal in certain situations 
saying that something happened. This is all it does to communicate and 
it does not know whether anything is interested in this information. On 
the other side there might be an object waiting for that signal and 
ready to react to it. This object disposes of special instruments to 
listen to the sent out signals. To have a communication we need a 
message transmission between the objects. In this simple example we use 
signals and slots. The code of the method <strong><code>TGButton::Clicked()</code></strong> is:</p>
<div class="sourceCode" id="cb1215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1215-1" title="1"><span class="kw">virtual</span> <span class="dt">void</span> Clicked()  { Emit(<span class="st">"Clicked()"</span>); }   <span class="co">// *SIGNAL*</span></a></code></pre></div>
<p>I.e. any button emits the signal <code>Clicked()</code> any time 
someone clicks on it. As you can see this method is virtual and could be
 overridden if you need to. In our simple example we call the <code>Connect()</code> method to connect the <code>Clicked()</code> signal of Draw button with <code>MyMainFrame::DoDraw():</code></p>
<div class="sourceCode" id="cb1216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1216-1" title="1">draw-&gt;Connect(<span class="st">"Clicked()"</span>,<span class="st">"MyMainFrame"</span>,<span class="kw">this</span>,<span class="st">"DoDraw()"</span>);</a></code></pre></div>
<p>In the same way we can connect to the signal <code>Clicked()</code> of the Exit button with the system call <code>gApplication-&gt;Terminate(0).</code> We declare a new slot <code>DoExit(),</code> implement it to invoke the termination call and associate this slot with the signal <code>Clicked()</code> of the Exit button.</p>
<p>The code of <code>example.C</code> can be changed as follows:</p>
<div class="sourceCode" id="cb1217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1217-1" title="1"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1217-2" title="2">...</a>
<a class="sourceLine" id="cb1217-3" title="3">   <span class="dt">void</span> DoExit();  <span class="co">// a new slot is added</span></a>
<a class="sourceLine" id="cb1217-4" title="4">}</a>
<a class="sourceLine" id="cb1217-5" title="5"><span class="dt">void</span> MyMainFrame::DoExit() {</a>
<a class="sourceLine" id="cb1217-6" title="6">   gApplication-&gt;Terminate(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1217-7" title="7">}</a>
<a class="sourceLine" id="cb1217-8" title="8">MyMainFrame::MyMainFrame(<span class="at">const</span> TGWindow *p,<span class="dt">UInt_t</span> w,<span class="dt">UInt_t</span> h) {</a>
<a class="sourceLine" id="cb1217-9" title="9">...</a>
<a class="sourceLine" id="cb1217-10" title="10">   TGTextButton *exit = <span class="kw">new</span> TGTextButton(hframe,<span class="st">"&amp;Exit "</span>);</a>
<a class="sourceLine" id="cb1217-11" title="11">   <span class="co">// connects signal Clicked() with slot DoExit()</span></a>
<a class="sourceLine" id="cb1217-12" title="12">   exit-&gt;Connect(<span class="st">"Clicked()"</span>,<span class="st">"MyMainFrame"</span>,<span class="kw">this</span>,<span class="st">"DoExit()"</span>);</a>
<a class="sourceLine" id="cb1217-13" title="13">...</a>
<a class="sourceLine" id="cb1217-14" title="14">}</a></code></pre></div>
<p>Here is an abstract view of the signal/slots connections in <code>example.C</code>:</p>
<p><img src="ROOTUsersGuide_files/0200020C.jpg"></p>
<p>To benefit from this mechanism your classes must inherit from <strong><code>TQObject</code></strong> or otherwise the class definition must start with <code>RQ_OBJECT("ClassName")</code>macro.
 This macro allows the signals/slots communication mechanism to be 
applied between compiled and interpreted classes in an interactive ROOT 
session without having the class derive from <strong><code>TQObject</code></strong>. Every signal method declaration is followed by a comment <code>"*SIGNAL*".</code>
 Only instances of a class that defines a signal or instances of its 
subclasses can emit the signal. The ROOT implementation of a popular 
example presenting signals and slots is the next. Let’s have a minimal 
class declaration:</p>
<div class="sourceCode" id="cb1218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1218-1" title="1"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb1218-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1218-3" title="3">   <span class="dt">Int_t</span> fValue;</a>
<a class="sourceLine" id="cb1218-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1218-5" title="5">   MyClass()  { fValue=<span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb1218-6" title="6">   <span class="dt">Int_t</span> GetValue() <span class="at">const</span> { <span class="cf">return</span> fValue; }</a>
<a class="sourceLine" id="cb1218-7" title="7">   <span class="dt">void</span>  SetValue(<span class="dt">Int_t</span>);</a>
<a class="sourceLine" id="cb1218-8" title="8">};</a></code></pre></div>
<p>It will become the following as interpreted:</p>
<div class="sourceCode" id="cb1219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1219-1" title="1"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb1219-2" title="2">   RQ_OBJECT(<span class="st">"MyClass"</span>)</a>
<a class="sourceLine" id="cb1219-3" title="3"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1219-4" title="4">   <span class="dt">Int_t</span> fValue;</a>
<a class="sourceLine" id="cb1219-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1219-6" title="6">   MyClass() { fValue=<span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb1219-7" title="7">   <span class="dt">Int_t</span> GetValue() <span class="at">const</span> { <span class="cf">return</span> fValue; }</a>
<a class="sourceLine" id="cb1219-8" title="8">   <span class="dt">void</span>  SetValue(<span class="dt">Int_t</span>); <span class="co">// *SIGNAL*</span></a>
<a class="sourceLine" id="cb1219-9" title="9">};</a></code></pre></div>
<p>Both class declarations have the same data member and public methods to access the value. By placing the <code>RQ_OBJECT("MyClass")</code> macro inside the <code>MyClass</code> body (<code>MyClass</code> is not inherited from <strong><code>TQObject</code></strong>)
 we allow this class to use the signal/slot communication. Any instance 
of this class can tell the outside world that the state of its data 
member has changed by emitting a signal <code>SetValue(Int_t).</code> A possible implementation of <code>MyClass::SetValue()</code> can be:</p>
<div class="sourceCode" id="cb1220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1220-1" title="1"><span class="dt">void</span> MyClass::SetValue(<span class="dt">Int_t</span> v) {</a>
<a class="sourceLine" id="cb1220-2" title="2">   <span class="cf">if</span> (v != fValue) {</a>
<a class="sourceLine" id="cb1220-3" title="3">      fValue = v;</a>
<a class="sourceLine" id="cb1220-4" title="4">      Emit(<span class="st">"SetValue(Int_t)"</span>,v);</a>
<a class="sourceLine" id="cb1220-5" title="5">   }</a>
<a class="sourceLine" id="cb1220-6" title="6">}</a></code></pre></div>
<p>The line <code>Emit("SetValue(Int_t)",v)</code> activates the signal <code>SetValue(Int_t)</code> with argument v. You can use any of the methods <strong><code>TQObject::Emit("full_method_name",arguments)</code></strong> to emit a signal. We create two instances of <code>MyClass</code> and connect them together:</p>
<div class="sourceCode" id="cb1221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1221-1" title="1">MyClass *objA = <span class="kw">new</span> MyClass();</a>
<a class="sourceLine" id="cb1221-2" title="2">MyClass *objB = <span class="kw">new</span> MyClass();</a>
<a class="sourceLine" id="cb1221-3" title="3">objA-&gt;Connect(<span class="st">"SetValue(Int_t)"</span>,<span class="st">"MyClass"</span>,objB,<span class="st">"SetValue(Int_t)"</span>);</a>
<a class="sourceLine" id="cb1221-4" title="4">objB-&gt;SetValue(<span class="dv">11</span>);</a>
<a class="sourceLine" id="cb1221-5" title="5">objA-&gt;SetValue(<span class="dv">79</span>);</a>
<a class="sourceLine" id="cb1221-6" title="6">objB-&gt;GetValue();          <span class="co">// the value is 79</span></a></code></pre></div>
<p>By calling the method <code>objA-&gt;Connect()</code>, <code>objA</code> connects its signal “<code>SetValue(Int_t)</code>” to the “<code>MyClass::SetValue(Int_t)</code>” method (slot) of <code>objB</code>. Next, when you call <code>objA-&gt;SetValue(79)</code>object <code>objA</code>emits a signal which <code>objB</code>receives and <code>objB-&gt;SetValue(79)</code>is invoked.</p>
<p>It is executed immediately, just like a normal function call. <code>objB</code>
 will emit the same signal in turn, but nobody is interested in this 
signal, since no slot has been connected to it. Signals are currently 
implemented for all ROOT GUI classes, event handlers (<strong><code>TFileHandler</code></strong>, <strong><code>TSignalHandler</code></strong>, etc.), timers (<strong><code>TTimer)</code></strong> and pads (<strong><code>TPad</code></strong>, <strong><code>TCanvas</code></strong>, etc.). To find all defined signals you just do: <code>grep ‘*SIGNAL*' $ROOTSYS/include/*.h</code></p>
<p>As a programmer you build the sender-receiver part of object connections using the <code>TQObject::Connect()</code>
 method. You can connect one signal to many different slots. The slots 
will be activated in order they were connected to the signal. You can 
change this order using the methods <code>LowPriority()</code> and <code>HightPriority()</code> of <strong><code>TQObject</code></strong>.
 Also, many signals can be connected to one slot of a particular object 
or a slot can be connected to a signal for all objects of a specific 
class. It is even possible to connect a signal directly to another 
signal - this will emit the second signal immediately after the first 
one is emitted.</p>
<p>All signals and slots are normal class methods and can take any number of arguments of any type. The common methods of <strong><code>TQObject</code></strong> that activate a signal with any number and type of parameters are:</p>
<div class="sourceCode" id="cb1222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1222-1" title="1">Emit(signal_name,param);</a></code></pre></div>
<p>With no parameters <code>param</code> the method will be:</p>
<div class="sourceCode" id="cb1223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1223-1" title="1">ApplyButton-&gt;Emit(<span class="st">"Clicked()"</span>);</a></code></pre></div>
<p><code>param</code> can be a single parameter or an array of <code>Long_t</code> parameters as it is shown below:</p>
<div class="sourceCode" id="cb1224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1224-1" title="1">TQObject *processor;  <span class="co">// data processor</span></a>
<a class="sourceLine" id="cb1224-2" title="2">TH1F     *hist;       <span class="co">// filled with processor results</span></a>
<a class="sourceLine" id="cb1224-3" title="3">...</a>
<a class="sourceLine" id="cb1224-4" title="4">processor-&gt;Connect(<span class="st">"Evaluated(Float_t, Float_t)"</span>, <span class="st">"TH1F"</span>, hist,</a>
<a class="sourceLine" id="cb1224-5" title="5">                   <span class="st">"Fill(Axis_t x, Axis_t y)"</span>);</a>
<a class="sourceLine" id="cb1224-6" title="6">...</a>
<a class="sourceLine" id="cb1224-7" title="7"><span class="dt">Longptr_t</span> args[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb1224-8" title="8">args[<span class="dv">0</span>]=(<span class="dt">Longptr_t</span>)processor-&gt;GetValue(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1224-9" title="9">args[<span class="dv">1</span>]=(<span class="dt">Longptr_t</span>)processor-&gt;GetValue(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1224-10" title="10">...</a>
<a class="sourceLine" id="cb1224-11" title="11">processor-&gt;Emit(<span class="st">"Evaluated(Float_t, Float_t)"</span>, args);</a>
<a class="sourceLine" id="cb1224-12" title="12">...</a></code></pre></div>
<p>To use signals and slot you need something that brings them together. The class <strong><code>TQObject</code></strong>
 has several methods creating sender-receiver connections. Some of them 
are static and can be called without having an instance of the class. 
The ROOT implementation of signals and slots allows connections to any 
known Cling object. The class name parameter in the <code>Connect()</code> methods must be a class with a dictionary (interpreted classes have an implicit dictionary).</p>
<div class="sourceCode" id="cb1225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1225-1" title="1">TGButton *button;</a>
<a class="sourceLine" id="cb1225-2" title="2">TH2      *hist;</a>
<a class="sourceLine" id="cb1225-3" title="3">...</a>
<a class="sourceLine" id="cb1225-4" title="4">TQObject::Connect(button,<span class="st">"Clicked()"</span>,<span class="st">"TH2"</span>,hist,<span class="st">"Draw(Option_t*)"</span>);</a></code></pre></div>
<p>You can replace it with 0 (zero) and in this case the slot string 
defines a global or interpreted function name. The receiver parameter 
should be zero too. For example:</p>
<div class="sourceCode" id="cb1226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1226-1" title="1">TQObject::Connect(button, <span class="st">"Clicked()"</span>,<span class="dv">0</span>,<span class="dv">0</span>, <span class="st">"hsimple()"</span>);</a></code></pre></div>
<p>To make a single connection from all objects of a class you should write:</p>
<div class="sourceCode" id="cb1227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1227-1" title="1">TQObject::Connect(<span class="st">"Channel"</span>, <span class="st">"AllarmOn()"</span>,<span class="st">"HandlerClass"</span>,handler,</a>
<a class="sourceLine" id="cb1227-2" title="2">                  <span class="st">"HandleAllarm()"</span>);</a></code></pre></div>
<p>The first argument specifies the class name Channel. The signal <code>AllarmOn()</code> of any object of the class Channel is connected to the <code>HandleAllarm()</code> method of the handler object of the class <code>HandlerClass</code>.</p>
<p>In <code>example.C</code> we have used the not-static <code>Connect()</code>method:</p>
<div class="sourceCode" id="cb1228"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1228-1" title="1"><span class="dt">Bool_t</span> Connect(<span class="at">const</span> <span class="dt">char</span> *signal, <span class="at">const</span> <span class="dt">char</span> *receiver_class,</a>
<a class="sourceLine" id="cb1228-2" title="2">               <span class="dt">void</span> *receiver, <span class="at">const</span> <span class="dt">char</span> *slot);</a></code></pre></div>
<p>It needs to know four things: the signal that should be connected, 
the receiver class, the object that will receive the signal, and the 
slot that will be connected to the signal. Because this method is 
non-static we can write this as a receiver parameter.</p>
<p>In all methods you have to specify the signal and the slot with their
 names and parameter types. Do not write values instead of types in that
 place. It is possible to pass a parameter by value to a slot method in 
the following way:</p>
<div class="sourceCode" id="cb1229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1229-1" title="1">Connect(myButton, <span class="st">"Pressed()"</span>, <span class="st">"TH1"</span>, hist, <span class="st">"SetMaximum(=123) "</span>);</a>
<a class="sourceLine" id="cb1229-2" title="2">Connect(myButton, <span class="st">"Pressed()"</span>, <span class="st">"TH1"</span>, hist, <span class="st">"Draw(=</span><span class="sc">\"</span><span class="st">LEGO</span><span class="sc">\"</span><span class="st">)"</span>);</a></code></pre></div>
<p>As you see the parameter’s value is preceded by the equation symbol 
(=). Please note that this method of passing arguments by value works 
only if the signal has less arguments than the slot. If the signal 
method has the same number of arguments, then the slot argument will be 
overwritten with the signal argument. In the example below, the Draw 
option would be overwritten in the first line by the emitted signal 
argument. The second line would be ok, the argument passed by value 
would not be overwritten.</p>
<div class="sourceCode" id="cb1230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1230-1" title="1">Connect(myComboBox, <span class="st">"Selected(const char*)"</span>, <span class="st">"TTree"</span>, myTree, <span class="st">"Draw(=</span><span class="sc">\"</span><span class="st">x</span><span class="sc">\"</span><span class="st">)"</span>);</a>
<a class="sourceLine" id="cb1230-2" title="2">Connect(myComboBox, <span class="st">"Selected(const char*)"</span>, <span class="st">"TTree"</span>, myTree, <span class="st">"Draw(const char*, =</span><span class="sc">\"</span><span class="st"> y==1 </span><span class="sc">\"</span><span class="st">)"</span>);</a></code></pre></div>
<p>In addition, if the signal and slot arguments differ in argument 
type, passing arguments by value leads to undefined behaviour and 
illegal memory access, as the signal argument will be casted to another 
data type. In the example below, if Selected emits Int_t = 1, then 
ChangeText will try to read a TString at address 0x1.</p>
<div class="sourceCode" id="cb1231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1231-1" title="1">Connect(myComboBox, <span class="st">"Selected(Int_t)"</span>, <span class="st">"TGTextButton"</span>, myButton, <span class="st">"ChangeText(=</span><span class="sc">\"</span><span class="st">Hello</span><span class="sc">\"</span><span class="st">)"</span>);</a></code></pre></div>
<p>You have the possibility to destroy a signal/slot connection by using <code>Disconnect()</code> methods. There are three ways to do this:</p>
<p>1/ to destroy all connections to an object’s signals;</p>
<p>2/ to destroy all connections to a particular object’s signal; 3/ to detach an object from a specific receiver:</p>
<div class="sourceCode" id="cb1232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1232-1" title="1">Disconnect(myObgect);                     <span class="co">// case 1</span></a>
<a class="sourceLine" id="cb1232-2" title="2">Disconnect(myObgect, <span class="st">"mySignal"</span>);         <span class="co">// case 2</span></a>
<a class="sourceLine" id="cb1232-3" title="3">Disconnect(myObgect,<span class="dv">0</span>,myReceiver,<span class="dv">0</span>);      <span class="co">// case 3</span></a></code></pre></div>
<p>Three parameters of these methods could be replaced by 0. The meaning
 in these cases would be “any signal”, “any receiving object”, “any slot
 of the receiving object”, i.e.&nbsp;0 is used as a wildcard. The sender
 parameter cannot be 0, because you can disconnect signals from one 
given object. If the signal parameter is 0, the receiver and the slot 
are disconnected from any signal. Giving the name of the signal you 
disconnect this signal.</p>
<p>In addition to all Qt features the ROOT version of signals/slots 
gives you the possibility to connect slots to a class. The slots will be
 executed every time the specified signal is emitted by any object of 
this class. A slot can have default arguments and it can be either a 
class method or stand-alone function (compiled or interpreted).</p>
<p>The method <code>TQObject::HasConnection(signale_name)</code> checks if there is an object connected to this signal and returns true if it is the case.</p>
<p>Using <code>TQObject::NumberOfConnections()</code>, <strong><code>TQObject</code></strong><code>::NumberOfSignals()</code> you can check how many signals or connections has the object.</p>
<p>The rules for using signals/slots mechanism in a standalone 
executable program do not differ from what was described previously. 
Let’s remind that</p>
<ul>
<li><p>a slot can be any class method with a generated Cling dictionary</p></li>
<li><p>a slot can be a function with a dictionary</p></li>
</ul>
<p>Detailed information how to generate a dictionary can be found on <a href="http://root.cern.ch/root/CintGenerator.html" class="uri">http://root.cern.ch/root/CintGenerator.html</a></p>
<p>The following example demonstrates how to use signals/slots mechanism in a standalone executable program on <code>linux</code> platform with the <code>gcc</code> compiler.</p>
<p><code>tst.C</code></p>
<div class="sourceCode" id="cb1233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1233-1" title="1"><span class="pp">#include </span><span class="im">&lt;TQObject.h&gt;</span></a>
<a class="sourceLine" id="cb1233-2" title="2"><span class="pp">#include </span><span class="im">&lt;RQ_OBJECT.h&gt;</span></a>
<a class="sourceLine" id="cb1233-3" title="3"></a>
<a class="sourceLine" id="cb1233-4" title="4"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb1233-5" title="5">   RQ_OBJECT(<span class="st">"A"</span>)</a>
<a class="sourceLine" id="cb1233-6" title="6"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1233-7" title="7">   <span class="dt">Int_t</span> fValue;</a>
<a class="sourceLine" id="cb1233-8" title="8"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1233-9" title="9">   A() : fValue(<span class="dv">0</span>) { }</a>
<a class="sourceLine" id="cb1233-10" title="10">   ~A() { }</a>
<a class="sourceLine" id="cb1233-11" title="11">   <span class="dt">void</span>  SetValue(<span class="dt">Int_t</span> value);  <span class="co">// *SIGNAL*</span></a>
<a class="sourceLine" id="cb1233-12" title="12">   <span class="dt">void</span>  PrintValue() <span class="at">const</span>   { printf(<span class="st">"value = </span><span class="sc">%d\n</span><span class="st">"</span>, fValue); }</a>
<a class="sourceLine" id="cb1233-13" title="13">};</a>
<a class="sourceLine" id="cb1233-14" title="14"><span class="dt">void</span> A::SetValue(<span class="dt">Int_t</span> value) {  <span class="co">// Set new value</span></a>
<a class="sourceLine" id="cb1233-15" title="15">   <span class="co">// Emit signal "SetValue(Int_t)" with a single parameter</span></a>
<a class="sourceLine" id="cb1233-16" title="16">   <span class="cf">if</span> (value != fValue) {</a>
<a class="sourceLine" id="cb1233-17" title="17">      fValue = value;</a>
<a class="sourceLine" id="cb1233-18" title="18">      Emit(<span class="st">"SetValue(Int_t)"</span>, fValue);</a>
<a class="sourceLine" id="cb1233-19" title="19">   }</a>
<a class="sourceLine" id="cb1233-20" title="20">}</a>
<a class="sourceLine" id="cb1233-21" title="21"><span class="co">// Main program</span></a>
<a class="sourceLine" id="cb1233-22" title="22"><span class="pp">#ifdef STANDALONE</span></a>
<a class="sourceLine" id="cb1233-23" title="23"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</a>
<a class="sourceLine" id="cb1233-24" title="24">   A* a = <span class="kw">new</span> A();</a>
<a class="sourceLine" id="cb1233-25" title="25">   A* b = <span class="kw">new</span> A();</a>
<a class="sourceLine" id="cb1233-26" title="26">   a-&gt;Connect(<span class="st">"SetValue(Int_t)"</span>, <span class="st">"A"</span>, b, <span class="st">"SetValue(Int_t)"</span>);</a>
<a class="sourceLine" id="cb1233-27" title="27">   printf(<span class="st">"n******* Test of SetValue(Int_t) signal *******n"</span>);</a>
<a class="sourceLine" id="cb1233-28" title="28">   b-&gt;SetValue(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1233-29" title="29">   printf(<span class="st">"nt***** b before ******n"</span>);</a>
<a class="sourceLine" id="cb1233-30" title="30">   b-&gt;PrintValue();</a>
<a class="sourceLine" id="cb1233-31" title="31">   a-&gt;SetValue(<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1233-32" title="32">   printf(<span class="st">"t***** b after a-&gt;SetValue(20) ******n"</span>);</a>
<a class="sourceLine" id="cb1233-33" title="33">   b-&gt;PrintValue();</a>
<a class="sourceLine" id="cb1233-34" title="34">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1233-35" title="35">}</a>
<a class="sourceLine" id="cb1233-36" title="36"><span class="pp">#endif</span></a></code></pre></div>
<p>ACLiC simplifies this procedure and allows the dictionary generation by:</p>
<div class="sourceCode" id="cb1234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1234-1" title="1">root[] .L tst.C++</a></code></pre></div>
<p>It will create the shared library <code>tst_C.so.</code></p>
<p>The next line will create an executable:</p>
<p><strong><code>g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE</code></strong></p>
<p>The library <code>tst_C.so</code> is a dynamically loaded library and should be located in <code>$LD_LIBRARY_PATH</code>. The current working directory should be added to <code>$LD_LIBRARY_PATH</code> via:</p>
<p><strong><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./</code></strong></p>
<p>To run it, you just do:</p>
<p><strong><code>./tst</code></strong></p>
<h2 id="widgets-in-detail"><span class="header-section-number">25.8</span> Widgets in Detail</h2>
<h3 id="buttons"><span class="header-section-number">25.8.1</span> Buttons</h3>
<p>Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. <strong><code>TGButton</code></strong> is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.</p>
<p>There are two main groups of buttons: command buttons with a text or 
graphics inside that indicate the action to be accomplished and option 
buttons well known as radio and check buttons that select or change 
properties. The first group is presented in ROOT by <strong><code>TGPictureButton</code></strong> and <strong><code>TGTextButton</code></strong>
 classes. They yield an action as soon as they are clicked. It can be 
opening/closing a dialog box or invoking a specific function in an 
application. Remember the Draw button from the example. The radio and 
check buttons from the second group are used to select an option. There 
is a visual difference between these two groups: the text buttons appear
 “pressed in” only while they are clicked, while the radio and check 
buttons change their appearance when they are selected and keep that 
appearance afterwards.</p>
<p>A text button is represented by the class <strong><code>TGTextButton</code></strong>.
 We already used its constructor in the example. The button label 
indicates the action to be taken when the button is selected or pressed.
 The text can be a hot string defining a hot key (known as shortcut key 
also) for this selection. The hot key is an underlined character in a 
button label that shows the assigned keyboard mnemonic for its choice. A
 button that prompts more information for users has the label generally 
followed by ellipsis (…).</p>
<p><img src="ROOTUsersGuide_files/0300020D.png"></p>
<p>As we saw the hot strings “&amp;Draw” and “&amp;Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics <code>Alt+D</code>, <code>Alt+E</code>
 for their selection. The letter D and E appear underlined on the 
screen. All text buttons should have a unique shortcut key with the 
exception of OK and Cancel.</p>
<p>These buttons are usually placed within a window to provide fast 
access to frequently used or critical commands. They help in situations 
where a command is not available through the menu bar. You already know 
that a command string can be passed in the text button via the 
constructor:</p>
<div class="sourceCode" id="cb1235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1235-1" title="1">TGTextButton(<span class="at">const</span> TGWindow *p, <span class="at">const</span> <span class="dt">char</span> *s, <span class="at">const</span> <span class="dt">char</span> *cmd,</a>
<a class="sourceLine" id="cb1235-2" title="2">             <span class="dt">Int_t</span> id, <span class="dt">GContext_t</span> norm, <span class="dt">FontStruct_t</span> font,</a>
<a class="sourceLine" id="cb1235-3" title="3">             <span class="dt">UInt_t</span> options);</a></code></pre></div>
<p>A button label can be changed by <code>SetText(new_label).</code> 
There are important guidelines to be followed about a button label. The 
text has to provide a meaningful description of the performed action. 
The single-word label should be used whenever possible, only two-three 
words for clarity, if necessary. Do not number labels. Always follow all
 platform presentation and usage guidelines for standard button 
functions. Let’s remember a few standard names and definitions of well 
known buttons:</p>
<p><strong><em><code>OK</code></em></strong> - any changed information in a window is accepted and the window is closed;</p>
<p><strong><em><code>Cancel</code></em></strong> - closes window without implementing submitted changes;</p>
<p><strong><em><code>Reset</code></em></strong>- resets defaults and cancels any changed information that has not be submitted;</p>
<p><strong><em><code>Apply</code></em></strong> - any changed information is accepted and again displayed in the window that remains open;</p>
<p><strong><em><code>Close</code></em></strong> - closes the window;</p>
<p><strong><em><code>Help</code></em></strong> - opens online Help.</p>
<p>Below are examples of text buttons. Note the two placement methods. 
The first example should be used when there are one to three command 
buttons; the second one when there are more than three buttons.</p>
<p><img src="ROOTUsersGuide_files/0200020E.jpg"></p>
<p>Picture buttons are usually rectangular in shape with an icon or 
graphics label. These buttons may appear alone or placed in a group at 
the window’s top or side. They are most frequently used to quickly 
access commands, many of which are normally accessed through the tool 
bar. For example, the picture buttons below can be used to provide 
different styles of a histogram drawing.</p>
<p><img src="ROOTUsersGuide_files/0200020F.jpg"></p>
<p>Here is the example how to create the first button:</p>
<div class="sourceCode" id="cb1236"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1236-1" title="1">TGPictureButton *fPicture = <span class="kw">new</span> TGPictureButton(parent,</a>
<a class="sourceLine" id="cb1236-2" title="2">                           gClient-&gt;GetPicture(<span class="st">"h1_s.xpm"</span>), <span class="dv">11</span>);</a></code></pre></div>
<p>The picture of file h1_s.xpm is used in the button. All <code>.xpm</code> files are located in the directory <code>$ROOTSYS/icons</code>. You can assign a command directly as a parameter of the picture button constructor. The picture of <strong><code>TGPictureButton</code></strong> can be changed by:</p>
<div class="sourceCode" id="cb1237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1237-1" title="1">fPicture-&gt;SetPicture(<span class="st">"h2_s.xpm"</span>);</a></code></pre></div>
<p>The advantage of command buttons is that they are always visible, 
providing a reminder of their existence. They can be inscribed with a 
meaningful description of what they do by <code>TGToolTip("Some describing text").</code>
 Their activation is much easier and faster than using a two-step menu 
bar/pull-down sequence. The only disadvantage of the text and picture 
buttons is that they consume considerable screen space if they are many.
 Having no more than six command buttons per window or dialog box helps 
to appropriately balance the application’s effectiveness, its real 
efficiency, and the operational simplicity.</p>
<p>The classes <strong><code>TGRadioButton</code></strong> and <strong><code>TGCheckButton</code></strong>
 present the option buttons in ROOT. Like the text buttons, they have 
text or hot string as a label. Radio buttons are grouped in logical sets
 of two or more and appear with a text label to the right. The choices 
are mutually exclusive and only one setting is permitted at one time. 
They represent visually all alternatives and it is easy to access and 
compare choices. They facilitate the situations where all alternatives 
cannot be easily remembered or where displaying the alternatives 
together helps to understand and select the proper choice. It is very 
useful to provide a default setting whenever it is possible. When it is 
not possible to establish a default setting because of the nature of the
 information, it is better to leave all radio buttons blank.</p>
<p><img src="ROOTUsersGuide_files/03000210.png"></p>
<p>A columnar orientation is the preferred manner of radio buttons 
presentation. If the vertical space on the window is limited, they can 
be oriented horizontally. Selection choices should be organized 
logically in groups. Here is the example that produces the image above:</p>
<div class="sourceCode" id="cb1238"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1238-1" title="1">br = <span class="kw">new</span> TGButtonGroup(p,<span class="st">"Coordinate system"</span>,kVerticalFrame);</a>
<a class="sourceLine" id="cb1238-2" title="2">fR[<span class="dv">0</span>] = <span class="kw">new</span> TGRadioButton(bg,<span class="kw">new</span> TGHotString(<span class="st">"&amp;Pixel"</span>));</a>
<a class="sourceLine" id="cb1238-3" title="3">fR[<span class="dv">1</span>] = <span class="kw">new</span> TGRadioButton(bg,<span class="kw">new</span> TGHotString(<span class="st">"&amp;NDC "</span>));</a>
<a class="sourceLine" id="cb1238-4" title="4">fR[<span class="dv">2</span>] = <span class="kw">new</span> TGRadioButton(bg,<span class="kw">new</span> TGHotString(<span class="st">"&amp;User "</span>));</a>
<a class="sourceLine" id="cb1238-5" title="5">fR[<span class="dv">1</span>]-&gt;SetState(kButtonDown);</a>
<a class="sourceLine" id="cb1238-6" title="6">br-&gt;Show();</a></code></pre></div>
<p>It is enough to change <code>kVerticalFrame</code> to <code>kHorizontalFrame</code> in <strong><code>TGButtonGroup</code></strong> constructor and you will have radio buttons aligned horizontally:</p>
<p><img src="ROOTUsersGuide_files/03000211.png"></p>
<p>The class <strong><code>TGButtonGroup</code></strong> will help you to organize button widgets in a group. There is no need to call <code>AddFrame()</code> since the buttons are added automatically with a default layout hint to their parent by <strong><code>TGButtonGroup</code></strong><code>::Show()</code> as shown in the previous example. The buttons in the group have assigned identifiers. Any button in a group emits a <code>Clicked()</code> signal with this identifier when it is clicked. This giving an ideal solution to connect several <code>Clicked()</code> signals to one slot.</p>
<p>An exclusive button group switches off all toggle buttons except the 
selected one. The group is by default non-exclusive but its entire radio
 buttons will be mutually exclusive.</p>
<p><strong><code>TGHButtonGroup</code></strong> and <strong><code>TGVButtonGroup</code></strong> are convenience classes that offer you a thin layer on top of <strong><code>TGButtonGroup</code></strong>. <strong><code>TGHButtonGroup</code></strong> organize button widgets in a group of one horizontal row, <strong><code>TGVButtonGroup</code></strong> in a group of one column. You can also organize buttons in rows and columns using the provided constructor and <strong><code>TGMatrixLayout</code></strong>.</p>
<p>Do not use a radio button to indicate the presence or absence of a state - use a check box instead.</p>
<p><img src="ROOTUsersGuide_files/03000212.png"></p>
<p>To have the check button “Event Status” and to set it as selected we need to write:</p>
<div class="sourceCode" id="cb1239"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1239-1" title="1">TGCheckButton *estat = <span class="kw">new</span> TGCheckButton(p, <span class="st">"Event Status"</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1239-2" title="2">estat-&gt;SetState(kButtonDown);</a></code></pre></div>
<p>Check boxes show the selected choices and any number of them can be 
selected, including none. Their proper usage is for setting attributes, 
properties or values; also for data or choices that are discrete, small 
and fixed in number, not easily remembered. With check boxes all 
alternatives are visible: it is easy to access and compare choices 
because they can all be seen together. Each option acts as a switch and 
can be either “on” or “off”. It is never changed in contents. Checkboxes
 differ from radio buttons in that they permit selection of more than 
one alternative. Each box can be switched on or off independently. These
 buttons can be used alone or grouped in sets. It is good practice to 
provide default settings for check boxes whenever it is possible.</p>
<p><img src="ROOTUsersGuide_files/03000213.png"></p>
<p>This can be done by:</p>
<div class="sourceCode" id="cb1240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1240-1" title="1">SetState(EButtonState state)</a></code></pre></div>
<p>The parameter state can be one of <code>kButtonUp</code>, <code>kButtonDown</code>, <code>kButtonEngaged</code>, <code>kButtonDisabled</code>.</p>
<p>Check boxes can be used to affect other controls. The contents of a 
list can, for example, be filtered by setting a check box. In any case, 
use a check box only when both states of a choice are clearly opposite 
and unambiguous. If opposite states are not clear, it is better to use 
two radio buttons.</p>
<p>Choice description, i.e.&nbsp;check box label, must be clear, 
meaningful, fully spelled out, and displayed in mixed-type text. 
Whenever the use of a given button is inappropriate, for whatever 
reason, that button should be disabled:</p>
<div class="sourceCode" id="cb1241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1241-1" title="1">button-&gt;SetState(kButtonDisabled);</a></code></pre></div>
<p>Never make a button appear and disappear.</p>
<p>In general, option buttons should not offer more than eight choices. 
If the number of choices exceeds this maximum, it is better to use a 
multiple selection list box.</p>
<p>The method <code>IsToggleButton()</code> gives the information 
whether a radio button or a check button is selected. An option button 
can be set or unset via its method <code>PSetState(EButtonState state).</code></p>
<p>The method <code>HandleKey(event)</code> is called when the defined 
hotkey is hit for any button. It sets the selected option button or 
clicks the selected text button and invokes its defined action.</p>
<h3 id="text-entries"><span class="header-section-number">25.8.2</span> Text Entries</h3>
<p>A <strong><code>TGTextEntry</code></strong> is a one-line text input 
widget. It contains text that is entered or modified through the 
keyboard. This text may be displayed in different way according to the 
set echo mode. Users can control them by<code>SetEchoMode()</code>, <code>GetEchoMode()</code> methods.</p>
<ul>
<li><p><code>kNormal</code> - display characters as they are entered (default);</p></li>
<li><p><code>kNoEcho</code> - do not display anything;</p></li>
<li><p><code>kPassword</code> - display asterisks instead of the characters actually entered.</p></li>
</ul>
<p>The way in which typed characters are inserted in the text entry is defined by <code>TGTextEntry::EInsertMode</code> and can be toggled by the Insert key:</p>
<ul>
<li><p><code>kInsert</code> - typed character are inserted (cursor has shape of short line)</p></li>
<li><p><code>kReplace</code> - entered characters substitute already typed ones (cursor has the shape of filled rectangle).</p></li>
</ul>
<p><img src="ROOTUsersGuide_files/03000214.png"> <img src="ROOTUsersGuide_files/03000215.png"></p>
<p>There ate different text alignment modes defined by <code>TGWidget::ETextJustification</code>. They are valid until text fits the frame width of the text entry field.</p>
<ul>
<li><p><code>kTextLeft</code> - left-side text alignment</p></li>
<li><p><code>kTextRight</code> - right-side text alignment</p></li>
<li><p><code>kTextCenterX</code> - center text alignment along x direction</p></li>
<li><p><code>kTextTop</code> - top-side text alignment</p></li>
<li><p><code>kTextBottom</code> - bottom-side text alignment</p></li>
<li><p><code>kTextCenterY</code> - center text alignment along y direction</p></li>
</ul>
<h3 id="number-entries"><span class="header-section-number">25.8.3</span> Number Entries</h3>
<p>The <strong><code>TGNumberEntry</code></strong> class present number 
entry widgets. A number entry is a single-line field followed by two 
small, vertically arranged up-down buttons. Its purpose is to make a 
selection by either scrolling through a small set of meaningful 
predefined choices or typing numbers. The <strong><code>TGNumberFormat</code></strong> class contains <code>enum</code> types to specify the numeric format. The number entry widget is based on <strong><code>TGTextEntry</code></strong>.
 It allows only numerical input. The widget supports numerous formats 
including integers, hex numbers, real numbers, fixed fraction real and 
time/date formats. It also allows to restrict input values to 
non-negative or positive numbers and to specify explicit limits.</p>
<p><img src="ROOTUsersGuide_files/03000216.png"></p>
<p>The following styles are supported:</p>
<ul>
<li><p><code>kNESInteger</code> - integer number</p></li>
<li><p><code>kNESRealOne</code> - real number with one digit (no exponent)</p></li>
<li><p><code>kNESRealTwo</code> - real number with two digits (no exponent)</p></li>
<li><p><code>kNESRealThree</code> - real number with three digits (no exponent)</p></li>
<li><p><code>kNESRealFour</code> - real number with four digits (no exponent)</p></li>
<li><p><code>kNESReal</code> - arbitrary real number</p></li>
<li><p><code>kNESDegree</code> - angle in degree:minutes:seconds format</p></li>
<li><p><code>kNESMinSec</code> - time in minutes:seconds format</p></li>
<li><p><code>kNESMinSecCent</code> - time in minutes:seconds.centiseconds format</p></li>
<li><p><code>kNESHourMin</code> - time in hour:minutes format</p></li>
<li><p><code>kNESHourMinSec</code> - time in hour:minutes:seconds format</p></li>
<li><p><code>kNESDayMYear</code> - date in day/month/year format</p></li>
<li><p><code>kNESMDayYear</code> - date in month/day/year format</p></li>
<li><p><code>kNESHex</code>- hexadecimal number</p></li>
</ul>
<p>The following attributes can be specified:</p>
<ul>
<li><p><code>kNEAAnyNumber</code> - any number is allowed</p></li>
<li><p><code>kNEANonNegative</code> - only non-negative numbers are allowed</p></li>
<li><p><code>kNEAPositive</code> - only positive numbers are allowed</p></li>
</ul>
<p>Explicit limits can be specified individually:</p>
<ul>
<li><p><code>kNELNoLimits</code> - no limits</p></li>
<li><p><code>kNELLimitMin</code> - lower limit only</p></li>
<li><p><code>kNELLimitMax</code> - upper limit only</p></li>
<li><p><code>kNELLimitMinMax</code> - both lower and upper limits</p></li>
</ul>
<div class="sourceCode" id="cb1242"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1242-1" title="1">fN1 = <span class="kw">new</span> TGNumberEntry(parent, <span class="fl">0.005</span>, <span class="dv">9</span>, kENTRY1,</a>
<a class="sourceLine" id="cb1242-2" title="2">         TGNumberFormat::kNESRealThree,   <span class="co">//style</span></a>
<a class="sourceLine" id="cb1242-3" title="3">         TGNumberFormat::kNEAAnyNumber,   <span class="co">//input value filter</span></a>
<a class="sourceLine" id="cb1242-4" title="4">         TGNumberFormat::kNELLimitMinMax, <span class="co">//specify limits</span></a>
<a class="sourceLine" id="cb1242-5" title="5">         -<span class="fl">1.</span>,<span class="fl">1.</span>);                         <span class="co">//limit values</span></a></code></pre></div>
<p><strong><code>TGNumberEntryField</code></strong> is a number entry input widget.</p>
<div class="sourceCode" id="cb1243"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1243-1" title="1">Nent = <span class="kw">new</span> TGNumberEntryField(hgrunf2, kNENT_ID, <span class="fl">0.6</span>,</a>
<a class="sourceLine" id="cb1243-2" title="2">                              TGNumberFormat::kNESRealThree,</a>
<a class="sourceLine" id="cb1243-3" title="3">                              TGNumberFormat::kNEAAnyNumber);</a></code></pre></div>
<p><strong><code>TGNumberEntryField</code></strong> is a plain vanilla entry field, whereas <strong><code>TGNumberEntry</code></strong>
 adds two small buttons to increase and decrease the numerical value in 
the field. The number entry widgets also support using the up and down 
cursor keys to change the numerical values. The step size can be 
selected with control and shift keys:</p>
<ul>
<li><p>–small step (1 unit/factor of 3)</p></li>
<li><p>Shift medium step (10 units/factor of 10)</p></li>
<li><p>Controllarge step (100 units/factor of 30)</p></li>
<li><p>Shift+Controlhuge step (1000 units/factor of 100)</p></li>
</ul>
<p>The steps are either linear or logarithmic. The default behavior is 
set when the entry field is created, but it can be changed by pressing 
the alt key at the same time.</p>
<h3 id="menus"><span class="header-section-number">25.8.4</span> Menus</h3>
<p>Menus provide a list of commands or options helping the user to select and to perform a task. The menu system classes are <strong><code>TGMenuBar</code></strong>, <strong><code>TGMenuTitle</code></strong>, <strong><code>TGPopupMenu</code></strong>, and <strong><code>TGMenuEntry</code></strong>.</p>
<p>The <strong><code>TGMenuBar</code></strong> class implements a menu 
bar widget. It is used to specify and provide access to common and 
frequently used application actions described in menu titles, 
implemented by <strong><code>TGMenuTitle</code></strong> class. The menu
 bar is the highest-level of the menu system and it is a starting point 
for all interactions. Also, it is always visible and allows using the 
keyboard equivalents. The geometry of the menu bar is automatically set 
to the parent widget, i.e.&nbsp;the menu bar automatically resizes 
itself so that it has the same width as its parent (typically <strong><code>TGMainFrame</code></strong>).</p>
<p>The menu bar is as a container for its menus - objects of the type <strong><code>TGPopupMenu.</code></strong>
 Popup menus can appear in a menu bar. They can be a sub-menu of another
 popup menu (cascading menus) or can be standalone (as a context menu). 
They are made of one or more menu items choices. When displayed, the 
menu items are arranged in a vertical list. Usually they correspond to 
actions (e.g.&nbsp;<code>Open</code><strong>)</strong>. These items can 
be labeled with text, graphics or a combination of both. Each of them 
should have a character defined as its unique key for access. Grouped 
logically by their functionality, they are separated visually by menu 
separators in groups. For example, The <code>File</code> menu is a common menu title for tasks that apply to a file, as <strong><code>Open</code></strong>,<strong><code>Save</code></strong>,<strong><code>Close</code></strong>,<strong><code>Print</code></strong>…</p>
<div class="sourceCode" id="cb1244"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1244-1" title="1"><span class="co">// a popup menu</span></a>
<a class="sourceLine" id="cb1244-2" title="2">fMenuFile = <span class="kw">new</span> TGPopupMenu(gClient-&gt;GetRoot());</a>
<a class="sourceLine" id="cb1244-3" title="3"></a>
<a class="sourceLine" id="cb1244-4" title="4"><span class="co">// adding menu entries</span></a>
<a class="sourceLine" id="cb1244-5" title="5">fMenuFile-&gt;AddEntry(<span class="st">"&amp;Open..."</span>,M_FILE_OPEN);</a>
<a class="sourceLine" id="cb1244-6" title="6">fMenuFile-&gt;AddEntry(<span class="st">"&amp;Save"</span>,M_FILE_SAVE);</a>
<a class="sourceLine" id="cb1244-7" title="7">fMenuFile-&gt;AddEntry(<span class="st">"S&amp;ave as..."</span>,M_FILE_SAVEAS);</a>
<a class="sourceLine" id="cb1244-8" title="8">fMenuFile-&gt;AddEntry(<span class="st">"&amp;Close"</span>, -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1244-9" title="9"></a>
<a class="sourceLine" id="cb1244-10" title="10"><span class="co">// adding separator</span></a>
<a class="sourceLine" id="cb1244-11" title="11">fMenuFile-&gt;AddSeparator();</a>
<a class="sourceLine" id="cb1244-12" title="12"></a>
<a class="sourceLine" id="cb1244-13" title="13"><span class="co">// next group of menu entries</span></a>
<a class="sourceLine" id="cb1244-14" title="14">fMenuFile-&gt;AddEntry(<span class="st">"&amp;Print"</span>,M_FILE_PRINT);</a>
<a class="sourceLine" id="cb1244-15" title="15">fMenuFile-&gt;AddEntry(<span class="st">"P&amp;rint setup..."</span>,M_FILE_PRINTSETUP);</a>
<a class="sourceLine" id="cb1244-16" title="16">. . .</a>
<a class="sourceLine" id="cb1244-17" title="17">fMenuFile-&gt;AddSeparator();</a>
<a class="sourceLine" id="cb1244-18" title="18">fMenuFile-&gt;AddEntry(<span class="st">"E&amp;xit"</span>,M_FILE_EXIT);</a></code></pre></div>
<p>First we create the File menu by creating an object of class<strong><code>TGPopupMenu</code></strong> and adding menu entries with <code>AddEntry</code>
 method. Its first parameter is a hot string, the second - a menu ID. 
The ampersand character (&amp;) denotes shortcut for each menu entry; 
you can use the letter after it to manage the menu via keyboard. There 
are three groups of menu entries separated visually by two separators.</p>
<p>You can add a sub-menu by using the method <code>TGPopupMenu::AddPopup</code>. Its first parameter is again a string, the second one - a pointer to a <strong><code>TGPopupMenu</code></strong>
 object that will appear as a sub-menu when the menu entry will be 
selected. The often used visual indicator of a sub- menu is a 
right-facing arrow to the right of the parent menu item. Generally only 
one level of cascading menus is recommended and you should be careful in
 using more. Next lines show how to create a menu bar with <code>File</code><strong>,</strong><code>Test</code> and <code>Help</code> menus:</p>
<div class="sourceCode" id="cb1245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1245-1" title="1"><span class="co">// menu bar item layout hints</span></a>
<a class="sourceLine" id="cb1245-2" title="2">fMBItemLayout = <span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsLeft,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1245-3" title="3">fMBHelpLayout = <span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsRight);</a>
<a class="sourceLine" id="cb1245-4" title="4"></a>
<a class="sourceLine" id="cb1245-5" title="5"><span class="co">// menu bar</span></a>
<a class="sourceLine" id="cb1245-6" title="6">fMenuBar = <span class="kw">new</span> TGMenuBar(fMain,<span class="dv">100</span>,<span class="dv">20</span>,kHorizontalFrame);</a>
<a class="sourceLine" id="cb1245-7" title="7"></a>
<a class="sourceLine" id="cb1245-8" title="8"><span class="co">// adding popup menus</span></a>
<a class="sourceLine" id="cb1245-9" title="9">fMenuBar-&gt;AddPopup(<span class="st">"&amp;File"</span>, fMenuFile, fMBItemLayout);</a>
<a class="sourceLine" id="cb1245-10" title="10">fMenuBar-&gt;AddPopup(<span class="st">"&amp;Test"</span>, fMenuTest, fMBItemLayout);</a>
<a class="sourceLine" id="cb1245-11" title="11">fMenuBar-&gt;AddPopup(<span class="st">"&amp;Help"</span>, fMenuHelp, fMBHelpLayout);</a></code></pre></div>
<p>Using the method <code>TGMenuBar::AddPopup</code> we add three <strong><code>TGPopupMenu</code></strong> objects to the menu bar <code>fMenuBar</code>. The first parameter is a hot string used by <strong><code>TGMenuTitle</code></strong> object. When you add a popup menu to the menu bar, a <strong><code>TGMenuTitle</code></strong>
 object is created by the menu bar. It is the name of the popup menu. A 
menu title should have a one-word name that reflects the purpose of all 
items within the corresponding popup menu. It should also have a defined
 character as its unique access key. The second parameter is the popup 
menu we would like to add. The third one is an object of <strong><code>TGLayoutHints</code></strong> type that defines how the menu title will be laid out in the menu bar. In our example the <em><code>File</code></em> and <code>Test</code> menus will be laid out to the left of the menu bar with 4 pixels distance in between, the <code>Help</code> menu - will be laid out to the right.</p>
<p>The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method <code>HideEntry(menuID)</code> hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call <code>EnableEntry(menuID)</code> method. By default all entries are enabled. The method <code>DisableEntry(menuID)</code> helps you to disable a menu entry - it will appear in sunken relieve. The <code>DeleteEntry(menuID)</code> method will delete the specified entry from the menu.</p>
<p>A few words about the menu design. A menu should be kept consistent 
and simple. All related items need to be in a popup menu. The cascade 
menus should be used judiciously. Try to limit them to one, maximum two 
levels.</p>
<p>There are some rules for naming the menu objects:</p>
<ul>
<li><p>Define unique names within a menu</p></li>
<li><p>Use capitalized one-word names allowing the quick scan of the menu</p></li>
<li><p>Define unique access key for any menu item</p></li>
<li><p>Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box</p></li>
</ul>
<p>The proper kind of graphical menus is a critical point to every application success and depends of three main factors:</p>
<ul>
<li><p>number of presented items in the menu</p></li>
<li><p>how often the menu is used</p></li>
<li><p>how often the menu contents may change</p></li>
</ul>
<h3 id="toolbar-1"><span class="header-section-number">25.8.5</span> Toolbar</h3>
<p><img src="ROOTUsersGuide_files/03000217.png"></p>
<p>A toolbar (<strong><code>TGToolBar</code></strong>) is a composite frame that contains <strong><code>TGPictureButton</code></strong>objects.
 It provides an easy and fast access to most frequently used commands or
 options across multiple application screens. Also, it invokes easily a 
sub application within an application. All its functions can be obtained
 by application menus. It is located horizontally at the top of the main
 window just below the menu bar. All other subtask and sub-feature bars 
are positioned along sides of window.</p>
<div class="sourceCode" id="cb1246"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1246-1" title="1"><span class="co">// toolbar icon files</span></a>
<a class="sourceLine" id="cb1246-2" title="2"><span class="at">const</span> <span class="dt">char</span> *xpms[] = {</a>
<a class="sourceLine" id="cb1246-3" title="3">   <span class="st">"x_pic.xpm"</span>,</a>
<a class="sourceLine" id="cb1246-4" title="4">   <span class="st">"y_pic.xpm"</span>,</a>
<a class="sourceLine" id="cb1246-5" title="5">   <span class="st">"z_pic.xpm"</span>,</a>
<a class="sourceLine" id="cb1246-6" title="6">   <span class="dv">0</span></a>
<a class="sourceLine" id="cb1246-7" title="7">};</a>
<a class="sourceLine" id="cb1246-8" title="8"><span class="co">// toolbar tool tip text</span></a>
<a class="sourceLine" id="cb1246-9" title="9"><span class="at">const</span> <span class="dt">char</span> *tips[] = {</a>
<a class="sourceLine" id="cb1246-10" title="10">   <span class="st">"X Settings"</span>,</a>
<a class="sourceLine" id="cb1246-11" title="11">   <span class="st">"Y Settings"</span>,</a>
<a class="sourceLine" id="cb1246-12" title="12">   <span class="st">"Z Settings"</span>,</a>
<a class="sourceLine" id="cb1246-13" title="13">   <span class="dv">0</span></a>
<a class="sourceLine" id="cb1246-14" title="14">};</a>
<a class="sourceLine" id="cb1246-15" title="15"><span class="co">// toolbar button separator</span></a>
<a class="sourceLine" id="cb1246-16" title="16"><span class="dt">int</span> separator = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1246-17" title="17"></a>
<a class="sourceLine" id="cb1246-18" title="18"><span class="co">// structure containing toolbar button information</span></a>
<a class="sourceLine" id="cb1246-19" title="19"><span class="dt">ToolBarData_t</span> t[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb1246-20" title="20"></a>
<a class="sourceLine" id="cb1246-21" title="21"><span class="co">// creation of a toolbar object as a child of main frame</span></a>
<a class="sourceLine" id="cb1246-22" title="22">TGToolBar *tb = <span class="kw">new</span> TGToolBar(fMain,<span class="dv">520</span>,<span class="dv">80</span>);</a>
<a class="sourceLine" id="cb1246-23" title="23"></a>
<a class="sourceLine" id="cb1246-24" title="24"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb1246-25" title="25">   <span class="co">// filling the ToolBarData_t with information</span></a>
<a class="sourceLine" id="cb1246-26" title="26">   t[i].fPixmap   = xpms[i];   <span class="co">// icon file</span></a>
<a class="sourceLine" id="cb1246-27" title="27">   t[i].fTipText  = tips[i];   <span class="co">// tool tip text</span></a>
<a class="sourceLine" id="cb1246-28" title="28">   t[i].fStayDown = kFALSE;    <span class="co">// button behavior if clicked</span></a>
<a class="sourceLine" id="cb1246-29" title="29">   t[i].fId = i+<span class="dv">1</span>;             <span class="co">// button id</span></a>
<a class="sourceLine" id="cb1246-30" title="30">   t[i].fButton = NULL;        <span class="co">// button pointer</span></a>
<a class="sourceLine" id="cb1246-31" title="31"></a>
<a class="sourceLine" id="cb1246-32" title="32">   <span class="cf">if</span> (strlen(xpms[i]) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb1246-33" title="33">      separator = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1246-34" title="34">      <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb1246-35" title="35">   }</a>
<a class="sourceLine" id="cb1246-36" title="36">   tb-&gt;AddButton(fMain,&amp;t[i],separator);</a>
<a class="sourceLine" id="cb1246-37" title="37">   separator = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1246-38" title="38">}</a>
<a class="sourceLine" id="cb1246-39" title="39"><span class="co">// adding the tool bar to the main frame</span></a>
<a class="sourceLine" id="cb1246-40" title="40">fMain-&gt;AddFrame(tb, <span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsExpandX));</a>
<a class="sourceLine" id="cb1246-41" title="41"></a>
<a class="sourceLine" id="cb1246-42" title="42"><span class="co">// adding a horizontal line as a separator</span></a>
<a class="sourceLine" id="cb1246-43" title="43">TGHorizontal3DLine *lh = <span class="kw">new</span> TGHorizontal3DLine(fMain);</a>
<a class="sourceLine" id="cb1246-44" title="44">fMain-&gt;AddFrame(lh, <span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsExpandX));</a></code></pre></div>
<p>To have a tool bar in your application you do not need to do anything
 special - only to create objects: a tool bar and its picture buttons. 
This sample code creates the following three toolbar buttons:</p>
<p><img src="ROOTUsersGuide_files/03000218.png"></p>
<p>First we need to complete a <code>ToolBarData_t</code> structure for each tool bar button before adding it to the tool bar. This structure contains:</p>
<ul>
<li><p>the icon file name “<code>filename.xpm</code>”</p></li>
<li><p>the tool tip text - a short help message explaining the button purpose</p></li>
<li><p>the Boolean variable defining the button behavior when is clicked</p></li>
<li><p><code>kFALSE</code> - do not stay down</p></li>
<li><p><code>kTRUE</code> - to stay down</p></li>
<li><p>the button ID</p></li>
<li><p>the button pointer (<strong><code>TGButton *</code></strong>) - should be <code>NULL</code></p></li>
</ul>
<p>We create an array <code>*xpms[]</code> containing the icon file 
names that will be used for a picture button creation. If you write only
 the file names here ROOT will search these files in <code>$ROOTSYS/icons</code> directory. If the icon files are not there, you should provide the full path name also. The array <code>*tips[]</code>contains
 the tool tip texts for buttons. The integer variable separator is used 
to set the distance between two groups of toolbar buttons. It defines 
the amount of pixels to the left for each button.</p>
<p>We create a tool bar object and add the buttons using the <code>AddButton</code>
 method. The variable separator helps us to define no space between the 
buttons in a group (0), and 5 pixels extra-space before and after. All 
buttons added via this method will be deleted by the toolbar. On return 
the <strong><code>TGButton</code></strong> field of the <code>ToolBarData_t</code>
 structure is filled in (if the icon pixmap was valid). The first 
parameter is the window to which the button messages will be sent. 
Lastly, we create an object of class <strong><code>TGHorizontal3DLine</code></strong> - a horizontal 3D line. It will separate the toolbar from the menu bar because the layout hints we define as <code>kLHintsTop</code> | <code>kLHintsExpandX</code>.</p>
<p>It is user friendly to allow the possibility for the tool bar to be 
turned on or off (via a menu). If you use a single tool bar, it should 
fill the complete width of its parent. When using more than one, you 
should also think about setting the bar size to the end of the most 
right button. This way other bars can be displayed in the same row below
 the menu bar.</p>
<p>Tool bar buttons should have equal size, meaningful and unique icons,
 and short meaningful tool tip text. The related buttons should be 
grouped together by frequency or sequence of use, or importance. 
Potentially destructive buttons must be separated from them to avoid 
accidental activation and potentially catastrophic results. Temporarily 
not available items should be displayed grayed out.</p>
<h3 id="list-boxes"><span class="header-section-number">25.8.6</span> List Boxes</h3>
<p>The purpose of a list box is to display a collection of items from 
which single or multiple selection can be made. It is always visible, 
having a scroll bar when the displayed area is not enough to show all 
items. The choices may be mutually exclusive (a list box with single 
selection) or not mutually exclusive (a list box with multiple 
selection).</p>
<p><img src="ROOTUsersGuide_files/02000219.jpg"></p>
<p>The proper usage of the list boxes is for selecting values, or 
objects, or setting attributes. You have to create them to display 4 to 8
 choices at one time (3 is a required minimum in case of lack of screen 
space). The list should contain not more than 40 items accessible by 
scrolling view (vertical scroll bar). If more are required, you should 
provide a method for using search criteria or scoping the options. The 
best list boxes use is for textual data or choices. They should be wide 
enough to display fully all items. When it is not possible, break the 
long items with ellipsis and provide tool tip that displays the full 
item text.</p>
<p>The list box widget is represented by <strong><code>TGListBox</code></strong>, <strong><code>TGLBContainer</code></strong>, <strong><code>TGLBEntry</code></strong> and <strong><code>TGTextLBEntry</code></strong> classes. Currently entries are simple text strings (<strong><code>TGTextLBEntry</code></strong>). A <strong><code>TGListBox</code></strong> looks a lot like a <strong><code>TGCanvas</code></strong>. It has a <strong><code>TGViewPort</code></strong> containing a <strong><code>TGLBContainer</code></strong>
 which contains the entries and it also has a vertical scrollbar which 
becomes visible if there are more items than fit in the visible part of 
the container. The <strong><code>TGListBox</code></strong> is user 
callable. The other classes are service classes of the list box. Here is
 a sample code showing how to create a list box with ten entries:</p>
<div class="sourceCode" id="cb1247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1247-1" title="1"><span class="co">// list box widget containing 10 entries</span></a>
<a class="sourceLine" id="cb1247-2" title="2"><span class="dt">int</span> fFirstEntry = <span class="dv">0</span>, fLastEntry = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb1247-3" title="3"><span class="dt">char</span> tmp[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb1247-4" title="4">TGListBox *fListBox = <span class="kw">new</span> TGListBox(parent, <span class="dv">90</span>);</a>
<a class="sourceLine" id="cb1247-5" title="5"><span class="cf">for</span> (i = fFirstEntry; i &lt; fLastEntry; i++) {</a>
<a class="sourceLine" id="cb1247-6" title="6">   sprintf(tmp, <span class="st">"Entry </span><span class="sc">%i</span><span class="st">"</span>, i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1247-7" title="7">   fListBox-&gt;AddEntry(tmp, i);</a>
<a class="sourceLine" id="cb1247-8" title="8">}</a>
<a class="sourceLine" id="cb1247-9" title="9">fListBox-&gt;Resize(<span class="dv">150</span>, <span class="dv">80</span>);</a>
<a class="sourceLine" id="cb1247-10" title="10">parent-&gt;AddFrame(fListBox,<span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsLeft,</a>
<a class="sourceLine" id="cb1247-11" title="11">                                            <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>));</a></code></pre></div>
<p>We create the list box widget passing the parent window pointer and 
giving an ID number. Next we add entries with specified string and ID to
 the list box. Before adding the list box to its parent widget, it 
should be resized via <code>Resize(width, height)</code> method. The list box width and height are in pixels. The default entry layout hints are <code>kLHintsExpandX | kLHintsTop</code>. If you want to add entries using different ones, call the method:</p>
<div class="sourceCode" id="cb1248"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1248-1" title="1">TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);</a></code></pre></div>
<p>It adds the specified <strong><code>TGLBEntry</code></strong> and <strong><code>TGLayoutHints</code></strong>
 to the list box. There are several methods providing a flexible entry 
manipulation: you can insert, add or remove list box items dynamically. 
The list box entry IDs are used in these methods and also in event 
processing routines. In our example the integer variables <code>fFirstEntry</code> and <code>fLastEntry</code>
 contain the information about the first and last entry IDs. You can add
 or remove a list box entry using them in the following way:</p>
<div class="sourceCode" id="cb1249"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1249-1" title="1"><span class="co">// adding an entry</span></a>
<a class="sourceLine" id="cb1249-2" title="2">fLastEntry++;</a>
<a class="sourceLine" id="cb1249-3" title="3">sprintf(tmp, <span class="st">"Entry </span><span class="sc">%i</span><span class="st">"</span>, fLastEntry);</a>
<a class="sourceLine" id="cb1249-4" title="4">fListBox-&gt;AddEntry(tmp, fLastEntry);</a>
<a class="sourceLine" id="cb1249-5" title="5">fListBox-&gt;MapSubwindows();</a>
<a class="sourceLine" id="cb1249-6" title="6">fListBox-&gt;Layout();</a>
<a class="sourceLine" id="cb1249-7" title="7">. . .</a>
<a class="sourceLine" id="cb1249-8" title="8"><span class="co">// removing an entry</span></a>
<a class="sourceLine" id="cb1249-9" title="9"><span class="cf">if</span> (fFirstEntry &lt; fLastEntry) {</a>
<a class="sourceLine" id="cb1249-10" title="10">   fListBox-&gt;RemoveEntry(fFirstEntry);</a>
<a class="sourceLine" id="cb1249-11" title="11">   fListBox-&gt;Layout();</a>
<a class="sourceLine" id="cb1249-12" title="12">   fFirstEntry++;</a>
<a class="sourceLine" id="cb1249-13" title="13">}</a></code></pre></div>
<p>A single-selection list box is used for selecting only one item in a list.</p>
<p>A multiple-selection list box permits selection of more than one 
item. The selected choices should be visible - you have several choices 
to do this:</p>
<ul>
<li><p>to mark selected choices with a check mark or highlight them</p></li>
<li><p>to provide a summary list box to the right of the list box, containing the selected choices</p></li>
<li><p>to provide a display-only text control indicating the number of 
selected choices (its position should be justified upper-right above the
 list box)</p></li>
<li><p>if the actions <code>Select All</code> or <code>Deselect All</code> must be quickly or frequently performed, use command buttons</p></li>
</ul>
<h3 id="combo-boxes"><span class="header-section-number">25.8.7</span> Combo Boxes</h3>
<p>A combo box is as single-selection list box that shows only the 
currently selected entry and a prompt button displayed as a downward 
arrow. The prompt button provides a visual cue that a list box is 
hidden. Its main advantage is consuming of quite a bit of screen space. 
When the user clicks on it, a list pops up, from which a new choice can 
be made. After a new item is chosen the combo box folds again showing 
the new selection.</p>
<p><img src="ROOTUsersGuide_files/0200021A.jpg"></p>
<p>The combo box widget is represented by the user callable class <strong><code>TGComboBox</code></strong>. The class <strong><code>TGComboBoxPopup</code></strong>
 is a service class. The combo box constructor is very similar to the 
list box one. The first parameter is a parent widget pointer again, the 
second - an integer value that will be used as combo box ID. The method 
used for adding entries is very similar to the list box method we used 
before. The method <code>Select(entryID)</code> sets the current combo box entry.</p>
<div class="sourceCode" id="cb1250"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1250-1" title="1"><span class="dt">char</span> tmp[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb1250-2" title="2"><span class="co">// combo box layout hints</span></a>
<a class="sourceLine" id="cb1250-3" title="3">fLcombo = <span class="kw">new</span> TGLayoutHints(kLHintsTop | kLHintsLeft,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1250-4" title="4"><span class="co">// combo box widget</span></a>
<a class="sourceLine" id="cb1250-5" title="5">TGComboBox *fCombo = <span class="kw">new</span> TGComboBox(parent,<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb1250-6" title="6"><span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {</a>
<a class="sourceLine" id="cb1250-7" title="7">   sprintf(tmp, <span class="st">"Entry</span><span class="sc">%i</span><span class="st">"</span>, i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1250-8" title="8">   fCombo-&gt;AddEntry(tmp, i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1250-9" title="9">}</a>
<a class="sourceLine" id="cb1250-10" title="10">fCombo-&gt;Resize(<span class="dv">150</span>, <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1250-11" title="11"><span class="co">// Entry3 is selected as current</span></a>
<a class="sourceLine" id="cb1250-12" title="12">fCombo-&gt;Select(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1250-13" title="13">parent-&gt;AddFrame(fCombo, fLcombo);</a></code></pre></div>
<p>You have the same flexibility to add, insert or remove entries. As 
with list boxes you can retrieve the information for currently selected 
item via <code>GetSelected</code> or <code>GetSelectedEntry</code> methods. The first one returns the entry ID, the second - the current entry pointer (<strong><code>TGLBEntry *</code></strong>).</p>
<h3 id="sliders"><span class="header-section-number">25.8.8</span> Sliders</h3>
<p>A slider is a scale with an indicator (slider) that you can drag to 
choose a value from a predefined range. It may be oriented horizontally 
or vertically. In both cases it provides an excellent indication of 
where a value exists within a range of values.</p>
<p><img src="ROOTUsersGuide_files/0200021B.jpg"></p>
<p>The class <strong><code>TGHSlider</code></strong> represents the horizontal slider; <strong><code>TGVSlider</code></strong> - the vertical one. Both inherit from the base class <strong><code>TGSlider</code></strong>
 that creates the main slider parameters: the range of values within a 
value can be selected; the indicator type; the tick mark scale. Using 
its methods <code>SetRange</code>, <code>SetPosition</code> and <code>SetScale</code> you can set these parameters. To retrieve the set slider value you can call <code>GetPosition</code> method.</p>
<p>Next sample code creates a horizontal slider <code>hslider</code> with a tick mark of type <code>kSlider1</code>. Its width is 150 pixels, and its scale is placed down (<code>kScaleDownRight</code>). The last parameter in the <strong><code>TGHSlider</code></strong> constructor is the slider ID. It will be used for event processing. The methods <code>SetRange</code> and <code>SetPosition</code> set the range and the current tick mark position of the slider.</p>
<div class="sourceCode" id="cb1251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1251-1" title="1">hslider = <span class="kw">new</span> TGHSlider(parent,<span class="dv">150</span>,kSlider1|kScaleDownRight,sID);</a>
<a class="sourceLine" id="cb1251-2" title="2">hslider-&gt;SetRange(<span class="dv">0</span>,<span class="dv">50</span>);</a>
<a class="sourceLine" id="cb1251-3" title="3">hslider-&gt;SetPosition(<span class="dv">39</span>);</a></code></pre></div>
<p>Slider values can be set by using the mouse to drag the slider across
 the scale until the desired value is reached. Another way is to click 
in the slider trough instead of dragging.</p>
<h4 id="double-slider"><span class="header-section-number">25.8.8.1</span> Double Slider</h4>
<p>Double slider widgets allow easy selection of a min and a max value 
out of a range. They can be either horizontal or vertical oriented. 
There is a choice of different types of tick marks: <code>kDoubleScaleNo</code>, <code>kScaleDownRight</code>, <code>kDoubleScaleBoth</code>.</p>
<p>To change the <code>min</code> value you should press the left mouse button near to the left (<strong><code>TGDoubleHSlider</code></strong>) or bottom (<strong><code>TGDoubleHSlider</code></strong>) edge of the slider. Alternatively, to change the <code>max</code> value you need to press the mouse near to the right (<strong><code>TGDoubleHSlider</code></strong>) or top (<strong><code>TGDoubleHSlider</code></strong>)
 edge of the slider. To change both values simultaneously you should 
press the left mouse button near to the center of the slider.</p>
<p><img src="ROOTUsersGuide_files/0200021C.jpg"></p>
<p><strong><code>TGDoubleSlider</code></strong> is an abstract base class that creates the main slider parameters. The concrete class to use for a vertical double slider is <strong><code>TGDoubleVSlider</code></strong> and <strong><code>TGDoubleHSlider</code></strong> for a horizontal one. The double slider constructors are similar to those of the other sliders. If you set <code>kDoubleScaleNo</code> as a scale parameter no scale will be drawn. Here is an example:</p>
<div class="sourceCode" id="cb1252"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1252-1" title="1">vDslider = <span class="kw">new</span> TGDoubleVSlider(p,<span class="dv">100</span>,kDoubleScaleNo,dsliderID);</a>
<a class="sourceLine" id="cb1252-2" title="2">vDslider-&gt;SetRange(-<span class="dv">10</span>,<span class="dv">10</span>);</a></code></pre></div>
<h3 id="triple-slider"><span class="header-section-number">25.8.9</span> Triple Slider</h3>
<p>The new <strong><code>TGTripleHSlider</code></strong> and <strong><code>TGTripleVSlider</code></strong>
 classes inherit from the double slider widgets and allow easy selection
 of a range and a pointer value. The pointer position can be constrained
 into the selected range or can be relative to it.</p>
<p><img src="ROOTUsersGuide_files/0300021D.png"></p>
<p>To change the slider range value press the left mouse button near to 
the left/right (top/bottom) edges of the slider. To change both values 
simultaneously press the mouse button near to the slider center. To 
change pointer value press the mouse on the pointer and drag it to the 
desired position.</p>
<div class="sourceCode" id="cb1253"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1253-1" title="1">fSlider = <span class="kw">new</span> TGTripleHSlider(parent,<span class="dv">100</span>,kDoubleScaleBoth,kSLD_ID,</a>
<a class="sourceLine" id="cb1253-2" title="2">                              kHorizontalFrame);</a>
<a class="sourceLine" id="cb1253-3" title="3">parent-&gt;AddFrame(fSlider,<span class="kw">new</span> TGLayoutHints(kLHintsExpandX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>));</a>
<a class="sourceLine" id="cb1253-4" title="4">fSlider-&gt;SetConstrained(kTRUE);</a>
<a class="sourceLine" id="cb1253-5" title="5">fSlider-&gt;SetRange(rmin, rmax);</a>
<a class="sourceLine" id="cb1253-6" title="6">fSlider-&gt;SetPosition(pmin, pmax);</a>
<a class="sourceLine" id="cb1253-7" title="7">fSlider -&gt;SetPointerPosition(pvalue);</a></code></pre></div>
<h3 id="progress-bars"><span class="header-section-number">25.8.10</span> Progress Bars</h3>
<p>A progress bar is a widget that shows that an operation is in 
progress and how much time is left. It is a long rectangular bar, 
initially empty, that fills with a color as a process is being 
performed. The filled-in area indicates the percentage of the process 
that has been completed. You should use this widget for waits exceeding <code>one minute</code>.
 For a very time consuming operation it is better to break the operation
 into subtasks and provide a progress bar for each of them.</p>
<p><img src="ROOTUsersGuide_files/0200021E.jpg"></p>
<p>A progress bar may be oriented horizontally or vertically. The 
horizontally oriented progress bar fills with a color from left to 
right; the vertically oriented - from bottom to top. A percent complete 
message provides an indication of the completed part of the process. It 
is a good practice to include some descriptive text of the process to 
keep users informed and entertained while they are waiting for process 
completion.</p>
<p>The picture below shows the progress bars you can create using the classes <strong><code>TGProgressBar</code></strong>, <strong><code>TGHProgressBar</code></strong>, and <strong><code>TGHProgressBar</code></strong>.</p>
<div class="sourceCode" id="cb1254"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1254-1" title="1"><span class="co">// vertical frame with three horizontal progressive bars</span></a>
<a class="sourceLine" id="cb1254-2" title="2">TGVerticalFrame *vframe = <span class="kw">new</span> TGVerticalFrame(fMain, <span class="dv">10</span>, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1254-3" title="3">fHProg1 = <span class="kw">new</span> TGHProgressBar(vframe,TGProgressBar::kStandard,<span class="dv">300</span>);</a>
<a class="sourceLine" id="cb1254-4" title="4">fHProg1-&gt;ShowPosition();</a>
<a class="sourceLine" id="cb1254-5" title="5">fHProg1-&gt;SetBarColor(<span class="st">"yellow"</span>);</a>
<a class="sourceLine" id="cb1254-6" title="6">fHProg2 = <span class="kw">new</span> TGHProgressBar(vframe,TGProgressBar::kFancy,<span class="dv">300</span>);</a>
<a class="sourceLine" id="cb1254-7" title="7">fHProg2-&gt;SetBarColor(<span class="st">"lightblue"</span>);</a>
<a class="sourceLine" id="cb1254-8" title="8">fHProg2-&gt;ShowPosition(kTRUE,kFALSE,<span class="st">"%.0f events"</span>);</a>
<a class="sourceLine" id="cb1254-9" title="9">fHProg3 = <span class="kw">new</span> TGHProgressBar(vframe,TGProgressBar::kStandard,<span class="dv">300</span>);</a>
<a class="sourceLine" id="cb1254-10" title="10">fHProg3-&gt;SetFillType(TGProgressBar::kBlockFill);</a>
<a class="sourceLine" id="cb1254-11" title="11"></a>
<a class="sourceLine" id="cb1254-12" title="12">vframe-&gt;AddFrame(fHProg1,<span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsLeft|</a>
<a class="sourceLine" id="cb1254-13" title="13">                                        kLHintsExpandX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">10</span>));</a>
<a class="sourceLine" id="cb1254-14" title="14">vframe-&gt;AddFrame(fHProg2,<span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsLeft|</a>
<a class="sourceLine" id="cb1254-15" title="15">                                        kLHintsExpandX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">10</span>));</a>
<a class="sourceLine" id="cb1254-16" title="16">vframe-&gt;AddFrame(fHProg3,<span class="kw">new</span> TGLayoutHints(kLHintsTop|kLHintsLeft|</a>
<a class="sourceLine" id="cb1254-17" title="17">                                        kLHintsExpandX,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">10</span>));</a>
<a class="sourceLine" id="cb1254-18" title="18">vframe-&gt;Resize(<span class="dv">200</span>, <span class="dv">200</span>);</a></code></pre></div>
<h3 id="static-widgets"><span class="header-section-number">25.8.11</span> Static Widgets</h3>
<p>The classes <strong><code>TGLabel</code></strong> and <strong><code>TGIcon</code></strong>
 show some information - text or graphics. The line below creates a 
label object. The syntax is very simple: you specify the parent widget 
and a string object holding the desired text.</p>
<div class="sourceCode" id="cb1255"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1255-1" title="1">TGLabel *label = <span class="kw">new</span> TGLabel(parentWidget, <span class="st">"Label's string"</span>);</a></code></pre></div>
<p>Next sample creates an icon object. First we create an object of type <strong><code>TGPicture</code></strong>. The <strong><code>TGPicture</code></strong> objects are never created directly by the application code. We call <strong><code>TGClient</code></strong> telling it the pixmap’s file name to create a <strong><code>TGPicture</code></strong>
 object and, in turn, it will return a pointer to the created object. If
 the pixmap file cannot be found the returned pointer will be <code>NULL</code>. As usual, the first parameter of a <strong><code>TGIcon</code></strong> constructor is the parent frame. The second one is the <strong><code>TGPicture</code></strong>
 object holding the pixmap we want to show. Last two parameters define 
the width and height of pixmap in pixels. In the end we add the created 
icon object to its parent.</p>
<div class="sourceCode" id="cb1256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1256-1" title="1"><span class="co">// icon widget</span></a>
<a class="sourceLine" id="cb1256-2" title="2"><span class="at">const</span> TGPicture *ipic=(TGPicture *)gClient-&gt;GetPicture(<span class="st">"leaf.xpm"</span>);</a>
<a class="sourceLine" id="cb1256-3" title="3">TGIcon *icon = <span class="kw">new</span> TGIcon(parent,ipic,<span class="dv">40</span>,<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb1256-4" title="4">parent-&gt;AddFrame(icon,<span class="kw">new</span> TGLayoutHints(kLHintsLeft|kLHintsBottom,</a>
<a class="sourceLine" id="cb1256-5" title="5">                                        <span class="dv">1</span>, <span class="dv">15</span>, <span class="dv">1</span>, <span class="dv">1</span>));</a></code></pre></div>
<p>The <strong><code>TGPicture</code></strong> objects are cached by <strong><code>TGClient</code></strong> in order to keep the resource usage low and to improve the efficiency of the client-server windowing systems. <strong><code>TGClient</code></strong>
 will check whether a pixmap with the same name was already loaded 
before to register a new picture object. If it finds it, it will return a
 pointer to the existing object. Also, it will increase the usage 
counter for the object.</p>
<p>All <strong><code>TGPicture</code></strong> objects are managed by the class <strong><code>TGPicturePool</code></strong>. <strong><code>TGClient</code></strong>
 creates an object of this type upon initialization. Normally your 
application program does not deal directly with this class because all 
manipulations go through <strong><code>TGClient</code></strong> class.</p>
<p>Once you have finished with using of the <strong><code>TGPicture</code></strong> object, you should call the method <strong><code>TGClient::FreePicture(const TGPicture *pic)</code></strong> to free it. The usage counter of the picture object will be decreased and when it reaches zero - the <strong><code>TGPicture</code></strong> object will be deleted.</p>
<h3 id="status-bar"><span class="header-section-number">25.8.12</span> Status Bar</h3>
<p>The status bar widget is used to display some information about the 
current application state: what is being viewed in the window, a 
descriptive message about selected objects, or other no interactive 
information. It may also be used to explain highlighted menu and tool 
bar items.</p>
<p><img src="ROOTUsersGuide_files/0200021F.jpg"></p>
<p>An application can only have one status bar at a time.</p>
<p>There is nothing special to create a status bar in your application. 
You should decide how many fields you need to present the current 
application state to the user. By default a status bar consists of one 
part. Multiple parts can be created by <code>SetParts</code> method. Its
 first parameter is an array of integers that give the percentage size 
of each part. The second parameter gives the number of status bar parts.
 Using <code>SetText</code> method you can set a text for any part.</p>
<div class="sourceCode" id="cb1257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1257-1" title="1"><span class="co">// status bar</span></a>
<a class="sourceLine" id="cb1257-2" title="2"><span class="dt">Int_t</span> parts[] = {<span class="dv">33</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">47</span>};</a>
<a class="sourceLine" id="cb1257-3" title="3">fStatusBar = <span class="kw">new</span> TGStatusBar(fMain,<span class="dv">50</span>,<span class="dv">10</span>,kHorizontalFrame);</a>
<a class="sourceLine" id="cb1257-4" title="4">fStatusbar-&gt;SetParts(parts,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb1257-5" title="5">fMain-&gt;AddFrame(fStatusBar, <span class="kw">new</span> TGLayoutHints(kLHintsBottom |</a>
<a class="sourceLine" id="cb1257-6" title="6">                kLHintsLeft | kLHintsExpandX, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1257-7" title="7">. . .</a>
<a class="sourceLine" id="cb1257-8" title="8"><span class="co">// fill status bar fields with information; selected is the object</span></a>
<a class="sourceLine" id="cb1257-9" title="9"><span class="co">// below the cursor; atext contains pixel coordinates info</span></a>
<a class="sourceLine" id="cb1257-10" title="10">fStatusBar-&gt;SetText(selected-&gt;GetTitle(),<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1257-11" title="11">fStatusBar-&gt;SetText(selected-&gt;GetName(),<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1257-12" title="12">fStatusBar-&gt;SetText(atext,<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1257-13" title="13">fStatusBar-&gt;SetText(selected-&gt;GetObjectInfo(px,py),<span class="dv">3</span>);</a></code></pre></div>
<h3 id="splitters"><span class="header-section-number">25.8.13</span> Splitters</h3>
<p>A window can be split into two parts (panes) by using a horizontal or
 a vertical splitter. A horizontal splitter resizes the frames above and
 below of it; a vertical splitter resizes the frames left and right of 
it.</p>
<p><img src="ROOTUsersGuide_files/02000220.jpg"></p>
<p>This widget is represented by <strong><code>TGSplitter</code></strong>, <strong><code>TGHSplitter</code></strong>, and <strong><code>TGVSplitter</code></strong>
 classes. Currently there is no special graphics representation for 
splitter widgets; only the cursor changes when crossing a splitter.</p>
<p>There is nothing special to create a splitter - two lines of code only:</p>
<div class="sourceCode" id="cb1258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1258-1" title="1">TGHSplitter *hsplitter = <span class="kw">new</span> TGHSplitter(fVf);</a>
<a class="sourceLine" id="cb1258-2" title="2">hsplitter-&gt;SetFrame(fH1,kTRUE);</a></code></pre></div>
<p>You call a horizontal <strong><code>TGHSplitter</code></strong> or a vertical <strong><code>TGVSplitter</code></strong> splitter constructor and after you set the frame to be resized via <code>SetFrame</code> method. In spite of that, there are rules to be followed when you create a splitter in your application.</p>
<p>For a <code>horizontal</code> splitter they are:</p>
<ul>
<li><p>the parent of a horizontal splitter must inherit from <strong><code>TGCompoziteFrame</code></strong> and must have a vertical layout</p></li>
<li><p>the <code>above</code> resized frame must have <code>kFixedHeight</code> option set</p></li>
<li><p>use layout hints <code>kLHintsTop | kLHintsExpandX</code> when adding the <strong><code>above</code></strong> resized frame to its parent</p></li>
<li><p>use layout hints <code>kLHintsBottom | kLHintsExpandX | kLHintsExpandY</code> when adding the bottom resized frame to its parent</p></li>
<li><p>set the <strong><code>above</code></strong> frame to be resized using <code>SetFrame</code> method; the second parameter should be <code>kTRUE</code></p></li>
</ul>
<p>You can see these rules in the code below:</p>
<div class="sourceCode" id="cb1259"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1259-1" title="1"><span class="co">// Create horizontal splitter</span></a>
<a class="sourceLine" id="cb1259-2" title="2">fVf = <span class="kw">new</span> TGVerticalFrame(fMain,<span class="dv">10</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1259-3" title="3">fH1 = <span class="kw">new</span> TGHorizontalFrame(fVf,<span class="dv">10</span>,<span class="dv">10</span>, kFixedHeight);</a>
<a class="sourceLine" id="cb1259-4" title="4">fH2 = <span class="kw">new</span> TGHorizontalFrame(fVf,<span class="dv">10</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1259-5" title="5">fFtop = <span class="kw">new</span> TGCompositeFrame(fH1,<span class="dv">10</span>,<span class="dv">10</span>, kSunkenFrame);</a>
<a class="sourceLine" id="cb1259-6" title="6">fFbottom = <span class="kw">new</span> TGCompositeFrame(fH2,<span class="dv">10</span>,<span class="dv">10</span>,kSunkenFrame);</a>
<a class="sourceLine" id="cb1259-7" title="7">fLtop = <span class="kw">new</span> TGLabel(fFtop,<span class="st">"Top Frame"</span>);</a>
<a class="sourceLine" id="cb1259-8" title="8">fLbottom = <span class="kw">new</span> TGLabel(fFbottom,<span class="st">"Bottom Frame"</span>);</a>
<a class="sourceLine" id="cb1259-9" title="9"></a>
<a class="sourceLine" id="cb1259-10" title="10">fFtop-&gt;AddFrame(fLtop, <span class="kw">new</span> TGLayoutHints(kLHintsLeft |</a>
<a class="sourceLine" id="cb1259-11" title="11">                kLHintsCenterY,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1259-12" title="12">fFbottom-&gt;AddFrame(fLbottom, <span class="kw">new</span> TGLayoutHints(kLHintsLeft |</a>
<a class="sourceLine" id="cb1259-13" title="13">                   kLHintsCenterY,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1259-14" title="14">fH1-&gt;AddFrame(fFtop, <span class="kw">new</span> TGLayoutHints(kLHintsTop |</a>
<a class="sourceLine" id="cb1259-15" title="15">              kLHintsExpandY | kLHintsExpandX,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>));</a>
<a class="sourceLine" id="cb1259-16" title="16">fH2-&gt;AddFrame(fFbottom,<span class="kw">new</span> TGLayoutHints(kLHintsTop |</a>
<a class="sourceLine" id="cb1259-17" title="17">              kLHintsExpandY | kLHintsExpandX,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>));</a>
<a class="sourceLine" id="cb1259-18" title="18">fH1-&gt;Resize(fFtop-&gt;GetDefaultWidth(),fH1-&gt;GetDefaultHeight()+<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1259-19" title="19">fH2-&gt;Resize(fFbottom-&gt;GetDefaultWidth(),fH2-&gt;GetDefaultHeight()+<span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1259-20" title="20">fVf-&gt;AddFrame(fH1, <span class="kw">new</span> TGLayoutHints(kLHintsTop | kLHintsExpandX));</a>
<a class="sourceLine" id="cb1259-21" title="21"></a>
<a class="sourceLine" id="cb1259-22" title="22">TGHSplitter *hsplitter = <span class="kw">new</span> TGHSplitter(fVf);</a>
<a class="sourceLine" id="cb1259-23" title="23">hsplitter-&gt;SetFrame(fH1,kTRUE);</a>
<a class="sourceLine" id="cb1259-24" title="24">fVf-&gt;AddFrame(hsplitter,<span class="kw">new</span> TGLayoutHints(kLHintsTop |</a>
<a class="sourceLine" id="cb1259-25" title="25">              kLHintsExpandX));</a>
<a class="sourceLine" id="cb1259-26" title="26">fVf-&gt;AddFrame(fH2, <span class="kw">new</span> TGLayoutHints(kLHintsBottom |</a>
<a class="sourceLine" id="cb1259-27" title="27">              kLHintsExpandX | kLHintsExpandY));</a></code></pre></div>
<p>For a <code>vertical</code> splitter the rules are:</p>
<ul>
<li><p>the parent of a vertical splitter must inherit from <strong><code>TGCompoziteFrame</code></strong> and must have a horizontal layout</p></li>
<li><p>the <code>left</code> resized frame must have <code>kFixedWidth</code> option set</p></li>
<li><p>use layout hints <code>kLHintsLeft | kLHintsExpandY</code> when adding the <code>left</code> resized frame to the parent</p></li>
<li><p>use layout hints <code>kLHintsRight|kLHintsExpandX |kLHintsExpandY</code> when adding the right resized frame to the parent</p></li>
<li><p>set the <code>left</code> frame to be resized using <code>SetFrame</code> method; the second parameter should be <code>kTRUE</code></p></li>
</ul>
<p>Next is a sample code for a vertical splitter:</p>
<div class="sourceCode" id="cb1260"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1260-1" title="1"><span class="co">// Create vertical splitter</span></a>
<a class="sourceLine" id="cb1260-2" title="2">fHf = <span class="kw">new</span> TGHorizontalFrame(fMain, <span class="dv">50</span>, <span class="dv">50</span>);</a>
<a class="sourceLine" id="cb1260-3" title="3">fV1 = <span class="kw">new</span> TGVerticalFrame(fHf, <span class="dv">10</span>, <span class="dv">10</span>, kFixedWidth);</a>
<a class="sourceLine" id="cb1260-4" title="4">fV2 = <span class="kw">new</span> TGVerticalFrame(fHf, <span class="dv">10</span>, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1260-5" title="5">fFleft = <span class="kw">new</span> TGCompositeFrame(fV1, <span class="dv">10</span>, <span class="dv">10</span>, kSunkenFrame);</a>
<a class="sourceLine" id="cb1260-6" title="6">fFright = <span class="kw">new</span> TGCompositeFrame(fV2, <span class="dv">10</span>, <span class="dv">10</span>, kSunkenFrame);</a>
<a class="sourceLine" id="cb1260-7" title="7"></a>
<a class="sourceLine" id="cb1260-8" title="8">fLleft = <span class="kw">new</span> TGLabel(fFleft, <span class="st">"Left Frame"</span>);</a>
<a class="sourceLine" id="cb1260-9" title="9">fLright = <span class="kw">new</span> TGLabel(fFright, <span class="st">"Right Frame"</span>);</a>
<a class="sourceLine" id="cb1260-10" title="10"></a>
<a class="sourceLine" id="cb1260-11" title="11">fFleft-&gt;AddFrame(fLleft, <span class="kw">new</span> TGLayoutHints(kLHintsLeft |</a>
<a class="sourceLine" id="cb1260-12" title="12">                 kLHintsCenterY,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1260-13" title="13">fFright-&gt;AddFrame(fLright, <span class="kw">new</span> TGLayoutHints(kLHintsLeft |</a>
<a class="sourceLine" id="cb1260-14" title="14">                  kLHintsCenterY,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1260-15" title="15">fV1-&gt;AddFrame(fFleft,<span class="kw">new</span> TGLayoutHints(kLHintsTop |</a>
<a class="sourceLine" id="cb1260-16" title="16">              kLHintsExpandX | kLHintsExpandY,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">5</span>));</a>
<a class="sourceLine" id="cb1260-17" title="17">fV2-&gt;AddFrame(fFright,<span class="kw">new</span> TGLayoutHints(kLHintsTop |</a>
<a class="sourceLine" id="cb1260-18" title="18">              kLHintsExpandX | kLHintsExpandY, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">5</span>));</a>
<a class="sourceLine" id="cb1260-19" title="19">fV1-&gt;Resize(fFleft-&gt;GetDefaultWidth()+<span class="dv">20</span>, fV1-&gt;GetDefaultHeight());</a>
<a class="sourceLine" id="cb1260-20" title="20">fV2-&gt;Resize(fFright-&gt;GetDefaultWidth(), fV1-&gt;GetDefaultHeight());</a>
<a class="sourceLine" id="cb1260-21" title="21">fHf-&gt;AddFrame(fV1,<span class="kw">new</span> TGLayoutHints(kLHintsLeft | kLHintsExpandY));</a>
<a class="sourceLine" id="cb1260-22" title="22"></a>
<a class="sourceLine" id="cb1260-23" title="23">splitter = <span class="kw">new</span> TGVSplitter(fHf,<span class="dv">2</span>,<span class="dv">30</span>);</a>
<a class="sourceLine" id="cb1260-24" title="24">splitter-&gt;SetFrame(fV1, kTRUE);</a>
<a class="sourceLine" id="cb1260-25" title="25">fHf-&gt;AddFrame(splitter,<span class="kw">new</span> TGLayoutHints(kLHintsLeft |</a>
<a class="sourceLine" id="cb1260-26" title="26">                                         kLHintsExpandY));</a>
<a class="sourceLine" id="cb1260-27" title="27">fHf-&gt;AddFrame(fV2,<span class="kw">new</span> TGLayoutHints(kLHintsRight | kLHintsExpandX |</a>
<a class="sourceLine" id="cb1260-28" title="28">                                    kLHintsExpandY));</a></code></pre></div>
<h3 id="tgcanvas-viewport-and-container"><span class="header-section-number">25.8.14</span> TGCanvas, ViewPort and Container</h3>
<p>When all display information cannot be presented in a window, the additional information must be found and made visible. A <strong><code>TGCanvas</code></strong> is a frame containing two scrollbars (horizontal and vertical) and a viewport (<strong><code>TGViewPort</code></strong>). The viewport acts as the window through which we look at the contents of the container frame. A <strong><code>TGContainer</code></strong>
 frame manages a content area. It can display and control a hierarchy of
 multi-column items, and provides the ability to add new items at any 
time. By default it doesn’t map sub-windows, which are items of the 
container. In this case sub-window must provide <code>DrawCopy</code> method, see for example <strong><code>TGLVEntry</code></strong>
 class. It is also possible to use option which allows mapping 
sub-windows. This option has much slower drawing speed in case of more 
than 1000 items placed in container. To activate this option the 
fMapSubwindows data member must be set to <code>kTRUE</code> (for example <strong><code>TTVLVContainer</code></strong> class).</p>
<p>A scroll bar only is available when scrolling is necessary. It 
consists of three elements: a slider box and two directional scroll 
arrows (buttons).</p>
<div class="sourceCode" id="cb1261"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1261-1" title="1">fCanvas = <span class="kw">new</span> TGCanvas(parent, w, h);</a>
<a class="sourceLine" id="cb1261-2" title="2">fContents = <span class="kw">new</span> TGListTree(fCanvas, kHorizontalFrame);</a>
<a class="sourceLine" id="cb1261-3" title="3">fContents-&gt;Associate(parent);</a>
<a class="sourceLine" id="cb1261-4" title="4">parent-&gt;AddFrame(fCanvas, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1261-5" title="5">                                            kLHintsExpandY));</a>
<a class="sourceLine" id="cb1261-6" title="6"><span class="co">// or</span></a>
<a class="sourceLine" id="cb1261-7" title="7">fCanvas = <span class="kw">new</span> TGCanvas(parent, w, h);</a>
<a class="sourceLine" id="cb1261-8" title="8">fContents = <span class="kw">new</span> TGListTree(fCanvas-&gt;GetViewPort(),<span class="dv">100</span>,<span class="dv">100</span>,</a>
<a class="sourceLine" id="cb1261-9" title="9">                           kHorizontalFrame);</a>
<a class="sourceLine" id="cb1261-10" title="10">fContents-&gt;SetCanvas(fCanvas);</a>
<a class="sourceLine" id="cb1261-11" title="11">fContents-&gt;Associate(parent);</a>
<a class="sourceLine" id="cb1261-12" title="12">fCanvas-&gt;SetContainer(fContents);</a>
<a class="sourceLine" id="cb1261-13" title="13">parent-&gt;AddFrame(fCanvas, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1261-14" title="14">                                            kLHintsExpandY));</a></code></pre></div>
<p>The <strong><code>TGContainer</code></strong> class can handle the following keys:</p>
<p>F7, Ctnrl-Factivate a search dialog</p>
<p>F3, Ctnrl-Gcontinue to search</p>
<p>Endgo to the last item in container</p>
<p>Homego to the first item in container</p>
<p>PageUpnavigate up</p>
<p>PageDownnavigate down</p>
<p>arrow keysnavigate inside container</p>
<p>Return/Enterequivalent to double click of the mouse button</p>
<p>Contrl-Aselect all items</p>
<p>Spaceinvert selection.</p>
<h3 id="embedded-canvas"><span class="header-section-number">25.8.15</span> Embedded Canvas</h3>
<p>This class creates a <strong><code>TGCanvas</code></strong> in which a well known ROOT <strong><code>TCanvas</code></strong> is embedded. A pointer to the <strong><code>TCanvas</code></strong> can be obtained via the <code>GetCanvas()</code> member function.</p>
<div class="sourceCode" id="cb1262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1262-1" title="1">fEc1 = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="st">"ec1"</span>,fParent,<span class="dv">100</span>,<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb1262-2" title="2">fParent -&gt;AddFrame(fEc1, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1262-3" title="3">                                           kLHintsExpandY));</a>
<a class="sourceLine" id="cb1262-4" title="4">fEc2 = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="st">"ec2"</span>,fParent,<span class="dv">100</span>,<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb1262-5" title="5">fParent -&gt;AddFrame(fEc2, <span class="kw">new</span> TGLayoutHints(kLHintsExpandX |</a>
<a class="sourceLine" id="cb1262-6" title="6">                                           kLHintsExpandY));</a>
<a class="sourceLine" id="cb1262-7" title="7">fEc1-&gt;GetCanvas()-&gt;SetBorderMode(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1262-8" title="8">fEc2-&gt;GetCanvas()-&gt;SetBorderMode(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1262-9" title="9">fEc1-&gt;GetCanvas()-&gt;SetBit(kNoContextMenu);</a>
<a class="sourceLine" id="cb1262-10" title="10">fEc1-&gt;GetCanvas()-&gt;Connect(<span class="st">"ProcessedEvent(Int_t,Int_t,Int_t,TObject*)"</span>,</a>
<a class="sourceLine" id="cb1262-11" title="11">        <span class="st">"MyClass"</span>, <span class="kw">this</span>, <span class="st">"HandleMyCanvas(Int_t,Int_t,Int_t,TObject*)"</span>);</a></code></pre></div>
<p><img src="ROOTUsersGuide_files/03000221.png"></p>
<p>To embed a canvas derived from a <strong><code>TCanvas</code></strong> do the following:</p>
<div class="sourceCode" id="cb1263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1263-1" title="1">TRootEmbeddedCanvas *embed = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="dv">0</span>, p, w, h);</a>
<a class="sourceLine" id="cb1263-2" title="2"><span class="co">// note name must be 0, not null string ""</span></a>
<a class="sourceLine" id="cb1263-3" title="3"><span class="dt">Int_t</span> wid = embed-&gt;GetCanvasWindowId();</a>
<a class="sourceLine" id="cb1263-4" title="4">TCanvas *myc = <span class="kw">new</span> TCanvas(<span class="st">"myname"</span>,<span class="dv">10</span>,<span class="dv">10</span>,wid);</a>
<a class="sourceLine" id="cb1263-5" title="5">embed-&gt;AdoptCanvas(myc);</a>
<a class="sourceLine" id="cb1263-6" title="6"><span class="co">// the TCanvas is adopted by the embedded canvas and will be</span></a>
<a class="sourceLine" id="cb1263-7" title="7"><span class="co">// destroyed by it</span></a></code></pre></div>
<h2 id="the-root-graphics-editor-ged"><span class="header-section-number">25.9</span> The ROOT Graphics Editor (GED)</h2>
<p>Everything drawn in a ROOT canvas is an object. There are classes for
 all objects, and they fall into hierarchies. In addition, the ROOT has 
fully cross-platform GUI classes and provides all standard components 
for an application environment with common ‘look and feel’. The 
object-oriented, event-driven programming model supports the modern 
signals/slots communication mechanism. It handles user interface actions
 and allows total independence of interacting objects and classes. This 
mechanism uses the ROOT dictionary information and the Cling the C++ 
Interpreter to connect signals to slots methods.</p>
<p>Therefore, all necessary elements for an object-oriented editor 
design are in place. The editor complexity can be reduced by splitting 
it into discrete units of so-called <em><code>object</code></em> <em><code>editors</code></em>.
 Any object editor provides an object specific GUI. The main purpose of 
the ROOT graphics editor is the organization of the object editors’ 
appearance and the task sequence between them.</p>
<h3 id="object-editors"><span class="header-section-number">25.9.1</span> Object Editors</h3>
<p>Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘<em><code>Editor</code></em>’ (e.g.&nbsp;for <strong><code>TGraph</code></strong> objects the object editor is <strong><code>TGraphEditor</code></strong>). Thanks to the signals/slots communication mechanism and to the method <code>DistanceToPrimitive()</code>
 that computes a ‘‘distance’’ to an object from the mouse position, it 
was possible to implement a signal method of the canvas that says which 
is the selected object and to which pad it belongs. Having this 
information the graphics editor loads the corresponding object editor 
and the user interface is ready for use. This way after a click on 
‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad 
editor, etc.</p>
<p>The algorithm in use is simple and is based on the object-oriented 
relationship and communication. When the user activates the editor, 
according to the selected object <strong><code>&lt;obj&gt;</code></strong> in the canvas it looks for a class name <strong><code>&lt;obj&gt;Editor</code></strong>.
 For that reason, the correct naming is very important. If a class with 
this name is found, the editor verifies that this class derives from the
 base editor class <strong><code>TGedFrame</code></strong>. If all 
checks are satisfied, the editor makes an instance of the object editor.
 Then, it scans all object base classes searching the corresponding 
object editors. When it finds one, it makes an instance of the base 
class editor too.</p>
<p>Once the object editor is in place, it sets the user interface 
elements according to the object’s status. After that, it is ready to 
interact with the object following the user actions.</p>
<p>The graphics editor gives an intuitive way to edit objects in a 
canvas with immediate feedback. Complexity of some object editors is 
reduced by hiding GUI elements and revealing them only on users’ 
requests.</p>
<p>An object in the canvas is selected by clicking on it with the left 
mouse button. Its name is displayed on the top of the editor frame in 
red color. If the editor frame needs more space than the canvas window, a
 vertical scroll bar appears for easy navigation.</p>
<figure>
<img src="ROOTUsersGuide_files/03000222.png" alt="Histogram, pad and axis editors"><figcaption>Histogram, pad and axis editors</figcaption>
</figure>
<h3 id="editor-design-elements"><span class="header-section-number">25.9.2</span> Editor Design Elements</h3>
<p>The next rules describe the path to follow when creating your own 
object editor that will be recognized and loaded by the graphics editor 
in ROOT, i.e.&nbsp;it will be included as a part of it.</p>
<ol type="a">
<li><p>Derive the code of your object editor from the base editor class <strong><code>TGedFrame</code></strong>.</p></li>
<li><p>Keep the correct naming convention: the name of the object editor should be the object class name concatenated with the word <code>‘Editor'</code>.</p></li>
<li><p>Provide a default constructor.</p></li>
<li><p>Use the signals/slots communication mechanism for event processing.</p></li>
<li><p>Implement the virtual method <code>SetModel(TObject *obj)</code> 
where all widgets are set with the current object’s attributes. This 
method is called when the editor receives a signal from the canvas 
saying that an object is the selected.</p></li>
<li><p>Implement all necessary slots and connect them to appropriate 
signals that GUI widgets send out. The GUI classes in ROOT are developed
 to emit signals whenever they change a state that others might be 
interested. As we noted already, the signals/slots communication 
mechanism allows total independence of the interacting classes.</p></li>
</ol>
<h4 id="creation-and-destruction"><span class="header-section-number">25.9.2.1</span> Creation and Destruction</h4>
<p>GED-frames are constructed during traversal of class hierarchy of the selected object, executed from method <strong><code>TGedEditor</code></strong><code>::SetModel()</code>.
 When a new object of a different class is selected, the unneeded 
GED-frames are cached in memory for potential reuse. The frames are 
deleted automatically when the editor is closed.</p>
<p>Note: A deep cleanup is assumed for all frames put into the editor. This implies:</p>
<ul>
<li><p>do not share the layout-hints among GUI components;</p></li>
<li><p>do not delete child widgets in the destructor as this is done automatically.</p></li>
</ul>
<h4 id="using-several-tabs"><span class="header-section-number">25.9.2.2</span> Using Several Tabs</h4>
<p>Sometimes you might need to use several tabs to organize properly 
your class-editor. Each editor tab is a resource shared among all the 
class-editors. Tabs must be created from the constructor of your 
editor-class by using the method:</p>
<div class="sourceCode" id="cb1264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1264-1" title="1">TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(<span class="at">const</span> <span class="dt">Text_t</span> *name),</a></code></pre></div>
<p>It returns a pointer to a new tab container frame ready for use in 
your class. If you need to hide/show this frame depending on the 
object’s status, you should store it in a data member. See for examples:
 <strong><code>TH1Editor</code></strong>, <strong><code>TH2Editor</code></strong>.</p>
<h4 id="base-class-editors-control"><span class="header-section-number">25.9.2.3</span> Base-Class Editors Control</h4>
<p>Full control over base-class editors can be achieved by re-implementing virtual method void <code>TGedFrame::ActivateBaseClassEditors(TClass</code> <code>*cl)</code>.
 It is called during each compound editor rebuild and the default 
implementation simply offers all base-classes to the publishing 
mechanism.</p>
<p>To prevent inclusion of a base-class into the compound editor, call:</p>
<div class="sourceCode" id="cb1265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1265-1" title="1"><span class="dt">void</span> TGedEditor::ExcludeClassEditor(TClass* <span class="kw">class</span>, <span class="dt">Bool_t</span> recurse)</a></code></pre></div>
<p>Pointer to the compound GED-editor is available in <strong><code>TGedFrame</code></strong>‘s data-member:</p>
<div class="sourceCode" id="cb1266"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1266-1" title="1">TGedEditor *fGedEditor</a></code></pre></div>
<p>Ordering of base-class editor frames follows the order of the classes
 in the class hierarchy. This order can be changed by modifying the 
value of <strong><code>TGedFrame</code></strong>’s data member <code>Int_t fPriority</code>.
 The default value is 50; smaller values move the frame towards to the 
top. This priority should be set in the editor constructor.</p>
<h2 id="drag-and-drop"><span class="header-section-number">25.10</span> Drag and Drop</h2>
<p>Drag and Drop support is introduced for Linux (via Xdnd - the drag 
and drop protocol for X window system) and for Windows (via Clipboard). 
Users can selects something in ROOT with a mouse press, drags it (moves 
the mouse while keeping the mouse button pressed) and releases the mouse
 button someplace else. When the button is released the selected data is
 “dropped” at that location. This way, a histogram from an opened ROOT 
file in the browser can be dragged to any <strong><code>TCanvas</code></strong>.</p>
<p><img src="ROOTUsersGuide_files/03000223.png"></p>
<p>A script file from the browser can be dropped to a <strong><code>TGTextView</code></strong> or TGTextEdit widget in <strong><code>TGTextEditor</code></strong>.</p>
<p>On Linux, it is possible to drag objects between ROOT and an external
 application. For example to drag a macro file from the ROOT browser to 
the Kate editor. On Windows, drag and drop works only within a single 
ROOT application (for the time being), but works also from Windows 
Explorer to <strong><code>TCanvas</code></strong> ot to <strong><code>TGTextEdit</code></strong>.</p>
<h3 id="drag-and-drop-data-class"><span class="header-section-number">25.10.1</span> Drag and Drop Data Class</h3>
<p>The Drag and Drop Cata class <strong><code>TDNDdata</code></strong> is used to describe and handle the transferred data during an drag and drop operation. It consists of:</p>
<p><code>Atom_t  fDataType</code>: atom describing the data type.</p>
<p><code>Atom_t  fAction</code>: atom describing the action (copy, move, link); currently, only copy is used.</p>
<p><code>void   *fData</code>: actual data (buffer).</p>
<p><code>Int_t</code> <code>fDataLength</code>: length (size) of data buffer.</p>
<p>Currently two types are recognized by ROOT: “application/root” for 
ROOT objects and “text/uri-list” for path/filenames (uri comes from 
Unique Resource Identifier). A text/uri-list is a standard file listing 
format for drag and drop that specifies a list of files (each file per 
line). Each line ends with a carriage return and newline<code>rn</code>. File names have to be valid, url-encoded URI’s as shown below:</p>
<p><code>file://localhost/usr/bin/opera</code> or <code>file://localhost/c:/programs/myfile.txt</code></p>
<p><code>file://server/data/software.xml</code> or <code>http://root.cern.ch/root/images/ftpstats.gif</code></p>
<p>The atoms and the drag and drop manager (<strong><code>TGDNDManager</code></strong>), are created at the main application creation time (class TGMainFrame).</p>
<p>Setting a Drag Source - first, create and fill data:</p>
<div class="sourceCode" id="cb1267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1267-1" title="1">TH1F *h = <span class="kw">new</span> TH1F(<span class="st">"h"</span>,<span class="st">"h"</span>,<span class="dv">1000</span>,-<span class="dv">3</span>,<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb1267-2" title="2">h-&gt;FillRandom(<span class="st">"gaus"</span>,<span class="dv">50000</span>);</a>
<a class="sourceLine" id="cb1267-3" title="3">TDNDdata data;</a>
<a class="sourceLine" id="cb1267-4" title="4">TBufferFile *buf = <span class="kw">new</span> TBufferFile(TBuffer::kWrite);</a>
<a class="sourceLine" id="cb1267-5" title="5">buf-&gt;WriteObject(h);</a>
<a class="sourceLine" id="cb1267-6" title="6">data.fData = buf-&gt;Buffer();</a>
<a class="sourceLine" id="cb1267-7" title="7">data.fDataLength = buf-&gt;Length();</a>
<a class="sourceLine" id="cb1267-8" title="8">data.fDataType = gVirtualX-&gt;InternAtom(<span class="st">"application/root"</span>);</a></code></pre></div>
<p>Then, set a GUI widget as DND Source, and associate the data. Source widget can be any class inheriting from <strong><code>TGFrame</code></strong>.</p>
<div class="sourceCode" id="cb1268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1268-1" title="1">SourceWidget=<span class="kw">new</span> TGIcon(<span class="kw">this</span>,gClient-&gt;GetPicture(<span class="st">"f1_s.xpm"</span>),<span class="dv">32</span>,<span class="dv">32</span>);</a>
<a class="sourceLine" id="cb1268-2" title="2">SourceWidget-&gt;SetDNDSource(kTRUE);</a>
<a class="sourceLine" id="cb1268-3" title="3">SourceWidget-&gt;SetDNDdata(&amp;data);</a></code></pre></div>
<p>Setting A Drop Target - set the widget as DND Target, and set the DND types it must be aware of: as <code>SourceWidget</code>, <code>TargetWidget</code> can be any class inheriting from <strong><code>TGFrame</code></strong>.</p>
<div class="sourceCode" id="cb1269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1269-1" title="1">TargetWidget = <span class="kw">new</span> TRootEmbeddedCanvas(<span class="st">"Target"</span>, <span class="kw">this</span>, <span class="dv">700</span>, <span class="dv">400</span>);</a>
<a class="sourceLine" id="cb1269-2" title="2">TargetWidget-&gt;SetDNDTarget(kTRUE);</a>
<a class="sourceLine" id="cb1269-3" title="3">gVirtualX-&gt;SetDNDAware(TargetWidget-&gt;GetId(),</a>
<a class="sourceLine" id="cb1269-4" title="4">                       gDNDManager-&gt;GetTypeList());</a></code></pre></div>
<p><code>gDNDManager-&gt;GetTypeList()</code> returns the list of types recognized by ROOT.</p>
<p>Note that the Widget may receive drag and drop messages with 
drop-data it does not understand, and thus it should only accept drops 
of the proper type.</p>
<h3 id="handling-drag-and-drop-events"><span class="header-section-number">25.10.2</span> Handling Drag and Drop Events</h3>
<p>Once a widget has been set as DND Target, it has to handle Drag and Drop events.</p>
<p><code>Atom_t HandleDNDenter(Atom_t *typelist)</code> - this method is
 used to handle a drag operation entering the widget. The typelist 
parameter is the list of types the data contains. If the list contains 
one type the widget understands, it should return this type to notify 
the manager that the drop would be accepted, i.e.&nbsp;:</p>
<div class="sourceCode" id="cb1270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1270-1" title="1"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; typelist[i] != kNone; ++i) {</a>
<a class="sourceLine" id="cb1270-2" title="2">   <span class="cf">if</span> (typelist[i] == gVirtualX-&gt;InternAtom(<span class="st">"application/root"</span>))</a>
<a class="sourceLine" id="cb1270-3" title="3">      <span class="co">// accept "application/root" DND type</span></a>
<a class="sourceLine" id="cb1270-4" title="4">      <span class="cf">return</span> typelist[i];</a>
<a class="sourceLine" id="cb1270-5" title="5">}</a>
<a class="sourceLine" id="cb1270-6" title="6"><span class="co">// other type not accepted</span></a>
<a class="sourceLine" id="cb1270-7" title="7"><span class="cf">return</span> kNone;</a></code></pre></div>
<p><code>Atom_t HandleDNDposition(Int_t x,Int_t y,Atom_t action,Int_t xroot, Int_t yroot)</code> - this method should be used to handle the drag position in widget coordinates (<code>x,y</code>) or in root coordinates (<code>xroot,yroot</code>).</p>
<div class="sourceCode" id="cb1271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1271-1" title="1"><span class="co">// get the pad over which the cursor is</span></a>
<a class="sourceLine" id="cb1271-2" title="2">TPad *pad = fCanvas-&gt;Pick(x, y, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1271-3" title="3"><span class="cf">if</span> (pad) {</a>
<a class="sourceLine" id="cb1271-4" title="4">   pad-&gt;cd();</a>
<a class="sourceLine" id="cb1271-5" title="5">   gROOT-&gt;SetSelectedPad(pad);</a>
<a class="sourceLine" id="cb1271-6" title="6">}</a>
<a class="sourceLine" id="cb1271-7" title="7"><span class="cf">return</span> action;</a></code></pre></div>
<p><code>Bool_t HandleDNDdrop(TDNDdata *data)</code> - this is the place where the widget actually receives the data. First, check the data format (see description of <strong><code>TDNDData</code></strong> - Drag and Drop data class) and then use it accordingly. In the case of ROOT object, here is an example of how to retrieve it:</p>
<div class="sourceCode" id="cb1272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1272-1" title="1"><span class="cf">if</span> (data-&gt;fDataType == gVirtualX-&gt;InternAtom(<span class="st">"application/root"</span>)) {</a>
<a class="sourceLine" id="cb1272-2" title="2">   TBufferFile buf(TBuffer::kRead, data-&gt;fDataLength,</a>
<a class="sourceLine" id="cb1272-3" title="3">                   (<span class="dt">void</span> *)data-&gt;fData);</a>
<a class="sourceLine" id="cb1272-4" title="4">   buf.SetReadMode();</a>
<a class="sourceLine" id="cb1272-5" title="5">   TObject *obj = (TObject *)buf.ReadObjectAny(TObject::Class());</a>
<a class="sourceLine" id="cb1272-6" title="6">   <span class="cf">if</span> (obj-&gt;IsA()-&gt;GetMethodAllAny(<span class="st">"Draw"</span>))</a>
<a class="sourceLine" id="cb1272-7" title="7">      obj-&gt;Draw();</a>
<a class="sourceLine" id="cb1272-8" title="8">}</a></code></pre></div>
<p>In the case of URI/list, the use is:</p>
<div class="sourceCode" id="cb1273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1273-1" title="1"><span class="cf">if</span> (data-&gt;fDataType == gVirtualX-&gt;InternAtom(<span class="st">"text/uri-list"</span>)) {</a>
<a class="sourceLine" id="cb1273-2" title="2">   TString sfname((<span class="dt">char</span> *)data-&gt;fData);</a>
<a class="sourceLine" id="cb1273-3" title="3">   TUrl uri(sfname.Data());</a>
<a class="sourceLine" id="cb1273-4" title="4">   <span class="cf">if</span> (sfname.EndsWith(<span class="st">".jpg"</span>)</a>
<a class="sourceLine" id="cb1273-5" title="5">      TImage *img = TImage::Open(uri.GetFile());</a>
<a class="sourceLine" id="cb1273-6" title="6">}</a></code></pre></div>
<p><code>Bool_t HandleDNDleave()</code> is used if a specific action has to be performed when the drag operation leaves the widget.</p>
<h1 id="the-signalslot-communication-mechanism"><span class="header-section-number">26</span> The Signal/Slot Communication Mechanism</h1>
<p></p>
<h2 id="introduction-2"><span class="header-section-number">26.1</span> Introduction</h2>
<p>ROOT supports its own version of the signal/slot communication mechanism originally featured in <strong>Qt</strong>, a C++ GUI application framework by <a href="https://www.qt.io/">the Qt Company.</a>
 The ROOT implementation uses the ROOT type system. In addition to all 
features provided by Qt the ROOT version supports connecting slots to a 
class (as opposed to connecting to a specific object). These slots will 
be called whenever the specified signal is emitted by any object of the 
class. Also a slot can have default arguments and be either a class 
method or a stand-alone function (compiled or interpreted).</p>
<h2 id="basic-concepts"><span class="header-section-number">26.2</span> Basic Concepts</h2>
<p>Signals and slots are used for communication between objects.</p>
<p>Signals are emitted by objects when they change their state in a way 
that may be interesting to the outside world. This is all the object 
does to communicate. It does not know if anything is receiving the 
signal at the other end.</p>
<p>Slots can be used for receiving signals. A slot does not know if it has any signal(s) connected to it.</p>
<p>This is true information encapsulation, and ensures that the object can be used as a true software component.</p>
<p>Signals and slots can take any number of arguments of any type.</p>
<p>It is possible to connect as many signals as you want to a single 
slot, and a signal can be connected to as many slots as you desire.</p>
<p>It is possible to make a single connection from all objects of the same class.</p>
<h2 id="a-small-example"><span class="header-section-number">26.3</span> A Small Example</h2>
<p>A minimal C++ class declaration might read:</p>
<div class="sourceCode" id="cb1274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1274-1" title="1"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb1274-2" title="2"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1274-3" title="3">   <span class="dt">Int_t</span>  fValue;</a>
<a class="sourceLine" id="cb1274-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1274-5" title="5">   A() { fValue = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb1274-6" title="6">   <span class="dt">Int_t</span>  GetValue() <span class="at">const</span> { <span class="cf">return</span> fValue; }</a>
<a class="sourceLine" id="cb1274-7" title="7">   <span class="dt">void</span>   SetValue(<span class="dt">Int_t</span>);</a>
<a class="sourceLine" id="cb1274-8" title="8">};</a></code></pre></div>
<p>A small ROOT <strong>interpreted</strong> class might read:</p>
<div class="sourceCode" id="cb1275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1275-1" title="1"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb1275-2" title="2">   RQ_OBJECT(<span class="st">"A"</span>)</a>
<a class="sourceLine" id="cb1275-3" title="3"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb1275-4" title="4">    <span class="dt">Int_t</span>  fValue;</a>
<a class="sourceLine" id="cb1275-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb1275-6" title="6">    A() { fValue = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb1275-7" title="7">    <span class="dt">Int_t</span>  GetValue() <span class="at">const</span> { <span class="cf">return</span> fValue; }</a>
<a class="sourceLine" id="cb1275-8" title="8">    <span class="dt">void</span>   SetValue(<span class="dt">Int_t</span>);      <span class="co">//*SIGNAL*</span></a>
<a class="sourceLine" id="cb1275-9" title="9">};</a></code></pre></div>
<p>This class has the same internal state, and public methods to access 
the state, but in addition it has support for component programming 
using signals. This class can tell the outside world that its state has 
changed by emitting a signal, <code>SetValue(Int_t)</code>.</p>
<p>Here is a possible implementation of <code>A::SetValue()</code>:</p>
<div class="sourceCode" id="cb1276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1276-1" title="1"><span class="dt">void</span> A::SetValue(<span class="dt">Int_t</span> v)</a>
<a class="sourceLine" id="cb1276-2" title="2">{</a>
<a class="sourceLine" id="cb1276-3" title="3">   <span class="cf">if</span> (v != fValue) {</a>
<a class="sourceLine" id="cb1276-4" title="4">      fValue = v;</a>
<a class="sourceLine" id="cb1276-5" title="5">      Emit(<span class="st">"SetValue(Int_t)"</span>, v);</a>
<a class="sourceLine" id="cb1276-6" title="6">   }</a>
<a class="sourceLine" id="cb1276-7" title="7">}</a></code></pre></div>
<p>The line <code>Emit("SetValue(Int_t)", v)</code> emits the signal <code>SetValue(Int_t)</code> with argument <code>v</code> from the object. As you can see, you emit a signal by using <code>Emit("full_method_name",arguments)</code>.</p>
<p>Here is one of the ways to connect two of these objects together:</p>
<div class="sourceCode" id="cb1277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1277-1" title="1">A *a = <span class="kw">new</span> A();</a>
<a class="sourceLine" id="cb1277-2" title="2">A *b = <span class="kw">new</span> A();</a>
<a class="sourceLine" id="cb1277-3" title="3">a-&gt;Connect(<span class="st">"SetValue(Int_t)"</span>, <span class="st">"A"</span>, b, <span class="st">"SetValue(Int_t)"</span>);</a>
<a class="sourceLine" id="cb1277-4" title="4">b-&gt;SetValue(<span class="dv">11</span>);</a>
<a class="sourceLine" id="cb1277-5" title="5">a-&gt;SetValue(<span class="dv">79</span>);</a>
<a class="sourceLine" id="cb1277-6" title="6">b-&gt;GetValue();          <span class="co">// this would now be 79, why?</span></a></code></pre></div>
<p>The statement <code>a-&gt;Connect("SetValue(Int_t)", "A", b, "SetValue(Int_t)")</code> denotes that object <code>a</code> connects its <code>"SetValue(Int_t)"</code> signal to <code>"A::SetValue(Int_t)"</code> method of object <code>b</code>.</p>
<p>Calling <code>a-&gt;SetValue(79)</code> will make <code>a</code> emit a signal, which <code>b</code> will receive, i.e.&nbsp;<code>b-&gt;SetValue(79)</code> is invoked. It is executed immediately, just like a normal function call. <code>b</code>
 will in turn emit the same signal, which nobody receives, since no slot
 has been connected to it, so it disappears into hyperspace.</p>
<p>This example illustrates that objects can work together without 
knowing about each other, as long as there is someone around to set up a
 connection between them.</p>
<h2 id="features-of-the-root-implementation"><span class="header-section-number">26.4</span> Features of the ROOT implementation</h2>
<ul>
<li><p>The ROOT implementation <strong>does not require the</strong> <em>moc</em> preprocessor and the <code>signal:</code> and <code>slot:</code> keywords in the class declaration. Signals and slots are normal class methods.</p></li>
<li><p>The class which corresponds to <strong>Qt’s</strong> <strong>QObject</strong> is <a href="http://root.cern.ch/root/html/TQObject.html">TQObject</a>. It reproduces the general features of the QObject class and has the <code>Connect()</code>, <code>Disconnect()</code> and <code>Emit()</code> methods. The <a href="http://root.cern.ch/root/html/TQObject.html">TQObject</a> class does not derive from any class which makes it possible to have multiple inheritance from <a href="http://root.cern.ch/root/html/TObject.html">TObject</a> derived classes and <a href="http://root.cern.ch/root/html/TQObject.html">TQObject</a>.</p></li>
<li><p>By placing the <a href="http://root.cern.ch/root/html/RQ_OBJECT.h"><code>RQ_OBJECT()</code></a> macro inside a class body you can use signals and slots with classes not inheriting from <a href="http://root.cern.ch/root/html/TQObject.html">TQObject</a>, like interpreted classes which can not derive from compiled classes. This makes it possible to apply the <strong>Object Communication Mechanism</strong> between compiled and interpreted classes in an interactive ROOT session.</p></li>
<li><p>The ROOT implementation allows to make connections to any object 
known to the ROOT C++ interpreter. The following line makes a connection
 between signal <code>Pressed()</code> from <code>button</code> and method/slot <code>Draw()</code> from object <code>hist</code> of class (compiled or interpreted) <code>TH1</code></p>
<div class="sourceCode" id="cb1278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1278-1" title="1">Connect(button, <span class="st">"Pressed()"</span>, <span class="st">"TH1"</span>, hist, <span class="st">"Draw()"</span>);</a></code></pre></div>
<p>To connect to a stand-alone function (compiled or interpreted) the 
arguments corresponding to the name of the class and receiving object 
should be zero. For example</p>
<div class="sourceCode" id="cb1279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1279-1" title="1">Connect(button, <span class="st">"Pressed()"</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="st">"printInfo()"</span>);</a></code></pre></div></li>
<li><p>It is also possible to make a single connection from all objects of the same class. For example:</p>
<div class="sourceCode" id="cb1280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1280-1" title="1">TQObject::Connect(<span class="st">"Channel"</span>, <span class="st">"AlarmOn()"</span>, <span class="st">"HandlerClass"</span>, handler, <span class="st">"HandleAlarm()"</span>);</a></code></pre></div>
<p>where the class name is specified by the first argument. Signal <code>"AlarmOn()"</code> for any object of class <code>"Channel"</code> is now connected to the <code>"HandleAlarm()"</code> method of the <code>"handler"</code> object of the <code>"HandlerClass"</code>.</p></li>
<li><p>It is possible to set default parameters values to a slot method 
while connecting to it. Such slot will be activated without passing 
parameters to it. To set default arguments to a slot an equal symbol ‘=’
 should be placed at the beginning of the prototype string. For example</p>
<div class="sourceCode" id="cb1281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1281-1" title="1">Connect(button, <span class="st">"Pressed()"</span>, <span class="st">"TH1"</span>, hist, <span class="st">"SetMaximum(=123)"</span>);</a>
<a class="sourceLine" id="cb1281-2" title="2">Connect(button, <span class="st">"Pressed()"</span>, <span class="st">"TH1"</span>, hist, <span class="st">"Draw(=</span><span class="sc">\"</span><span class="st">LEGO</span><span class="sc">\"</span><span class="st">)"</span>);</a></code></pre></div></li>
</ul>
<h2 id="signals"><span class="header-section-number">26.5</span> Signals</h2>
<p>A signal is a normal class method. <strong>The first requirement</strong> is that it should call an <code>Emit()</code> method. The format of this method is the following:</p>
<div class="sourceCode" id="cb1282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1282-1" title="1">Emit(<span class="st">"full_method_name"</span>[,arguments]);</a></code></pre></div>
<p>where <code>"full_method_name"</code> is the method name and prototype string of the signal method. For example, for <code>SetValue(Int_t value)</code> the full method name will be <code>"SetValue(Int_t)"</code>, where <code>SetValue</code> is the method name and <code>Int_t</code> the prototype string. Note that typedefs will be resolved to facilitate matching of slots to signals. So the slot <code>"print(int)"</code> can be connected to the above signal which has an <code>Int_t</code> as argument.</p>
<p><strong>The second requirement</strong> is that the method declaration should have the string <code>*SIGNAL*</code> in its comment field. Like:</p>
<div class="sourceCode" id="cb1283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1283-1" title="1"><span class="dt">void</span> SetValue(<span class="dt">Int_t</span> x);  <span class="co">//*SIGNAL*</span></a></code></pre></div>
<p>This provides an explicit interface specification for the user (this requirement is currently not enforced at run-time).</p>
<p><strong>The third requirement</strong>, only necessary if you want to
 have class signals (i.e.&nbsp;for all objects of a class), is that you 
have to replace the standard <code>ClassImp</code> macro by <code>ClassImpQ</code>.</p>
<p>Signals are currently implemented for all ROOT GUI classes and the <a href="http://root.cern.ch/root/html/TTimer.html">TTimer</a> and <a href="http://root.cern.ch/root/html/TCanvas.html">TCanvas</a> classes (to find quickly all defined signals do for example: <code>grep '*SIGNAL*' $ROOTSYS/include/*.h</code>).</p>
<h2 id="examples-2"><span class="header-section-number">26.6</span> Examples</h2>
<h3 id="a-first-time-example-rqfirst.c"><span class="header-section-number">26.6.1</span> A First Time Example (<a href="http://root.cern.ch/root/rqex/rqfirst.C">rqfirst.C</a>)</h3>
<p>This example shows:</p>
<ul>
<li>How to create interpreted class with signals with different types/number of arguments.</li>
<li>How to connect signals to slots.</li>
<li>How to activate signals.</li>
</ul>
<h3 id="histogram-filling-with-dynamic-state-reported-via-signals-rqsimple.c"><span class="header-section-number">26.6.2</span> Histogram Filling with Dynamic State Reported via Signals (<a href="http://root.cern.ch/root/rqex/rqsimple.C">rqsimple.C</a>)</h3>
<p>Based on hsimple this example demonstrates:</p>
<ul>
<li>All features of the hsimple example.</li>
<li>How to create an interpreted class with signals which will report about dynamic state of the histogram processing.</li>
<li>How to use the <a href="http://root.cern.ch/root/html/TTimer.html">TTimer</a> class for emulation of “multithreading”.</li>
<li>How to use signals for the concurrent update of pad, file, benchmark facility, etc.</li>
</ul>
<h3 id="an-example-on-how-to-use-canvas-event-signals-rqfiller.c"><span class="header-section-number">26.6.3</span> An Example on How to Use Canvas Event Signals (<a href="http://root.cern.ch/root/rqex/rqfiller.C">rqfiller.C</a>)</h3>
<p>This example shows:</p>
<ul>
<li>How the object communication mechanism can be used for handling the <a href="http://root.cern.ch/root/html/TCanvas.html">TCanvas</a>’s mouse/key events in an interpreted class.</li>
</ul>
<p>With this demo you can fill histograms by hand:</p>
<ul>
<li>Click the left button or move mouse with button pressed to fill histograms.</li>
<li>Use the right button of the mouse to reset the histograms.</li>
</ul>
<h3 id="complex-gui-using-signals-and-slots-guitest.c"><span class="header-section-number">26.6.4</span> Complex GUI Using Signals and Slots (<a href="https://root.cern.ch/doc/master/guitest_8C.html">guitest.C</a>)</h3>
<p>Based on <code>$ROOTSYS/test/guitest.cxx</code> this example demonstrates:</p>
<ul>
<li>All features of the original compiled guitest.cxx program.</li>
<li>Sophisticated use of signals and slots to build a complete user 
interface that can be executed either in the interpreter or as a 
compiled program.</li>
</ul>
<h1 id="automatic-html-documentation"><span class="header-section-number">27</span> Automatic HTML Documentation</h1>
<p></p>
<p><strong><code>THtml</code></strong> is ROOT’s documentation engine. 
It can be used to document your classes in a reference guide, and to 
convert your text or source files to HTML.</p>
<h2 id="reference-guide"><span class="header-section-number">27.1</span> Reference Guide</h2>
<p>The Reference Guide for the ROOT classes at <a href="http://root.cern.ch/root/html/" class="uri">http://root.cern.ch/root/html/</a> has been generated by ROOT’s <strong><code>THtml</code></strong>
 class. Just as for ROOT’s classes, it can generate (and update) a 
reference guide for your classes, too. You document your classes using 
source code comments. All comments will be automatically put into a <code>&lt;pre&gt;&lt;/pre&gt;</code> environment to keep the indentation and line length. You can write “raw” HTML by enclosing comments in the keywords <code>Begin_Html</code> and <code>End_Html</code>.</p>
<p>To generate documentation for the class <strong><code>TObject</code></strong> you could run the following commands:</p>
<div class="sourceCode" id="cb1284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1284-1" title="1">root[] THtml h</a>
<a class="sourceLine" id="cb1284-2" title="2">root[] h.SetInputDir(<span class="st">"$(ROOTSYS)"</span>);</a>
<a class="sourceLine" id="cb1284-3" title="3">root[] h.MakeClass(<span class="st">"TObject"</span>);</a>
<a class="sourceLine" id="cb1284-4" title="4">root[] h.CreateJavascript();</a>
<a class="sourceLine" id="cb1284-5" title="5">root[] h.CreateStylesheet();</a></code></pre></div>
<p>The comments following the first comment of the form //____________________, before any method, is assumed to be the <strong>class description</strong>. As with any other documentation part, it has to be a continuous block of comments.</p>
<p>Any documented class will have an <strong>class index entry</strong> in the <code>ClassIndex.html</code>,
 showing their name with a link to their documentation page and a 
miniature description. This description for e.g.&nbsp;the class <code>MyClass</code> has to be given in <code>MyClass's</code> header file as documentation.</p>
<p>A <strong>method description</strong> block starts immediately after ‘<code>{</code>’ and looks like this:</p>
<div class="sourceCode" id="cb1285"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1285-1" title="1"><span class="dt">void</span> TWorld::HelloWorldFunc(string *text)</a>
<a class="sourceLine" id="cb1285-2" title="2">{</a>
<a class="sourceLine" id="cb1285-3" title="3"><span class="co">// This is a documentation example of the function TWorld::HelloWorldFunc</span></a>
<a class="sourceLine" id="cb1285-4" title="4">helloWorld.Print(text);</a>
<a class="sourceLine" id="cb1285-5" title="5">}</a></code></pre></div>
<p>Like in a class description block, everything until the first 
non-commented line is considered as a valid member function description 
block.</p>
<p><strong>Data members</strong> are documented by putting a C++ comment behind their declaration in the header file, e.g.</p>
<div class="sourceCode" id="cb1286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1286-1" title="1"><span class="dt">Int_t</span> fIAmADataMember; <span class="co">// this is a data member</span></a></code></pre></div>
<p>When documenting a class, <strong><code>THtml</code></strong> creates
 both a “beautified” version of the source file and a web page 
containing the class documentation. The documentation also shows the <strong>author</strong> and a <strong>copyright statement</strong>. This information is extracted from the source file. The author can be in the format</p>
<div class="sourceCode" id="cb1287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1287-1" title="1"><span class="co">// Author: Enrico Fermi</span></a></code></pre></div>
<p>for people that have an entry in CERN’s XWho database, and for those who have not:</p>
<div class="sourceCode" id="cb1288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1288-1" title="1"><span class="co">// Author: Enrico Fermi &lt;mailto:enrico@fnal.gov&gt;</span></a></code></pre></div>
<p>The copyright statement is introduced by the string “<code>* Copyright</code>” inside a comment.</p>
<p>You should read the class reference page at <a href="http://root.cern.ch/root/html/THtml.html" class="uri">http://root.cern.ch/root/html/THtml.html</a> to learn about all of <strong><code>THtml</code></strong>’s features.</p>
<h3 id="product-and-module-documentation"><span class="header-section-number">27.1.1</span> Product and Module Documentation</h3>
<p>For <strong><code>THtml</code></strong>, a product like ROOT is a 
combination of several modules. It can include user-provided document 
for both products and modules. The name of the product can be set by 
calling <code>THtml::SetProductName()</code>. By default, the documentation is searched for in the <code>doc/</code> subdirectory of the source tree, and in the <code>../doc</code>directory, relative to the directory of first source file of a module. This can be set by calls to <code>THtml::SetProductDocDir()</code> and <code>THtml::SetModuleDocPath()</code>.</p>
<p>The documentation is generated as an index page with links to further files. This index page includes the file <code>index.txt</code> converted to HTML (via <code>THtml::Convert()</code>)
 or the file index.html (without conversion to HTML, of course), if any 
of these files exist. The index page will also contain a list of links 
to all files in the directory that end on <code>.html</code> or <code>.txt</code>. Files ending on <code>.txt</code>
 will be converted to HTML before they are copied to the output 
directory. For each file, the link’s text will be the file name without 
extension, with underscores replaced by spaces.</p>
<p>You can see an example of the module documentation including links, the corresponding <code>index.html</code>, and the module class index at <a href="http://root.cern.ch/root/html/HIST_Index.html" class="uri">http://root.cern.ch/root/html/HIST_Index.html</a>.</p>
<h2 id="converting-sources-and-other-files-to-html"><span class="header-section-number">27.2</span> Converting Sources (and Other Files) to HTML</h2>
<p><strong><code>THtml</code></strong> can take a file (C++ or text) and convert it to HTML. There are two main use cases:</p>
<p>The output of a <strong>macro</strong> converted to HTML will almost look like the beautified source file of a class reference. The <code>Begin_Html/End_Html</code> keywords are supported; comments, strings, and keywords are colored like in <strong><code>THtml</code></strong>’s output for source code.</p>
<p>The macro <code>Event.cxx</code> in <code>$ROOTSYS/test</code> can be seen as an example of documented ROOT macros at <a href="http://root.cern.ch/root/html/examples/Event.cxx.html" class="uri">http://root.cern.ch/root/html/examples/Event.cxx.html</a></p>
<p><code>THtml::Convert()</code>converts a single text file to HTML. For
 example, it can be run on a change log. Each known class name will be 
linked to its documentation page. An example is ROOT’s change log at <a href="http://root.cern.ch/root/html/examples/V5.16.txt.html" class="uri">http://root.cern.ch/root/html/examples/V5.16.txt.html</a></p>
<p>To convert the source file MyCode.C to HTML, you can run</p>
<div class="sourceCode" id="cb1289"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1289-1" title="1">root[] THtml h</a>
<a class="sourceLine" id="cb1289-2" title="2">root[] h.Convert(<span class="st">"MyCode.C"</span>, <span class="st">"Look At My Code"</span>, <span class="st">"htmlout/"</span>);</a></code></pre></div>
<p>This will create the file <code>htmlout/MyCode.C.html</code>. The HTML page will have the title “Look At My Code”.</p>
<h2 id="special-documentation-elements-directives"><span class="header-section-number">27.3</span> Special Documentation Elements: Directives</h2>
<p>A common documentation problem is the inclusion of images. They are 
usually generated externally, which poses problems with where to keep 
the images, and how to keep them up to date. <strong><code>THtml</code></strong> solves this by offering a few special documentation elements: macro and latex directives.</p>
<h3 id="latex-directive"><span class="header-section-number">27.3.1</span> Latex Directive</h3>
<p>Documentation surrounded by the keywords <code>BEGIN_LATEX / END_LATEX</code> will be passed to ROOT Latex engine <strong><code>TLatex</code></strong>.
 The keywords can be written with small or capital letters (case 
insensitive). The output will be stored to an image file, which gets 
automatically included in the documentation.</p>
<div class="sourceCode" id="cb1290"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1290-1" title="1"><span class="co">// This function calculates </span><span class="re">BEGIN</span><span class="co">_LATEX</span></a>
<a class="sourceLine" id="cb1290-2" title="2"><span class="co">//   F(x_{#frac{1}{2}}) = #prod(x &lt; x_{#frac{1}{2}}) = #frac{1}{2}</span></a>
<a class="sourceLine" id="cb1290-3" title="3"><span class="co">// </span><span class="re">END</span><span class="co">_LATEX</span></a></code></pre></div>
<p>THtml will inject the following picture:</p>
<p><img src="ROOTUsersGuide_files/0300022D.png"></p>
<p>The image file name is generated from the formula and will be unique 
for all the documentation. It is stored along-side the documentation, 
and it will be automatically regenerated when the documentation is 
updated. The handling of the Latex directive is done by the class <strong><code>TDocLatexDirective</code></strong>.</p>
<p>The <code>BEGIN_LATEX</code> keyword can take the following parameters:</p>
<ul>
<li><p><code>fontsize</code>: sets the <strong><code>TLatex</code></strong> font size. The default value is 16.</p></li>
<li><p><code>separator</code>: sets a list of characters for which a new
 column will be started. This allows aligned, multi-line, multi-column 
layout, which can be useful for e.g.&nbsp;mathematical derivations. It 
is unset by default, meaning the Latex directive will only generate one 
column.</p></li>
<li><p><code>rseparator</code>: like separator, but a regular 
expression. Columns start with a match of this regular expression. Only 
one of separator or rseparator can be given.</p></li>
<li><p><code>align</code>: defines the alignment of the columns. Note that the column delimiter counts as a column itself!</p></li>
</ul>
<p>Example invocation, where the font size is set to 10, new columns are started by the characters ‘<code>=</code>’ and ‘<code>,</code>’, and the two columns are left aligned with the separator column centered:</p>
<p><code>Begin_Latex(fontsize=10, separator='=,', align=lcl)</code></p>
<h3 id="macro-directive"><span class="header-section-number">27.3.2</span> Macro Directive</h3>
<p>A more general approach is offered by the Macro directive, enclosed in the keywords <code>BEGIN_MACRO /</code> <code>END_MACRO</code>.
 The keywords can be written with small or capital letters (case 
insensitive). If the text enclosed by these keywords contains the 
character ‘<code>{</code>’ the text is assumed to be source code. 
Otherwise it is assumed to be a file name relative to the current file’s
 path, and taking into account the paths specified by <strong><code>THtml::AddMacroPath()</code>. The macro file or the C++ source is executed when generating the documentation. It is expected to return a </strong><code>TObject*</code><strong>, which will be saved to a GIF file, by calling the virtual function </strong><code>TObject::SaveAs()</code>.****</p>
<p>The <code>BEGIN_MACRO</code> keyword can take the following parameters:</p>
<ul>
<li><p><code>GUI</code>: will end batch mode. This is needed e.g.&nbsp;for creating screen shots of GUI elements, where the call to <strong><code>TObject::SaveAs()</code> will invoke <code>TGObject</code></strong><code>::SaveAs()</code> which needs the graphics system to be initialized.</p></li>
<li><p><code>source</code>: requests the source of the macro to be shown
 in a second tab on the HTML page. This is useful e.g.&nbsp;for example 
macros, showing how the image was generated. Lines that should be 
executed but not shown in the source tab can be hidden by ending them 
with <code>*HIDE*</code> (most probably as a comment). Lines may be 
hidden because they are not needed for the understanding of the macro or
 because they only make sense in the context of the documentation, like 
the statement returning the <strong><code>TObject*</code></strong>.</p></li>
</ul>
<p>Example invocation, with enabled ROOT graphics system and a source tab:</p>
<p><code>Begin_Macro(gui, source)</code></p>
<h2 id="customizing-html"><span class="header-section-number">27.4</span> Customizing HTML</h2>
<p><strong><code>THtml</code></strong> allows a vast amount of 
customizations, from a custom style to custom links, to customized java 
scripts. By default, the style sheet is taken from <code>$ROOTSYS/etc/html/ROOT.css</code> when the documentation is generated. The path for <code>ROOT.css</code> can be changed by calling <code>THtml::SetEtcDir()</code>; it should contain the same CSS classes and entity IDs as the original <code>ROOT.css</code>. This style sheet is an easy means of customizing the layout and appearance of the documentation pages. Many of <strong><code>THtml</code></strong> setting can be customized by calls to <strong><code>THtml</code></strong> member functions or by settings in .rootrc, as documented in the <strong><code>THtml</code></strong> class reference page <a href="http://root.cern.ch/root/html/THtml" class="uri">http://root.cern.ch/root/html/THtml</a>. The following will enumerate some of the highlights.</p>
<h3 id="referencing-documentation-for-other-libraries"><span class="header-section-number">27.4.1</span> Referencing Documentation for other Libraries</h3>
<p>When <strong><code>THtml</code></strong> generates documentation for classes it recognizes all class names known to ROOT. If <strong><code>THtml</code></strong> does not have sources for a class it determines the class’s library name. This has to be set by means of <code>rootmap</code> files, see Library AutoLoading of this User’s Guide. Given the library name, <strong><code>THtml</code></strong>
 searches for an entry in its map of libraries to documentation URLs. If
 it finds it, it will create a link to the documentation at that URL for
 all occurrences of a given class name. One can set the URL <code>../mylib/</code> for a library name <code>MyLib</code> by setting <code>Root.Html.MyLib:</code> <code>../mylib/</code> or by calling <code>THtml::SetLibURL("MyLib", "../mylib/")</code>. Occurrences of class <code>MyClass</code> of <code>MyLib</code> will now be referenced as <code>../mylib/MyClass.html</code>.</p>
<h3 id="search-engine"><span class="header-section-number">27.4.2</span> Search Engine</h3>
<p><strong><code>THtml</code></strong> can invoke external search engines. The ROOT reference guide sets <code>Root.Html.Search</code> to <a href="http://www.google.com/search?q=%s+site%3A%u" class="uri">http://www.google.com/search?q=%s+site%3A%u</a>. Calling <strong><code>THtml::SetSearchStemURL()</code></strong> will set the same. If this URL stem is set, <code>THtml</code>
 will create search fields in the index pages. It will send the words 
entered in these search fields as %s in the URL; %u will be replaced by 
the current document’s path, allowing a site- and directory-specific 
search.</p>
<h3 id="viewcvs"><span class="header-section-number">27.4.3</span> ViewCVS</h3>
<p>Most code is managed in a version control system like CVS. ViewCVS is
 a WWW reader interface to the versioning control system that allows 
e.g. tracking a file’s changes. <strong><code>THtml</code></strong> will reference these pages automatically if the <code>.rootrc</code> variable <code>Root.Html.ViewCVS</code> is set to the URL stem of the ViewCVS. installation. Alternatively, one can call THtml::SetViewCVS().</p>
<h3 id="wiki-pages"><span class="header-section-number">27.4.4</span> Wiki Pages</h3>
<p>In some contexts it might be desirable to let users comment on 
classes, e.g.&nbsp;for suggestions of use or alternatives, details of 
behavior, and cross references to other relevant classes. A successful 
example of this is the PHP.net documentation with its user annotations. <strong><code>THtml</code></strong> can include a link to a class’s Wiki page by setting the Wiki base URL via <code>Root.Html.WikiURL</code> or <strong><code>THtml</code></strong><code>::SetWikiURL()</code>.</p>
<h2 id="tutorial"><span class="header-section-number">27.5</span> Tutorial</h2>
<p>You can run the tutorial <code>htmlex.C</code> to see how <strong><code>THtml</code></strong> converts a script to HTML and how it creates the corresponding class reference:</p>
<div class="sourceCode" id="cb1291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1291-1" title="1">root[] .x <span class="er">$</span>(ROOTSYS)/tutorials/htmlex.C+</a></code></pre></div>
<p>Have a look at the HTML version of the macro in <code>htmldoc/htmlex.C.html</code>(which should be the same as the one at <a href="http://root.cern.ch/root/html/examples/htmlex.C.html" class="uri">http://root.cern.ch/root/html/examples/htmlex.C.html</a>).</p>
<p>It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.</p>
<h1 id="appendix-a-install-and-build-root"><span class="header-section-number">28</span> Appendix A: Install and Build ROOT</h1>
<p></p>
<h2 id="license"><span class="header-section-number">28.1</span> License</h2>
<p>ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.</p>
<h2 id="installing-root-1"><span class="header-section-number">28.2</span> Installing ROOT</h2>
<p>To install ROOT you will need to go to the ROOT website at: <a href="https://root.cern/install/" class="uri">https://root.cern/install/</a></p>
<p>You have a choice to download the binaries or the source. The source 
is quicker to transfer since it is only 31 MB, but you will need to 
compile and link it. The binaries range from 50 MB to 100 MB depending 
on the target platform.</p>
<h2 id="choosing-a-version"><span class="header-section-number">28.3</span> Choosing a Version</h2>
<p>The ROOT developers follow the principle of “release early and 
release often”, however a very large portion of a user base requires a 
stable product therefore generally three versions of the system is 
available for download - new, old and pro:</p>
<ul>
<li><p>The <em>new</em> version evolves quickly, with weekly or 
bi-weekly releases. Use this to get access to the latest and greatest, 
but it may not be stable. By trying out the new version you can help us 
converge quickly to a stable version that can then become the new pro 
version. If you are a new user we would advice you to try the new 
version.</p></li>
<li><p>The <em>pro</em> (production) version is a version we feel 
comfortable with to exposing to a large audience for serious work. The 
change rate of this version is much lower than for the new version, it 
is about 3 to 6 months.</p></li>
<li><p>The <em>old</em> version is the previous pro version that people 
might need for some time before switching the new pro version. The old 
change rate is the same as for pro.</p></li>
</ul>
<h2 id="installing-precompiled-binaries"><span class="header-section-number">28.4</span> Installing Precompiled Binaries</h2>
<p>The binaries are available for downloading from <a href="https://root.cern/install/" class="uri">https://root.cern/install/</a>. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:</p>
<div class="sourceCode" id="cb1292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1292-1" title="1">% gunzip root_v5<span class="fl">.30</span><span class="er">.00</span>.Linux-slc5-gcc4<span class="fl">.3</span><span class="er">.tar</span>.gz</a>
<a class="sourceLine" id="cb1292-2" title="2">% tar xvf root_v5<span class="fl">.30</span><span class="er">.00</span>.Linux-slc5-gcc4<span class="fl">.3</span><span class="er">.tar</span></a></code></pre></div>
<p>This will create the directory root. Before getting started read the 
file README/README. Also, read the Introduction chapter for an 
explanation of the directory structure.</p>
<h2 id="installing-from-the-source"><span class="header-section-number">28.5</span> Installing from the Source</h2>
<p>The ROOT’s source code sits in the GitHub repository <a href="https://github.com/root-project/root" class="uri">https://github.com/root-project/root</a> all the details and options to buld ROOT from sources are given in <a href="https://root.cern/building-root" class="uri">https://root.cern/building-root</a></p>
<p>In short, the steps to build ROOT from the sources are the following:</p>
<ol type="1">
<li>Clone the repository:</li>
</ol>
<div class="sourceCode" id="cb1293"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1293-1" title="1"><span class="er">$</span> git clone https:<span class="co">//github.com/root-project/root.git</span></a></code></pre></div>
<ol start="2" type="1">
<li>Make a directory for building</li>
</ol>
<div class="sourceCode" id="cb1294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1294-1" title="1"><span class="er">$</span> mkdir build</a>
<a class="sourceLine" id="cb1294-2" title="2"><span class="er">$</span> cd build</a></code></pre></div>
<ol start="3" type="1">
<li>Run cmake and make</li>
</ol>
<div class="sourceCode" id="cb1295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1295-1" title="1"><span class="er">$</span> cmake ../root</a>
<a class="sourceLine" id="cb1295-2" title="2"><span class="er">$</span> make -j<span class="dv">8</span></a></code></pre></div>
<ol start="4" type="1">
<li>Setup and run ROOT</li>
</ol>
<div class="sourceCode" id="cb1296"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1296-1" title="1"><span class="er">$</span> source bin/thisroot.sh</a>
<a class="sourceLine" id="cb1296-2" title="2"><span class="er">$</span> root</a></code></pre></div>
<h4 id="staying-up-to-date"><span class="header-section-number">28.5.0.1</span> Staying up-to-date</h4>
<p>To keep your local ROOT source up-to-date with the GitHub repository you should regularly run the command:</p>
<div class="sourceCode" id="cb1297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1297-1" title="1">% git pull</a></code></pre></div>
<h2 id="file-system.rootrc"><span class="header-section-number">28.6</span> File system.rootrc</h2>
<p>ROOT Environment settings are handled via the class <strong><code>TEnv</code></strong>. <code>gEnv-&gt;Print()</code>shows which values are active. Any settings can be obtained by <code>TEnv::GetValue</code>
 methods that return an integer, double or character value for a named 
resource. If the resource is not found, the default value (given as the 
second parameter) is returned.</p>
<div class="sourceCode" id="cb1298"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1298-1" title="1">fShowEventStatus = gEnv-&gt;GetValue(<span class="st">"Canvas.ShowEventStatus"</span>,kFALSE);</a></code></pre></div>
<p>Via the method <code>TEnv::SetValue</code> allows you can set the value of a resource or create a new resource:</p>
<div class="sourceCode" id="cb1299"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1299-1" title="1">gEnv-&gt;SetValue(<span class="st">"Root.ObjectStat"</span>,<span class="dv">1</span>);</a></code></pre></div>
<p>Path used by dynamic loader to find shared libraries and macros. 
Paths are different for Unix and Windows. The example shows the defaults
 for all ROOT applications for either Unix or Windows:</p>
<div class="sourceCode" id="cb1300"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1300-1" title="1">Unix.*.Root.DynamicPath:    .:<span class="er">$</span>(ROOTSYS)/lib</a>
<a class="sourceLine" id="cb1300-2" title="2">Unix.*.Root.MacroPath:      .:<span class="er">$</span>(ROOTSYS)/macros</a>
<a class="sourceLine" id="cb1300-3" title="3">WinNT.*.Root.DynamicPath:   .;<span class="er">$</span>(ROOTSYS)/bin;<span class="er">$</span>(PATH)</a>
<a class="sourceLine" id="cb1300-4" title="4">WinNT.*.Root.MacroPath:     .;<span class="er">$</span>(ROOTSYS)/macros</a></code></pre></div>
<p>Path where to look for <code>TrueType</code> fonts:</p>
<div class="sourceCode" id="cb1301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1301-1" title="1">Unix.*.Root.UseTTFonts:     <span class="kw">true</span></a>
<a class="sourceLine" id="cb1301-2" title="2">*.*.Root.TTFontPath:        <span class="er">$</span>(ROOTSYS)/fonts</a></code></pre></div>
<p>Use <code>Net* API</code> functions:</p>
<div class="sourceCode" id="cb1302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1302-1" title="1">WinNT.UseNetAPI:            <span class="kw">true</span></a></code></pre></div>
<p>Use thread library (if exists).</p>
<div class="sourceCode" id="cb1303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1303-1" title="1">Unix.*.Root.UseThreads:     <span class="kw">false</span></a></code></pre></div>
<p>Select the compression algorithm (0=old zlib, 1=new zlib). Setting this to `0’ may be a security vulnerability.</p>
<div class="sourceCode" id="cb1304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1304-1" title="1">Root.ZipMode:               <span class="dv">1</span></a></code></pre></div>
<p>Show where item is found in the specified path:</p>
<div class="sourceCode" id="cb1305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1305-1" title="1">Root.ShowPath:              <span class="kw">false</span></a></code></pre></div>
<p>Activate memory statistics.</p>
<div class="sourceCode" id="cb1306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1306-1" title="1">Root.ObjectStat:            <span class="dv">0</span></a></code></pre></div>
<p>Global debug mode. When <code>&gt;0</code> turns on progressively more details debugging.</p>
<div class="sourceCode" id="cb1307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1307-1" title="1">Root.Debug:                 <span class="dv">0</span></a>
<a class="sourceLine" id="cb1307-2" title="2">Root.Stacktrace:            yes</a></code></pre></div>
<p>Settings for X11 behaviour.</p>
<div class="sourceCode" id="cb1308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1308-1" title="1">X11.Sync:                   no</a>
<a class="sourceLine" id="cb1308-2" title="2">X11.FindBestVisual:         yes</a></code></pre></div>
<p>Default editor in use.</p>
<div class="sourceCode" id="cb1309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1309-1" title="1">Unix.*.Editor:              vi</a>
<a class="sourceLine" id="cb1309-2" title="2">WinNT.*.Editor:             notepad</a></code></pre></div>
<p>Default 3d Viewer. By default 3-D views are shown in the pad, if the next line is activated, the default viewer will be OpenGL.</p>
<div class="sourceCode" id="cb1310"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1310-1" title="1">Viewer3D.DefaultDrawOption: ogl</a></code></pre></div>
<p>Default Fitter (current choices are <code>Minuit</code>, <code>Minuit2</code>, <code>Fumili</code> and <code>Fumili2</code>).</p>
<div class="sourceCode" id="cb1311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1311-1" title="1">Root.Fitter:                Minuit</a></code></pre></div>
<p>Specify list of file endings which <strong><code>TTabCom</code></strong> (TAB completion) should ignore.</p>
<div class="sourceCode" id="cb1312"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1312-1" title="1">TabCom.FileIgnore:          .cpp:.h:.cmz</a></code></pre></div>
<h3 id="tcanvas-specific-settings"><span class="header-section-number">28.6.1</span> TCanvas Specific Settings</h3>
<p>Opaque move and resize show full pad during the operation instead of 
only the outline. Especially for resize you will need serious CPU power.
 <code>UseScreenFactor=true</code> means to size canvas according to 
size of screen, so a canvas still looks good on a low resolution laptop 
screen without having to change canvas size in macros.</p>
<div class="sourceCode" id="cb1313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1313-1" title="1">Canvas.MoveOpaque:          <span class="kw">false</span></a>
<a class="sourceLine" id="cb1313-2" title="2">Canvas.ResizeOpaque:        <span class="kw">false</span></a>
<a class="sourceLine" id="cb1313-3" title="3">Canvas.UseScreenFactor:     <span class="kw">true</span></a></code></pre></div>
<p>Hight color 2 is the red one.</p>
<div class="sourceCode" id="cb1314"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1314-1" title="1">Canvas.HighLightColor:      <span class="dv">2</span></a></code></pre></div>
<p>Next three settings are related to different user interface parts of 
canvas window. If they are set to true, the corresponding event status 
bar, tool bar, graphics editor will be activated by default.</p>
<div class="sourceCode" id="cb1315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1315-1" title="1">Canvas.ShowEventStatus:     <span class="kw">false</span></a>
<a class="sourceLine" id="cb1315-2" title="2">Canvas.ShowToolBar:         <span class="kw">false</span></a>
<a class="sourceLine" id="cb1315-3" title="3">Canvas.ShowEditor:          <span class="kw">false</span></a></code></pre></div>
<p>AutoExec allows <strong><code>TExec</code></strong> objects to be executed on mouse and key events.</p>
<div class="sourceCode" id="cb1316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1316-1" title="1">Canvas.AutoExec:            <span class="kw">true</span></a></code></pre></div>
<p>Canvas print directory is set to the current one by default:</p>
<div class="sourceCode" id="cb1317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1317-1" title="1">Canvas.PrintDirectory     .</a></code></pre></div>
<p>Printer settings:</p>
<div class="sourceCode" id="cb1318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1318-1" title="1">WinNT.*.Print.Command:    AcroRd32.exe</a>
<a class="sourceLine" id="cb1318-2" title="2"><span class="pp">#</span><span class="er">Unix.*.Print.Command:    a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f</span></a>
<a class="sourceLine" id="cb1318-3" title="3">Print.Printer:            <span class="dv">32</span>-rb20-hp</a>
<a class="sourceLine" id="cb1318-4" title="4">Print.Directory:          .</a>
<a class="sourceLine" id="cb1318-5" title="5">Print.FileType:           pdf</a></code></pre></div>
<p>Default histogram binnings used by <code>TTree::Draw()</code> method.</p>
<div class="sourceCode" id="cb1319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1319-1" title="1">Hist.Binning<span class="fl">.1</span><span class="er">D</span>.x:          <span class="dv">100</span></a>
<a class="sourceLine" id="cb1319-2" title="2">Hist.Binning<span class="fl">.2</span><span class="er">D</span>.x:           <span class="dv">40</span></a>
<a class="sourceLine" id="cb1319-3" title="3">Hist.Binning<span class="fl">.2</span><span class="er">D</span>.y:           <span class="dv">40</span></a>
<a class="sourceLine" id="cb1319-4" title="4">Hist.Binning<span class="fl">.2</span><span class="er">D</span>.Prof:       <span class="dv">100</span></a>
<a class="sourceLine" id="cb1319-5" title="5">Hist.Binning<span class="fl">.3</span><span class="er">D</span>.x:           <span class="dv">20</span></a>
<a class="sourceLine" id="cb1319-6" title="6">Hist.Binning<span class="fl">.3</span><span class="er">D</span>.y:           <span class="dv">20</span></a>
<a class="sourceLine" id="cb1319-7" title="7">Hist.Binning<span class="fl">.3</span><span class="er">D</span>.z:           <span class="dv">20</span></a>
<a class="sourceLine" id="cb1319-8" title="8">Hist.Binning<span class="fl">.3</span><span class="er">D</span>.Profx:      <span class="dv">100</span></a>
<a class="sourceLine" id="cb1319-9" title="9">Hist.Binning<span class="fl">.3</span><span class="er">D</span>.Profy:      <span class="dv">100</span></a></code></pre></div>
<p>Default statistics names used for parameters in <strong><code>TPaveStats</code></strong>:</p>
<div class="sourceCode" id="cb1320"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1320-1" title="1">Hist.Stats.Entries         Entries</a>
<a class="sourceLine" id="cb1320-2" title="2">Hist.Stats.Mean            Mean</a>
<a class="sourceLine" id="cb1320-3" title="3">Hist.Stats.MeanX           Mean x</a>
<a class="sourceLine" id="cb1320-4" title="4">Hist.Stats.MeanY           Mean y</a>
<a class="sourceLine" id="cb1320-5" title="5">Hist.Stats.RMS             RMS</a>
<a class="sourceLine" id="cb1320-6" title="6">Hist.Stats.RMSX            RMS x</a>
<a class="sourceLine" id="cb1320-7" title="7">Hist.Stats.RMSY            RMS y</a>
<a class="sourceLine" id="cb1320-8" title="8">Hist.Stats.Underflow       Underflow</a>
<a class="sourceLine" id="cb1320-9" title="9">Hist.Stats.Overflow        Overflow</a>
<a class="sourceLine" id="cb1320-10" title="10">Hist.Stats.Integral        Integral</a>
<a class="sourceLine" id="cb1320-11" title="11">Hist.Stats.Skewness        Skewness</a>
<a class="sourceLine" id="cb1320-12" title="12">Hist.Stats.SkewnessX       Skewness x</a>
<a class="sourceLine" id="cb1320-13" title="13">Hist.Stats.SkewnessY       Skewness y</a>
<a class="sourceLine" id="cb1320-14" title="14">Hist.Stats.Kurtosis        Kurtosis</a>
<a class="sourceLine" id="cb1320-15" title="15">Hist.Stats.KurtosisX       Kurtosis x</a>
<a class="sourceLine" id="cb1320-16" title="16">Hist.Stats.KurtosisY       Kurtosis y</a></code></pre></div>
<h3 id="thtml-specific-settings"><span class="header-section-number">28.6.2</span> THtml Specific Settings</h3>
<p>See the reference guide documentation of <strong><code>THtml</code></strong> class at <a href="http://root.cern.ch/root/htmldoc/THtml.html" class="uri">http://root.cern.ch/root/htmldoc/THtml.html</a> for more details.</p>
<p>XHTML content charset (see <a href="http://www.w3.org/TR/2002/REC-xhtml1-20020801" class="uri">http://www.w3.org/TR/2002/REC-xhtml1-20020801</a>, default: ISO-8859-1) is set by:</p>
<div class="sourceCode" id="cb1321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1321-1" title="1">Root.Html.Charset:</a></code></pre></div>
<p>Stem of a search engine for the documentation, where <code>%s</code> is replaced by the term entered in the search text box (example: <code>http://www.google.com/search?q=%s+site%3Aroot.cern.ch%2Froot%2Fhtml</code>, default is <code>""</code>)</p>
<div class="sourceCode" id="cb1322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1322-1" title="1">Root.Html.Search:</a></code></pre></div>
<p>Link to the site’s search engine (default: <code>""</code>, example: <code>http://root.cern.ch/root/Search.phtml</code>)</p>
<div class="sourceCode" id="cb1323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1323-1" title="1">Root.Html.SearchEngine:</a></code></pre></div>
<p>String to prepend to <code>TClass::GetImplFileName()</code> names containing directories when looking for source files (default: <code>""</code>, <code>e</code>xample: <code>../root</code>)</p>
<div class="sourceCode" id="cb1324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1324-1" title="1">Root.Html.SourcePrefix:</a></code></pre></div>
<p>Link stem to <code>ViewCVS</code> entry for classes, where a class name is assumed to match a file name (default: <code>""</code>, example: <code>http://root.cern.ch/viewcvs</code>).</p>
<div class="sourceCode" id="cb1325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1325-1" title="1">Root.Html.ViewCVS:</a></code></pre></div>
<p>Stem of the CERN XWho system (default: <code>http://consult.cern.ch/xwho/people?</code>)</p>
<div class="sourceCode" id="cb1326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1326-1" title="1">Root.Html.XWho:</a></code></pre></div>
<p>If set to Doc++, allow method documentation in front of method even for methods in the source file (default: <code>""</code>)</p>
<div class="sourceCode" id="cb1327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1327-1" title="1">Root.Html.DescriptionStyle:</a></code></pre></div>
<p>Search path for the source and header files with their default settings:</p>
<div class="sourceCode" id="cb1328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1328-1" title="1">Unix.*.Root.Html.SourceDir:  .:src:include</a>
<a class="sourceLine" id="cb1328-2" title="2">WinNT.*.Root.Html.SourceDir: .;src;include</a></code></pre></div>
<p>URL stem for ROOT documentation pages (default is <code>""</code>).</p>
<div class="sourceCode" id="cb1329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1329-1" title="1">Root.Html.Root:              http:<span class="co">//root.cern.ch/root/html</span></a></code></pre></div>
<p>Filesystem output directory for generated web pages (default: <code>htmldoc)</code>.</p>
<div class="sourceCode" id="cb1330"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1330-1" title="1">Root.Html.OutputDir:        htmldoc/</a></code></pre></div>
<p>Address of the package’s home page (default: <a href="http://root.cern.ch/" class="uri">http://root.cern.ch</a>):</p>
<div class="sourceCode" id="cb1331"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1331-1" title="1">Root.Html.HomePage:</a></code></pre></div>
<p>Location of user defined header and footer files, see <a href="http://root.cern.ch/root/html/THtml#conf:header" class="uri">http://root.cern.ch/root/html/THtml#conf:header</a> (defaults are <code>""</code>, example: <code>../header.txt</code>, <code>../footer.txt</code>):</p>
<div class="sourceCode" id="cb1332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1332-1" title="1">Root.Html.Header:</a>
<a class="sourceLine" id="cb1332-2" title="2">Root.Html.Footer:</a></code></pre></div>
<p>Tag for detecting class description comments (default value is set below).</p>
<div class="sourceCode" id="cb1333"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1333-1" title="1">Root.Html.Description:      <span class="co">//____________________</span></a></code></pre></div>
<p>Tag for detecting “Author” comment (default value is set below).</p>
<div class="sourceCode" id="cb1334"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1334-1" title="1">Root.Html.Author:           <span class="co">// Author:</span></a></code></pre></div>
<p>Tag for detecting “last updated” comment. <strong><code>THtml</code></strong> uses the current date if this tag is not found in a class source file (default value is set below).</p>
<div class="sourceCode" id="cb1335"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1335-1" title="1">Root.Html.LastUpdate:       <span class="co">// @(#)</span></a></code></pre></div>
<p>Tag for detecting “Copyright” comment (default value is set below).</p>
<div class="sourceCode" id="cb1336"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1336-1" title="1">Root.Html.Copyright:        * Copyright</a></code></pre></div>
<h3 id="gui-specific-settings"><span class="header-section-number">28.6.3</span> GUI Specific Settings</h3>
<p>Set the “<code>native</code>” ROOT GUI interface to be used in a ROOT session.</p>
<div class="sourceCode" id="cb1337"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1337-1" title="1">Gui.Backend:                native</a>
<a class="sourceLine" id="cb1337-2" title="2">Gui.Factory:                native</a></code></pre></div>
<p>GUI default fonts in use:</p>
<div class="sourceCode" id="cb1338"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1338-1" title="1">Gui.DefaultFont:            -adobe-helvetica-medium-r-*-*-<span class="dv">12</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-2" title="2">Gui.MenuFont:               -adobe-helvetica-medium-r-*-*-<span class="dv">12</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-3" title="3">Gui.MenuHiFont:             -adobe-helvetica-bold-r-*-*-<span class="dv">12</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-4" title="4">Gui.DocFixedFont:           -adobe-courier-medium-r-*-*-<span class="dv">12</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-5" title="5">Gui.DocPropFont:            -adobe-helvetica-medium-r-*-*-<span class="dv">12</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-6" title="6">Gui.IconFont:               -adobe-helvetica-medium-r-*-*-<span class="dv">10</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a>
<a class="sourceLine" id="cb1338-7" title="7">Gui.StatusFont:             -adobe-helvetica-medium-r-*-*-<span class="dv">10</span>-*-*-*-*-*-iso8859-<span class="dv">1</span></a></code></pre></div>
<p>Regular background and foreground colors in use:</p>
<div class="sourceCode" id="cb1339"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1339-1" title="1">Gui.BackgroundColor:         <span class="er">#c0c0c0</span></a>
<a class="sourceLine" id="cb1339-2" title="2">Gui.ForegroundColor:         black</a></code></pre></div>
<p>Selection background and foreground colors in use:</p>
<div class="sourceCode" id="cb1340"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1340-1" title="1">Gui.SelectBackgroundColor:   <span class="er">#000080</span></a>
<a class="sourceLine" id="cb1340-2" title="2">Gui.SelectForegroundColor:   white</a></code></pre></div>
<p>Document background and foreground colors in use:</p>
<div class="sourceCode" id="cb1341"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1341-1" title="1">Gui.DocumentBackgroundColor: white</a>
<a class="sourceLine" id="cb1341-2" title="2">Gui.DocumentForegroundColor: black</a></code></pre></div>
<p>Tooltip background and foreground colors in use:</p>
<div class="sourceCode" id="cb1342"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1342-1" title="1">Gui.TooltipBackgroundColor:  LightYellow</a>
<a class="sourceLine" id="cb1342-2" title="2">Gui.TooltipForegroundColor:  black</a></code></pre></div>
<p>Path where all GUI icons in use can be found:</p>
<div class="sourceCode" id="cb1343"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1343-1" title="1">Gui.IconPath:                <span class="er">$</span>(HOME)/icons:<span class="er">$</span>(ROOTSYS)/icons:.</a></code></pre></div>
<p>Mime type file setting:</p>
<div class="sourceCode" id="cb1344"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1344-1" title="1">Gui.MimeTypeFile:            <span class="er">$</span>(HOME)/.root.mimes</a></code></pre></div>
<p>If <code>$(HOME)/.root.mimes</code> does not exists, defaults to this:</p>
<div class="sourceCode" id="cb1345"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1345-1" title="1"><span class="pp">#</span><span class="er">Gui.MimeTypeFile:            $(ROOTSYS)/etc/root.mimes</span></a></code></pre></div>
<h3 id="tbrowser-settings"><span class="header-section-number">28.6.4</span> TBrowser Settings</h3>
<p>Current icon style selection - can be either <code>small</code>, <code>big</code>, <code>list</code>, <code>details</code>:</p>
<div class="sourceCode" id="cb1346"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1346-1" title="1">Browser.IconStyle:           small</a></code></pre></div>
<p>Current sorting rule applied on the browser objects - can be <code>name</code>, <code>type</code>, <code>size</code>, <code>date</code>:</p>
<div class="sourceCode" id="cb1347"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1347-1" title="1">Browser.SortBy:              name</a></code></pre></div>
<p>Number of items in a group view:</p>
<div class="sourceCode" id="cb1348"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1348-1" title="1">Browser.GroupView:           <span class="dv">10000</span></a></code></pre></div>
<p>Show or not hidden items:</p>
<div class="sourceCode" id="cb1349"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1349-1" title="1">Browser.ShowHidden:          no</a></code></pre></div>
<p>Create a thumbnail view after executing the macro (default is <code>yes</code>).</p>
<div class="sourceCode" id="cb1350"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1350-1" title="1">Browser.AutoThumbnail:       yes</a></code></pre></div>
<h3 id="trint-specific-settings"><span class="header-section-number">28.6.5</span> TRint Specific Settings</h3>
<p>Rint (interactive ROOT executable) specific alias, logon and logoff macros.</p>
<div class="sourceCode" id="cb1351"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1351-1" title="1">Rint.Load:               rootalias.C</a>
<a class="sourceLine" id="cb1351-2" title="2">Rint.Logon:              rootlogon.C</a>
<a class="sourceLine" id="cb1351-3" title="3">Rint.Logoff:             rootlogoff.C</a></code></pre></div>
<p>Record ROOT session commands in a given history file (default is <code>$(HOME)/.root_hist</code>). If set to “<code>-</code>”, it turn off the command recording.</p>
<div class="sourceCode" id="cb1352"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1352-1" title="1">Rint.History:            <span class="er">$</span>(HOME)/.root_hist</a></code></pre></div>
<p>Next two lines set the history file size handling. Once <code>HistSize</code> is reached, the last <code>HistSave</code> entries are removed. If <code>HistSize</code> is set to 0, it turns off command recording. Both values can be overridden by environment variable <code>ROOT_HIST=size[:save]</code>, where the “<code>:save</code>” part is optional.</p>
<div class="sourceCode" id="cb1353"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1353-1" title="1">Rint.HistSize:         <span class="dv">500</span></a>
<a class="sourceLine" id="cb1353-2" title="2">Rint.HistSave:         <span class="dv">400</span></a></code></pre></div>
<h3 id="aclic-specific-settings"><span class="header-section-number">28.6.6</span> ACLiC Specific Settings</h3>
<p><code>ACLiC.Linkdef</code> specifies the suffix that will be added to
 the script name to try to locate a custom linkdef file when generating 
the dictionary.</p>
<div class="sourceCode" id="cb1354"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1354-1" title="1">ACLiC.Linkdef:          _linkdef</a></code></pre></div>
<p>The top directory for storing the libraries produced by ACLiC is set by:</p>
<div class="sourceCode" id="cb1355"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1355-1" title="1">ACLiC.BuildDir:        /where/I/would/like/my/compiled/scripts</a></code></pre></div>
<p>The additional include directives for ACLiC compilations are set by:</p>
<div class="sourceCode" id="cb1356"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1356-1" title="1">ACLiC.IncludePaths:     -I/where/the/includes/are</a></code></pre></div>
<h3 id="proof-related-variables"><span class="header-section-number">28.6.7</span> PROOF Related Variables</h3>
<p>PROOF debug options.</p>
<div class="sourceCode" id="cb1357"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1357-1" title="1">Proof.DebugLevel: <span class="dv">0</span></a>
<a class="sourceLine" id="cb1357-2" title="2">Proof.DebugMask:-<span class="dv">1</span></a></code></pre></div>
<p>PROOF GDB hooks allows a debugger to be attached early in the startup phase of <code>proofserv:</code>0 - don’t wait; 1 - master proofserv enters wait loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters wait loop</p>
<div class="sourceCode" id="cb1358"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1358-1" title="1">Proof.GdbHook:    <span class="dv">0</span></a></code></pre></div>
<p>On the master to enable the parallel startup of workers using threads set next to “<code>yes</code>” (default is “<code>no</code>”):</p>
<div class="sourceCode" id="cb1359"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1359-1" title="1">Proof.ParallelStartup: no</a></code></pre></div>
<div class="sourceCode" id="cb1360"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1360-1" title="1">Proof.StatsHist:       no</a>
<a class="sourceLine" id="cb1360-2" title="2">Proof.StatsTrace:      no</a>
<a class="sourceLine" id="cb1360-3" title="3">Proof.SlaveStatsTrace: no</a></code></pre></div>
<div class="sourceCode" id="cb1361"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1361-1" title="1">Proof.CondorHome:     /opt/condor</a>
<a class="sourceLine" id="cb1361-2" title="2">Proof.CondorConfig:   /opt/condor/etc/condor_config</a></code></pre></div>
<div class="sourceCode" id="cb1362"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1362-1" title="1">PEAC.GmUrl:           http:<span class="co">//somewhere:8080/clarens/</span></a>
<a class="sourceLine" id="cb1362-2" title="2">PEAC.LmUrl:           http:<span class="co">//elsewhere:8080/clarens/</span></a></code></pre></div>
<h4 id="server-authentication-in-tserversocket"><span class="header-section-number">28.6.7.1</span> Server Authentication in TServerSocket</h4>
<p>General setting: file with server access rules</p>
<div class="sourceCode" id="cb1363"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1363-1" title="1">SrvAuth.DaemonRc:        /etc/root/system.daemonrc</a></code></pre></div>
<p>Check of host equivalence via <code>/etc/hosts</code>.<code>equiv</code> or <code>$HOME/.rhosts</code>.</p>
<div class="sourceCode" id="cb1364"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1364-1" title="1">SrvAuth.CheckHostsEquivalence: <span class="dv">1</span></a></code></pre></div>
<p>Force file opening via <strong><code>TNetFile</code></strong> (<strong><code>TXNetFile</code></strong>) if a hostname is specified in the Url. By default, for local files <code>TFile::Open()</code> invokes directly <strong><code>TFile.</code></strong></p>
<div class="sourceCode" id="cb1365"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1365-1" title="1">TFile.ForceRemote:        yes</a></code></pre></div>
<p>Special cases for the <strong><code>TUrl</code></strong> parser, 
where the special cases are parsed in a protocol + file part, like 
rfio:host:/path/file.root, castor:/path/file.root or 
/alien/path/file.root. In case the file namespace descriptor ends with -
 the namespace is not a part of the filename. Extend in private .rootrc 
with a +Url.Special line.</p>
<div class="sourceCode" id="cb1366"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1366-1" title="1">Url.Special:             file: rfio: hpss: castor: dcache:</a>
<a class="sourceLine" id="cb1366-2" title="2">+Url.Special:            /alien/- /castor/</a></code></pre></div>
<h4 id="proof-xrd-client-variables"><span class="header-section-number">28.6.7.2</span> PROOF XRD Client Variables</h4>
<p>Debug level (if &lt;=0 : none, 1 : low, 2 : medium, 3 : high)</p>
<div class="sourceCode" id="cb1367"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1367-1" title="1">XProof.Debug:       <span class="dv">0</span></a></code></pre></div>
<p>Socket read timeout [in secs: default 10 secs]</p>
<div class="sourceCode" id="cb1368"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1368-1" title="1">XProof.ReadTimeout: <span class="dv">10</span></a></code></pre></div>
<p>The following env vars are handled by <strong><code>TXNetFile</code></strong> and related classes (module <code>netx</code>, <code>libNetx.so</code>).</p>
<p><code>XNet.ConnectTimeout</code> - maximum time to wait before server’s response on a connect [10 s]</p>
<p><code>XNet.RequestTimeout</code> - maximum time to wait before considering a read/write failure [60 s]</p>
<p><code>XNet.ConnectDomainAllowRE</code> - sequence of <strong><code>TRegexp</code></strong> regular expressions separated by a <code>|</code>. A domain is granted access to for the first connection if it matches one of these regexps. Example:</p>
<div class="sourceCode" id="cb1369"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1369-1" title="1">slac.stanford.edu|pd.infn.it|fe.infn.it</a></code></pre></div>
<p><code>XNet.ConnectDomainDenyRE</code> - sequence of TRegexp regular expressions separated by a <code>|</code>. A domain is denied access to for the first connection if it matches one of these regexps.</p>
<p><code>XNet.RedirDomainAllowRE</code> - sequence of TRegexp regular expressions separated by a <code>|</code>. A domain is granted access to for a redirection if it matches one of these regexps. Example:</p>
<p><code>XNet.RedirDomainDenyRE</code> - sequence of TRegexp regular expressions separated by a <code>|</code>. A domain is granted access to for a redirection if it matches one of these regexps.</p>
<p><code>XNet.MaxRedirectCount</code> - maximum number of redirections from server [default - 255]</p>
<p><code>XNet.Debug</code> - log verbosity level (0=nothing,1=messages 
of interest to the user, 2=messages of interest to the developers 
(includes also user messages), 3=dump of all sent/received data buffers 
(includes also user and developers messages). [default - 0]</p>
<p><code>XNet.ReconnectTimeout</code> - sleep-time before going back to 
the load balancer (or rebouncing to the same failing host) after a 
read/write error [default - 10s]</p>
<p><code>XNet.StartGarbageCollectorThread</code> - for test/development 
purposes. Normally nonzero (true), but as workaround for external causes
 someone could be interested in not having the garbage collector thread 
around. [experimental!]</p>
<p><code>XNet.GoAsynchronous</code> - default is 0. When activated, <strong><code>XTNetFile</code></strong> works in async mode, allowing input buffering and unsolicited responses [experimental!]</p>
<p><code>XNet.TryConnect</code> - Number of tries connect to a single server before giving up.</p>
<p><code>XNet.TryConnectServersList</code> - number of connect retries to the whole server list given [default - 240]</p>
<p><code>XNet.PrintTAG</code> - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]</p>
<p>Example of custom setting for the Rint application (root.exe). This 
overrides the default specified above for a generic application. Color 5
 is yellow.</p>
<div class="sourceCode" id="cb1370"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1370-1" title="1">Rint.Canvas.HighLightColor:      <span class="dv">5</span></a></code></pre></div>
<h2 id="documentation-to-download"><span class="header-section-number">28.7</span> Documentation to Download</h2>
<ul>
<li><p>The latest ROOT Users Guide</p></li>
<li><p><a href="https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html" class="uri">https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html</a></p></li>
<li><p>ROOT Reference Guide</p></li>
<li><p><a href="http://root.cern.ch/root/Reference.html" class="uri">http://root.cern.ch/root/Reference.html</a></p></li>
</ul>
<section class="footnotes">
<hr>
<ol>
<li id="fn1"><p>http://root.cern.ch/twiki/bin/view/ROOT/PROOF<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>


</body></html>